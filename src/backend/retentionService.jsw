import wixUsersBackend from 'wix-users-backend';
import { log } from 'backend/observabilityService';
import { getSubscription } from 'backend/subscriptionService';
import { seedDriverPerformance } from 'backend/seeds/seedMockData';
import * as dataAccess from 'backend/dataAccess';

// ===========================================
// CONFIGURATION & CONSTANTS
// ===========================================

const RISK_THRESHOLDS = { CRITICAL: 90, HIGH: 70, MEDIUM: 40 };
const RISK_LEVELS = { CRITICAL: 'CRITICAL', HIGH: 'HIGH', MEDIUM: 'MEDIUM', LOW: 'LOW' };
const ROI_CONSTANTS = { COST_PER_TURNOVER: 10000, BASELINE_RETENTION_RATE: 0.55 };

// Collection keys for dataAccess
const COLLECTION_KEYS = {
    driverPerformance: 'driverPerformance',
    riskLogs: 'retentionRiskLogs',
    carriers: 'carriers',
    retentionOutcomes: 'retentionOutcomes'
};

// ===========================================
// CORE LOGIC
// ===========================================

export function calculateRiskScore(metrics) {
    let score = 0, factors = [], suggestedActions = [];
    const { miles_driven, on_time_delivery_rate, safety_incidents, home_time_days, prev_miles_driven, pay_volatility_index, avg_weekly_pay, app_sessions_last_7d, app_sessions_prev_7d, dnps_score } = metrics;

    if (dnps_score !== undefined && dnps_score <= 6) {
        score = 95; factors.unshift('Detractor (dNPS ' + dnps_score + ')');
        suggestedActions.push("Immediate Manager Call");
    }

    if (app_sessions_prev_7d > 0) {
        const activityDrop = (app_sessions_prev_7d - app_sessions_last_7d) / app_sessions_prev_7d;
        if (activityDrop >= 0.50) { score += 50; factors.push('Silence Signal: 50%+ Activity Drop'); suggestedActions.push("Trigger Check-in (SMS)"); }
        else if (activityDrop >= 0.30) { score += 20; factors.push('Decreasing App Engagement'); }
    }

    if (safety_incidents >= 2) { score += 60; factors.push('Multiple Safety Incidents'); suggestedActions.push("Schedule Safety Review"); }
    else if (safety_incidents === 1) { score += 30; factors.push('Safety Incident'); }

    if (pay_volatility_index > 25) { score += 45; factors.push('Extreme Pay Volatility (>25%)'); suggestedActions.push("Verify Pay / Payroll Audit"); }
    else if (pay_volatility_index > 15) { score += 25; factors.push('Unstable Pay Checks'); }

    if (home_time_days < 2) { score += 30; factors.push('Severe Burnout Risk (Low Home Time)'); suggestedActions.push("Schedule Time Off"); }

    score = Math.min(100, score);
    let level = score >= RISK_THRESHOLDS.CRITICAL ? RISK_LEVELS.CRITICAL : score >= RISK_THRESHOLDS.HIGH ? RISK_LEVELS.HIGH : score >= RISK_THRESHOLDS.MEDIUM ? RISK_LEVELS.MEDIUM : RISK_LEVELS.LOW;

    return { score, level, primaryFactor: factors[0] || 'Stable Operation', allFactors: factors, suggestedActions: suggestedActions.slice(0, 2) };
}

// ===========================================
// EXPORTED SERVICES
// ===========================================

async function verifyCarrierOwnership(carrierDot) {
    const user = wixUsersBackend.currentUser;
    if (!user.loggedIn) throw new Error('Not authenticated');
    
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
        filters: { dot_number: carrierDot, _owner: user.id },
        limit: 1, suppressAuth: true
    });
    if (!result.success || !result.items?.length) throw new Error('Unauthorized');
    return true;
}

export async function getCarrierRetentionDashboardForCarrier(carrierDot) {
    try {
        await verifyCarrierOwnership(carrierDot);
        const sub = await getSubscription(carrierDot);
        if (!['pro', 'enterprise'].includes(sub.plan_type)) {
            return { success: true, isFreeTier: true, message: 'Upgrade to Pro to identify flight-risk drivers.', upgradeUrl: '/pricing' };
        }
        return await getCarrierRetentionDashboard(carrierDot);
    } catch (error) {
        return { success: false, error: error.message };
    }
}

export async function getCarrierRetentionDashboard(carrierDot) {
    try {
        const dotStr = String(carrierDot);
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.driverPerformance, {
            filters: { carrier_dot: dotStr }, limit: 1000, suppressAuth: true
        });
        let drivers = result.items || [];

        if (drivers.length === 0) drivers = await seedDriverPerformance(dotStr);

        let totalScore = 0, highRiskCount = 0, riskDistribution = { LOW: 0, MEDIUM: 0, HIGH: 0, CRITICAL: 0 };
        let payVolatilitySum = 0, totalWeeklyPay = 0, processedDrivers = [];

        for (const record of drivers) {
            const risk = calculateRiskScore(record);
            totalScore += risk.score;
            riskDistribution[risk.level]++;
            payVolatilitySum += (record.pay_volatility_index || 0);
            totalWeeklyPay += (record.avg_weekly_pay || 0);
            if (['HIGH', 'CRITICAL'].includes(risk.level)) highRiskCount++;

            processedDrivers.push({
                driverId: record.driver_id, driverName: record.driver_name || 'Driver',
                metrics: { miles: record.miles_driven, safety: record.safety_incidents, homeTime: record.home_time_days, weeklyPay: record.avg_weekly_pay, payVolatility: record.pay_volatility_index, sessionsLast7: record.app_sessions_last_7d, dNPS: record.dnps_score },
                risk
            });
        }

        const count = drivers.length || 1;
        const avgScore = Math.round(totalScore / count);
        const retentionRate = (100 - (avgScore * 0.5)) / 100;
        const improvement = Math.max(0, retentionRate - ROI_CONSTANTS.BASELINE_RETENTION_RATE);
        const driversSaved = Math.round(count * improvement);

        processedDrivers.sort((a, b) => b.risk.score - a.risk.score);

        return {
            success: true,
            overview: {
                avgRetentionScore: Math.round(retentionRate * 100), avgRiskScore: avgScore, highRiskCount, activeDrivers: drivers.length, riskDistribution,
                roi: { costAvoided: driversSaved * ROI_CONSTANTS.COST_PER_TURNOVER, driversSaved, baselineRate: ROI_CONSTANTS.BASELINE_RETENTION_RATE * 100 }
            },
            financialHealth: { avgWeeklyPay: Math.round(totalWeeklyPay / count), avgPayVolatility: Math.round(payVolatilitySum / count), volatilityStatus: Math.round(payVolatilitySum / count) > 15 ? 'UNSTABLE' : 'STABLE' },
            atRiskWatchlist: processedDrivers.filter(d => d.risk.score >= RISK_THRESHOLDS.MEDIUM),
            allDrivers: processedDrivers
        };
    } catch (error) {
        log({ level: 'ERROR', source: 'retention-service', message: error.message }).catch(() => {});
        throw new Error('Failed to load retention dashboard');
    }
}

export async function refreshAllRetentionRiskScores() {
    const startTime = Date.now();
    try {
        const perfResult = await dataAccess.queryRecords(COLLECTION_KEYS.driverPerformance, { limit: 1000, suppressAuth: true });
        const records = perfResult.items || [];
        const now = new Date();
        
        for (const metrics of records) {
            const risk = calculateRiskScore(metrics);
            await dataAccess.insertRecord(COLLECTION_KEYS.riskLogs, {
                driver_id: metrics.driver_id, carrier_dot: metrics.carrier_dot,
                risk_level: risk.level, risk_score: risk.score, primary_factor: risk.primaryFactor,
                assessment_date: now.toISOString()
            }, { suppressAuth: true });
        }
        return { success: true, processed: records.length, durationMs: Date.now() - startTime };
    } catch (error) {
        log({ level: 'ERROR', source: 'retention-service', message: `Risk refresh failed: ${error.message}` }).catch(() => {});
        return { success: false, error: error.message };
    }
}

// ===========================================
// INTERVENTION SUGGESTIONS (Phase 3 Integration)
// ===========================================

/**
 * Map risk factors to risk_types and return top 3 matching intervention templates
 * @param {string} driverId - Driver ID
 * @param {Object} riskData - Risk calculation result from calculateRiskScore
 * @returns {Promise<Object>} { suggestions: Array }
 */
export async function getInterventionSuggestions(driverId, riskData) {
    try {
        if (!riskData || !riskData.allFactors || riskData.allFactors.length === 0) {
            return { success: true, suggestions: [] };
        }

        // Map risk factors to intervention risk_types
        const riskTypeMap = {
            'Silence Signal': 'SILENCE_SIGNAL',
            'Decreasing App Engagement': 'SILENCE_SIGNAL',
            'Detractor': 'DETRACTOR_NPS',
            'Multiple Safety Incidents': 'SAFETY_INCIDENT',
            'Safety Incident': 'SAFETY_INCIDENT',
            'Extreme Pay Volatility': 'PAY_VOLATILITY',
            'Unstable Pay Checks': 'PAY_VOLATILITY',
            'Severe Burnout Risk': 'BURNOUT_RISK'
        };

        const matchedRiskTypes = new Set();
        for (const factor of riskData.allFactors) {
            for (const [pattern, riskType] of Object.entries(riskTypeMap)) {
                if (factor.includes(pattern)) {
                    matchedRiskTypes.add(riskType);
                }
            }
        }

        if (matchedRiskTypes.size === 0) {
            return { success: true, suggestions: [] };
        }

        // Lazy-load interventionService to avoid circular deps
        const interventionService = await import('backend/interventionService');

        const allSuggestions = [];
        for (const riskType of matchedRiskTypes) {
            const result = await interventionService.getTemplates('', riskType);
            if (result.success && result.templates) {
                allSuggestions.push(...result.templates);
            }
        }

        // Return top 3 sorted by usage count (most effective first)
        const top3 = allSuggestions
            .sort((a, b) => (b.usage_count || 0) - (a.usage_count || 0))
            .slice(0, 3);

        return { success: true, suggestions: top3 };
    } catch (error) {
        console.error('getInterventionSuggestions error:', error);
        return { success: false, error: error.message, suggestions: [] };
    }
}

// ===========================================
// RETENTION OUTCOMES (Task 3)
// ===========================================

/**
 * Log when a driver-carrier match converts to a hire.
 * @param {string} driverId
 * @param {string} carrierDot
 * @param {string} matchedDate - ISO date string of original match
 */
export async function logHireEvent(driverId, carrierDot, matchedDate) {
    try {
        await dataAccess.insertRecord(COLLECTION_KEYS.retentionOutcomes, {
            driver_id: driverId,
            carrier_dot: carrierDot,
            matched_date: matchedDate,
            hire_date: new Date().toISOString().split('T')[0],
            event_type: 'hire',
            still_employed: true,
            days_elapsed: 0
        }, { suppressAuth: true });
        return { success: true };
    } catch (error) {
        console.error('logHireEvent error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Called at 90/180/365-day checkpoints to record retention status.
 * @param {string} driverId
 * @param {string} carrierDot
 * @param {number} daysElapsed
 * @param {boolean} stillEmployed
 */
export async function logRetentionCheckpoint(driverId, carrierDot, daysElapsed, stillEmployed) {
    try {
        await dataAccess.insertRecord(COLLECTION_KEYS.retentionOutcomes, {
            driver_id: driverId,
            carrier_dot: carrierDot,
            event_type: 'checkpoint',
            days_elapsed: daysElapsed,
            still_employed: stillEmployed,
            checkpoint_date: new Date().toISOString().split('T')[0]
        }, { suppressAuth: true });
        return { success: true };
    } catch (error) {
        console.error('logRetentionCheckpoint error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Returns avg tenure and 12-month retention rate for a carrier.
 * @param {string} carrierDot
 * @returns {Promise<Object>} { avgTenureDays, twelveMonthRetentionRate, totalHires }
 */
export async function getRetentionStats(carrierDot) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.retentionOutcomes, {
            filters: { carrier_dot: carrierDot, event_type: 'hire' },
            limit: 1000,
            suppressAuth: true
        });
        const hireRecords = result.items || [];

        if (hireRecords.length === 0) {
            return { success: true, avgTenureDays: 0, twelveMonthRetentionRate: 0, totalHires: 0 };
        }

        // Pull checkpoint records for the same carrier to compute 365-day retention
        const checkpointResult = await dataAccess.queryRecords(COLLECTION_KEYS.retentionOutcomes, {
            filters: { carrier_dot: carrierDot, event_type: 'checkpoint', days_elapsed: 365 },
            limit: 1000,
            suppressAuth: true
        });
        const yearCheckpoints = checkpointResult.items || [];

        const stillAt365 = yearCheckpoints.filter(r => r.still_employed).length;
        const twelveMonthRetentionRate = yearCheckpoints.length > 0
            ? Math.round((stillAt365 / yearCheckpoints.length) * 100)
            : 0;

        // Avg tenure from hire records that have a known end (still_employed = false)
        const terminatedRecords = hireRecords.filter(r => !r.still_employed && r.days_elapsed > 0);
        const avgTenureDays = terminatedRecords.length > 0
            ? Math.round(terminatedRecords.reduce((sum, r) => sum + (r.days_elapsed || 0), 0) / terminatedRecords.length)
            : 0;

        return {
            success: true,
            avgTenureDays,
            twelveMonthRetentionRate,
            totalHires: hireRecords.length
        };
    } catch (error) {
        console.error('getRetentionStats error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Heuristic predicted retention score (0-1) based on carrier signals.
 * Base 0.5 + pay match bonus (+0.2) + low turnover (+0.15) + low accident rate (+0.1) + fleet size fit (+0.05)
 * @param {Object} driverProfile - Driver profile fields
 * @param {Object} carrierProfile - Carrier profile fields
 * @returns {Promise<number>} Score between 0 and 1
 */
export async function getPredictedRetentionScore(driverProfile, carrierProfile) {
    try {
        let score = 0.5;

        // Pay match bonus: driver expected CPM vs carrier offered CPM
        const driverPayExpectation = Number(driverProfile.desired_pay_cpm) || 0;
        const carrierOfferedCpm = Number(carrierProfile.pay_cpm) || 0;
        if (carrierOfferedCpm > 0 && driverPayExpectation > 0) {
            const payRatio = carrierOfferedCpm / driverPayExpectation;
            if (payRatio >= 1.0) score += 0.2;
            else if (payRatio >= 0.9) score += 0.1;
        }

        // Low turnover bonus: carrier annual turnover < 50% is below avg
        const turnoverPct = Number(carrierProfile.driver_turnover_rate) || 90;
        if (turnoverPct < 50) score += 0.15;
        else if (turnoverPct < 70) score += 0.07;

        // Low accident rate bonus
        const accidentRate = Number(carrierProfile.accident_rate) || 0;
        if (accidentRate < 1) score += 0.1;
        else if (accidentRate < 2) score += 0.05;

        // Fleet size fit bonus: driver prefers small/mid-carrier
        const fleetSize = Number(carrierProfile.total_power_units) || 0;
        const driverPreference = driverProfile.preferred_fleet_size || '';
        if (driverPreference === 'small' && fleetSize <= 50) score += 0.05;
        else if (driverPreference === 'mid' && fleetSize > 50 && fleetSize <= 500) score += 0.05;
        else if (driverPreference === 'large' && fleetSize > 500) score += 0.05;

        return { success: true, score: Math.min(1, Math.round(score * 100) / 100) };
    } catch (error) {
        console.error('getPredictedRetentionScore error:', error);
        return { success: false, score: 0.5, error: error.message };
    }
}

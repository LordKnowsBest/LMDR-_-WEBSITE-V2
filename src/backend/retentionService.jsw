import wixUsersBackend from 'wix-users-backend';
import { log } from 'backend/observabilityService';
import { getSubscription } from 'backend/subscriptionService';
import { seedDriverPerformance } from 'backend/seeds/seedMockData';
import * as dataAccess from 'backend/dataAccess';

// ===========================================
// CONFIGURATION & CONSTANTS
// ===========================================

const RISK_THRESHOLDS = { CRITICAL: 90, HIGH: 70, MEDIUM: 40 };
const RISK_LEVELS = { CRITICAL: 'CRITICAL', HIGH: 'HIGH', MEDIUM: 'MEDIUM', LOW: 'LOW' };
const ROI_CONSTANTS = { COST_PER_TURNOVER: 10000, BASELINE_RETENTION_RATE: 0.55 };

// Collection keys for dataAccess
const COLLECTION_KEYS = {
    driverPerformance: 'driverPerformance',
    riskLogs: 'retentionRiskLogs',
    carriers: 'carriers'
};

// ===========================================
// CORE LOGIC
// ===========================================

export function calculateRiskScore(metrics) {
    let score = 0, factors = [], suggestedActions = [];
    const { miles_driven, on_time_delivery_rate, safety_incidents, home_time_days, prev_miles_driven, pay_volatility_index, avg_weekly_pay, app_sessions_last_7d, app_sessions_prev_7d, dnps_score } = metrics;

    if (dnps_score !== undefined && dnps_score <= 6) {
        score = 95; factors.unshift('Detractor (dNPS ' + dnps_score + ')');
        suggestedActions.push("Immediate Manager Call");
    }

    if (app_sessions_prev_7d > 0) {
        const activityDrop = (app_sessions_prev_7d - app_sessions_last_7d) / app_sessions_prev_7d;
        if (activityDrop >= 0.50) { score += 50; factors.push('Silence Signal: 50%+ Activity Drop'); suggestedActions.push("Trigger Check-in (SMS)"); }
        else if (activityDrop >= 0.30) { score += 20; factors.push('Decreasing App Engagement'); }
    }

    if (safety_incidents >= 2) { score += 60; factors.push('Multiple Safety Incidents'); suggestedActions.push("Schedule Safety Review"); }
    else if (safety_incidents === 1) { score += 30; factors.push('Safety Incident'); }

    if (pay_volatility_index > 25) { score += 45; factors.push('Extreme Pay Volatility (>25%)'); suggestedActions.push("Verify Pay / Payroll Audit"); }
    else if (pay_volatility_index > 15) { score += 25; factors.push('Unstable Pay Checks'); }

    if (home_time_days < 2) { score += 30; factors.push('Severe Burnout Risk (Low Home Time)'); suggestedActions.push("Schedule Time Off"); }

    score = Math.min(100, score);
    let level = score >= RISK_THRESHOLDS.CRITICAL ? RISK_LEVELS.CRITICAL : score >= RISK_THRESHOLDS.HIGH ? RISK_LEVELS.HIGH : score >= RISK_THRESHOLDS.MEDIUM ? RISK_LEVELS.MEDIUM : RISK_LEVELS.LOW;

    return { score, level, primaryFactor: factors[0] || 'Stable Operation', allFactors: factors, suggestedActions: suggestedActions.slice(0, 2) };
}

// ===========================================
// EXPORTED SERVICES
// ===========================================

async function verifyCarrierOwnership(carrierDot) {
    const user = wixUsersBackend.currentUser;
    if (!user.loggedIn) throw new Error('Not authenticated');
    
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
        filters: { dot_number: carrierDot, _owner: user.id },
        limit: 1, suppressAuth: true
    });
    if (!result.success || !result.items?.length) throw new Error('Unauthorized');
    return true;
}

export async function getCarrierRetentionDashboardForCarrier(carrierDot) {
    try {
        await verifyCarrierOwnership(carrierDot);
        const sub = await getSubscription(carrierDot);
        if (!['pro', 'enterprise'].includes(sub.plan_type)) {
            return { success: true, isFreeTier: true, message: 'Upgrade to Pro to identify flight-risk drivers.', upgradeUrl: '/pricing' };
        }
        return await getCarrierRetentionDashboard(carrierDot);
    } catch (error) {
        return { success: false, error: error.message };
    }
}

export async function getCarrierRetentionDashboard(carrierDot) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.driverPerformance, {
            filters: { carrier_dot: carrierDot }, limit: 1000, suppressAuth: true
        });
        let drivers = result.items || [];

        if (drivers.length === 0) drivers = await seedDriverPerformance(carrierDot);

        let totalScore = 0, highRiskCount = 0, riskDistribution = { LOW: 0, MEDIUM: 0, HIGH: 0, CRITICAL: 0 };
        let payVolatilitySum = 0, totalWeeklyPay = 0, processedDrivers = [];

        for (const record of drivers) {
            const risk = calculateRiskScore(record);
            totalScore += risk.score;
            riskDistribution[risk.level]++;
            payVolatilitySum += (record.pay_volatility_index || 0);
            totalWeeklyPay += (record.avg_weekly_pay || 0);
            if (['HIGH', 'CRITICAL'].includes(risk.level)) highRiskCount++;

            processedDrivers.push({
                driverId: record.driver_id, driverName: record.driver_name || 'Driver',
                metrics: { miles: record.miles_driven, safety: record.safety_incidents, homeTime: record.home_time_days, weeklyPay: record.avg_weekly_pay, payVolatility: record.pay_volatility_index, sessionsLast7: record.app_sessions_last_7d, dNPS: record.dnps_score },
                risk
            });
        }

        const count = drivers.length || 1;
        const avgScore = Math.round(totalScore / count);
        const retentionRate = (100 - (avgScore * 0.5)) / 100;
        const improvement = Math.max(0, retentionRate - ROI_CONSTANTS.BASELINE_RETENTION_RATE);
        const driversSaved = Math.round(count * improvement);

        processedDrivers.sort((a, b) => b.risk.score - a.risk.score);

        return {
            success: true,
            overview: {
                avgRetentionScore: Math.round(retentionRate * 100), avgRiskScore: avgScore, highRiskCount, activeDrivers: drivers.length, riskDistribution,
                roi: { costAvoided: driversSaved * ROI_CONSTANTS.COST_PER_TURNOVER, driversSaved, baselineRate: ROI_CONSTANTS.BASELINE_RETENTION_RATE * 100 }
            },
            financialHealth: { avgWeeklyPay: Math.round(totalWeeklyPay / count), avgPayVolatility: Math.round(payVolatilitySum / count), volatilityStatus: Math.round(payVolatilitySum / count) > 15 ? 'UNSTABLE' : 'STABLE' },
            atRiskWatchlist: processedDrivers.filter(d => d.risk.score >= RISK_THRESHOLDS.MEDIUM),
            allDrivers: processedDrivers
        };
    } catch (error) {
        log({ level: 'ERROR', source: 'retention-service', message: error.message }).catch(() => {});
        throw new Error('Failed to load retention dashboard');
    }
}

export async function refreshAllRetentionRiskScores() {
    const startTime = Date.now();
    try {
        const perfResult = await dataAccess.queryRecords(COLLECTION_KEYS.driverPerformance, { limit: 1000, suppressAuth: true });
        const records = perfResult.items || [];
        const now = new Date();
        
        for (const metrics of records) {
            const risk = calculateRiskScore(metrics);
            await dataAccess.insertRecord(COLLECTION_KEYS.riskLogs, {
                driver_id: metrics.driver_id, carrier_dot: metrics.carrier_dot,
                risk_level: risk.level, risk_score: risk.score, primary_factor: risk.primaryFactor,
                assessment_date: now.toISOString()
            }, { suppressAuth: true });
        }
        return { success: true, processed: records.length, durationMs: Date.now() - startTime };
    } catch (error) {
        log({ level: 'ERROR', source: 'retention-service', message: `Risk refresh failed: ${error.message}` }).catch(() => {});
        return { success: false, error: error.message };
    }
}

// ===========================================
// INTERVENTION SUGGESTIONS (Phase 3 Integration)
// ===========================================

/**
 * Map risk factors to risk_types and return top 3 matching intervention templates
 * @param {string} driverId - Driver ID
 * @param {Object} riskData - Risk calculation result from calculateRiskScore
 * @returns {Promise<Object>} { suggestions: Array }
 */
export async function getInterventionSuggestions(driverId, riskData) {
    try {
        if (!riskData || !riskData.allFactors || riskData.allFactors.length === 0) {
            return { success: true, suggestions: [] };
        }

        // Map risk factors to intervention risk_types
        const riskTypeMap = {
            'Silence Signal': 'SILENCE_SIGNAL',
            'Decreasing App Engagement': 'SILENCE_SIGNAL',
            'Detractor': 'DETRACTOR_NPS',
            'Multiple Safety Incidents': 'SAFETY_INCIDENT',
            'Safety Incident': 'SAFETY_INCIDENT',
            'Extreme Pay Volatility': 'PAY_VOLATILITY',
            'Unstable Pay Checks': 'PAY_VOLATILITY',
            'Severe Burnout Risk': 'BURNOUT_RISK'
        };

        const matchedRiskTypes = new Set();
        for (const factor of riskData.allFactors) {
            for (const [pattern, riskType] of Object.entries(riskTypeMap)) {
                if (factor.includes(pattern)) {
                    matchedRiskTypes.add(riskType);
                }
            }
        }

        if (matchedRiskTypes.size === 0) {
            return { success: true, suggestions: [] };
        }

        // Lazy-load interventionService to avoid circular deps
        const interventionService = await import('backend/interventionService');

        const allSuggestions = [];
        for (const riskType of matchedRiskTypes) {
            const result = await interventionService.getTemplates('', riskType);
            if (result.success && result.templates) {
                allSuggestions.push(...result.templates);
            }
        }

        // Return top 3 sorted by usage count (most effective first)
        const top3 = allSuggestions
            .sort((a, b) => (b.usage_count || 0) - (a.usage_count || 0))
            .slice(0, 3);

        return { success: true, suggestions: top3 };
    } catch (error) {
        console.error('getInterventionSuggestions error:', error);
        return { success: false, error: error.message, suggestions: [] };
    }
}

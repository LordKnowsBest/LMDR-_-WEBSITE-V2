/**
 * agentRuntimeService.jsw
 *
 * Velo-side wrapper for the external AI Runtime microservice.
 *
 * Exposes two functions consumed by agentService.jsw:
 *   - isRuntimeAvailable()  — check flag + circuit state before routing
 *   - callRuntimeStep(...)  — call POST /v1/agent/turn and normalize response
 *
 * Circuit breaker: after CIRCUIT_THRESHOLD consecutive failures the circuit
 * opens for CIRCUIT_OPEN_MS. During this window isRuntimeAvailable() returns
 * false and agentService.jsw falls back to routeAIRequest (legacy path).
 *
 * Feature flag: FEATURE_FLAGS.runtimeEnabled in configData.js must be true.
 * Set to false to disable the runtime path entirely without code changes.
 *
 * Microservice base URL: https://ai.lastmiledr.app
 * Caller timeout: 25 000 ms (microservice internal timeout is 28 000 ms)
 */

import { getSecret } from 'wix-secrets-backend';
import { FEATURE_FLAGS } from 'backend/configData';

const RUNTIME_BASE = 'https://lmdr-ai-intelligence-production.up.railway.app';
const RUNTIME_TIMEOUT_MS = 25_000; // caller budget; runtime hard-stops at 28s
const CIRCUIT_THRESHOLD = 3;       // consecutive failures to open circuit
const CIRCUIT_OPEN_MS   = 60_000;  // 60s cooldown before half-open probe

// In-memory circuit breaker state (per Velo instance)
let _circuitFailures  = 0;
let _circuitOpenUntil = 0;

// ── Circuit breaker helpers ──────────────────────────────────────────────────

function _circuitIsOpen() {
  return Date.now() < _circuitOpenUntil;
}

function _recordFailure() {
  _circuitFailures += 1;
  if (_circuitFailures >= CIRCUIT_THRESHOLD) {
    _circuitOpenUntil = Date.now() + CIRCUIT_OPEN_MS;
    console.error(
      `[agentRuntime] Circuit OPENED after ${_circuitFailures} consecutive failures.`,
      `Will retry after ${new Date(_circuitOpenUntil).toISOString()}`
    );
  }
}

function _recordSuccess() {
  if (_circuitFailures > 0) {
    console.log('[agentRuntime] Circuit closed — runtime healthy again.');
  }
  _circuitFailures  = 0;
  _circuitOpenUntil = 0;
}

// ── Internal fetch helper ────────────────────────────────────────────────────

async function _authHeaders() {
  const key = await getSecret('LMDR_INTERNAL_KEY');
  return {
    'Content-Type':        'application/json',
    'x-lmdr-internal-key': key,
    'x-lmdr-timestamp':    String(Date.now()),
  };
}

// ── Public API ───────────────────────────────────────────────────────────────

/**
 * Returns true when the runtime should be used for the next AI step.
 * Returns false if:
 *   - FEATURE_FLAGS.runtimeEnabled is false (kills runtime path without deploy)
 *   - Circuit breaker is open (too many recent failures)
 *
 * @returns {boolean}
 */
export function isRuntimeAvailable() {
  return FEATURE_FLAGS.runtimeEnabled === true && !_circuitIsOpen();
}

/**
 * Calls POST /v1/agent/turn on the external runtime microservice and
 * normalises the response into the shape agentService.jsw expects from
 * routeAIRequest: { contentBlocks, stopReason, tokensUsed, content }
 *
 * On any failure this function throws — the caller (agentService.jsw) must
 * catch and fall back to the legacy routeAIRequest path.
 *
 * @param {object} params
 * @param {string}   params.systemPrompt  - Role system prompt string
 * @param {Array}    params.messages      - Anthropic messages array
 * @param {Array}   [params.tools]        - Anthropic tool definitions (optional)
 * @param {string}  [params.modelId]      - Override model (default: claude-sonnet-4-6)
 * @param {number}  [params.maxTokens]    - Max tokens for this step (default: 2048)
 * @param {string}  [params.traceId]      - Wix run/trace ID for cross-system correlation
 *
 * @returns {Promise<{
 *   contentBlocks: Array,
 *   stopReason:   string,
 *   tokensUsed:   number,
 *   content:      string|null,
 *   providerRunId: string|null,
 *   latencyMs:    number
 * }>}
 */
/**
 * Creates a streaming session on the runtime microservice.
 *
 * Calls POST /v1/stream/agent-turn (auth required), which starts async Claude
 * streaming and returns { token, eventsPath } immediately.
 *
 * Returns { token, streamUrl, requestId } to the page code. The page code
 * forwards streamUrl to the HTML iframe, which uses AgentStreamClient.js
 * (CDN module) to open an EventSource directly from the browser.
 *
 * The browser needs NO auth headers — the token itself (unguessable 48-char
 * hex, 90 s TTL) is the credential for the events endpoint.
 *
 * @param {object} params
 * @param {string}   params.systemPrompt
 * @param {Array}    params.messages
 * @param {Array}   [params.tools]
 * @param {string}  [params.modelId]
 * @param {number}  [params.maxTokens]
 * @param {string}  [params.traceId]
 * @returns {Promise<{ token: string, streamUrl: string, requestId: string }>}
 */
export async function createStreamSession({
  systemPrompt,
  messages,
  tools = [],
  modelId,
  maxTokens,
  traceId,
}) {
  const callStart = Date.now();

  let headers;
  try {
    headers = await _authHeaders();
  } catch (err) {
    throw new Error(`[agentRuntime] Secret load failed: ${err.message}`);
  }

  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 10_000); // session create is fast

  let res;
  try {
    res = await fetch(`${RUNTIME_BASE}/v1/stream/agent-turn`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ systemPrompt, messages, tools, modelId, maxTokens, traceId }),
      signal: controller.signal,
    });
  } catch (err) {
    clearTimeout(timer);
    const reason = err.name === 'AbortError' ? 'Request timed out' : err.message;
    throw new Error(`[agentRuntime] createStreamSession fetch failed: ${reason}`);
  }

  clearTimeout(timer);

  if (!res.ok) {
    let errCode = `HTTP_${res.status}`;
    try {
      const body = await res.json();
      errCode = body?.error?.code || errCode;
    } catch { /* ignore */ }
    throw new Error(`[agentRuntime] Stream session create: runtime responded ${res.status} (${errCode})`);
  }

  const data = await res.json();
  console.log(`[agentRuntime] Stream session created in ${Date.now() - callStart}ms token=${data.token?.slice(0, 8)}…`);

  return {
    token:      data.token,
    streamUrl:  `${RUNTIME_BASE}${data.eventsPath}`,
    requestId:  data.requestId,
  };
}

export async function callRuntimeStep({
  systemPrompt,
  messages,
  tools = [],
  modelId,
  maxTokens,
  traceId,
  ragConfig,
}) {
  const callStart = Date.now();

  // ── Load auth headers ──
  let headers;
  try {
    headers = await _authHeaders();
  } catch (err) {
    _recordFailure();
    throw new Error(`[agentRuntime] Secret load failed: ${err.message}`);
  }

  // ── Abort controller for timeout ──
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), RUNTIME_TIMEOUT_MS);

  let res;
  try {
    res = await fetch(`${RUNTIME_BASE}/v1/agent/turn`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        systemPrompt,
        messages,
        tools,
        modelId,
        maxTokens,
        traceId: traceId || undefined,
        ragConfig: ragConfig || undefined,
      }),
      signal: controller.signal,
    });
  } catch (err) {
    clearTimeout(timer);
    _recordFailure();
    const reason = err.name === 'AbortError' ? 'Request timed out' : err.message;
    throw new Error(`[agentRuntime] Fetch failed: ${reason}`);
  }

  clearTimeout(timer);

  if (!res.ok) {
    let errCode = `HTTP_${res.status}`;
    try {
      const body = await res.json();
      errCode = body?.error?.code || errCode;
    } catch { /* ignore parse error */ }
    _recordFailure();
    throw new Error(`[agentRuntime] Runtime responded ${res.status} (${errCode})`);
  }

  const data = await res.json();
  _recordSuccess();

  // ── Normalise runtime response → agentService.jsw expected shape ──
  //
  // Runtime text response:   { type: 'text', text, stopReason, inputTokens, outputTokens, ... }
  // Runtime tool_use:        { type: 'tool_use', toolUseBlocks, contentBlocks, stopReason, ... }
  //
  // agentService.jsw expects: { contentBlocks, stopReason, tokensUsed, content }

  const contentBlocks = data.type === 'tool_use'
    ? (data.contentBlocks || data.toolUseBlocks || [])
    : [{ type: 'text', text: data.text || '' }];

  return {
    contentBlocks,
    stopReason:    data.stopReason || 'end_turn',
    tokensUsed:    (data.inputTokens || 0) + (data.outputTokens || 0),
    content:       data.type === 'text' ? (data.text || '') : null,
    providerRunId: data.providerRunId || null,
    latencyMs:     Date.now() - callStart,
    ragLatencyMs:       data.ragLatencyMs || 0,
    retrievedChunks:    data.retrievedChunks || 0,
    ragNoContextReason: data.ragNoContextReason || null,
  };
}

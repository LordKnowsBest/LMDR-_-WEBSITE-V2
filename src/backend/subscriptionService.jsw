import wixUsersBackend from 'wix-users-backend';
import { log } from 'backend/observabilityService';
import {
  createCheckoutSession,
  createPortalSession,
  getSubscriptionDetails,
  createPlacementDepositCheckout,
  getPublishableKey
} from 'backend/stripeService';
import * as dataAccess from 'backend/dataAccess';

// Collection keys (camelCase, matching config.jsw)
const COLLECTION_KEYS = {
  subscriptions: 'carrierSubscriptions',
  views: 'carrierDriverViews',
  carrierAccounts: 'carriers'
};

// Default free tier subscription object
const DEFAULT_FREE_SUBSCRIPTION = {
  plan_type: 'free',
  monthly_view_quota: 0,
  views_used_this_month: 0,
  is_active: true
};

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Checks if a subscription has valid data (not malformed)
 */
function isValidSubscription(subscription) {
  return subscription &&
    typeof subscription.plan_type === 'string' &&
    ['free', 'pro', 'enterprise'].includes(subscription.plan_type) &&
    typeof subscription.is_active === 'boolean';
}

function getStartOfToday() {
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
}

function getOneMonthFromNow() {
  const date = new Date();
  date.setMonth(date.getMonth() + 1);
  return date;
}

function daysBetween(from, to) {
  const msPerDay = 1000 * 60 * 60 * 24;
  return Math.ceil((to - from) / msPerDay);
}

function getCurrentBillingPeriod() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
}

function calculateRemaining(subscription) {
  if (!subscription || !subscription.is_active) return 0;
  if (subscription.monthly_view_quota === -1) return -1;
  return Math.max(0, subscription.monthly_view_quota - subscription.views_used_this_month);
}

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Gets the active subscription for a carrier
 */
export async function getSubscription(carrierDot) {
  try {
    if (!carrierDot) return { ...DEFAULT_FREE_SUBSCRIPTION };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.subscriptions, {
      filters: { 
        carrier_dot: carrierDot, 
        is_active: true 
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { ...DEFAULT_FREE_SUBSCRIPTION };
    }

    const subscription = result.items[0];
    if (!isValidSubscription(subscription) || !subscription.is_active) {
      return { ...DEFAULT_FREE_SUBSCRIPTION };
    }

    return subscription;
  } catch (error) {
    console.error('getSubscription error:', error);
    log({ level: 'ERROR', source: 'subscription-service', message: `Failed to get subscription for ${carrierDot}`, details: { error: error.message } }).catch(() => {});
    return { ...DEFAULT_FREE_SUBSCRIPTION };
  }
}

/**
 * Checks if a carrier has view quota remaining
 */
export async function checkViewQuota(carrierDot) {
  try {
    const subscription = await getSubscription(carrierDot);
    const resetResult = await resetQuotaIfNeeded(subscription);
    const currentSub = resetResult.wasReset ? resetResult.subscription : subscription;

    if (currentSub.plan_type === 'free') {
      return { hasQuota: false, remaining: 0, resetDate: currentSub.quota_reset_date || null };
    }

    if (currentSub.monthly_view_quota === -1) {
      return { hasQuota: true, remaining: -1, resetDate: currentSub.quota_reset_date };
    }

    const remaining = calculateRemaining(currentSub);
    return { hasQuota: remaining > 0, remaining, resetDate: currentSub.quota_reset_date };
  } catch (error) {
    console.error('checkViewQuota error:', error);
    log({ level: 'ERROR', source: 'subscription-service', message: `checkViewQuota failed for ${carrierDot}`, details: { error: error.message } }).catch(() => {});
    return { hasQuota: false, remaining: 0, resetDate: null, error: 'system_error' };
  }
}

/**
 * Records a profile view and increments the view count
 */
export async function recordProfileView(carrierDot, driverId, viewType, options = {}) {
  try {
    const subscription = await getSubscription(carrierDot);
    if (subscription.plan_type === 'free') return { success: false, error: 'tier_not_allowed' };

    const isUnlimited = subscription.monthly_view_quota === -1;
    const remaining = calculateRemaining(subscription);

    if (!isUnlimited && remaining <= 0) {
      return { success: false, error: 'quota_exhausted', remaining: 0, resetDate: subscription.quota_reset_date };
    }

    // Check for existing view today
    const startOfToday = getStartOfToday();
    const existingViewResult = await dataAccess.queryRecords(COLLECTION_KEYS.views, {
      filters: {
        carrier_dot: carrierDot,
        driver_id: driverId,
        _createdDate: { gte: startOfToday }
      },
      limit: 1,
      suppressAuth: true
    });

    if (existingViewResult.success && existingViewResult.items.length > 0) {
      return { success: true, alreadyViewed: true, viewId: existingViewResult.items[0]._id };
    }

    const viewRecord = {
      carrier_dot: carrierDot,
      driver_id: driverId,
      view_type: viewType,
      billing_period: getCurrentBillingPeriod(),
      _createdDate: new Date()
    };

    if (options.matchScore !== undefined) viewRecord.match_score = options.matchScore;
    if (options.recruiterId) viewRecord.recruiter_id = options.recruiterId;

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.views, viewRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    // Increment views counter
    const newViewsUsed = subscription.views_used_this_month + 1;
    await dataAccess.updateRecord(COLLECTION_KEYS.subscriptions, {
      ...subscription,
      views_used_this_month: newViewsUsed
    }, { suppressAuth: true });

    return {
      success: true,
      viewsUsed: newViewsUsed,
      remaining: isUnlimited ? -1 : Math.max(0, subscription.monthly_view_quota - newViewsUsed)
    };
  } catch (error) {
    console.error('recordProfileView error:', error);
    log({ level: 'ERROR', source: 'subscription-service', message: `recordProfileView failed for ${carrierDot}`, details: { error: error.message, driverId, viewType } }).catch(() => {});
    return { success: false, error: 'system_error' };
  }
}

/**
 * Gets usage statistics for the current billing period
 */
export async function getUsageStats(carrierDot) {
  try {
    const subscription = await getSubscription(carrierDot);
    const used = subscription.views_used_this_month || 0;
    const quota = subscription.monthly_view_quota || 0;
    const isUnlimited = quota === -1;
    const remaining = isUnlimited ? -1 : Math.max(0, quota - used);
    const isExhausted = !isUnlimited && used >= quota && quota > 0;

    let daysUntilReset = 0;
    if (subscription.quota_reset_date) {
      daysUntilReset = Math.max(0, daysBetween(new Date(), new Date(subscription.quota_reset_date)));
    }

    return {
      used, quota, remaining, plan_type: subscription.plan_type,
      isUnlimited, isExhausted, daysUntilReset, resetDate: subscription.quota_reset_date
    };
  } catch (error) {
    console.error('getUsageStats error:', error);
    return { used: 0, quota: 0, remaining: 0, plan_type: 'unknown', isUnlimited: false, isExhausted: true, daysUntilReset: 0, resetDate: null, error: 'system_error' };
  }
}

export function canSearchDrivers(subscription) {
  return subscription?.is_active && ['pro', 'enterprise'].includes(subscription.plan_type);
}

export function canViewProfile(subscription) {
  if (!subscription?.is_active || subscription.plan_type === 'free') return false;
  if (subscription.monthly_view_quota === -1) return true;
  return calculateRemaining(subscription) > 0;
}

/**
 * Resets quota if the billing cycle has passed
 */
export async function resetQuotaIfNeeded(subscription) {
  try {
    if (!subscription || subscription.plan_type === 'free' || subscription.monthly_view_quota === -1) {
      return { wasReset: false, subscription };
    }

    const now = new Date();
    const resetDate = subscription.quota_reset_date ? new Date(subscription.quota_reset_date) : null;

    if (resetDate && resetDate > now) return { wasReset: false, subscription };

    const updatedSubscription = {
      ...subscription,
      views_used_this_month: 0,
      quota_reset_date: getOneMonthFromNow()
    };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.subscriptions, updatedSubscription, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    return { wasReset: true, subscription: result.record };
  } catch (error) {
    console.error('resetQuotaIfNeeded error:', error);
    log({ level: 'ERROR', source: 'subscription-service', message: `resetQuotaIfNeeded failed`, details: { error: error.message } }).catch(() => {});
    return { wasReset: false, subscription };
  }
}

// ============================================================================
// Stripe Bridge Functions
// ============================================================================

async function getCurrentCarrier() {
  const user = wixUsersBackend.currentUser;
  if (!user.loggedIn) throw new Error('User not logged in');

  const email = await user.getEmail();
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierAccounts, {
    filters: { _owner: user.id },
    limit: 1,
    suppressAuth: true
  });

  if (result.success && result.items.length > 0) {
    return { dotNumber: String(result.items[0].dot_number), email };
  }
  throw new Error('No carrier profile found for this user');
}

export async function getAllPlanInfo() {
  return {
    pro: { id: 'pro', name: 'Pro', price: 24900, currency: 'usd', interval: 'month', quota: 25 },
    enterprise: { id: 'enterprise', name: 'Enterprise', price: 74900, currency: 'usd', interval: 'month', quota: -1 }
  };
}

export async function getStripePublishableKey() {
  return await getPublishableKey();
}

export async function getFullSubscriptionStatus(carrierDot) {
  let dot = carrierDot;
  if (!dot) {
    try {
      const carrier = await getCurrentCarrier();
      dot = carrier.dotNumber;
    } catch (e) {
      console.error('getFullSubscriptionStatus: No carrier context');
      return { success: false, error: 'No carrier profile found' };
    }
  }
  return await getSubscriptionDetails(dot);
}

export async function startCheckout(priceId, billingPeriod = 'monthly', fallbackEmail = null, fallbackDot = null) {
  try {
    let carrier;
    try {
      carrier = await getCurrentCarrier();
    } catch (carrierError) {
      let email = fallbackEmail;
      if (!email) {
        const user = wixUsersBackend.currentUser;
        if (user.loggedIn) email = await user.getEmail();
      }
      if (email) carrier = { dotNumber: fallbackDot || 'PENDING', email };
      else throw carrierError;
    }

    const baseUrl = 'https://www.lastmiledr.app';
    const successUrl = `${baseUrl}/subscription-success?session_id={CHECKOUT_SESSION_ID}&plan=${priceId}`;
    const cancelUrl = `${baseUrl}/subscription-canceled?plan=${priceId}`;

    return await createCheckoutSession(priceId, carrier.dotNumber, carrier.email, successUrl, cancelUrl, billingPeriod);
  } catch (error) {
    console.error('startCheckout error:', error);
    return { success: false, error: error.message };
  }
}

export async function startPlacementCheckout(driverCount, formData = {}) {
  try {
    const email = formData.email;
    if (!email) return { success: false, error: 'Email required for checkout' };

    const carrierDot = formData.dotNumber || formData.carrierDot || 'PENDING';
    const baseUrl = 'https://www.lastmiledr.app';
    const successUrl = `${baseUrl}/placement-success?session_id={CHECKOUT_SESSION_ID}&drivers=${driverCount}`;
    const cancelUrl = `${baseUrl}/subscription-canceled?service=placement`;

    return await createPlacementDepositCheckout(carrierDot, email, driverCount, successUrl, cancelUrl, formData);
  } catch (error) {
    console.error('startPlacementCheckout error:', error);
    return { success: false, error: error.message };
  }
}

export async function openBillingPortal() {
  try {
    const carrier = await getCurrentCarrier();
    const returnUrl = 'https://www.lastmiledr.app/carrier-dashboard';
    return await createPortalSession(carrier.dotNumber, returnUrl);
  } catch (error) {
    console.error('openBillingPortal error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get all plan information for the pricing page
 */
export async function getAllPlanInfo() {
  // Return the plan configuration matching the spec
  return {
    pro: {
      id: 'pro',
      name: 'Pro',
      price: 24900, // cents
      currency: 'usd',
      interval: 'month',
      quota: 25
    },
    enterprise: {
      id: 'enterprise',
      name: 'Enterprise',
      price: 74900, // cents
      currency: 'usd',
      interval: 'month',
      quota: -1 // unlimited
    }
  };
}

/**
 * Get Stripe publishable key
 */
export async function getStripePublishableKey() {
  return await getPublishableKey();
}

/**
 * Get full subscription status for current user's carrier
 */
export async function getFullSubscriptionStatus(carrierDot) {
  // If dot passed, use it (admin/testing), otherwise resolve current user
  let dot = carrierDot;
  if (!dot) {
    try {
      const carrier = await getCurrentCarrier();
      dot = carrier.dotNumber;
    } catch (e) {
      console.error('getFullSubscriptionStatus: No carrier context');
      return { success: false, error: 'No carrier profile found' };
    }
  }

  return await getSubscriptionDetails(dot);
}

/**
 * Start a subscription checkout session
 */
export async function startCheckout(priceId, billingPeriod = 'monthly', fallbackEmail = null, fallbackDot = null) {
  try {
    let carrier;
    try {
      carrier = await getCurrentCarrier();
    } catch (carrierError) {
      // No carrier record linked to this user â€” resolve email from available sources
      let email = fallbackEmail;

      // If no URL-param email, try the logged-in user's own email (direct-to-pricing path)
      if (!email) {
        const user = wixUsersBackend.currentUser;
        if (user.loggedIn) {
          email = await user.getEmail();
          console.log('No carrier record found, using logged-in member email for checkout:', email);
        }
      } else {
        console.log('No carrier record found, using fallback email for checkout:', email);
      }

      if (email) {
        carrier = {
          dotNumber: fallbackDot || 'PENDING',
          email: email
        };
      } else {
        throw carrierError;
      }
    }

    // Use dedicated success/cancel pages with HTML components
    const baseUrl = 'https://www.lastmiledr.app';
    const successUrl = `${baseUrl}/subscription-success?session_id={CHECKOUT_SESSION_ID}&plan=${priceId}`;
    const cancelUrl = `${baseUrl}/subscription-canceled?plan=${priceId}`;

    return await createCheckoutSession(
      priceId,
      carrier.dotNumber,
      carrier.email,
      successUrl,
      cancelUrl,
      billingPeriod
    );
  } catch (error) {
    console.error('startCheckout error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Start a placement deposit checkout (one-time)
 *
 * GUEST CHECKOUT ENABLED: This function does NOT require login.
 * It uses formData directly to identify the carrier/customer.
 * This allows carriers to pay the $100/driver deposit without creating an account first.
 *
 * @param {number} driverCount - Number of drivers to hire
 * @param {Object} formData - Form data including email, dotNumber, companyName, etc.
 * @returns {Promise<Object>} - { success, checkoutUrl } or { success: false, error }
 */
export async function startPlacementCheckout(driverCount, formData = {}) {
  try {
    // Validate required data
    const email = formData.email;
    if (!email) {
      return { success: false, error: 'Email required for checkout' };
    }

    // Get carrier DOT from formData (with fallbacks)
    // Guest users may not have a DOT yet - that's OK, we use 'PENDING'
    const carrierDot = formData.dotNumber || formData.carrierDot || 'PENDING';

    // Use dedicated success/cancel pages
    const baseUrl = 'https://www.lastmiledr.app';
    const successUrl = `${baseUrl}/placement-success?session_id={CHECKOUT_SESSION_ID}&drivers=${driverCount}`;
    const cancelUrl = `${baseUrl}/subscription-canceled?service=placement`;

    return await createPlacementDepositCheckout(
      carrierDot,
      email,
      driverCount,
      successUrl,
      cancelUrl,
      formData
    );
  } catch (error) {
    console.error('startPlacementCheckout error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Open the self-service billing portal
 */
export async function openBillingPortal() {
  try {
    const carrier = await getCurrentCarrier();
    const returnUrl = 'https://www.lastmiledr.app/carrier-dashboard';

    return await createPortalSession(carrier.dotNumber, returnUrl);
  } catch (error) {
    console.error('openBillingPortal error:', error);
    return { success: false, error: error.message };
  }
}

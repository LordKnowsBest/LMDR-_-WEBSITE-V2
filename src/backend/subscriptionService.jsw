/**
 * Subscription Service
 * 
 * Manages carrier subscriptions, usage quotas, and Stripe checkouts.
 * 
 * This service uses unified dataAccess for dual-source support.
 *
 * @module backend/subscriptionService
 */

import wixUsersBackend from 'wix-users-backend';
import { log } from 'backend/observabilityService';
import {
  createCheckoutSession,
  createPortalSession,
  getSubscriptionDetails,
  createPlacementDepositCheckout,
  getPublishableKey
} from 'backend/stripeService';
import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const COLLECTION_KEYS = {
  subscriptions: 'carrierSubscriptions',
  views: 'carrierDriverViews',
  carrierAccounts: 'carriers'
};

const DEFAULT_FREE_SUBSCRIPTION = {
  plan_type: 'free',
  monthly_view_quota: 0,
  views_used_this_month: 0,
  is_active: true
};

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function isValidSubscription(subscription) {
  return subscription &&
    typeof subscription.plan_type === 'string' &&
    ['free', 'pro', 'enterprise'].includes(subscription.plan_type) &&
    typeof subscription.is_active === 'boolean';
}

function getStartOfToday() {
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
}

function getOneMonthFromNow() {
  const date = new Date();
  date.setMonth(date.getMonth() + 1);
  return date;
}

function daysBetween(from, to) {
  const msPerDay = 1000 * 60 * 60 * 24;
  return Math.ceil((to - from) / msPerDay);
}

function getCurrentBillingPeriod() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
}

function calculateRemaining(subscription) {
  if (!subscription || !subscription.is_active) return 0;
  if (subscription.monthly_view_quota === -1) return -1;
  return Math.max(0, subscription.monthly_view_quota - subscription.views_used_this_month);
}

async function getCurrentCarrier() {
  const user = wixUsersBackend.currentUser;
  if (!user.loggedIn) throw new Error('User not logged in');

  const email = await user.getEmail();
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierAccounts, {
    filters: { _owner: user.id },
    limit: 1,
    suppressAuth: true
  });

  if (result.success && result.items.length > 0) {
    return { dotNumber: String(result.items[0].dot_number), email };
  }
  throw new Error('No carrier profile found for this user');
}

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Gets the active subscription for a carrier
 */
export async function getSubscription(carrierDot) {
  try {
    if (!carrierDot) return { ...DEFAULT_FREE_SUBSCRIPTION };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.subscriptions, {
      filters: { 
        carrier_dot: String(carrierDot), 
        is_active: true 
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { ...DEFAULT_FREE_SUBSCRIPTION };
    }

    const subscription = result.items[0];
    if (!isValidSubscription(subscription) || !subscription.is_active) {
      return { ...DEFAULT_FREE_SUBSCRIPTION };
    }

    return subscription;
  } catch (error) {
    console.error('[subscriptionService] getSubscription error:', error.message);
    return { ...DEFAULT_FREE_SUBSCRIPTION };
  }
}

/**
 * Checks if a carrier has view quota remaining
 */
export async function checkViewQuota(carrierDot) {
  try {
    const subscription = await getSubscription(carrierDot);
    const resetResult = await resetQuotaIfNeeded(subscription);
    const currentSub = resetResult.wasReset ? resetResult.subscription : subscription;

    if (currentSub.plan_type === 'free') {
      return { hasQuota: false, remaining: 0, resetDate: currentSub.quota_reset_date || null };
    }

    if (currentSub.monthly_view_quota === -1) {
      return { hasQuota: true, remaining: -1, resetDate: currentSub.quota_reset_date };
    }

    const remaining = calculateRemaining(currentSub);
    return { hasQuota: remaining > 0, remaining, resetDate: currentSub.quota_reset_date };
  } catch (error) {
    console.error('[subscriptionService] checkViewQuota error:', error.message);
    return { hasQuota: false, remaining: 0, resetDate: null, error: 'system_error' };
  }
}

/**
 * Records a profile view and increments usage count
 */
export async function recordProfileView(carrierDot, driverId, viewType, options = {}) {
  try {
    const subscription = await getSubscription(carrierDot);
    if (subscription.plan_type === 'free') return { success: false, error: 'tier_not_allowed' };

    const isUnlimited = subscription.monthly_view_quota === -1;
    const remaining = calculateRemaining(subscription);

    if (!isUnlimited && remaining <= 0) {
      return { success: false, error: 'quota_exhausted', remaining: 0, resetDate: subscription.quota_reset_date };
    }

    // Check for existing view today to avoid double-charging quota
    const startOfToday = getStartOfToday();
    const existingViewResult = await dataAccess.queryRecords(COLLECTION_KEYS.views, {
      filters: {
        carrier_dot: String(carrierDot),
        driver_id: driverId,
        _createdDate: { gte: startOfToday }
      },
      limit: 1,
      suppressAuth: true
    });

    if (existingViewResult.success && existingViewResult.items.length > 0) {
      return { success: true, alreadyViewed: true, viewId: existingViewResult.items[0]._id };
    }

    const viewRecord = {
      carrier_dot: String(carrierDot),
      driver_id: driverId,
      view_type: viewType,
      billing_period: getCurrentBillingPeriod(),
      _createdDate: new Date()
    };

    if (options.matchScore !== undefined) viewRecord.match_score = options.matchScore;
    if (options.recruiterId) viewRecord.recruiter_id = options.recruiterId;

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.views, viewRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    // Increment views counter
    const newViewsUsed = (subscription.views_used_this_month || 0) + 1;
    await dataAccess.updateRecord(COLLECTION_KEYS.subscriptions, {
      ...subscription,
      _id: subscription._id,
      views_used_this_month: newViewsUsed
    }, { suppressAuth: true });

    return {
      success: true,
      viewsUsed: newViewsUsed,
      remaining: isUnlimited ? -1 : Math.max(0, subscription.monthly_view_quota - newViewsUsed)
    };
  } catch (error) {
    console.error('[subscriptionService] recordProfileView error:', error.message);
    return { success: false, error: 'system_error' };
  }
}

/**
 * Gets usage statistics
 */
export async function getUsageStats(carrierDot) {
  try {
    const subscription = await getSubscription(carrierDot);
    const used = subscription.views_used_this_month || 0;
    const quota = subscription.monthly_view_quota || 0;
    const isUnlimited = quota === -1;
    const remaining = isUnlimited ? -1 : Math.max(0, quota - used);
    const isExhausted = !isUnlimited && used >= quota && quota > 0;

    let daysUntilReset = 0;
    if (subscription.quota_reset_date) {
      daysUntilReset = Math.max(0, daysBetween(new Date(), new Date(subscription.quota_reset_date)));
    }

    return {
      used, quota, remaining, plan_type: subscription.plan_type,
      isUnlimited, isExhausted, daysUntilReset, resetDate: subscription.quota_reset_date
    };
  } catch (error) {
    console.error('[subscriptionService] getUsageStats error:', error.message);
    return { used: 0, quota: 0, remaining: 0, plan_type: 'unknown', isUnlimited: false, isExhausted: true, daysUntilReset: 0, resetDate: null, error: 'system_error' };
  }
}

/**
 * Resets quota if billing cycle has passed
 */
export async function resetQuotaIfNeeded(subscription) {
  try {
    if (!subscription || subscription.plan_type === 'free' || subscription.monthly_view_quota === -1) {
      return { wasReset: false, subscription };
    }

    const now = new Date();
    const resetDate = subscription.quota_reset_date ? new Date(subscription.quota_reset_date) : null;

    if (resetDate && resetDate > now) return { wasReset: false, subscription };

    const updatedSubscription = {
      ...subscription,
      _id: subscription._id,
      views_used_this_month: 0,
      quota_reset_date: getOneMonthFromNow()
    };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.subscriptions, updatedSubscription, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    return { wasReset: true, subscription: result.record };
  } catch (error) {
    console.error('[subscriptionService] resetQuotaIfNeeded error:', error.message);
    return { wasReset: false, subscription };
  }
}

// ============================================================================
// STRIPE BRIDGE FUNCTIONS
// ============================================================================

/**
 * Get all plan information
 */
export async function getAllPlanInfo() {
  return {
    pro: { id: 'pro', name: 'Pro', price: 24900, currency: 'usd', interval: 'month', quota: 25 },
    enterprise: { id: 'enterprise', name: 'Enterprise', price: 74900, currency: 'usd', interval: 'month', quota: -1 }
  };
}

/**
 * Get Stripe publishable key
 */
export async function getStripePublishableKey() {
  return await getPublishableKey();
}

/**
 * Get full subscription status
 */
export async function getFullSubscriptionStatus(carrierDot) {
  let dot = carrierDot;
  if (!dot) {
    try {
      const carrier = await getCurrentCarrier();
      dot = carrier.dotNumber;
    } catch (e) {
      return { success: false, error: 'No carrier profile found' };
    }
  }
  return await getSubscriptionDetails(dot);
}

/**
 * Start a subscription checkout
 */
export async function startCheckout(priceId, billingPeriod = 'monthly', fallbackEmail = null, fallbackDot = null) {
  try {
    let carrier;
    try {
      carrier = await getCurrentCarrier();
    } catch (carrierError) {
      let email = fallbackEmail;
      if (!email) {
        const user = wixUsersBackend.currentUser;
        if (user.loggedIn) email = await user.getEmail();
      }
      if (email) carrier = { dotNumber: fallbackDot || 'PENDING', email };
      else throw carrierError;
    }

    const baseUrl = 'https://www.lastmiledr.app';
    const successUrl = `${baseUrl}/subscription-success?session_id={CHECKOUT_SESSION_ID}&plan=${priceId}`;
    const cancelUrl = `${baseUrl}/subscription-canceled?plan=${priceId}`;

    return await createCheckoutSession(priceId, carrier.dotNumber, carrier.email, successUrl, cancelUrl, billingPeriod);
  } catch (error) {
    console.error('[subscriptionService] startCheckout error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Start a placement deposit checkout
 */
export async function startPlacementCheckout(driverCount, formData = {}) {
  try {
    const email = formData.email;
    if (!email) return { success: false, error: 'Email required for checkout' };

    const carrierDot = formData.dotNumber || formData.carrierDot || 'PENDING';
    const baseUrl = 'https://www.lastmiledr.app';
    const successUrl = `${baseUrl}/placement-success?session_id={CHECKOUT_SESSION_ID}&drivers=${driverCount}`;
    const cancelUrl = `${baseUrl}/subscription-canceled?service=placement`;

    return await createPlacementDepositCheckout(carrierDot, email, driverCount, successUrl, cancelUrl, formData);
  } catch (error) {
    console.error('[subscriptionService] startPlacementCheckout error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Open self-service billing portal
 */
export async function openBillingPortal() {
  try {
    const carrier = await getCurrentCarrier();
    const returnUrl = 'https://www.lastmiledr.app/carrier-dashboard';
    return await createPortalSession(carrier.dotNumber, returnUrl);
  } catch (error) {
    console.error('[subscriptionService] openBillingPortal error:', error.message);
    return { success: false, error: error.message };
  }
}
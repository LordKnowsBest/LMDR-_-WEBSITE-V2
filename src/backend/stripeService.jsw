import { getSecret } from 'wix-secrets-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  // Collection keys for dataAccess routing
  subscriptionsKey: 'carrierSubscriptions',
  stripeEventsKey: 'stripeEvents',
  billingHistoryKey: 'billingHistory',
  carrierPaymentsKey: 'carrierPayments',

  // Stripe API base URL
  stripeApiBase: 'https://api.stripe.com/v1',

  // Plan configurations
  plans: {
    pro: { name: 'LMDR Pro', monthlyQuota: 25, features: ['driver_search', 'profile_view', 'messaging'] },
    enterprise: { name: 'LMDR Enterprise', monthlyQuota: -1, features: ['driver_search', 'profile_view', 'messaging', 'api_access', 'priority_support'] }
  }
};

// ============================================================================
// STRIPE CLIENT HELPERS
// ============================================================================

let cachedSecrets = null;

async function getStripeSecrets() {
  if (cachedSecrets) return cachedSecrets;
  try {
    const [secretKey, publishableKey, pricePro, priceEnterprise, pricePlacementDeposit, webhookSecret, priceProMonthly, pricePro6Month, priceEnterprise6Month] = await Promise.all([
      getSecret('SECRET_KEY_STRIPE'), getSecret('PUBLISHABLE_STRIPE'), getSecret('STRIPE_PRICE_PRO').catch(() => null),
      getSecret('STRIPE_PRICE_ENTERPRISE').catch(() => null), getSecret('STRIPE_PRICE_PLACEMENT_DEPOSIT').catch(() => null),
      getSecret('STRIPE_WEBHOOK_SECRET').catch(() => null), getSecret('STRIPE_PRICE_PRO_MONTHLY').catch(() => null),
      getSecret('STRIPE_PRICE_PRO_6MONTH').catch(() => null), getSecret('STRIPE_PRICE_ENTERPRISE_6MONTH').catch(() => null)
    ]);
    cachedSecrets = { secretKey, publishableKey, pricePro, priceEnterprise, pricePlacementDeposit, webhookSecret, priceProMonthly, pricePro6Month, priceEnterprise6Month };
    return cachedSecrets;
  } catch (error) {
    throw new Error('Stripe configuration error');
  }
}

async function stripeRequest(endpoint, method = 'GET', body = null) {
  const secrets = await getStripeSecrets();
  const options = { method, headers: { 'Authorization': `Bearer ${secrets.secretKey}`, 'Content-Type': 'application/x-www-form-urlencoded' } };
  if (body) options.body = new URLSearchParams(body).toString();
  const response = await fetch(`${CONFIG.stripeApiBase}${endpoint}`, options);
  const data = await response.json();
  if (!response.ok) throw new Error(data.error?.message || 'Stripe API error');
  return data;
}

// ============================================================================
// CHECKOUT SESSION
// ============================================================================

export async function createCheckoutSession(priceId, carrierDot, email, successUrl, cancelUrl, billingPeriod = 'monthly') {
  try {
    if (!priceId || !carrierDot || !email) return { success: false, error: 'Missing required parameters' };
    const secrets = await getStripeSecrets();
    let resolvedPriceId = priceId;

    if (priceId === 'pro') {
      resolvedPriceId = (billingPeriod === '6month' && secrets.pricePro6Month) ? secrets.pricePro6Month : (secrets.priceProMonthly || secrets.pricePro);
    } else if (priceId === 'enterprise') {
      resolvedPriceId = (billingPeriod === '6month' && secrets.priceEnterprise6Month) ? secrets.priceEnterprise6Month : secrets.priceEnterprise;
    }

    if (!resolvedPriceId) return { success: false, error: 'Invalid price ID configuration' };

    const existing = await getSubscriptionByCarrier(carrierDot);
    if (existing && existing.status === 'active') return { success: false, error: 'Already has active subscription' };

    const sessionData = await stripeRequest('/checkout/sessions', 'POST', {
      'mode': 'subscription', 'payment_method_types[0]': 'card', 'line_items[0][price]': resolvedPriceId, 'line_items[0][quantity]': '1', 'customer_email': email,
      'success_url': successUrl || 'https://www.lastmiledr.app/subscription-success?session_id={CHECKOUT_SESSION_ID}',
      'cancel_url': cancelUrl || 'https://www.lastmiledr.app/subscription-canceled',
      'metadata[carrier_dot]': carrierDot, 'subscription_data[metadata][carrier_dot]': carrierDot
    });

    return { success: true, checkoutUrl: sessionData.url, sessionId: sessionData.id };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CUSTOMER PORTAL
// ============================================================================

export async function createPortalSession(carrierDot, returnUrl) {
  try {
    const subscription = await getSubscriptionByCarrier(carrierDot);
    if (!subscription || !subscription.stripe_customer_id) return { success: false, error: 'No subscription found' };

    const portalData = await stripeRequest('/billing_portal/sessions', 'POST', {
      'customer': subscription.stripe_customer_id,
      'return_url': returnUrl || 'https://www.lastmiledr.app/recruiter-console'
    });

    return { success: true, portalUrl: portalData.url };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SUBSCRIPTION QUERIES
// ============================================================================

export async function getSubscriptionByCarrier(carrierDot) {
  try {
    const result = await dataAccess.queryRecords(CONFIG.subscriptionsKey, {
      filters: { carrier_dot: String(carrierDot).trim() },
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 1, suppressAuth: true
    });
    return result.items?.[0] || null;
  } catch (error) { return null; }
}

export async function getSubscriptionDetails(carrierDot) {
  try {
    const subscription = await getSubscriptionByCarrier(carrierDot);
    if (!subscription) return { success: true, subscription: null, tier: 'free', usage: { viewsUsed: 0, viewsLimit: 5, viewsRemaining: 5 } };

    const tier = subscription.plan_type || 'free';
    const planConfig = CONFIG.plans[tier] || { monthlyQuota: 5 };
    const viewsUsed = subscription.views_used_this_month || 0;
    const viewsLimit = planConfig.monthlyQuota === -1 ? Infinity : planConfig.monthlyQuota;

    return {
      success: true,
      subscription: { id: subscription._id, stripeSubscriptionId: subscription.stripe_subscription_id, planType: tier, status: subscription.status || 'active' },
      tier,
      usage: { viewsUsed, viewsLimit: planConfig.monthlyQuota === -1 ? 'unlimited' : viewsLimit, viewsRemaining: planConfig.monthlyQuota === -1 ? 'unlimited' : Math.max(0, viewsLimit - viewsUsed) }
    };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// SUBSCRIPTION MANAGEMENT
// ============================================================================

export async function upsertSubscription(stripeSubscription, customerId) {
  try {
    const carrierDot = stripeSubscription.metadata?.carrier_dot;
    if (!carrierDot) return { success: false, error: 'Missing carrier_dot' };

    const secrets = await getStripeSecrets();
    const priceId = stripeSubscription.items?.data[0]?.price?.id;
    let planType = 'pro';
    if (priceId === secrets.priceEnterprise || priceId === secrets.priceEnterprise6Month) planType = 'enterprise';

    const existing = await getSubscriptionByCarrier(carrierDot);
    const subscriptionData = {
      carrier_dot: carrierDot, stripe_subscription_id: stripeSubscription.id, stripe_customer_id: customerId, plan_type: planType,
      status: stripeSubscription.status, current_period_start: new Date(stripeSubscription.current_period_start * 1000),
      current_period_end: new Date(stripeSubscription.current_period_end * 1000), monthly_view_quota: CONFIG.plans[planType].monthlyQuota,
      views_used_this_month: existing?.views_used_this_month || 0, is_active: stripeSubscription.status === 'active'
    };

    const result = existing 
      ? await dataAccess.updateRecord(CONFIG.subscriptionsKey, { ...existing, ...subscriptionData }, { suppressAuth: true })
      : await dataAccess.insertRecord(CONFIG.subscriptionsKey, subscriptionData, { suppressAuth: true });

    return { success: true, subscriptionId: result.record._id };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function resetQuota(carrierDot, periodStart, periodEnd) {
  try {
    const subscription = await getSubscriptionByCarrier(carrierDot);
    if (!subscription) return { success: false, error: 'Not found' };
    await dataAccess.updateRecord(CONFIG.subscriptionsKey, { ...subscription, views_used_this_month: 0, current_period_start: periodStart, current_period_end: periodEnd }, { suppressAuth: true });
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateSubscriptionStatus(stripeSubscriptionId, status) {
  try {
    const result = await dataAccess.queryRecords(CONFIG.subscriptionsKey, { filters: { stripe_subscription_id: stripeSubscriptionId }, limit: 1, suppressAuth: true });
    if (!result.items?.length) return { success: false, error: 'Not found' };
    await dataAccess.updateRecord(CONFIG.subscriptionsKey, { ...result.items[0], status, is_active: status === 'active' }, { suppressAuth: true });
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// BILLING HISTORY & EVENT LOGGING
// ============================================================================

export async function recordBillingEvent(carrierDot, eventType, details = {}) {
  try {
    await dataAccess.insertRecord(CONFIG.billingHistoryKey, { carrier_dot: carrierDot, event_type: eventType, amount: details.amount || 0, timestamp: new Date() }, { suppressAuth: true });
  } catch (e) { }
}

export async function getBillingHistory(carrierDot, limit = 50) {
  try {
    const result = await dataAccess.queryRecords(CONFIG.billingHistoryKey, { filters: { carrier_dot: String(carrierDot) }, sort: [{ field: 'timestamp', direction: 'desc' }], limit, suppressAuth: true });
    return { success: true, history: result.items || [] };
  } catch (error) { return { success: false, history: [] }; }
}

export async function isEventProcessed(eventId) {
  try {
    const result = await dataAccess.queryRecords(CONFIG.stripeEventsKey, { filters: { event_id: eventId }, limit: 1, suppressAuth: true });
    return (result.items?.length || 0) > 0;
  } catch (e) { return false; }
}

export async function logStripeEvent(eventId, eventType, data = {}) {
  try {
    await dataAccess.insertRecord(CONFIG.stripeEventsKey, { event_id: eventId, event_type: eventType, processed_at: new Date() }, { suppressAuth: true });
  } catch (e) { }
}

export async function getPublishableKey() {
  try {
    const secrets = await getStripeSecrets();
    return { success: true, publishableKey: secrets.publishableKey };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getCheckoutSession(sessionId) {
  try {
    const session = await stripeRequest(`/checkout/sessions/${sessionId}`, 'GET');
    return { success: true, session: { id: session.id, customerEmail: session.customer_email, paymentStatus: session.payment_status, metadata: session.metadata || {} } };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function createPlacementDepositCheckout(carrierDot, email, driverCount, successUrl, cancelUrl, formData = {}) {
  try {
    const secrets = await getStripeSecrets();
    const sessionData = await stripeRequest('/checkout/sessions', 'POST', {
      'mode': 'payment', 'payment_method_types[0]': 'card', 'line_items[0][price]': secrets.pricePlacementDeposit, 'line_items[0][quantity]': String(driverCount), 'customer_email': email,
      'success_url': successUrl || 'https://www.lastmiledr.app/placement-success?session_id={CHECKOUT_SESSION_ID}',
      'cancel_url': cancelUrl || 'https://www.lastmiledr.app/pricing',
      'metadata[carrier_dot]': carrierDot, 'metadata[service_type]': 'placement_deposit'
    });
    await dataAccess.insertRecord(CONFIG.carrierPaymentsKey, { carrier_dot: carrierDot, stripe_session_id: sessionData.id, amount: secrets.pricePlacementDeposit * driverCount, status: 'pending' }, { suppressAuth: true });
    return { success: true, checkoutUrl: sessionData.url, sessionId: sessionData.id };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updatePaymentStatus(sessionId, status, paymentData = {}) {
  try {
    const result = await dataAccess.queryRecords(CONFIG.carrierPaymentsKey, { filters: { stripe_session_id: sessionId }, limit: 1, suppressAuth: true });
    if (!result.items?.length) return { success: false, error: 'Not found' };
    await dataAccess.updateRecord(CONFIG.carrierPaymentsKey, { ...result.items[0], status, completed_at: new Date() }, { suppressAuth: true });
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

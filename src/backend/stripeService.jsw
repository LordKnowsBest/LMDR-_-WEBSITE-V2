import * as dataAccess from 'backend/dataAccess';
import {
  CONFIG,
  getStripeSecrets,
  getSubscriptionByCarrier,
  getApiPartner,
  getApiSubscriptionByPartner,
  getApiPriceId,
  resolveApiTierFromSubscription,
  recordBillingEvent
} from 'backend/stripeCommon';

// Re-export shared helpers that other files depend on
export { getSubscriptionByCarrier, recordBillingEvent };

// ============================================================================
// STRIPE CLIENT HELPERS
// ============================================================================

async function stripeRequest(endpoint, method = 'GET', body = null) {
  const secrets = await getStripeSecrets();
  const options = { method, headers: { 'Authorization': `Bearer ${secrets.secretKey}`, 'Content-Type': 'application/x-www-form-urlencoded' } };
  if (body) options.body = new URLSearchParams(body).toString();
  const response = await fetch(`${CONFIG.stripeApiBase}${endpoint}`, options);
  const data = await response.json();
  if (!response.ok) throw new Error(data.error?.message || 'Stripe API error');
  return data;
}

// ============================================================================
// CHECKOUT SESSION
// ============================================================================

export async function createCheckoutSession(priceId, carrierDot, email, successUrl, cancelUrl, billingPeriod = 'monthly') {
  try {
    if (!priceId || !carrierDot || !email) return { success: false, error: 'Missing required parameters' };
    const secrets = await getStripeSecrets();
    let resolvedPriceId = priceId;

    if (priceId === 'pro') {
      resolvedPriceId = (billingPeriod === '6month' && secrets.pricePro6Month) ? secrets.pricePro6Month : (secrets.priceProMonthly || secrets.pricePro);
    } else if (priceId === 'enterprise') {
      resolvedPriceId = (billingPeriod === '6month' && secrets.priceEnterprise6Month) ? secrets.priceEnterprise6Month : secrets.priceEnterprise;
    }

    if (!resolvedPriceId) return { success: false, error: 'Invalid price ID configuration' };

    const existing = await getSubscriptionByCarrier(carrierDot);
    if (existing && existing.status === 'active') return { success: false, error: 'Already has active subscription' };

    const sessionData = await stripeRequest('/checkout/sessions', 'POST', {
      'mode': 'subscription', 'payment_method_types[0]': 'card', 'line_items[0][price]': resolvedPriceId, 'line_items[0][quantity]': '1', 'customer_email': email,
      'success_url': successUrl || 'https://www.lastmiledr.app/subscription-success?session_id={CHECKOUT_SESSION_ID}',
      'cancel_url': cancelUrl || 'https://www.lastmiledr.app/subscription-canceled',
      'metadata[carrier_dot]': carrierDot, 'subscription_data[metadata][carrier_dot]': carrierDot
    });

    return { success: true, checkoutUrl: sessionData.url, sessionId: sessionData.id };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CUSTOMER PORTAL
// ============================================================================

export async function createPortalSession(carrierDot, returnUrl) {
  try {
    const subscription = await getSubscriptionByCarrier(carrierDot);
    if (!subscription || !subscription.stripe_customer_id) return { success: false, error: 'No subscription found' };

    const portalData = await stripeRequest('/billing_portal/sessions', 'POST', {
      'customer': subscription.stripe_customer_id,
      'return_url': returnUrl || 'https://www.lastmiledr.app/recruiter-console'
    });

    return { success: true, portalUrl: portalData.url };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SUBSCRIPTION QUERIES
// ============================================================================

export async function getSubscriptionDetails(carrierDot) {
  try {
    const subscription = await getSubscriptionByCarrier(carrierDot);
    if (!subscription) return { success: true, subscription: null, tier: 'free', usage: { viewsUsed: 0, viewsLimit: 5, viewsRemaining: 5 } };

    const tier = subscription.plan_type || 'free';
    const planConfig = CONFIG.plans[tier] || { monthlyQuota: 5 };
    const viewsUsed = subscription.views_used_this_month || 0;
    const viewsLimit = planConfig.monthlyQuota === -1 ? Infinity : planConfig.monthlyQuota;

    return {
      success: true,
      subscription: { id: subscription._id, stripeSubscriptionId: subscription.stripe_subscription_id, planType: tier, status: subscription.status || 'active' },
      tier,
      usage: { viewsUsed, viewsLimit: planConfig.monthlyQuota === -1 ? 'unlimited' : viewsLimit, viewsRemaining: planConfig.monthlyQuota === -1 ? 'unlimited' : Math.max(0, viewsLimit - viewsUsed) }
    };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// BILLING HISTORY
// ============================================================================

export async function getBillingHistory(carrierDot, limit = 50) {
  try {
    const result = await dataAccess.queryRecords(CONFIG.billingHistoryKey, { filters: { carrier_dot: String(carrierDot) }, sort: [{ field: 'timestamp', direction: 'desc' }], limit, suppressAuth: true });
    return { success: true, history: result.items || [] };
  } catch (error) { return { success: false, history: [] }; }
}

export async function getPublishableKey() {
  try {
    const secrets = await getStripeSecrets();
    return { success: true, publishableKey: secrets.publishableKey };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getCheckoutSession(sessionId) {
  try {
    const session = await stripeRequest(`/checkout/sessions/${sessionId}`, 'GET');
    return { success: true, session: { id: session.id, customerEmail: session.customer_email, paymentStatus: session.payment_status, metadata: session.metadata || {} } };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function createPlacementDepositCheckout(carrierDot, email, driverCount, successUrl, cancelUrl, formData = {}) {
  try {
    const secrets = await getStripeSecrets();
    const sessionData = await stripeRequest('/checkout/sessions', 'POST', {
      'mode': 'payment', 'payment_method_types[0]': 'card', 'line_items[0][price]': secrets.pricePlacementDeposit, 'line_items[0][quantity]': String(driverCount), 'customer_email': email,
      'success_url': successUrl || 'https://www.lastmiledr.app/placement-success?session_id={CHECKOUT_SESSION_ID}',
      'cancel_url': cancelUrl || 'https://www.lastmiledr.app/pricing',
      'metadata[carrier_dot]': carrierDot, 'metadata[service_type]': 'placement_deposit'
    });
    await dataAccess.insertRecord(CONFIG.carrierPaymentsKey, { carrier_dot: carrierDot, stripe_session_id: sessionData.id, amount: secrets.pricePlacementDeposit * driverCount, status: 'pending' }, { suppressAuth: true });
    return { success: true, checkoutUrl: sessionData.url, sessionId: sessionData.id };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// API PLATFORM BILLING
// ============================================================================

export async function createApiCheckoutSession(
  partnerId,
  tier = 'starter',
  planType = 'monthly',
  successUrl = null,
  cancelUrl = null
) {
  try {
    const normalizedTier = String(tier || 'starter').toLowerCase();
    const normalizedPlan = String(planType || 'monthly').toLowerCase();
    const partner = await getApiPartner(partnerId);
    if (!partner) return { success: false, error: 'Partner not found' };

    const priceId = await getApiPriceId(normalizedTier, normalizedPlan);
    if (!priceId) return { success: false, error: 'API tier price is not configured' };

    const sessionData = await stripeRequest('/checkout/sessions', 'POST', {
      'mode': 'subscription',
      'payment_method_types[0]': 'card',
      'line_items[0][price]': priceId,
      'line_items[0][quantity]': '1',
      'customer_email': partner.contact_email,
      'success_url': successUrl || 'https://www.lastmiledr.app/api-portal?billing=success&session_id={CHECKOUT_SESSION_ID}',
      'cancel_url': cancelUrl || 'https://www.lastmiledr.app/api-portal?billing=canceled',
      'metadata[partner_id]': partnerId,
      'metadata[api_tier]': normalizedTier,
      'metadata[product]': 'external_api_platform',
      'subscription_data[metadata][partner_id]': partnerId,
      'subscription_data[metadata][api_tier]': normalizedTier,
      'subscription_data[metadata][product]': 'external_api_platform'
    });

    return { success: true, checkoutUrl: sessionData.url, sessionId: sessionData.id };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function createApiPortalSession(partnerId, returnUrl = null) {
  try {
    const subscription = await getApiSubscriptionByPartner(partnerId);
    if (!subscription?.stripe_customer_id) {
      return { success: false, error: 'No Stripe customer found for partner' };
    }

    const portalData = await stripeRequest('/billing_portal/sessions', 'POST', {
      'customer': subscription.stripe_customer_id,
      'return_url': returnUrl || 'https://www.lastmiledr.app/api-portal'
    });

    return { success: true, portalUrl: portalData.url };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getApiBillingSummary(partnerId, periodKey = null) {
  try {
    const subscription = await getApiSubscriptionByPartner(partnerId);
    if (!subscription) {
      return { success: false, error: 'No active API subscription found' };
    }

    const targetPeriod = periodKey || new Date().toISOString().slice(0, 7);
    const usageResult = await dataAccess.queryRecords(CONFIG.apiUsageKey, {
      filters: { partner_id: partnerId, period_key: targetPeriod },
      limit: 1,
      suppressAuth: true
    });
    const usageRecord = usageResult?.items?.[0] || null;

    const used = Number(usageRecord?.usage?.total_requests || 0);
    const included = Number(subscription?.rate_limits?.requests_per_month || 0);
    const unlimited = included === Number.MAX_SAFE_INTEGER || included < 0;
    const overageRequests = unlimited ? 0 : Math.max(0, used - included);
    const tierConfig = CONFIG.apiPlans[String(subscription.tier || 'starter').toLowerCase()] || CONFIG.apiPlans.starter;
    const overageRate = Number(subscription?.overage_price_per_call || tierConfig.overagePricePerCall || 0.005);
    const overageAmount = Number((overageRequests * overageRate).toFixed(2));
    const baseAmount = Number(subscription?.price_monthly || tierConfig.monthlyPrice || 0);

    return {
      success: true,
      period_key: targetPeriod,
      tier: subscription.tier,
      base_amount: baseAmount,
      usage: {
        total_requests: used,
        included_requests: unlimited ? 'unlimited' : included,
        overage_requests: overageRequests
      },
      overage_price_per_call: overageRate,
      overage_amount: overageAmount,
      estimated_total: Number((baseAmount + overageAmount).toFixed(2))
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function ensureApiStripeProducts() {
  try {
    const secrets = await getStripeSecrets();
    const products = [
      {
        tier: 'starter',
        name: 'LMDR API Starter',
        monthlyPriceId: secrets.priceApiStarterMonthly || null,
        annualPriceId: secrets.priceApiStarterAnnual || null
      },
      {
        tier: 'growth',
        name: 'LMDR API Growth',
        monthlyPriceId: secrets.priceApiGrowthMonthly || null,
        annualPriceId: secrets.priceApiGrowthAnnual || null
      },
      {
        tier: 'enterprise',
        name: 'LMDR API Enterprise',
        monthlyPriceId: secrets.priceApiEnterpriseMonthly || null,
        annualPriceId: secrets.priceApiEnterpriseAnnual || null
      }
    ];

    return {
      success: true,
      products,
      configured: products.every((item) => Boolean(item.monthlyPriceId && item.annualPriceId))
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function generateApiOverageInvoice(partnerId, periodKey = null, autoFinalize = true) {
  try {
    const subscription = await getApiSubscriptionByPartner(partnerId);
    if (!subscription?.stripe_customer_id) {
      return { success: false, error: 'No Stripe customer found for partner' };
    }

    const summary = await getApiBillingSummary(partnerId, periodKey);
    if (!summary?.success) {
      return { success: false, error: summary?.error || 'Unable to compute billing summary' };
    }
    if (Number(summary.overage_amount || 0) <= 0) {
      return { success: true, skipped: true, reason: 'No overage charges for period', summary };
    }

    const amountCents = Math.max(1, Math.round(Number(summary.overage_amount || 0) * 100));
    const period = summary.period_key || (periodKey || new Date().toISOString().slice(0, 7));
    const invoiceItem = await stripeRequest('/invoiceitems', 'POST', {
      customer: subscription.stripe_customer_id,
      amount: String(amountCents),
      currency: 'usd',
      description: `LMDR API overage (${period})`,
      'metadata[partner_id]': partnerId,
      'metadata[type]': 'api_overage',
      'metadata[period_key]': period
    });

    const invoice = await stripeRequest('/invoices', 'POST', {
      customer: subscription.stripe_customer_id,
      auto_advance: autoFinalize ? 'true' : 'false',
      collection_method: 'charge_automatically',
      'metadata[partner_id]': partnerId,
      'metadata[type]': 'api_overage',
      'metadata[period_key]': period
    });

    await recordBillingEvent(partnerId, 'api_overage_invoice_created', {
      amount: Number(summary.overage_amount || 0),
      invoice_id: invoice?.id || null,
      invoice_item_id: invoiceItem?.id || null,
      period_key: period
    });

    return {
      success: true,
      period_key: period,
      amount: Number(summary.overage_amount || 0),
      invoice_id: invoice?.id || null,
      invoice_item_id: invoiceItem?.id || null
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function changeApiSubscriptionPlan(partnerId, newTier, planType = 'monthly', immediate = true) {
  try {
    const normalizedTier = String(newTier || '').toLowerCase();
    if (!CONFIG.apiPlans[normalizedTier]) {
      return { success: false, error: 'newTier must be starter, growth, or enterprise' };
    }

    const normalizedPlanType = String(planType || 'monthly').toLowerCase() === 'annual' ? 'annual' : 'monthly';
    const subscription = await getApiSubscriptionByPartner(partnerId);
    if (!subscription?.stripe_subscription_id) {
      return { success: false, error: 'No Stripe subscription found for partner' };
    }

    const priceId = await getApiPriceId(normalizedTier, normalizedPlanType);
    if (!priceId) return { success: false, error: 'API tier price is not configured' };

    const stripeSub = await stripeRequest(`/subscriptions/${subscription.stripe_subscription_id}`, 'GET');
    const itemId = stripeSub?.items?.data?.[0]?.id;
    if (!itemId) {
      return { success: false, error: 'Unable to resolve Stripe subscription item' };
    }

    await stripeRequest(`/subscriptions/${subscription.stripe_subscription_id}`, 'POST', {
      [`items[0][id]`]: itemId,
      [`items[0][price]`]: priceId,
      proration_behavior: immediate ? 'create_prorations' : 'none'
    });

    const tierConfig = CONFIG.apiPlans[normalizedTier];
    await dataAccess.updateRecord(CONFIG.apiSubscriptionsKey, {
      _id: subscription._id,
      tier: normalizedTier,
      plan_type: normalizedPlanType,
      price_monthly: tierConfig.monthlyPrice,
      api_products: tierConfig.apiProducts,
      rate_limits: {
        requests_per_minute: tierConfig.requestsPerMinute,
        requests_per_month: tierConfig.requestsPerMonth
      },
      quotas: {
        driver_searches_monthly: tierConfig.driverSearchesMonthly,
        document_extractions_monthly: tierConfig.documentExtractionsMonthly
      },
      updated_at: new Date()
    }, { suppressAuth: true });

    await recordBillingEvent(partnerId, 'api_plan_changed', {
      amount: tierConfig.monthlyPrice,
      tier: normalizedTier,
      plan_type: normalizedPlanType
    });

    return {
      success: true,
      partner_id: partnerId,
      tier: normalizedTier,
      plan_type: normalizedPlanType
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Scheduler Service - "The Silent Night Shift"
 * Handles background jobs, batch enrichment, and abandonment recovery follow-ups.
 * 
 * This service uses unified dataAccess for dual-source support.
 *
 * @module backend/scheduler
 */

import { enrichCarrier } from 'backend/aiEnrichment';
import { scanSocialMedia } from 'backend/socialScanner';
import {
  sendAbandonmentEmail1,
  sendAbandonmentEmail2,
  sendAbandonmentEmail3,
  markEmailSent
} from 'backend/abandonmentEmailService';
import * as dataAccess from 'backend/dataAccess';
import { log } from 'backend/observabilityService';

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  carriersKey: 'carriers',
  enrichmentsKey: 'carrierEnrichments',
  
  // EXECUTION LIMITS
  batchSize: 3, 
  staleThresholdDays: 30,
  
  // THROTTLING
  delayBetweenCallsMs: 2000,
  
  // HIGH VALUE THRESHOLDS
  highValueFleetSize: 50,
  highValueScore: 80
};

const ABANDONMENT_CONFIG = {
  collectionKey: 'checkoutAbandonment',
  email2DelayDays: 3,
  email3DelayDays: 7,
  maxPerRun: 10,
  delayBetweenEmailsMs: 1000
};

// ============================================================================
// JOB: PROCESS ENRICHMENT BATCH
// ============================================================================

export async function runEnrichmentBatch() {
  console.log('â° SCHEDULER: Starting enrichment batch...');
  const startTime = Date.now();
  const traceId = `enrich-${Date.now()}`;
  
  let processedCount = 0;
  let errorCount = 0;
  let socialScansRun = 0;

  try {
    const carrierResult = await dataAccess.queryRecords(CONFIG.carriersKey, {
      sort: [{ field: 'combined_score', direction: 'desc' }],
      limit: 60,
      suppressAuth: true
    });
      
    if (!carrierResult.success || carrierResult.items.length === 0) {
      return { status: 'empty' };
    }

    const candidates = await filterForUnenriched(carrierResult.items);
    
    if (candidates.length === 0) {
      return { success: true, processed: 0, message: "All fresh" };
    }
    
    const batch = candidates.slice(0, CONFIG.batchSize);
    
    for (const carrier of batch) {
      const dot = String(carrier.dot_number || carrier.DOT_NUMBER).trim();
      if (!dot) continue;
      
      try {
        const fleetSize = carrier.nbr_power_unit || carrier.NBR_POWER_UNIT || 0;
        const score = carrier.combined_score || 0;
        const isHighValue = fleetSize >= CONFIG.highValueFleetSize || score >= CONFIG.highValueScore;
        
        let socialIntel = null;
        if (isHighValue) {
          socialIntel = await scanSocialMedia(carrier.legal_name, dot);
          if (socialIntel) socialScansRun++;
        }

        const systemPrefs = { 
          minCPM: 0.50, 
          operationType: 'Any',
          driverName: 'System Scheduler',
          isSystemJob: true 
        };

        await enrichCarrier(dot, carrier, systemPrefs, socialIntel);
        processedCount++;
        
        if (processedCount < batch.length) {
            await sleep(CONFIG.delayBetweenCallsMs);
        }
      } catch (err) {
        console.error(`âŒ FAILED DOT ${dot}:`, err.message);
        errorCount++;
      }
    }

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    
    await log({
      level: 'INFO',
      source: 'scheduler',
      message: `Enrichment batch complete: ${processedCount} processed`,
      traceId,
      details: { processedCount, socialScansRun, errorCount, duration: elapsed }
    });
    
    return { success: true, processed: processedCount, socialScans: socialScansRun, errors: errorCount, timeTaken: elapsed };
  } catch (error) {
    console.error('âŒ SCHEDULER CRITICAL FAILURE:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// JOB: PROCESS ABANDONMENT FOLLOW-UPS
// ============================================================================

export async function processAbandonmentFollowUps() {
  console.log('ðŸ“§ SCHEDULER: Starting abandonment follow-up processing...');
  const startTime = Date.now();
  const traceId = `abandon-followup-${Date.now()}`;

  let email2Sent = 0;
  let email3Sent = 0;
  let errorCount = 0;

  try {
    const now = new Date();
    const threeDaysAgo = new Date(now.getTime() - (ABANDONMENT_CONFIG.email2DelayDays * 24 * 60 * 60 * 1000));
    const sevenDaysAgo = new Date(now.getTime() - (ABANDONMENT_CONFIG.email3DelayDays * 24 * 60 * 60 * 1000));

    const result = await dataAccess.queryRecords(ABANDONMENT_CONFIG.collectionKey, {
      filters: { recovered: false },
      limit: 50,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: true, processed: 0, message: 'No pending abandonments' };
    }

    let processedCount = 0;
    for (const record of result.items) {
      if (processedCount >= ABANDONMENT_CONFIG.maxPerRun) break;
      if (record.recovered) continue;

      const abandonedAt = new Date(record.abandoned_at || record.abandonedAt);
      const abandonmentData = {
        email: record.email,
        firstName: record.first_name || record.firstName,
        planType: record.plan_type || record.planType,
        planName: record.plan_name || record.planName
      };

      try {
        if (!(record.email_3_sent || record.email3Sent) && abandonedAt <= sevenDaysAgo) {
          const sendResult = await sendAbandonmentEmail3(abandonmentData);
          if (sendResult.success) {
            await markEmailSent(record._id, 3);
            email3Sent++;
            processedCount++;
          } else {
            errorCount++;
          }
          await sleep(ABANDONMENT_CONFIG.delayBetweenEmailsMs);
          continue;
        }

        if (!(record.email_2_sent || record.email2Sent) && abandonedAt <= threeDaysAgo) {
          const sendResult = await sendAbandonmentEmail2(abandonmentData);
          if (sendResult.success) {
            await markEmailSent(record._id, 2);
            email2Sent++;
            processedCount++;
          } else {
            errorCount++;
          }
          await sleep(ABANDONMENT_CONFIG.delayBetweenEmailsMs);
        }
      } catch (err) {
        console.error(`âŒ Error processing abandonment ${record._id}:`, err.message);
        errorCount++;
      }
    }

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    
    await log({
      level: 'INFO',
      source: 'scheduler',
      message: `Abandonment follow-ups complete: ${email2Sent + email3Sent} sent`,
      traceId,
      details: { email2Sent, email3Sent, errorCount, duration: elapsed }
    });

    return { success: true, email2Sent, email3Sent, errors: errorCount, timeTaken: elapsed };
  } catch (error) {
    console.error('âŒ ABANDONMENT SCHEDULER CRITICAL FAILURE:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ACTIONS
// ============================================================================

/**
 * Records a checkout abandonment
 */
export async function recordCheckoutAbandonment(email, planType, sessionId, additionalData = {}) {
  try {
    const existing = await dataAccess.queryRecords(ABANDONMENT_CONFIG.collectionKey, {
      filters: { email: email, session_id: sessionId },
      limit: 1,
      suppressAuth: true
    });

    if (existing.success && existing.items.length > 0) {
      return { success: true, recordId: existing.items[0]._id, alreadyExists: true };
    }

    const planName = getPlanDisplayName(planType);
    const abandonmentRecord = {
      email: email,
      plan_type: planType,
      plan_name: planName,
      session_id: sessionId,
      first_name: additionalData.firstName || '',
      company_name: additionalData.companyName || '',
      abandoned_at: new Date(),
      recovered: false,
      email_1_sent: false,
      email_2_sent: false,
      email_3_sent: false
    };

    const insertResult = await dataAccess.insertRecord(ABANDONMENT_CONFIG.collectionKey, abandonmentRecord, { suppressAuth: true });
    if (!insertResult.success) throw new Error(insertResult.error);

    const insertedId = insertResult.record._id;

    // Send immediate email
    const emailData = { email, firstName: additionalData.firstName || '', planType, planName };
    const emailResult = await sendAbandonmentEmail1(emailData);

    if (emailResult.success) {
      await markEmailSent(insertedId, 1);
    }

    return { success: true, recordId: insertedId, emailSent: emailResult.success };
  } catch (error) {
    console.error('[scheduler] recordCheckoutAbandonment error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Marks abandonment as recovered
 */
export async function markAbandonmentRecovered(email, sessionId = null) {
  try {
    const filters = { email: email, recovered: false };
    if (sessionId) filters.session_id = sessionId;

    const result = await dataAccess.queryRecords(ABANDONMENT_CONFIG.collectionKey, {
      filters: filters,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) return { success: true, updated: 0 };

    let updatedCount = 0;
    for (const record of result.items) {
      await dataAccess.updateRecord(ABANDONMENT_CONFIG.collectionKey, {
        ...record,
        _id: record._id,
        recovered: true,
        recovered_at: new Date()
      }, { suppressAuth: true });
      updatedCount++;
    }

    return { success: true, updated: updatedCount };
  } catch (error) {
    console.error('[scheduler] markAbandonmentRecovered error:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// HELPERS
// ============================================================================

async function filterForUnenriched(carriers) {
  const dotNumbers = carriers.map(c => String(c.dot_number || c.DOT_NUMBER)).filter(d => d);
  if (dotNumbers.length === 0) return [];

  try {
    const existingResult = await dataAccess.queryRecords(CONFIG.enrichmentsKey, {
        filters: { dot_number: { hasSome: dotNumbers } },
        limit: 100,
        suppressAuth: true
    });
        
    const enrichmentMap = {};
    (existingResult.items || []).forEach(item => { enrichmentMap[item.dot_number] = item; });

    return carriers.filter(c => {
        const dot = String(c.dot_number || c.DOT_NUMBER);
        const existing = enrichmentMap[dot];
        if (!existing) return true;
        
        const enrichedDate = existing.enriched_date ? new Date(existing.enriched_date) : new Date(0);
        const ageInDays = (Date.now() - enrichedDate.getTime()) / (1000 * 60 * 60 * 24);
        return ageInDays > CONFIG.staleThresholdDays;
    });
  } catch (err) {
      console.error("Filter logic error:", err.message);
      return [];
  }
}

function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

function getPlanDisplayName(planType) {
  const names = { pro: 'Pro Plan', enterprise: 'Enterprise Plan' };
  return names[planType] || 'Pro Plan';
}
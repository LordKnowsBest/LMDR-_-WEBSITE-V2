/**
 * Scheduler Service - "The Silent Night Shift"
 * Handles background jobs, batch enrichment, and abandonment recovery follow-ups.
 * 
 * This service uses unified dataAccess for dual-source support.
 *
 * @module backend/scheduler
 */

import { enrichCarrier } from 'backend/aiEnrichment';
import { scanSocialMedia } from 'backend/socialScanner';
import {
  sendAbandonmentEmail1,
  sendAbandonmentEmail2,
  sendAbandonmentEmail3,
  markEmailSent
} from 'backend/abandonmentEmailService';
import * as dataAccess from 'backend/dataAccess';
import { log } from 'backend/observabilityService';
import { getSystemSetting } from 'backend/admin_config_service';

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  carriersKey: 'carriers',
  enrichmentsKey: 'carrierEnrichments',
  
  // EXECUTION LIMITS
  batchSize: 3, 
  staleThresholdDays: 30,
  
  // THROTTLING
  delayBetweenCallsMs: 2000,
  
  // HIGH VALUE THRESHOLDS
  highValueFleetSize: 50,
  highValueScore: 80
};

const ABANDONMENT_CONFIG = {
  collectionKey: 'checkoutAbandonment',
  email2DelayDays: 3,
  email3DelayDays: 7,
  maxPerRun: 10,
  delayBetweenEmailsMs: 1000
};

// ============================================================================
// JOB: PROCESS ENRICHMENT BATCH
// ============================================================================

export async function runEnrichmentBatch() {
  console.log('â° SCHEDULER: Starting enrichment batch...');
  const startTime = Date.now();
  const traceId = `enrich-${Date.now()}`;
  
  let processedCount = 0;
  let errorCount = 0;
  let socialScansRun = 0;

  try {
    // Fetch dynamic configuration
    const [batchSize, staleThresholdDays, apiRateLimit] = await Promise.all([
        getSystemSetting('enrichment_batch_size'),
        getSystemSetting('fmcsa_refresh_days'),
        getSystemSetting('api_rate_limit_per_second')
    ]);

    const delayMs = Math.max(200, 1000 / apiRateLimit);

    const carrierResult = await dataAccess.queryRecords(CONFIG.carriersKey, {
      sort: [{ field: 'combined_score', direction: 'desc' }],
      limit: 60,
      suppressAuth: true
    });
      
    if (!carrierResult.success || carrierResult.items.length === 0) {
      return { status: 'empty' };
    }

    const candidates = await filterForUnenriched(carrierResult.items, staleThresholdDays);
    
    if (candidates.length === 0) {
      return { success: true, processed: 0, message: "All fresh" };
    }
    
    const batch = candidates.slice(0, batchSize);
    
    for (const carrier of batch) {
      const dot = String(carrier.dot_number || carrier.DOT_NUMBER).trim();
      if (!dot) continue;
      
      try {
        const fleetSize = carrier.nbr_power_unit || carrier.NBR_POWER_UNIT || 0;
        const score = carrier.combined_score || 0;
        const isHighValue = fleetSize >= CONFIG.highValueFleetSize || score >= CONFIG.highValueScore;
        
        let socialIntel = null;
        if (isHighValue) {
          socialIntel = await scanSocialMedia(carrier.legal_name, dot);
          if (socialIntel) socialScansRun++;
        }

        const systemPrefs = { 
          minCPM: 0.50, 
          operationType: 'Any',
          driverName: 'System Scheduler',
          isSystemJob: true 
        };

        await enrichCarrier(dot, carrier, systemPrefs, socialIntel);
        processedCount++;
        
        if (processedCount < batch.length) {
            await sleep(delayMs);
        }
      } catch (err) {
        console.error(`âŒ FAILED DOT ${dot}:`, err.message);
        errorCount++;
      }
    }

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    
    await log({
      level: 'INFO',
      source: 'scheduler',
      message: `Enrichment batch complete: ${processedCount} processed`,
      traceId,
      details: { processedCount, socialScansRun, errorCount, duration: elapsed }
    });
    
    return { success: true, processed: processedCount, socialScans: socialScansRun, errors: errorCount, timeTaken: elapsed };
  } catch (error) {
    console.error('âŒ SCHEDULER CRITICAL FAILURE:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// JOB: NIGHTLY WEB RESEARCH BATCH
// Uses Perplexity sonar-pro for thorough web research (no time pressure).
// Pre-populates enrichment cache so real-time searches get High confidence data.
// ============================================================================

const NIGHTLY_CONFIG = {
  batchSize: 25,           // Carriers per nightly run
  perplexityTimeout: 30000, // 30s â€” no rush at night
  delayBetweenMs: 3000,    // 3s between calls (conservative rate limiting)
  budgetMs: 45000,         // 45s per carrier (FMCSA + Perplexity + Groq)
  maxStaleAgeDays: 7       // Re-enrich if older than 7 days
};

export async function runNightlyWebResearch() {
  console.log('ðŸŒ™ SCHEDULER: Starting nightly web research batch...');
  const startTime = Date.now();
  const traceId = `nightly-research-${Date.now()}`;

  let processedCount = 0;
  let errorCount = 0;
  let skippedCount = 0;

  try {
    // Fetch top carriers by combined score â€” these are most likely to be matched
    const carrierResult = await dataAccess.queryRecords(CONFIG.carriersKey, {
      sort: [{ field: 'combined_score', direction: 'desc' }],
      limit: 200,
      suppressAuth: true
    });

    if (!carrierResult.success || carrierResult.items.length === 0) {
      console.log('ðŸŒ™ No carriers to research');
      return { status: 'empty' };
    }

    // Find carriers with no enrichment or stale/low-confidence enrichment
    const candidates = await filterForResearch(carrierResult.items, NIGHTLY_CONFIG.maxStaleAgeDays);
    const batch = candidates.slice(0, NIGHTLY_CONFIG.batchSize);

    console.log(`ðŸŒ™ Found ${candidates.length} candidates, processing ${batch.length}`);

    for (const carrier of batch) {
      const dot = String(carrier.dot_number || carrier.DOT_NUMBER).trim();
      if (!dot) continue;

      try {
        console.log(`ðŸŒ™ [${processedCount + 1}/${batch.length}] Researching DOT ${dot}: ${carrier.legal_name || carrier.LEGAL_NAME || 'Unknown'}`);

        // Run full pipeline with Perplexity web research enabled
        await enrichCarrier(dot, carrier, {
          minCPM: 0.50,
          operationType: 'Any',
          driverName: 'Nightly Research Bot',
          isSystemJob: true
        }, null, {
          enableWebResearch: true,
          researchProvider: 'perplexity',
          budgetMs: NIGHTLY_CONFIG.budgetMs,
          skipCache: true  // Force re-enrichment even if cached
        });

        processedCount++;

        if (processedCount < batch.length) {
          await sleep(NIGHTLY_CONFIG.delayBetweenMs);
        }
      } catch (err) {
        console.error(`ðŸŒ™ âŒ FAILED DOT ${dot}:`, err.message);
        errorCount++;
      }
    }

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`ðŸŒ™ Nightly research complete: ${processedCount} enriched, ${errorCount} errors, ${elapsed}s`);

    await log({
      level: 'INFO',
      source: 'scheduler',
      message: `Nightly web research complete: ${processedCount} carriers enriched`,
      traceId,
      details: { processedCount, errorCount, skippedCount, candidates: candidates.length, duration: elapsed }
    });

    return { success: true, processed: processedCount, errors: errorCount, timeTaken: elapsed };
  } catch (error) {
    console.error('ðŸŒ™ âŒ NIGHTLY RESEARCH CRITICAL FAILURE:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Filter carriers that need web research:
 * - No enrichment at all
 * - Enrichment older than maxAgeDays
 * - Low confidence enrichment (worth re-enriching with web data)
 */
async function filterForResearch(carriers, maxAgeDays) {
  const dotNumbers = carriers.map(c => String(c.dot_number || c.DOT_NUMBER)).filter(d => d);
  if (dotNumbers.length === 0) return [];

  try {
    const existingResult = await dataAccess.queryRecords(CONFIG.enrichmentsKey, {
      filters: { dot_number: { hasSome: dotNumbers } },
      limit: 200,
      suppressAuth: true
    });

    const enrichmentMap = {};
    (existingResult.items || []).forEach(item => { enrichmentMap[item.dot_number] = item; });

    return carriers.filter(c => {
      const dot = String(c.dot_number || c.DOT_NUMBER);
      const existing = enrichmentMap[dot];

      // No enrichment at all â€” definitely needs research
      if (!existing) return true;

      // Low confidence â€” worth re-enriching with real web data
      if (existing.data_confidence === 'Low') return true;

      // Stale enrichment
      const enrichedDate = existing.enriched_date ? new Date(existing.enriched_date) : new Date(0);
      const ageInDays = (Date.now() - enrichedDate.getTime()) / (1000 * 60 * 60 * 24);
      return ageInDays > maxAgeDays;
    });
  } catch (err) {
    console.error('ðŸŒ™ Filter logic error:', err.message);
    return [];
  }
}

// ============================================================================
// JOB: PROCESS ABANDONMENT FOLLOW-UPS
// ============================================================================

export async function processAbandonmentFollowUps() {
  console.log('ðŸ“§ SCHEDULER: Starting abandonment follow-up processing...');
  const startTime = Date.now();
  const traceId = `abandon-followup-${Date.now()}`;

  let email2Sent = 0;
  let email3Sent = 0;
  let errorCount = 0;

  try {
    // Fetch dynamic configuration
    const [maxPerRun, apiRateLimit] = await Promise.all([
        getSystemSetting('email_batch_size'),
        getSystemSetting('api_rate_limit_per_second')
    ]);

    const delayMs = Math.max(500, 1000 / apiRateLimit);

    const now = new Date();
    const threeDaysAgo = new Date(now.getTime() - (ABANDONMENT_CONFIG.email2DelayDays * 24 * 60 * 60 * 1000));
    const sevenDaysAgo = new Date(now.getTime() - (ABANDONMENT_CONFIG.email3DelayDays * 24 * 60 * 60 * 1000));

    const result = await dataAccess.queryRecords(ABANDONMENT_CONFIG.collectionKey, {
      filters: { recovered: false },
      limit: 50,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: true, processed: 0, message: 'No pending abandonments' };
    }

    let processedCount = 0;
    for (const record of result.items) {
      if (processedCount >= maxPerRun) break;
      if (record.recovered) continue;

      const abandonedAt = new Date(record.abandoned_at || record.abandonedAt);
      const abandonmentData = {
        email: record.email,
        firstName: record.first_name || record.firstName,
        planType: record.plan_type || record.planType,
        planName: record.plan_name || record.planName
      };

      try {
        if (!(record.email_3_sent || record.email3Sent) && abandonedAt <= sevenDaysAgo) {
          const sendResult = await sendAbandonmentEmail3(abandonmentData);
          if (sendResult.success) {
            await markEmailSent(record._id, 3);
            email3Sent++;
            processedCount++;
          } else {
            errorCount++;
          }
          await sleep(delayMs);
          continue;
        }

        if (!(record.email_2_sent || record.email2Sent) && abandonedAt <= threeDaysAgo) {
          const sendResult = await sendAbandonmentEmail2(abandonmentData);
          if (sendResult.success) {
            await markEmailSent(record._id, 2);
            email2Sent++;
            processedCount++;
          } else {
            errorCount++;
          }
          await sleep(delayMs);
        }
      } catch (err) {
        console.error(`âŒ Error processing abandonment ${record._id}:`, err.message);
        errorCount++;
      }
    }

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    
    await log({
      level: 'INFO',
      source: 'scheduler',
      message: `Abandonment follow-ups complete: ${email2Sent + email3Sent} sent`,
      traceId,
      details: { email2Sent, email3Sent, errorCount, duration: elapsed }
    });

    return { success: true, email2Sent, email3Sent, errors: errorCount, timeTaken: elapsed };
  } catch (error) {
    console.error('âŒ ABANDONMENT SCHEDULER CRITICAL FAILURE:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ACTIONS
// ============================================================================

/**
 * Records a checkout abandonment
 */
export async function recordCheckoutAbandonment(email, planType, sessionId, additionalData = {}) {
  try {
    const existing = await dataAccess.queryRecords(ABANDONMENT_CONFIG.collectionKey, {
      filters: { email: email, session_id: sessionId },
      limit: 1,
      suppressAuth: true
    });

    if (existing.success && existing.items.length > 0) {
      return { success: true, recordId: existing.items[0]._id, alreadyExists: true };
    }

    const planName = getPlanDisplayName(planType);
    const abandonmentRecord = {
      email: email,
      plan_type: planType,
      plan_name: planName,
      session_id: sessionId,
      first_name: additionalData.firstName || '',
      company_name: additionalData.companyName || '',
      abandoned_at: new Date(),
      recovered: false,
      email_1_sent: false,
      email_2_sent: false,
      email_3_sent: false
    };

    const insertResult = await dataAccess.insertRecord(ABANDONMENT_CONFIG.collectionKey, abandonmentRecord, { suppressAuth: true });
    if (!insertResult.success) throw new Error(insertResult.error);

    const insertedId = insertResult.record._id;

    // Send immediate email
    const emailData = { email, firstName: additionalData.firstName || '', planType, planName };
    const emailResult = await sendAbandonmentEmail1(emailData);

    if (emailResult.success) {
      await markEmailSent(insertedId, 1);
    }

    return { success: true, recordId: insertedId, emailSent: emailResult.success };
  } catch (error) {
    console.error('[scheduler] recordCheckoutAbandonment error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Marks abandonment as recovered
 */
export async function markAbandonmentRecovered(email, sessionId = null) {
  try {
    const filters = { email: email, recovered: false };
    if (sessionId) filters.session_id = sessionId;

    const result = await dataAccess.queryRecords(ABANDONMENT_CONFIG.collectionKey, {
      filters: filters,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) return { success: true, updated: 0 };

    let updatedCount = 0;
    for (const record of result.items) {
      await dataAccess.updateRecord(ABANDONMENT_CONFIG.collectionKey, {
        ...record,
        _id: record._id,
        recovered: true,
        recovered_at: new Date()
      }, { suppressAuth: true });
      updatedCount++;
    }

    return { success: true, updated: updatedCount };
  } catch (error) {
    console.error('[scheduler] markAbandonmentRecovered error:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// HELPERS
// ============================================================================

async function filterForUnenriched(carriers, staleThresholdDays = 30) {
  const dotNumbers = carriers.map(c => String(c.dot_number || c.DOT_NUMBER)).filter(d => d);
  if (dotNumbers.length === 0) return [];

  try {
    const existingResult = await dataAccess.queryRecords(CONFIG.enrichmentsKey, {
        filters: { dot_number: { hasSome: dotNumbers } },
        limit: 100,
        suppressAuth: true
    });
        
    const enrichmentMap = {};
    (existingResult.items || []).forEach(item => { enrichmentMap[item.dot_number] = item; });

    return carriers.filter(c => {
        const dot = String(c.dot_number || c.DOT_NUMBER);
        const existing = enrichmentMap[dot];
        if (!existing) return true;
        
        const enrichedDate = existing.enriched_date ? new Date(existing.enriched_date) : new Date(0);
        const ageInDays = (Date.now() - enrichedDate.getTime()) / (1000 * 60 * 60 * 24);
        return ageInDays > staleThresholdDays;
    });
  } catch (err) {
      console.error("Filter logic error:", err.message);
      return [];
  }
}

function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

function getPlanDisplayName(planType) {
  const names = { pro: 'Pro Plan', enterprise: 'Enterprise Plan' };
  return names[planType] || 'Pro Plan';
}
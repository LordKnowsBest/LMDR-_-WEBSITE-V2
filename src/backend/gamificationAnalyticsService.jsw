/**
 * Gamification Analytics Service
 *
 * Provides metrics and monitoring for the gamification system including:
 * - XP/Points economy health metrics
 * - Achievement unlock rates
 * - Challenge completion rates
 * - Engagement metrics
 * - Gaming/abuse detection
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
    driverProgression: 'driverProgression',
    recruiterProgression: 'recruiterProgression',
    driverAchievements: 'driverAchievements',
    recruiterBadges: 'recruiterBadges',
    driverChallenges: 'driverChallenges',
    recruiterChallenges: 'recruiterChallenges',
    gamificationEvents: 'gamificationEvents',
    driverReferrals: 'driverReferrals',
    matchQualityBonuses: 'matchQualityBonuses',
    seasonalEvents: 'seasonalEvents',
    eventParticipants: 'eventParticipants'
};

// =============================================================================
// DASHBOARD METRICS
// =============================================================================

export async function getGamificationDashboardMetrics() {
    try {
        const [economy, achievements, challenges, engagement, events] = await Promise.all([
            getEconomyHealthMetrics(), getAchievementUnlockRates(), getChallengeCompletionRates(),
            getEngagementMetrics(), getEventMetrics()
        ]);
        return { success: true, timestamp: new Date().toISOString(), metrics: { economy, achievements, challenges, engagement, events } };
    } catch (error) {
        console.error('getGamificationDashboardMetrics error:', error);
        return { success: false, error: error.message };
    }
}

// =============================================================================
// ECONOMY HEALTH METRICS
// =============================================================================

export async function getEconomyHealthMetrics() {
    try {
        const [driverProgs, recruiterProgs] = await Promise.all([
            dataAccess.queryRecords(COLLECTION_KEYS.driverProgression, { limit: 5000, suppressAuth: true }).then(r => r.items || []),
            dataAccess.queryRecords(COLLECTION_KEYS.recruiterProgression, { limit: 5000, suppressAuth: true }).then(r => r.items || [])
        ]);

        const driverXPs = driverProgs.map(d => d.current_xp || 0);
        const driverStats = calculateStats(driverXPs);
        const levelDist = countDistribution(driverProgs.map(d => d.level || 1));

        const recruiterPts = recruiterProgs.map(r => r.current_points || 0);
        const recruiterStats = calculateStats(recruiterPts);
        const rankDist = countDistribution(recruiterProgs.map(r => r.rank || 1));

        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
        const recentRes = await dataAccess.queryRecords(COLLECTION_KEYS.gamificationEvents, { filters: { created_at: { gte: weekAgo } }, limit: 5000, suppressAuth: true });
        const recent = recentRes.items || [];

        const dailyXP = Math.round(recent.filter(e => e.event_type === 'xp_earned').reduce((s, e) => s + (e.xp_earned || 0), 0) / 7);
        const dailyPts = Math.round(recent.filter(e => e.event_type === 'points_earned').reduce((s, e) => s + (e.points_earned || 0), 0) / 7);

        return {
            drivers: { totalUsers: driverProgs.length, totalXP: driverStats.sum, averageXP: driverStats.avg, dailyXPEarnRate: dailyXP, levelDistribution: levelDist },
            recruiters: { totalUsers: recruiterProgs.length, totalPoints: recruiterStats.sum, averagePoints: recruiterStats.avg, dailyPointsEarnRate: dailyPts, rankDistribution: rankDist },
            health: { xpInflation: calculateInflationRate(dailyXP, driverStats.sum), pointsInflation: calculateInflationRate(dailyPts, recruiterStats.sum) }
        };
    } catch (error) { return { error: error.message }; }
}

// =============================================================================
// ACHIEVEMENT METRICS
// =============================================================================

export async function getAchievementUnlockRates() {
    try {
        const [dAch, rBadges, dProgs, rProgs] = await Promise.all([
            dataAccess.queryRecords(COLLECTION_KEYS.driverAchievements, { limit: 5000, suppressAuth: true }).then(r => r.items || []),
            dataAccess.queryRecords(COLLECTION_KEYS.recruiterBadges, { limit: 5000, suppressAuth: true }).then(r => r.items || []),
            dataAccess.countRecords(COLLECTION_KEYS.driverProgression, {}),
            dataAccess.countRecords(COLLECTION_KEYS.recruiterProgression, {})
        ]);

        const dTotal = dProgs || 1, rTotal = rProgs || 1;
        const dByAch = groupBy(dAch, 'achievement_id');
        const rByBadge = groupBy(rBadges, 'badge_id');

        const dRates = Object.entries(dByAch).map(([id, recs]) => ({ achievementId: id, count: recs.length, rate: Math.round((recs.length / dTotal) * 1000) / 10 }));
        const rRates = Object.entries(rByBadge).map(([id, recs]) => ({ badgeId: id, count: recs.length, rate: Math.round((recs.length / rTotal) * 1000) / 10 }));

        return {
            drivers: { totalUnlocks: dAch.length, averagePerUser: Math.round((dAch.length / dTotal) * 10) / 10, rates: dRates.sort((a,b)=>b.count-a.count).slice(0, 10) },
            recruiters: { totalUnlocks: rBadges.length, averagePerUser: Math.round((rBadges.length / rTotal) * 10) / 10, rates: rRates.sort((a,b)=>b.count-a.count).slice(0, 10) }
        };
    } catch (error) { return { error: error.message }; }
}

// =============================================================================
// CHALLENGE METRICS
// =============================================================================

export async function getChallengeCompletionRates() {
    try {
        const [dCh, rCh] = await Promise.all([
            dataAccess.queryRecords(COLLECTION_KEYS.driverChallenges, { limit: 5000, suppressAuth: true }).then(r => r.items || []),
            dataAccess.queryRecords(COLLECTION_KEYS.recruiterChallenges, { limit: 5000, suppressAuth: true }).then(r => r.items || [])
        ]);

        const dComp = dCh.filter(c => c.status === 'completed' || c.status === 'claimed').length;
        const rComp = rCh.filter(c => c.status === 'completed' || c.status === 'claimed').length;

        return {
            drivers: { total: dCh.length, completed: dComp, rate: dCh.length > 0 ? Math.round((dComp / dCh.length) * 100) : 0 },
            recruiters: { total: rCh.length, completed: rComp, rate: rCh.length > 0 ? Math.round((rComp / rCh.length) * 100) : 0 }
        };
    } catch (error) { return { error: error.message }; }
}

// =============================================================================
// ENGAGEMENT METRICS
// =============================================================================

export async function getEngagementMetrics() {
    try {
        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
        const [recent, referrals, bonuses] = await Promise.all([
            dataAccess.queryRecords(COLLECTION_KEYS.gamificationEvents, { filters: { created_at: { gte: monthAgo } }, limit: 10000, suppressAuth: true }).then(r => r.items || []),
            dataAccess.countRecords(COLLECTION_KEYS.driverReferrals, { is_referrer_record: 'No' }),
            dataAccess.countRecords(COLLECTION_KEYS.matchQualityBonuses, {})
        ]);

        const mau = new Set(recent.map(e => e.user_id)).size;
        const types = groupBy(recent, 'event_type');

        return {
            activeUsers: { monthly: mau },
            events: { last30d: recent.length, types: Object.entries(types).map(([t, e]) => ({ type: t, count: e.length })).sort((a,b)=>b.count-a.count).slice(0, 5) },
            referrals: { total: referrals },
            matchQuality: { totalBonuses: bonuses }
        };
    } catch (error) { return { error: error.message }; }
}

// =============================================================================
// EVENT METRICS
// =============================================================================

export async function getEventMetrics() {
    try {
        const [events, participants] = await Promise.all([
            dataAccess.queryRecords(COLLECTION_KEYS.seasonalEvents, { limit: 100, suppressAuth: true }).then(r => r.items || []),
            dataAccess.queryRecords(COLLECTION_KEYS.eventParticipants, { limit: 5000, suppressAuth: true }).then(r => r.items || [])
        ]);

        return {
            summary: { totalEvents: events.length, activeEvents: events.filter(e => e.status === 'active').length, totalParticipants: participants.length },
            events: events.map(e => ({ id: e._id, name: e.name, status: e.status, participants: participants.filter(p => p.event_id === e._id).length }))
        };
    } catch (error) { return { error: error.message }; }
}

// =============================================================================
// ABUSE DETECTION
// =============================================================================

export async function detectAbusePatterns() {
    try {
        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        const recentRes = await dataAccess.queryRecords(COLLECTION_KEYS.gamificationEvents, { filters: { created_at: { gte: dayAgo } }, limit: 10000, suppressAuth: true });
        const byUser = groupBy(recentRes.items || [], 'user_id');

        const suspicious = [];
        for (const [uid, evts] of Object.entries(byUser)) {
            const xp = evts.filter(e => e.event_type === 'xp_earned').reduce((s, e) => s + (e.xp_earned || 0), 0);
            if (xp > 1000 || evts.length > 100) suspicious.push({ userId: uid, eventCount: evts.length, totalXP: xp, risk: xp > 2000 ? 'high' : 'medium' });
        }

        return { success: true, timestamp: new Date().toISOString(), totalUsers: Object.keys(byUser).length, suspiciousUsers: suspicious.sort((a,b)=>b.totalXP-a.totalXP).slice(0, 20) };
    } catch (error) { return { success: false, error: error.message }; }
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

function calculateStats(values) {
    if (!values.length) return { sum: 0, avg: 0 };
    const sum = values.reduce((a, b) => a + b, 0);
    return { sum, avg: Math.round(sum / values.length) };
}

function countDistribution(values) {
    const dist = {};
    values.forEach(v => { dist[v] = (dist[v] || 0) + 1; });
    return dist;
}

function groupBy(arr, key) {
    return arr.reduce((acc, item) => {
        const k = item[key] || 'unknown';
        if (!acc[k]) acc[k] = [];
        acc[k].push(item);
        return acc;
    }, {});
}

function calculateInflationRate(daily, total) {
    return total === 0 ? 0 : Math.round((daily / total) * 10000) / 100;
}

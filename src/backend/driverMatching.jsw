import wixData from 'wix-data';
import { currentUser } from 'wix-users-backend';
import { getSubscription, checkViewQuota, recordProfileView } from 'backend/subscriptionService';
import { calculateDriverMatchScore, generateDriverMatchRationale, getCarrierFeedbackWeights, applyFeedbackAdjustments } from 'backend/driverScoring';
import { startTrace, endTrace, log, logDatabase } from 'backend/observabilityService';
import { withRetry } from 'backend/utils/retryUtils';
import { logFeatureInteraction } from 'backend/featureAdoptionService';
import * as dataAccess from 'backend/dataAccess';

// Gamification hooks - lazy-loaded to avoid circular dependencies
async function getGamificationService() {
  return await import('backend/gamificationService');
}

// Match notifications - lazy-loaded to avoid circular dependencies
async function getMatchNotifications() {
  return await import('backend/matchNotifications');
}

function notifyDriverProfileViewedNonBlocking(driverId, carrierInfo) {
  getMatchNotifications()
    .then(svc => svc.notifyDriverProfileViewed(driverId, carrierInfo))
    .catch(err => console.warn('Profile view notification failed (non-critical):', err.message));
}

// Non-blocking recruiter points award helper
async function awardRecruiterPointsNonBlocking(recruiterId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardRecruiterPoints(recruiterId, action, metadata);
  } catch (err) {
    console.warn(`Recruiter points award failed for ${action}:`, err.message);
  }
}

// ============================================================================
// CONSTANTS
// ============================================================================

/** DEV MODE: Set to true to bypass role verification during development */
const DEV_MODE_BYPASS_ROLES = true; // TODO: Set to false for production

/** Allowed roles for accessing driver matching features */
const ALLOWED_ROLES = ['recruiter', 'admin'];

/** Tier-based result limits */
const TIER_LIMITS = {
  free: 0,
  pro: 25,
  enterprise: -1 // Unlimited
};

/** Default page size for pagination */
const DEFAULT_PAGE_SIZE = 20;

/** Score boost for mutual matches */
const MUTUAL_MATCH_SCORE_BOOST = 10;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Verifies the current user is authenticated
 * @returns {Promise<{success: boolean, userId?: string, error?: string}>}
 */
async function verifyAuthenticated() {
  if (!currentUser.loggedIn) {
    return {
      success: false,
      error: 'You must be authenticated to access this feature. Please login.'
    };
  }
  return { success: true, userId: currentUser.id };
}

/**
 * Verifies the user has an allowed role/badge (recruiter or admin)
 * Checks both Wix roles and member badges
 * @returns {Promise<{success: boolean, roles?: Array, error?: string}>}
 */
async function verifyRole() {
  // DEV MODE: Skip role verification for development/testing
  if (DEV_MODE_BYPASS_ROLES) {
    console.log('[driverMatching] DEV MODE: Bypassing role verification');
    return { success: true, roles: ['dev_bypass'] };
  }

  try {
    // First check Wix roles
    const roles = await currentUser.getRoles();
    const roleNames = roles.map(r => r.name);
    const hasAllowedRole = roleNames.some(role => ALLOWED_ROLES.includes(role));

    if (hasAllowedRole) {
      return { success: true, roles: roleNames };
    }

    // If no Wix role, check for badge assignments
    // Note: Member badges always use Wix (system collection)
    const badgeResult = await wixData.query('Members/Badges')
      .eq('memberId', currentUser.id)
      .find({ suppressAuth: true });

    if (badgeResult.items.length > 0) {
      const badgeSlugs = badgeResult.items.map(b => b.slug || b.title?.toLowerCase());
      const hasAllowedBadge = badgeSlugs.some(slug =>
        ALLOWED_ROLES.includes(slug) || slug === 'recruiter' || slug === 'admin'
      );

      if (hasAllowedBadge) {
        return { success: true, roles: badgeSlugs };
      }
    }

    return {
      success: false,
      error: 'Recruiter or admin role required to search drivers.'
    };
  } catch (err) {
    console.error('[driverMatching] Role verification error:', err.message);
    return {
      success: false,
      error: 'Failed to verify user role.'
    };
  }
}

/**
 * Verifies the user is authorized to access the specified carrier.
 * Checks the 'recruiterCarriers' collection for a valid recruiter-carrier association.
 *
 * @param {string} carrierDot - The carrier DOT number
 * @param {string} userId - The user ID
 * @returns {Promise<{success: boolean, subscription?: Object, error?: string}>}
 */
async function verifyCarrierAuthorization(carrierDot, userId) {
  try {
    // Check if the user has access to this carrier using dataAccess
    const accessResult = await dataAccess.queryRecords('recruiterCarriers', {
      filters: {
        recruiter_id: userId,
        carrier_dot: carrierDot,
        is_active: true
      },
      limit: 1,
      suppressAuth: true
    });

    if (!accessResult.success || accessResult.items.length === 0) {
      return {
        success: false,
        error: 'You are not authorized to access this carrier\'s data.'
      };
    }

    // Get subscription - internally validates carrier authorization
    const subscription = await getSubscription(carrierDot);

    if (!subscription) {
      return {
        success: false,
        error: 'No active subscription found for this carrier.'
      };
    }

    return { success: true, subscription };
  } catch (err) {
    return {
      success: false,
      error: 'An error occurred during carrier authorization.'
    };
  }
}

/**
 * Performs full access control check (auth + role + carrier authorization)
 * @param {string} carrierDot - The carrier DOT number
 * @returns {Promise<{success: boolean, userId?: string, subscription?: Object, error?: string}>}
 */
async function performAccessCheck(carrierDot) {
  // Check authentication
  const authCheck = await verifyAuthenticated();
  if (!authCheck.success) return authCheck;

  // Check role
  const roleCheck = await verifyRole();
  if (!roleCheck.success) return roleCheck;

  // Check carrier authorization (also returns subscription)
  const carrierCheck = await verifyCarrierAuthorization(carrierDot, authCheck.userId);
  if (!carrierCheck.success) return carrierCheck;

  return { success: true, userId: authCheck.userId, subscription: carrierCheck.subscription };
}

/**
 * Masks PII (email and phone) for limited visibility drivers
 * @param {Object} driver - The driver profile object
 * @returns {Object} Driver with masked PII
 */
function maskPII(driver) {
  return {
    ...driver,
    email: '***masked***',
    phone: '***masked***'
  };
}

/**
 * Gets carrier hiring preferences if available
 * @param {string} carrierDot - The carrier DOT number
 * @returns {Promise<Object|null>}
 */
async function getCarrierPreferences(carrierDot) {
  try {
    const result = await dataAccess.queryRecords('carrierHiringPreferences', {
      filters: {
        carrier_dot: carrierDot,
        is_active: true
      },
      limit: 1
    });

    return result.success && result.items.length > 0 ? result.items[0] : null;
  } catch (err) {
    return null;
  }
}

/**
 * Checks if a driver has expressed interest in a carrier
 * @param {string} carrierDot - The carrier DOT number
 * @param {string} driverId - The driver ID
 * @returns {Promise<{hasInterest: boolean, interestDate?: Date}>}
 */
async function checkDriverInterest(carrierDot, driverId) {
  try {
    const result = await dataAccess.queryRecords('driverInterests', {
      filters: {
        driver_id: driverId,
        carrier_dot: carrierDot,
        status: 'interested'
      },
      limit: 1
    });

    if (result.success && result.items.length > 0) {
      return {
        hasInterest: true,
        interestDate: result.items[0].created_date
      };
    }
    return { hasInterest: false };
  } catch (err) {
    return { hasInterest: false };
  }
}

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Searches for drivers matching the carrier's criteria
 *
 * @param {string} carrierDot - The carrier's DOT number
 * @param {Object} filters - Search filters
 * @param {Array<string>} [filters.cdl_types] - Required CDL classes ['A', 'B']
 * @param {Array<string>} [filters.endorsements] - Required endorsements
 * @param {string} [filters.zip_code] - Center zip code for location search
 * @param {number} [filters.radius_miles] - Search radius from zip code
 * @param {number} [filters.min_experience] - Minimum years of experience
 * @param {string} [filters.availability] - 'immediate', '2_week', '30_day'
 * @param {Object} options - Search options
 * @param {number} [options.page] - Page number (0-indexed)
 * @param {number} [options.pageSize] - Results per page
 * @param {number} [options.limit] - Max results to return
 * @param {boolean} [options.usePreferences] - Use carrier preferences for scoring
 * @param {boolean} [options.includeMutualMatches] - Check for mutual matches
 * @returns {Promise<Object>} Search results with matches and metadata
 */
export async function findMatchingDrivers(carrierDot, filters = {}, options = {}) {
  const startTime = Date.now();

  // Start distributed trace for this matching operation
  const trace = await startTrace('findMatchingDrivers', {
    carrierDot,
    filterCount: Object.keys(filters).length,
    tags: ['driver-matching', 'search', 'reverse-matching']
  });
  const traceId = trace.traceId;

  await log({
    level: 'INFO',
    source: 'driver-matching',
    message: 'Starting driver search',
    traceId,
    details: { carrierDot, filters: Object.keys(filters), options: Object.keys(options) }
  });

  try {
    // Access control (also retrieves subscription)
    const accessCheck = await performAccessCheck(carrierDot);
    if (!accessCheck.success) {
      await log({ level: 'WARN', source: 'driver-matching', message: `Access denied: ${accessCheck.error}`, traceId });
      await endTrace(traceId, 'denied', { error: accessCheck.error, elapsed: Date.now() - startTime });
      return { success: false, error: accessCheck.error };
    }

    const subscription = accessCheck.subscription;

    // Check if tier allows searching
    if (subscription.plan_type === 'free') {
      return {
        success: false,
        error: 'Driver search requires a Pro or Enterprise subscription. Please upgrade to access this feature.',
        code: 'SUBSCRIPTION_TIER_LIMIT'
      };
    }

    // Check if subscription is active
    if (!subscription.is_active) {
      return {
        success: false,
        error: 'Your subscription has expired or is inactive. Please renew to search drivers.',
        code: 'SUBSCRIPTION_INACTIVE'
      };
    }

    // Build base query FIRST - exclude non-searchable and hidden drivers
    const queryStartTime = Date.now();
    
    // Use dataAccess for DriverProfiles query
    const driverFilters = {
      is_searchable: true,
      visibility_level: { ne: 'hidden' }
    };

    // Add dynamic filters
    if (filters.cdl_types && Array.isArray(filters.cdl_types) && filters.cdl_types.length > 0) {
      driverFilters.cdl_class = { hasSome: filters.cdl_types };
    }

    if (filters.min_experience && typeof filters.min_experience === 'number') {
      driverFilters.years_experience = { gte: filters.min_experience };
    }

    if (filters.availability && typeof filters.availability === 'string') {
      driverFilters.availability = filters.availability;
    }

    const result = await dataAccess.queryRecords('driverProfiles', {
      filters: driverFilters,
      limit: 1000,
      suppressAuth: true
    });

    if (!result.success) throw new Error(result.error);
    let drivers = result.items || [];

    const queryLatency = Date.now() - queryStartTime;

    await logDatabase({
      operation: 'query',
      collection: 'DriverProfiles',
      affectedRows: drivers.length,
      latencyMs: queryLatency,
      traceId
    });

    // Log if no drivers found
    if (drivers.length === 0) {
      await log({
        level: 'INFO',
        source: 'driver-matching',
        message: 'No searchable drivers found in database',
        traceId,
        details: { filterCount: Object.keys(filters).length }
      });

      return {
        success: true,
        matches: [],
        message: 'No drivers found matching your criteria.',
        code: 'NO_MATCHES_DB',
        pagination: {
          page: options.page || 0,
          pageSize: options.pageSize || DEFAULT_PAGE_SIZE,
          totalCount: 0,
          totalPages: 0
        },
        subscription: {
          plan_type: subscription.plan_type,
          views_remaining: subscription.monthly_view_quota === -1 ? -1 : Math.max(0, subscription.monthly_view_quota - subscription.views_used_this_month),
          views_used: subscription.views_used_this_month,
          views_total: subscription.monthly_view_quota
        },
        traceId
      };
    }

    // Get carrier preferences if requested
    let carrierPrefs = null;
    if (options.usePreferences) {
      carrierPrefs = await getCarrierPreferences(carrierDot);
    }

    // Filter by endorsements (must have ALL) - post-query validation for complex logic
    if (filters.endorsements && Array.isArray(filters.endorsements) && filters.endorsements.length > 0) {
      drivers = drivers.filter(d => {
        if (!d.endorsements || !Array.isArray(d.endorsements)) return false;
        return filters.endorsements.every(e => d.endorsements.includes(e));
      });
    }

    // Score each driver with DYNAMIC WEIGHTS in parallel chunks
    const scoringStartTime = Date.now();
    const scoredDrivers = [];
    const scoringPrefs = carrierPrefs || {};
    let scoringFailures = 0;

    // Fetch carrier feedback weights once per search
    let feedbackWeights = null;
    try {
      feedbackWeights = await getCarrierFeedbackWeights(carrierDot);
    } catch (e) { /* ignore */ }

    // Process in parallel chunks to maximize throughput
    const CHUNK_SIZE = 50;
    for (let i = 0; i < drivers.length; i += CHUNK_SIZE) {
      const chunk = drivers.slice(i, i + CHUNK_SIZE);
      const chunkResults = await Promise.all(chunk.map(async (driver) => {
        try {
          // Apply feedback adjustments if available
          let finalWeights = scoringPrefs;
          if (feedbackWeights) {
            finalWeights = applyFeedbackAdjustments(scoringPrefs, feedbackWeights);
          }

          const scoreResult = calculateDriverMatchScore(driver, finalWeights, null, filters);
          const rationaleResult = generateDriverMatchRationale(scoreResult.scores || {}, driver, scoringPrefs);
          
          // Check for mutual match
          let isMutualMatch = false;
          let mutualMatchBoost = 0;
          if (options.includeMutualMatches) {
            const interest = await checkDriverInterest(carrierDot, driver._id);
            if (interest.hasInterest) {
              isMutualMatch = true;
              mutualMatchBoost = MUTUAL_MATCH_SCORE_BOOST;
            }
          }

          return {
            driver,
            score: Math.min(100, (scoreResult.overallScore || 0) + mutualMatchBoost),
            rationale: rationaleResult.points || [],
            summary: rationaleResult.summary,
            isMutualMatch,
            scoringFailed: false
          };
        } catch (err) {
          scoringFailures++;
          return {
            driver,
            score: 0,
            rationale: ['Match score based on available criteria.'],
            summary: 'Error calculating score',
            isMutualMatch: false,
            scoringFailed: true,
            error: err.message
          };
        }
      }));
      scoredDrivers.push(...chunkResults);
    }

    const scoringDuration = Date.now() - scoringStartTime;
    await log({
      level: 'INFO',
      source: 'driver-matching',
      message: `Scoring complete for ${scoredDrivers.length} drivers`,
      traceId,
      duration: scoringDuration
    });

    // Sort by score descending
    scoredDrivers.sort((a, b) => b.score - a.score);

    // Apply tier-based limits
    const tierLimit = TIER_LIMITS[subscription.plan_type] || 0;
    const effectiveLimit = tierLimit === -1
      ? (options.limit || scoredDrivers.length)
      : Math.min(tierLimit, options.limit || tierLimit);

    // Apply pagination
    const page = options.page || 0;
    const pageSize = options.pageSize || DEFAULT_PAGE_SIZE;
    const startIndex = page * pageSize;
    const endIndex = Math.min(startIndex + pageSize, effectiveLimit, scoredDrivers.length);

    const paginatedResults = scoredDrivers.slice(startIndex, endIndex);

    // Calculate remaining views
    const viewsRemaining = subscription.monthly_view_quota === -1
      ? -1
      : Math.max(0, subscription.monthly_view_quota - subscription.views_used_this_month);

    const elapsed = Date.now() - startTime;

    // Log successful completion
    await log({
      level: 'INFO',
      source: 'driver-matching',
      message: `Search complete: ${paginatedResults.length} results returned`,
      traceId,
      duration: elapsed,
      details: {
        totalDrivers: drivers.length,
        totalScored: scoredDrivers.length,
        returned: paginatedResults.length,
        scoringFailures,
        carrierDot,
        planType: subscription.plan_type
      }
    });

    await endTrace(traceId, 'completed', {
      totalMatches: paginatedResults.length,
      totalScored: scoredDrivers.length,
      scoringFailures,
      elapsed
    });

    // Log for Feature Adoption Tracking
    await logFeatureInteraction('recruiter_driver_search', accessCheck.userId, 'recruiter', 'search', {
      filters: Object.keys(filters),
      resultCount: paginatedResults.length,
      carrierDot
    });

    return {
      success: true,
      matches: paginatedResults,
      message: paginatedResults.length === 0
        ? 'No drivers found matching your criteria.'
        : `Found ${scoredDrivers.length} matching drivers.`,
      code: paginatedResults.length === 0 ? 'NO_MATCHES_FILTERS' : 'SUCCESS',
      pagination: {
        page,
        pageSize,
        totalCount: scoredDrivers.length,
        totalPages: Math.ceil(Math.min(scoredDrivers.length, effectiveLimit) / pageSize)
      },
      subscription: {
        plan_type: subscription.plan_type,
        views_remaining: viewsRemaining,
        views_used: subscription.views_used_this_month,
        views_total: subscription.monthly_view_quota
      },
      traceId
    };

  } catch (err) {
    await log({
      level: 'ERROR',
      source: 'driver-matching',
      message: `Search failed: ${err.message}`,
      traceId,
      details: { error: err.message, stack: err.stack }
    });
    await endTrace(traceId, 'error', { error: err.message, elapsed: Date.now() - startTime });

    return {
      success: false,
      error: err.message || 'An unexpected error occurred while searching for drivers.',
      code: 'SEARCH_ERROR',
      traceId
    };
  }
}

/**
 * Retrieves a driver's full profile (paid feature)
 *
 * @param {string} carrierDot - The carrier's DOT number
 * @param {string} driverId - The driver's profile ID
 * @param {Object} [options] - Additional options
 * @param {number} [options.matchScore] - Match score to record with view
 * @returns {Promise<Object>} Driver profile or error
 */
export async function getDriverProfile(carrierDot, driverId, options = {}) {
  try {
    // Access control (also retrieves subscription)
    const accessCheck = await performAccessCheck(carrierDot);
    if (!accessCheck.success) {
      return { success: false, error: accessCheck.error };
    }

    const userId = accessCheck.userId;
    const subscription = accessCheck.subscription;

    // Check subscription tier
    if (subscription.plan_type === 'free') {
      return {
        success: false,
        error: 'Viewing driver profiles requires a Pro or Enterprise subscription. Please upgrade.'
      };
    }

    // Check subscription is active
    if (!subscription.is_active) {
      return {
        success: false,
        error: 'Your subscription has expired or is inactive. Please renew to view profiles.'
      };
    }

    // Check quota
    const quotaCheck = await checkViewQuota(carrierDot);
    if (!quotaCheck.hasQuota) {
      return {
        success: false,
        error: 'Your monthly profile view quota is exhausted. Quota resets on your next billing cycle.'
      };
    }

    // Get driver profile using dataAccess
    const driver = await dataAccess.getRecord('driverProfiles', driverId, { suppressAuth: true });

    if (!driver) {
      return {
        success: false,
        error: 'Driver profile not found. The driver may have been removed.'
      };
    }

    // Check if driver is hidden
    if (driver.visibility_level === 'hidden' || driver.is_searchable === false) {
      return {
        success: false,
        error: 'This driver profile is not available or has been set to private.'
      };
    }

    // Record the view in CarrierDriverViews using dataAccess
    const viewRecord = {
      carrier_dot: carrierDot,
      driver_id: driverId,
      recruiter_id: userId,
      view_type: 'full_profile',
      billing_period: new Date().toISOString().slice(0, 7), // YYYY-MM format
      _createdDate: new Date()
    };

    if (options.matchScore !== undefined) {
      viewRecord.match_score = options.matchScore;
    }

    await dataAccess.insertRecord('carrierDriverViews', viewRecord, { suppressAuth: true });

    // Record profile view for quota tracking
    const viewResult = await recordProfileView(carrierDot, driverId, { userId });

    // NOTIFICATION: Notify driver they were viewed (non-blocking)
    notifyDriverProfileViewedNonBlocking(driverId, { 
      carrierDot, 
      carrierName: subscription.company_name || 'A Carrier' 
    });

    return {
      success: true,
      driver: maskPII(driver), // Always mask, full unlock happens via contact/application
      viewId: viewResult.viewId
    };

  } catch (err) {
    console.error('[driverMatching] getDriverProfile error:', err.message);
    return {
      success: false,
      error: 'Failed to retrieve driver profile: ' + err.message
    };
  }
}

/**
 * Detects if a driver has expressed interest in the carrier (mutual match)
 *
 * @param {string} carrierDot - The carrier's DOT number
 * @param {string} driverId - The driver's profile ID
 * @returns {Promise<Object>} Mutual match status
 */
export async function detectMutualMatch(carrierDot, driverId) {
  try {
    // Access control
    const accessCheck = await performAccessCheck(carrierDot);
    if (!accessCheck.success) {
      return { success: false, error: accessCheck.error };
    }

    // Query DriverInterests collection using dataAccess
    const result = await dataAccess.queryRecords('driverInterests', {
      filters: {
        driver_id: driverId,
        carrier_dot: carrierDot,
        status: 'interested'
      },
      limit: 1
    });

    if (result.success && result.items.length > 0) {
      const interest = result.items[0];
      return {
        success: true,
        isMutualMatch: true,
        interestDate: interest.created_date,
        scoreBoost: MUTUAL_MATCH_SCORE_BOOST,
        rationaleNote: 'Driver has expressed interest in your company - mutual match!'
      };
    }

    return {
      success: true,
      isMutualMatch: false,
      scoreBoost: 0
    };

  } catch (err) {
    return {
      success: false,
      isMutualMatch: false,
      error: err.message || 'An unexpected error occurred while checking for mutual match.'
    };
  }
}
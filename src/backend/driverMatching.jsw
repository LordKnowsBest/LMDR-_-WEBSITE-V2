import { currentUser } from 'wix-users-backend';
import { getSubscription, checkViewQuota, recordProfileView } from 'backend/subscriptionService';
import { calculateDriverMatchScore, generateDriverMatchRationale, getCarrierFeedbackWeights, applyFeedbackAdjustments, DEFAULT_WEIGHTS } from 'backend/driverScoring';
import { getDriverMatchingWeights } from 'backend/admin_config_service';
import { startTrace, endTrace, log, logDatabase } from 'backend/observabilityService';
import { withRetry } from 'backend/utils/retryUtils';
import { logFeatureInteraction } from 'backend/featureAdoptionService';
import * as dataAccess from 'backend/dataAccess';

// Gamification hooks - lazy-loaded to avoid circular dependencies
async function getGamificationService() {
  return await import('backend/gamificationService');
}

// Match notifications - lazy-loaded to avoid circular dependencies
async function getMatchNotifications() {
  return await import('backend/matchNotifications');
}

function notifyDriverProfileViewedNonBlocking(driverId, carrierInfo) {
  getMatchNotifications()
    .then(svc => svc.notifyDriverProfileViewed(driverId, carrierInfo))
    .catch(err => console.warn('Profile view notification failed (non-critical):', err.message));
}

// Non-blocking recruiter points award helper
async function awardRecruiterPointsNonBlocking(recruiterId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardRecruiterPoints(recruiterId, action, metadata);
  } catch (err) {
    console.warn(`Recruiter points award failed for ${action}:`, err.message);
  }
}

// ============================================================================
// CONSTANTS
// ============================================================================

/** DEV MODE: Set to true to bypass role verification during development */
const DEV_MODE_BYPASS_ROLES = true; // TODO: Set to false for production

/** DEV MODE: Set to true to bypass carrier auth + subscription checks */
const DEV_MODE_BYPASS_CARRIER = true; // TODO: Set to false for production

/** Allowed roles for accessing driver matching features */
const ALLOWED_ROLES = ['recruiter', 'admin'];

/** Tier-based result limits */
const TIER_LIMITS = {
  free: 0,
  pro: 25,
  enterprise: -1 // Unlimited
};

/** Default page size for pagination */
const DEFAULT_PAGE_SIZE = 20;

/** Score boost for mutual matches */
const MUTUAL_MATCH_SCORE_BOOST = 10;

/** Source priority for dedup (higher wins) */
const SOURCE_PRIORITY = {
  driver_profiles: 5,
  scored_drivers: 4,
  applications: 3,
  fb_campaign: 2,
  legacy_leads: 1
};

/** Human-readable source labels */
const SOURCE_LABELS = {
  driver_profiles: 'Profile',
  scored_drivers: 'Scored',
  applications: 'Application',
  fb_campaign: 'FB Campaign',
  legacy_leads: 'Legacy Lead'
};

/** Collection keys for the 4 additional sources */
const EXTRA_DRIVER_SOURCES = [
  'legacyDriverLeads',
  'driverApplications',
  'fbCampaignDrivers',
  'scoredDrivers'
];

// ============================================================================
// PARSING UTILITIES (for normalizing external driver sources)
// ============================================================================

/**
 * Parses CDL class from various formats → single letter
 * "Class A" → "A", "class c" → "C", "A" → "A", null → null
 */
function parseCdlClass(raw) {
  if (!raw) return null;
  const s = String(raw).trim().toUpperCase();
  const match = s.match(/(?:CLASS\s+)?([ABC])/);
  return match ? match[1] : null;
}

/**
 * Parses FB Campaign CDL type → single letter
 * "cdl_a" → "A", "cdl_b" → "B", null → null
 */
function parseFBCdlType(raw) {
  if (!raw) return null;
  const match = String(raw).trim().toLowerCase().match(/cdl_([abc])/);
  return match ? match[1].toUpperCase() : null;
}

/**
 * Parses endorsements text + binary flags into array
 * "Hazmat" → ["H"], "None" → [], merges HasHazmatEndorsement/HasTankerEndorsement flags
 */
function parseEndorsements(raw, flags = {}) {
  const result = [];
  if (raw && typeof raw === 'string') {
    const lower = raw.toLowerCase();
    if (lower.includes('hazmat') || lower.includes('haz')) result.push('H');
    if (lower.includes('tanker') || lower.includes('tank')) result.push('T');
    if (lower.includes('doubles') || lower.includes('triple')) result.push('T');
    if (lower.includes('passenger')) result.push('P');
    if (lower.includes('school')) result.push('S');
  }
  // Merge binary flags (from Applications table)
  if (flags.has_hazmat === 1 || flags.has_hazmat === true) {
    if (!result.includes('H')) result.push('H');
  }
  if (flags.has_tanker === 1 || flags.has_tanker === true) {
    if (!result.includes('T')) result.push('T');
  }
  return result;
}

/**
 * Parses years of experience text → number
 * "More than 10 years" → 10, "3-5 years" → 3, "1 year" → 1, null → null
 */
function parseYearsExperience(raw) {
  if (raw == null) return null;
  if (typeof raw === 'number') return raw;
  const s = String(raw);
  // "More than X years"
  const moreMatch = s.match(/more\s+than\s+(\d+)/i);
  if (moreMatch) return parseInt(moreMatch[1], 10);
  // "X-Y years" → take lower bound
  const rangeMatch = s.match(/(\d+)\s*[-–]\s*(\d+)/);
  if (rangeMatch) return parseInt(rangeMatch[1], 10);
  // "X year(s)"
  const simpleMatch = s.match(/(\d+)/);
  if (simpleMatch) return parseInt(simpleMatch[1], 10);
  return null;
}

/**
 * Maps availability text to standard values
 * "Immediate" → "immediate", "7-14 days" → "2_week", "30 days" → "30_day"
 */
function mapAvailabilityText(raw) {
  if (!raw) return null;
  const lower = String(raw).trim().toLowerCase();
  if (lower === 'immediate' || lower === 'yes' || lower === 'now') return 'immediate';
  if (lower.includes('7') || lower.includes('14') || lower.includes('2 week') || lower.includes('two week')) return '2_week';
  if (lower.includes('30') || lower.includes('month') || lower.includes('notice')) return '30_day';
  return null;
}

/**
 * Splits a full name into first/last
 * "John Doe" → { firstName: "John", lastName: "Doe" }
 * "John" → { firstName: "John", lastName: "" }
 */
function parseFullName(fullName) {
  if (!fullName) return { firstName: '', lastName: '' };
  const parts = String(fullName).trim().split(/\s+/);
  return {
    firstName: parts[0] || '',
    lastName: parts.slice(1).join(' ') || ''
  };
}

/**
 * Cleans FB Campaign phone (removes "p:" prefix)
 * "p:+15551234567" → "+15551234567"
 */
function cleanFBPhone(raw) {
  if (!raw) return null;
  return String(raw).replace(/^p:\s*/i, '').trim() || null;
}

// ============================================================================
// NORMALIZER FUNCTIONS (convert external sources to common driver shape)
// ============================================================================

/**
 * Normalizes a Legacy Driver Leads record to common shape.
 * These records have very thin data (name, email, phone only).
 */
function normalizeLegacyLead(record) {
  return {
    _id: record._id || record.id || `legacy_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
    first_name: record.first_name || record['First Name'] || '',
    last_name: record.last_name || record['Last Name'] || '',
    email: record.email || record['Email 1'] || null,
    phone: record.formatted_phone || record['Formatted Phone Number 1'] || record.phone || record['Phone 1'] || null,
    cdl_class: null,
    endorsements: [],
    years_experience: null,
    home_zip: null,
    city: null,
    state: null,
    zip_code: null,
    availability: null,
    equipment_experience: [],
    last_active_date: record.created_at || record['Created At (UTC+0)'] || null,
    profile_completeness_score: 10,
    is_searchable: true,
    visibility_level: 'visible',
    _source: 'legacy_leads',
    _source_label: SOURCE_LABELS.legacy_leads,
    _source_priority: SOURCE_PRIORITY.legacy_leads
  };
}

/**
 * Normalizes an Applications record to common shape.
 * Rich data: CDL, experience, endorsements, route prefs.
 */
function normalizeApplication(record) {
  const cdlRaw = record.cdl_class || record['CDL Class'];
  const endorseRaw = record.endorsements || record['Endorsements?'];
  const yearsRaw = record.years_experience || record['Years of Experience'] || record.years_exp_num || record['YearsExpNum'];
  const availRaw = record.availability || record['When can you start?'];
  const stateRaw = record.cdl_state || record['State of Issue'];

  return {
    _id: record._id || record.id || `app_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
    first_name: (record.first_name || record['First Name'] || '').trim(),
    last_name: (record.last_name || record['Last Name'] || '').trim(),
    email: record.email || record['Email'] || null,
    phone: record.phone || record['Phone Number'] || null,
    cdl_class: parseCdlClass(cdlRaw),
    endorsements: parseEndorsements(endorseRaw, {
      has_hazmat: record.has_hazmat || record['HasHazmatEndorsement'],
      has_tanker: record.has_tanker || record['HasTankerEndorsement']
    }),
    years_experience: parseYearsExperience(yearsRaw),
    home_zip: null,
    city: null,
    state: stateRaw || null,
    zip_code: null,
    availability: mapAvailabilityText(availRaw),
    equipment_experience: [],
    last_active_date: record.submission_date || record['Submission Date'] || null,
    profile_completeness_score: 40,
    is_searchable: true,
    visibility_level: 'visible',
    _source: 'applications',
    _source_label: SOURCE_LABELS.applications,
    _source_priority: SOURCE_PRIORITY.applications
  };
}

/**
 * Normalizes a CDL DRIVERS NJ FB CAMPAIGN record to common shape.
 * Thin data: full_name, email, phone, cdl type, availability.
 */
function normalizeFBCampaign(record) {
  const fullNameRaw = record.full_name || record['full_name'] || '';
  const { firstName, lastName } = parseFullName(fullNameRaw);
  const cdlTypeRaw = record.cdl_type || record['what_type_of_cdl_do_you_currently_hold?'];
  const canStartRaw = record.can_start_soon || record['are_you_able_to_start_within_the_next_7\u201314_days?'];
  const phoneRaw = record.phone_e164 || record['Phone (E164)'] || record.phone || record['phone'];

  return {
    _id: record._id || record.id || `fb_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
    first_name: firstName,
    last_name: lastName,
    email: record.email || record['email'] || null,
    phone: cleanFBPhone(phoneRaw),
    cdl_class: parseFBCdlType(cdlTypeRaw),
    endorsements: [],
    years_experience: null,
    home_zip: null,
    city: null,
    state: record.state || record['State (from Area Code)'] || null,
    zip_code: null,
    availability: canStartRaw && String(canStartRaw).toLowerCase() === 'yes' ? 'immediate' : '2_week',
    equipment_experience: [],
    last_active_date: record.created_time || record['created_time'] || null,
    profile_completeness_score: 20,
    is_searchable: true,
    visibility_level: 'visible',
    _source: 'fb_campaign',
    _source_label: SOURCE_LABELS.fb_campaign,
    _source_priority: SOURCE_PRIORITY.fb_campaign
  };
}

/**
 * Normalizes a Scored Drivers record to common shape.
 * Good data: CDL, experience, endorsements, score.
 */
function normalizeScoredDriver(record) {
  const cdlRaw = record.cdl_class || record['cdl_class'];
  const endorseRaw = record.endorsements || record['endorsements'];
  const yearsRaw = record.years_experience || record['years_experience'];
  const availRaw = record.availability || record['Start Date Availability'];

  return {
    _id: record._id || record.driver_id || record['Driver ID'] || `scored_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
    first_name: (record.first_name || record['First name'] || '').trim(),
    last_name: (record.last_name || record['Last Name'] || '').trim(),
    email: record.email || record['Email'] || null,
    phone: record.phone || record['Phone'] || null,
    cdl_class: parseCdlClass(cdlRaw),
    endorsements: parseEndorsements(endorseRaw),
    years_experience: parseYearsExperience(yearsRaw),
    home_zip: null,
    city: null,
    state: record.cdl_state || record['State of Issue'] || null,
    zip_code: null,
    availability: mapAvailabilityText(availRaw),
    equipment_experience: [],
    last_active_date: record.last_date_modified || record['Last Date Modified'] || null,
    profile_completeness_score: 35,
    is_searchable: true,
    visibility_level: 'visible',
    _source: 'scored_drivers',
    _source_label: SOURCE_LABELS.scored_drivers,
    _source_priority: SOURCE_PRIORITY.scored_drivers
  };
}

/**
 * Tags an existing DriverProfiles record with source metadata.
 */
function tagDriverProfile(record) {
  return {
    ...record,
    _source: 'driver_profiles',
    _source_label: SOURCE_LABELS.driver_profiles,
    _source_priority: SOURCE_PRIORITY.driver_profiles
  };
}

/** Maps collection keys to normalizer functions */
const SOURCE_NORMALIZERS = {
  legacyDriverLeads: normalizeLegacyLead,
  driverApplications: normalizeApplication,
  fbCampaignDrivers: normalizeFBCampaign,
  scoredDrivers: normalizeScoredDriver
};

/**
 * Queries all driver sources in parallel, normalizes, merges, and deduplicates.
 * @param {Object} driverFilters - Filters for the primary DriverProfiles query
 * @returns {Promise<Array>} Merged, deduplicated driver array
 */
async function queryAllDriverSources(driverFilters) {
  // Cap per-source to keep total under Wix serverless timeout (~14s)
  const EXTRA_SOURCE_LIMIT = 100;

  // Query primary source (DriverProfiles) with full filters
  const primaryPromise = dataAccess.queryRecords('driverProfiles', {
    filters: driverFilters,
    limit: 500,
    suppressAuth: true
  });

  // Query additional sources with capped limits — scoring ranks them anyway
  const extraPromises = EXTRA_DRIVER_SOURCES.map(sourceKey =>
    dataAccess.queryRecords(sourceKey, {
      filters: {},
      limit: EXTRA_SOURCE_LIMIT,
      suppressAuth: true
    }).catch(err => {
      console.warn(`[driverMatching] Failed to query ${sourceKey}:`, err.message);
      return { success: false, items: [] };
    })
  );

  // Execute all queries in parallel
  const [primaryResult, ...extraResults] = await Promise.all([primaryPromise, ...extraPromises]);
  console.log(`[driverMatching] Fetched: profiles=${primaryResult.items?.length || 0}, extras=${extraResults.map(r => r.items?.length || 0).join(',')}`);

  // Normalize primary results
  let allDrivers = [];
  if (primaryResult.success && primaryResult.items) {
    allDrivers = primaryResult.items.map(tagDriverProfile);
  }

  // Normalize extra source results
  EXTRA_DRIVER_SOURCES.forEach((sourceKey, index) => {
    const result = extraResults[index];
    if (result.success && result.items && result.items.length > 0) {
      const normalizer = SOURCE_NORMALIZERS[sourceKey];
      const normalized = result.items.map(record => {
        try {
          return normalizer(record);
        } catch (err) {
          console.warn(`[driverMatching] Normalize error for ${sourceKey}:`, err.message);
          return null;
        }
      }).filter(Boolean);
      allDrivers = allDrivers.concat(normalized);
    }
  });

  // Deduplicate by email (case-insensitive), keeping highest source priority
  const emailMap = new Map();
  for (const driver of allDrivers) {
    const key = driver.email
      ? driver.email.toLowerCase().trim()
      : `__no_email_${driver._id}`;
    const existing = emailMap.get(key);
    if (!existing || (driver._source_priority || 0) > (existing._source_priority || 0)) {
      emailMap.set(key, driver);
    }
  }

  const deduped = Array.from(emailMap.values());
  console.log(`[driverMatching] After dedup: ${deduped.length} unique drivers from ${allDrivers.length} total`);
  return deduped;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Verifies the current user is authenticated
 * @returns {Promise<{success: boolean, userId?: string, error?: string}>}
 */
async function verifyAuthenticated() {
  if (!currentUser.loggedIn) {
    return {
      success: false,
      error: 'You must be authenticated to access this feature. Please login.'
    };
  }
  return { success: true, userId: currentUser.id };
}

/**
 * Verifies the user has an allowed role/badge (recruiter or admin)
 * Checks both Wix roles and member badges
 * @returns {Promise<{success: boolean, roles?: Array, error?: string}>}
 */
async function verifyRole() {
  // DEV MODE: Skip role verification for development/testing
  if (DEV_MODE_BYPASS_ROLES) {
    console.log('[driverMatching] DEV MODE: Bypassing role verification');
    return { success: true, roles: ['dev_bypass'] };
  }

  try {
    // First check Wix roles
    const roles = await currentUser.getRoles();
    const roleNames = roles.map(r => r.name);
    const hasAllowedRole = roleNames.some(role => ALLOWED_ROLES.includes(role));

    if (hasAllowedRole) {
      return { success: true, roles: roleNames };
    }

    // If no Wix role, check for badge assignments
    // Note: Member badges always use Wix (system collection)
    const badgeResult = await dataAccess.queryRecords('memberBadges', {
      filters: { memberId: currentUser.id },
      suppressAuth: true
    });

    if (badgeResult.items?.length > 0) {
      const badgeSlugs = badgeResult.items.map(b => b.slug || b.title?.toLowerCase());
      const hasAllowedBadge = badgeSlugs.some(slug =>
        ALLOWED_ROLES.includes(slug) || slug === 'recruiter' || slug === 'admin'
      );

      if (hasAllowedBadge) {
        return { success: true, roles: badgeSlugs };
      }
    }

    return {
      success: false,
      error: 'Recruiter or admin role required to search drivers.'
    };
  } catch (err) {
    console.error('[driverMatching] Role verification error:', err.message);
    return {
      success: false,
      error: 'Failed to verify user role.'
    };
  }
}

/**
 * Verifies the user is authorized to access the specified carrier.
 * Checks the 'recruiterCarriers' collection for a valid recruiter-carrier association.
 *
 * @param {string} carrierDot - The carrier DOT number
 * @param {string} userId - The user ID
 * @returns {Promise<{success: boolean, subscription?: Object, error?: string}>}
 */
async function verifyCarrierAuthorization(carrierDot, userId) {
  try {
    // Check if the user has access to this carrier using dataAccess
    const accessResult = await dataAccess.queryRecords('recruiterCarriers', {
      filters: {
        recruiter_id: userId,
        carrier_dot: carrierDot,
        is_active: true
      },
      limit: 1,
      suppressAuth: true
    });

    if (!accessResult.success || accessResult.items.length === 0) {
      return {
        success: false,
        error: 'You are not authorized to access this carrier\'s data.'
      };
    }

    // Get subscription - internally validates carrier authorization
    const subscription = await getSubscription(carrierDot);

    if (!subscription) {
      return {
        success: false,
        error: 'No active subscription found for this carrier.'
      };
    }

    return { success: true, subscription };
  } catch (err) {
    return {
      success: false,
      error: 'An error occurred during carrier authorization.'
    };
  }
}

/**
 * Performs full access control check (auth + role + carrier authorization)
 * @param {string} carrierDot - The carrier DOT number
 * @returns {Promise<{success: boolean, userId?: string, subscription?: Object, error?: string}>}
 */
async function performAccessCheck(carrierDot) {
  // Check authentication
  const authCheck = await verifyAuthenticated();
  if (!authCheck.success) return authCheck;

  // Check role
  const roleCheck = await verifyRole();
  if (!roleCheck.success) return roleCheck;

  // Check carrier authorization (also returns subscription)
  const carrierCheck = await verifyCarrierAuthorization(carrierDot, authCheck.userId);
  if (!carrierCheck.success) return carrierCheck;

  return { success: true, userId: authCheck.userId, subscription: carrierCheck.subscription };
}

/**
 * Masks PII (email and phone) for limited visibility drivers
 * @param {Object} driver - The driver profile object
 * @returns {Object} Driver with masked PII
 */
function maskPII(driver) {
  return {
    ...driver,
    email: '***masked***',
    phone: '***masked***'
  };
}

/**
 * Gets carrier hiring preferences if available
 * @param {string} carrierDot - The carrier DOT number
 * @returns {Promise<Object|null>}
 */
async function getCarrierPreferences(carrierDot) {
  try {
    const result = await dataAccess.queryRecords('carrierHiringPreferences', {
      filters: {
        carrier_dot: carrierDot,
        is_active: true
      },
      limit: 1
    });

    return result.success && result.items.length > 0 ? result.items[0] : null;
  } catch (err) {
    return null;
  }
}

/**
 * Checks if a driver has expressed interest in a carrier
 * @param {string} carrierDot - The carrier DOT number
 * @param {string} driverId - The driver ID
 * @returns {Promise<{hasInterest: boolean, interestDate?: Date}>}
 */
async function checkDriverInterest(carrierDot, driverId) {
  try {
    const result = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: {
        driver_id: driverId,
        carrier_dot: carrierDot,
        status: 'interested'
      },
      limit: 1
    });

    if (result.success && result.items.length > 0) {
      return {
        hasInterest: true,
        interestDate: result.items[0].action_timestamp
      };
    }
    return { hasInterest: false };
  } catch (err) {
    return { hasInterest: false };
  }
}

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Searches for drivers matching the carrier's criteria
 *
 * @param {string} carrierDot - The carrier's DOT number
 * @param {Object} filters - Search filters
 * @param {Array<string>} [filters.cdl_types] - Required CDL classes ['A', 'B']
 * @param {Array<string>} [filters.endorsements] - Required endorsements
 * @param {string} [filters.zip_code] - Center zip code for location search
 * @param {number} [filters.radius_miles] - Search radius from zip code
 * @param {number} [filters.min_experience] - Minimum years of experience
 * @param {string} [filters.availability] - 'immediate', '2_week', '30_day'
 * @param {Object} options - Search options
 * @param {number} [options.page] - Page number (0-indexed)
 * @param {number} [options.pageSize] - Results per page
 * @param {number} [options.limit] - Max results to return
 * @param {boolean} [options.usePreferences] - Use carrier preferences for scoring
 * @param {boolean} [options.includeMutualMatches] - Check for mutual matches
 * @returns {Promise<Object>} Search results with matches and metadata
 */
export async function findMatchingDrivers(carrierDot, filters = {}, options = {}) {
  const startTime = Date.now();

  // Start distributed trace for this matching operation
  const trace = await startTrace('findMatchingDrivers', {
    carrierDot,
    filterCount: Object.keys(filters).length,
    tags: ['driver-matching', 'search', 'reverse-matching']
  });
  const traceId = trace.traceId;

  await log({
    level: 'INFO',
    source: 'driver-matching',
    message: 'Starting driver search',
    traceId,
    details: { carrierDot, filters: Object.keys(filters), options: Object.keys(options) }
  });

  try {
    let subscription;

    if (DEV_MODE_BYPASS_CARRIER) {
      // DEV MODE: Skip all access control and use a synthetic subscription
      console.log('[driverMatching] DEV MODE: Bypassing carrier auth + subscription checks');
      subscription = {
        plan_type: 'enterprise',
        is_active: true,
        monthly_view_quota: -1,
        views_used_this_month: 0
      };
    } else {
      // Access control (also retrieves subscription)
      const accessCheck = await performAccessCheck(carrierDot);
      if (!accessCheck.success) {
        await log({ level: 'WARN', source: 'driver-matching', message: `Access denied: ${accessCheck.error}`, traceId });
        await endTrace(traceId, 'denied', { error: accessCheck.error, elapsed: Date.now() - startTime });
        return { success: false, error: accessCheck.error };
      }

      subscription = accessCheck.subscription;

      // Check if tier allows searching
      if (subscription.plan_type === 'free') {
        return {
          success: false,
          error: 'Driver search requires a Pro or Enterprise subscription. Please upgrade to access this feature.',
          code: 'SUBSCRIPTION_TIER_LIMIT'
        };
      }

      // Check if subscription is active
      if (!subscription.is_active) {
        return {
          success: false,
          error: 'Your subscription has expired or is inactive. Please renew to search drivers.',
          code: 'SUBSCRIPTION_INACTIVE'
        };
      }
    }

    // Build base query FIRST - exclude non-searchable and hidden drivers
    const queryStartTime = Date.now();

    // Primary DriverProfiles filters (extra sources get no pre-filters; scoring ranks them)
    const driverFilters = {
      is_searchable: true,
      visibility_level: { ne: 'hidden' }
    };

    // Add dynamic filters (applied to primary source only)
    if (filters.cdl_types && Array.isArray(filters.cdl_types) && filters.cdl_types.length > 0) {
      driverFilters.cdl_class = { hasSome: filters.cdl_types };
    }

    if (filters.min_experience && typeof filters.min_experience === 'number') {
      driverFilters.years_experience = { gte: filters.min_experience };
    }

    if (filters.availability && typeof filters.availability === 'string') {
      driverFilters.availability = filters.availability;
    }

    // Query all driver sources (primary + 4 additional), normalize, and dedup
    let drivers = await queryAllDriverSources(driverFilters);

    const queryLatency = Date.now() - queryStartTime;

    await logDatabase({
      operation: 'query',
      collection: 'DriverProfiles',
      affectedRows: drivers.length,
      latencyMs: queryLatency,
      traceId
    });

    // Log if no drivers found
    if (drivers.length === 0) {
      await log({
        level: 'INFO',
        source: 'driver-matching',
        message: 'No searchable drivers found in database',
        traceId,
        details: { filterCount: Object.keys(filters).length }
      });

      return {
        success: true,
        matches: [],
        message: 'No drivers found matching your criteria.',
        code: 'NO_MATCHES_DB',
        pagination: {
          page: options.page || 0,
          pageSize: options.pageSize || DEFAULT_PAGE_SIZE,
          totalCount: 0,
          totalPages: 0
        },
        subscription: {
          plan_type: subscription.plan_type,
          views_remaining: subscription.monthly_view_quota === -1 ? -1 : Math.max(0, subscription.monthly_view_quota - subscription.views_used_this_month),
          views_used: subscription.views_used_this_month,
          views_total: subscription.monthly_view_quota
        },
        traceId
      };
    }

    // Get carrier preferences if requested
    let carrierPrefs = null;
    if (options.usePreferences) {
      carrierPrefs = await getCarrierPreferences(carrierDot);
    }

    // DEV MODE: Use synthetic preferences when none exist so scoring differentiates drivers
    if (DEV_MODE_BYPASS_CARRIER && !carrierPrefs) {
      console.log('[driverMatching] DEV MODE: Using synthetic carrier preferences for scoring');
      carrierPrefs = {
        carrier_dot: DEV_MODE_FALLBACK_DOT,
        required_cdl_types: filters.cdl_types || ['A'],
        required_endorsements: filters.endorsements || [],
        min_experience_years: 2,
        max_experience_years: null,
        equipment_types: filters.equipment_types || ['dry_van', 'reefer', 'flatbed'],
        target_zip_codes: filters.zip_code ? [filters.zip_code] : [],
        target_states: ['TX', 'LA', 'OK', 'AR', 'MS'],
        target_radius_miles: filters.radius_miles || 150,
        urgency: filters.availability || 'immediate',
        offered_pay_min_cpm: 55,
        offered_pay_max_cpm: 72,
        accepts_recent_grads: 'Yes',
        is_active: true,
        weight_qualifications: 30,
        weight_experience: 20,
        weight_location: 20,
        weight_availability: 15,
        weight_salaryFit: 10,
        weight_engagement: 5
      };
    }

    // Post-query CDL class filter (extra sources bypass DB-level filters)
    if (filters.cdl_types && Array.isArray(filters.cdl_types) && filters.cdl_types.length > 0) {
      const beforeCdl = drivers.length;
      drivers = drivers.filter(d => {
        if (!d.cdl_class) return false;
        return filters.cdl_types.includes(d.cdl_class);
      });
      console.log(`[driverMatching] CDL filter: ${beforeCdl} → ${drivers.length} (required: ${filters.cdl_types.join(',')})`);
    }

    // Filter by endorsements (must have ALL) - post-query validation for complex logic
    if (filters.endorsements && Array.isArray(filters.endorsements) && filters.endorsements.length > 0) {
      drivers = drivers.filter(d => {
        if (!d.endorsements || !Array.isArray(d.endorsements)) return false;
        return filters.endorsements.every(e => d.endorsements.includes(e));
      });
    }

    // Score each driver with DYNAMIC WEIGHTS in parallel chunks
    const scoringStartTime = Date.now();
    const scoredDrivers = [];
    const scoringPrefs = carrierPrefs || {};
    let scoringFailures = 0;

    // Fetch global driver weights from config service
    let globalWeights = DEFAULT_WEIGHTS;
    try {
        globalWeights = await getDriverMatchingWeights();
    } catch (e) {
        console.warn('⚠️ Failed to fetch global driver weights, using defaults');
    }

    // Fetch carrier feedback weights once per search
    let feedbackWeights = null;
    try {
      feedbackWeights = await getCarrierFeedbackWeights(carrierDot);
    } catch (e) { /* ignore */ }

    // Batch-fetch ALL mutual interests for this carrier ONCE (avoids N+1 Airtable queries)
    const mutualInterestSet = new Set();
    if (options.includeMutualMatches) {
      try {
        const interestResult = await dataAccess.queryRecords('driverCarrierInterests', {
          filters: { carrier_dot: carrierDot, status: 'interested' },
          limit: 1000,
          suppressAuth: true
        });
        if (interestResult.success && interestResult.items) {
          for (const item of interestResult.items) {
            if (item.driver_id) mutualInterestSet.add(item.driver_id);
          }
        }
        console.log(`[driverMatching] Batch-loaded ${mutualInterestSet.size} mutual interests for carrier ${carrierDot}`);
      } catch (e) {
        console.warn('[driverMatching] Failed to batch-load mutual interests:', e.message);
      }
    }

    // Process in parallel chunks to maximize throughput
    const CHUNK_SIZE = 50;
    for (let i = 0; i < drivers.length; i += CHUNK_SIZE) {
      const chunk = drivers.slice(i, i + CHUNK_SIZE);
      const chunkResults = chunk.map((driver) => {
        try {
          // Apply feedback adjustments if available
          let finalWeights = scoringPrefs;
          if (feedbackWeights) {
            finalWeights = applyFeedbackAdjustments(scoringPrefs, feedbackWeights);
          }

          // Use global weights if no custom weights provided in options
          const scoreResult = calculateDriverMatchScore(driver, finalWeights, options.weights || globalWeights, filters);
          const rationaleResult = generateDriverMatchRationale(scoreResult.scores || {}, driver, scoringPrefs);

          // Check for mutual match via in-memory set (no API call)
          const isMutualMatch = mutualInterestSet.has(driver._id);
          const mutualMatchBoost = isMutualMatch ? MUTUAL_MATCH_SCORE_BOOST : 0;

          return {
            driver,
            score: Math.min(100, (scoreResult.overallScore || 0) + mutualMatchBoost),
            rationale: rationaleResult.points || [],
            summary: rationaleResult.summary,
            isMutualMatch,
            scoringFailed: false
          };
        } catch (err) {
          scoringFailures++;
          return {
            driver,
            score: 0,
            rationale: ['Match score based on available criteria.'],
            summary: 'Error calculating score',
            isMutualMatch: false,
            scoringFailed: true,
            error: err.message
          };
        }
      });
      scoredDrivers.push(...chunkResults);
    }

    const scoringDuration = Date.now() - scoringStartTime;
    await log({
      level: 'INFO',
      source: 'driver-matching',
      message: `Scoring complete for ${scoredDrivers.length} drivers`,
      traceId,
      duration: scoringDuration
    });

    // Sort by score descending
    scoredDrivers.sort((a, b) => b.score - a.score);

    // Apply tier-based limits
    const tierLimit = TIER_LIMITS[subscription.plan_type] || 0;
    const effectiveLimit = tierLimit === -1
      ? (options.limit || scoredDrivers.length)
      : Math.min(tierLimit, options.limit || tierLimit);

    // Apply pagination
    const page = options.page || 0;
    const pageSize = options.pageSize || DEFAULT_PAGE_SIZE;
    const startIndex = page * pageSize;
    const endIndex = Math.min(startIndex + pageSize, effectiveLimit, scoredDrivers.length);

    const paginatedResults = scoredDrivers.slice(startIndex, endIndex);

    // Calculate remaining views
    const viewsRemaining = subscription.monthly_view_quota === -1
      ? -1
      : Math.max(0, subscription.monthly_view_quota - subscription.views_used_this_month);

    const elapsed = Date.now() - startTime;

    // Log successful completion
    await log({
      level: 'INFO',
      source: 'driver-matching',
      message: `Search complete: ${paginatedResults.length} results returned`,
      traceId,
      duration: elapsed,
      details: {
        totalDrivers: drivers.length,
        totalScored: scoredDrivers.length,
        returned: paginatedResults.length,
        scoringFailures,
        carrierDot,
        planType: subscription.plan_type
      }
    });

    await endTrace(traceId, 'completed', {
      totalMatches: paginatedResults.length,
      totalScored: scoredDrivers.length,
      scoringFailures,
      elapsed
    });

    // Log for Feature Adoption Tracking
    const searchUserId = DEV_MODE_BYPASS_CARRIER ? 'dev-mode' : accessCheck.userId;
    await logFeatureInteraction('recruiter_driver_search', searchUserId, 'recruiter', 'search', {
      filters: Object.keys(filters),
      resultCount: paginatedResults.length,
      carrierDot
    });

    return {
      success: true,
      matches: paginatedResults,
      message: paginatedResults.length === 0
        ? 'No drivers found matching your criteria.'
        : `Found ${scoredDrivers.length} matching drivers.`,
      code: paginatedResults.length === 0 ? 'NO_MATCHES_FILTERS' : 'SUCCESS',
      pagination: {
        page,
        pageSize,
        totalCount: scoredDrivers.length,
        totalPages: Math.ceil(Math.min(scoredDrivers.length, effectiveLimit) / pageSize)
      },
      subscription: {
        plan_type: subscription.plan_type,
        views_remaining: viewsRemaining,
        views_used: subscription.views_used_this_month,
        views_total: subscription.monthly_view_quota
      },
      traceId
    };

  } catch (err) {
    await log({
      level: 'ERROR',
      source: 'driver-matching',
      message: `Search failed: ${err.message}`,
      traceId,
      details: { error: err.message, stack: err.stack }
    });
    await endTrace(traceId, 'error', { error: err.message, elapsed: Date.now() - startTime });

    return {
      success: false,
      error: err.message || 'An unexpected error occurred while searching for drivers.',
      code: 'SEARCH_ERROR',
      traceId
    };
  }
}

/**
 * Retrieves a driver's full profile (paid feature)
 *
 * @param {string} carrierDot - The carrier's DOT number
 * @param {string} driverId - The driver's profile ID
 * @param {Object} [options] - Additional options
 * @param {number} [options.matchScore] - Match score to record with view
 * @returns {Promise<Object>} Driver profile or error
 */
export async function getDriverProfile(carrierDot, driverId, options = {}) {
  try {
    // Access control (also retrieves subscription)
    const accessCheck = await performAccessCheck(carrierDot);
    if (!accessCheck.success) {
      return { success: false, error: accessCheck.error };
    }

    const userId = accessCheck.userId;
    const subscription = accessCheck.subscription;

    // Check subscription tier
    if (subscription.plan_type === 'free') {
      return {
        success: false,
        error: 'Viewing driver profiles requires a Pro or Enterprise subscription. Please upgrade.'
      };
    }

    // Check subscription is active
    if (!subscription.is_active) {
      return {
        success: false,
        error: 'Your subscription has expired or is inactive. Please renew to view profiles.'
      };
    }

    // Check quota
    const quotaCheck = await checkViewQuota(carrierDot);
    if (!quotaCheck.hasQuota) {
      return {
        success: false,
        error: 'Your monthly profile view quota is exhausted. Quota resets on your next billing cycle.'
      };
    }

    // Get driver profile using dataAccess
    const driver = await dataAccess.getRecord('driverProfiles', driverId, { suppressAuth: true });

    if (!driver) {
      return {
        success: false,
        error: 'Driver profile not found. The driver may have been removed.'
      };
    }

    // Check if driver is hidden
    if (driver.visibility_level === 'hidden' || driver.is_searchable === false) {
      return {
        success: false,
        error: 'This driver profile is not available or has been set to private.'
      };
    }

    // Record the view in CarrierDriverViews using dataAccess
    const viewRecord = {
      carrier_dot: carrierDot,
      driver_id: driverId,
      recruiter_id: userId,
      view_type: 'full_profile',
      billing_period: new Date().toISOString().slice(0, 7), // YYYY-MM format
      _createdDate: new Date()
    };

    if (options.matchScore !== undefined) {
      viewRecord.match_score = options.matchScore;
    }

    await dataAccess.insertRecord('carrierDriverViews', viewRecord, { suppressAuth: true });

    // Record profile view for quota tracking
    const viewResult = await recordProfileView(carrierDot, driverId, { userId });

    // NOTIFICATION: Notify driver they were viewed (non-blocking)
    notifyDriverProfileViewedNonBlocking(driverId, { 
      carrierDot, 
      carrierName: subscription.company_name || 'A Carrier' 
    });

    return {
      success: true,
      driver: maskPII(driver), // Always mask, full unlock happens via contact/application
      viewId: viewResult.viewId
    };

  } catch (err) {
    console.error('[driverMatching] getDriverProfile error:', err.message);
    return {
      success: false,
      error: 'Failed to retrieve driver profile: ' + err.message
    };
  }
}

/**
 * Detects if a driver has expressed interest in the carrier (mutual match)
 *
 * @param {string} carrierDot - The carrier's DOT number
 * @param {string} driverId - The driver's profile ID
 * @returns {Promise<Object>} Mutual match status
 */
export async function detectMutualMatch(carrierDot, driverId) {
  try {
    // Access control
    const accessCheck = await performAccessCheck(carrierDot);
    if (!accessCheck.success) {
      return { success: false, error: accessCheck.error };
    }

    // Query DriverCarrierInterests collection using dataAccess
    const result = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: {
        driver_id: driverId,
        carrier_dot: carrierDot,
        status: 'interested'
      },
      limit: 1
    });

    if (result.success && result.items.length > 0) {
      const interest = result.items[0];
      return {
        success: true,
        isMutualMatch: true,
        interestDate: interest.action_timestamp,
        scoreBoost: MUTUAL_MATCH_SCORE_BOOST,
        rationaleNote: 'Driver has expressed interest in your company - mutual match!'
      };
    }

    return {
      success: true,
      isMutualMatch: false,
      scoreBoost: 0
    };

  } catch (err) {
    return {
      success: false,
      isMutualMatch: false,
      error: err.message || 'An unexpected error occurred while checking for mutual match.'
    };
  }
}
/**
 * semanticBackfillJob.jsw
 *
 * Populates and refreshes Pinecone vector indexes for driver and carrier profiles.
 *
 * Strategy:
 *   - Uses a daily date string (YYYY-MM-DD) as profileUpdatedAt.
 *     The embed endpoint skips a record if its stored date matches — so each
 *     record embeds at most once per day, and re-embeds daily to pick up
 *     profile changes from the previous day.
 *   - Processes in chunks of 10 with 300ms gaps → ~33 chunks/min (~330 records/min).
 *     Conservative enough for Voyage AI free tier and Pinecone serverless.
 *   - Gracefully handles individual record failures — logs them and continues.
 *   - Returns a stats object so callers can log/alert on failures.
 *
 * Scheduled: nightly at 03:30 UTC (low-traffic window, after B2B batch at 03:00).
 * Can also be called directly for manual/initial backfill.
 */

import * as dataAccess from 'backend/dataAccess';
import { embedDriver, embedCarrier } from 'backend/semanticSearchService';
import { chunkArray } from 'backend/utils/arrayUtils';
import { FEATURE_FLAGS } from 'backend/configData';

const CHUNK_SIZE     = 10;
const CHUNK_DELAY_MS = 300;
const PAGE_SIZE      = 100;

// ── Helpers ──────────────────────────────────────────────────────────────────

function todayVersionString() {
  return new Date().toISOString().split('T')[0]; // YYYY-MM-DD
}

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

// ── Driver backfill ──────────────────────────────────────────────────────────

/** Normalize CDL class strings to single letter: "Class A" / "cdl_a" → "A" */
function _normalizeCdlClass(raw) {
  if (!raw) return null;
  const s = String(raw).toUpperCase();
  if (s.includes('A')) return 'A';
  if (s.includes('B')) return 'B';
  if (s.includes('C')) return 'C';
  return null;
}

/** Normalize experience text to integer years */
function _normalizeExperience(raw) {
  if (!raw) return 0;
  if (typeof raw === 'number') return raw;
  const s = String(raw).toLowerCase();
  if (s.includes('10') || s.includes('more than 10')) return 10;
  if (s.includes('5') || s.includes('5-9'))            return 7;
  if (s.includes('3') || s.includes('less'))            return 2;
  if (s.includes('1') || s.includes('1-4'))             return 2;
  const n = parseInt(s);
  return isNaN(n) ? 0 : n;
}

/** Combine route type fields into comma-separated string */
function _normalizeHaulTypes(...fields) {
  const seen = new Set();
  const out = [];
  for (const f of fields) {
    if (!f) continue;
    const items = Array.isArray(f) ? f : [f];
    for (const item of items) {
      const v = String(item).trim();
      if (v && !seen.has(v)) { seen.add(v); out.push(v); }
    }
  }
  return out.length ? out.join(', ') : null;
}

/**
 * Generic paged driver embedder — shared by all three driver table backfills.
 */
async function _embedDriverPage(collectionKey, profileBuilder, stats, version) {
  let offset = 0;
  let hasMore = true;

  while (hasMore) {
    let page;
    try {
      const result = await dataAccess.queryRecords(collectionKey, {
        limit:  PAGE_SIZE,
        offset,
        suppressAuth: true,
      });
      page    = result.items || [];
      hasMore = page.length === PAGE_SIZE;
      offset += page.length;
    } catch (err) {
      console.error(`[semanticBackfill] ${collectionKey} page fetch failed at offset`, offset, ':', err.message);
      break;
    }

    if (page.length === 0) break;

    const chunks = chunkArray(page, CHUNK_SIZE);
    for (const chunk of chunks) {
      await Promise.all(chunk.map(async (record) => {
        if (!record._id) { stats.skipped++; return; }
        try {
          await embedDriver(record._id, version, profileBuilder(record));
          stats.processed++;
        } catch (err) {
          stats.failed++;
          stats.errors.push({ id: record._id, error: err.message });
        }
      }));
      await sleep(CHUNK_DELAY_MS);
    }

    console.log(`[semanticBackfill] ${collectionKey}: offset=${offset} processed=${stats.processed} failed=${stats.failed}`);
  }
}

/**
 * Embed all driver sources into lmdr-drivers Pinecone index.
 * Sources: v2_Driver Profiles, Applications, Scored Drivers.
 * @returns {{ processed, skipped, failed, errors }}
 */
async function _backfillDrivers() {
  const version = todayVersionString();
  const stats   = { processed: 0, skipped: 0, failed: 0, errors: [] };

  // 1. V2 Driver Profiles (active platform drivers)
  await _embedDriverPage('driverProfiles', (d) => ({
    cdl_class:        _normalizeCdlClass(d['CDL Class'] || d.cdl_class),
    endorsements:     d['Endorsements'] || d.endorsements || null,
    home_state:       d['Home State']   || d.home_state   || null,
    experience_years: _normalizeExperience(d['Years Experience'] || d.years_experience),
    haul_types:       d['Preferred Operation Type'] || d.haul_types || null,
    pay_min:          d['Min CPM'] || d.pay_min_cpm || d.minimum_pay || null,
    is_discoverable:  d['Is Discoverable'] || d.is_discoverable || 'No',
    bio:              d['Bio'] || d.bio || null,
  }), stats, version);

  // 2. Applications (job application form submissions)
  await _embedDriverPage('driverApplications', (d) => ({
    cdl_class:        _normalizeCdlClass(d['CDL Class']),
    endorsements:     d['Endorsements?'] !== 'None' ? d['Endorsements?'] : null,
    home_state:       d['State of Issue'] || null,
    experience_years: _normalizeExperience(d['Years of Experience']),
    haul_types:       _normalizeHaulTypes(
                        d['Route Types - First Option'],
                        d['Route Types - Second Option'],
                        d['Route Types - Third Option']
                      ),
    pay_min:          null,
    is_discoverable:  'Yes',
    bio:              null,
  }), stats, version);

  // 3. Scored Drivers
  await _embedDriverPage('scoredDrivers', (d) => ({
    cdl_class:        _normalizeCdlClass(d.cdl_class),
    endorsements:     d.endorsements !== 'None' ? d.endorsements : null,
    home_state:       d['State of Issue'] || null,
    experience_years: _normalizeExperience(d.years_experience),
    haul_types:       _normalizeHaulTypes(
                        d['Route Types - First Option'],
                        d['Route Types - Second Option'],
                        d['Route Types - Third Option']
                      ),
    pay_min:          null,
    is_discoverable:  'Yes',
    bio:              null,
  }), stats, version);

  // 4. Quick APP- JOTFORM (same field structure as Applications)
  await _embedDriverPage('quickAppJotform', (d) => ({
    cdl_class:        _normalizeCdlClass(d['CDL Class']),
    endorsements:     d['Endorsements?'] !== 'None' ? d['Endorsements?'] : null,
    home_state:       d['State of Issue'] || null,
    experience_years: _normalizeExperience(d['Years of Experience']),
    haul_types:       _normalizeHaulTypes(
                        d['Route Types - First Option'],
                        d['Route Types - Second Option'],
                        d['Route Types - Third Option']
                      ),
    pay_min:          null,
    is_discoverable:  'Yes',
    bio:              null,
  }), stats, version);

  return stats;
}

// ── Carrier backfill ─────────────────────────────────────────────────────────

/**
 * Embed all active carrier accounts into lmdr-carriers Pinecone index.
 * @returns {{ processed, skipped, failed, errors }}
 */
async function _backfillCarriers() {
  const version = todayVersionString();
  const stats   = { processed: 0, skipped: 0, failed: 0, errors: [] };

  let offset = 0;
  let hasMore = true;

  while (hasMore) {
    let page;
    try {
      // Query Carriers (Master) — the full FMCSA dataset, no status filter needed
      const result = await dataAccess.queryRecords('carriers', {
        limit:  PAGE_SIZE,
        offset,
        suppressAuth: true,
      });
      page    = result.items || [];
      hasMore = page.length === PAGE_SIZE;
      offset += page.length;
    } catch (err) {
      console.error('[semanticBackfill] Carrier page fetch failed at offset', offset, ':', err.message);
      break;
    }

    if (page.length === 0) break;

    const chunks = chunkArray(page, CHUNK_SIZE);
    for (const chunk of chunks) {
      await Promise.all(chunk.map(async (c) => {
        if (!c._id) { stats.skipped++; return; }

        try {
          await embedCarrier(
            c._id,
            version,
            {
              dot_number:     c.DOT_NUMBER      || c.dot_number                       || null,
              legal_name:     c.LEGAL_NAME      || c.legal_name                       || null,
              operation_type: c.CARRIER_OPERATION                                     || null,
              state:          c.PHY_STATE       || null,
              city:           c.PHY_CITY        || null,
              fleet_size:     c.NBR_POWER_UNIT  || c.fleet_size                       || 0,
              driver_count:   c.DRIVER_TOTAL                                          || 0,
              pay_cpm:        c.PAY_CPM         || c.pay_range_min                    || 0,
              turnover_pct:   c.TURNOVER_PERCENT                                      ?? null,
              accident_rate:  c.ACCIDENT_RATE                                         ?? null,
              avg_truck_age:  c.AVG_TRUCK_AGE                                         ?? null,
              priority_score: c.PRIORITY_SCORE  || c.priority_score                   || 0,
            }
          );
          stats.processed++;
        } catch (err) {
          stats.failed++;
          stats.errors.push({ id: c._id, error: err.message });
        }
      }));

      await sleep(CHUNK_DELAY_MS);
    }

    console.log(`[semanticBackfill] Carriers: offset=${offset} processed=${stats.processed} failed=${stats.failed}`);
  }

  return stats;
}

// ── Exported job functions ───────────────────────────────────────────────────

/**
 * Scheduled entry point — called nightly by jobs.config.
 * Skips gracefully if semanticToolEnabled is off.
 */
export async function runNightlySemanticBackfill() {
  if (!FEATURE_FLAGS.semanticToolEnabled) {
    console.log('[semanticBackfill] Skipped — semanticToolEnabled is false');
    return { skipped: true };
  }

  console.log('[semanticBackfill] Starting nightly backfill...');
  const start = Date.now();

  const [drivers, carriers] = await Promise.all([
    _backfillDrivers(),
    _backfillCarriers(),
  ]);

  const durationMs = Date.now() - start;
  const summary = {
    durationMs,
    drivers,
    carriers,
    totalProcessed: drivers.processed + carriers.processed,
    totalFailed:    drivers.failed    + carriers.failed,
  };

  console.log('[semanticBackfill] Complete:', JSON.stringify({
    durationMs,
    drivers:  `${drivers.processed} ok / ${drivers.failed} failed`,
    carriers: `${carriers.processed} ok / ${carriers.failed} failed`,
  }));

  if (summary.totalFailed > 0) {
    console.warn('[semanticBackfill] Failed records:', [
      ...drivers.errors.slice(0, 5),
      ...carriers.errors.slice(0, 5),
    ]);
  }

  return summary;
}

/**
 * Manual driver-only backfill — callable from admin dashboard or one-time migration.
 */
export async function runDriverBackfill() {
  console.log('[semanticBackfill] Starting driver backfill...');
  const stats = await _backfillDrivers();
  console.log('[semanticBackfill] Driver backfill complete:', stats.processed, 'processed,', stats.failed, 'failed');
  return stats;
}

/**
 * Manual carrier-only backfill.
 */
export async function runCarrierBackfill() {
  console.log('[semanticBackfill] Starting carrier backfill...');
  const stats = await _backfillCarriers();
  console.log('[semanticBackfill] Carrier backfill complete:', stats.processed, 'processed,', stats.failed, 'failed');
  return stats;
}

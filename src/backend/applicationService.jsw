/**
 * Application Service
 *
 * Handles driver applications to carriers.
 * Supports dual data sources (Wix and Airtable) via unified dataAccess layer.
 *
 * @module backend/applicationService
 */

import wixUsersBackend from 'wix-users-backend';
import { mediaManager } from 'wix-media-backend';
import { sendApplicationConfirmation } from 'backend/emailService';
import * as dataAccess from 'backend/dataAccess';
import * as lifecycleService from 'backend/lifecycleService';
import { checkApplicationAchievements } from 'backend/achievementService';
import { log } from 'backend/observabilityService';

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const COLLECTION_KEYS = {
  interests: 'driverCarrierInterests',
  profiles: 'driverProfiles'
};

const STATUS = {
  INTERESTED: 'interested',
  APPLIED: 'applied',
  IN_REVIEW: 'in_review',
  CONTACTED: 'contacted',
  OFFER: 'offer',
  HIRED: 'hired',
  REJECTED: 'rejected',
  WITHDRAWN: 'withdrawn'
};

// ============================================================================
// LAZY-LOADED SERVICES
// ============================================================================

async function getGamificationService() {
  return await import('backend/gamificationService');
}

async function getReferralService() {
  return await import('backend/referralService');
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Award XP to driver (non-blocking)
 */
async function awardXPNonBlocking(driverId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardDriverXP(driverId, action, metadata);
  } catch (err) {
    console.warn(`[applicationService] XP award failed for ${action}:`, err.message);
  }
}

/**
 * Track referral conversion (non-blocking)
 */
async function trackReferralApplicationNonBlocking(driverId, metadata = {}) {
  try {
    const referralService = await getReferralService();
    await referralService.trackReferralConversion(driverId, 'applied', metadata);
  } catch (err) {
    console.warn('[applicationService] Referral conversion tracking failed:', err.message);
  }
}

/**
 * Get driver profile by Wix user ID
 */
async function getDriverProfile(userId) {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.profiles, {
    filters: { _owner: userId },
    limit: 1,
    suppressAuth: true
  });

  return result.success && result.items.length > 0 ? result.items[0] : null;
}

/**
 * Upload base64 document to Wix Media
 */
async function uploadDocument(base64Data, fileName, mimeType, folder) {
  try {
    // Extract the actual base64 content (remove data URL prefix)
    const base64Content = base64Data.includes(',') ? base64Data.split(',')[1] : base64Data;

    // Convert base64 to buffer
    const buffer = Buffer.from(base64Content, 'base64');

    // Upload to Wix Media Manager
    const uploadResult = await mediaManager.upload(
      `/driver-documents/${folder}`,
      buffer,
      fileName,
      {
        mediaOptions: {
          mimeType: mimeType,
          mediaType: mimeType.startsWith('image/') ? 'image' : 'document'
        }
      }
    );

    return {
      success: true,
      fileUrl: uploadResult.fileUrl,
      fileName: fileName
    };
  } catch (error) {
    console.error('[applicationService] Document upload error:', error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================================================
// PUBLIC WEB METHODS
// ============================================================================

/**
 * Submit a formal application to a carrier
 * 
 * @param {Object} applicationData - Data from the application form
 */
export async function submitApplication(applicationData) {
  const traceId = `app-${Date.now()}`;
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }

    const userId = currentUser.id;
    const profile = await getDriverProfile(userId);

    if (!profile) {
      return { success: false, error: 'Driver profile not found' };
    }

    // Validate required fields
    if (!applicationData.carrierDOT) {
      return { success: false, error: 'Carrier DOT is required' };
    }

    const now = new Date();

    // 1. Prepare profile updates based on application form data
    const profileUpdates = {
      updated_date: now,
      docs_submitted: true,
      is_searchable: true,
      visibility_level: 'full',
      profile_status: 'active'
    };

    if (applicationData.firstName) profileUpdates.first_name = applicationData.firstName;
    if (applicationData.lastName) profileUpdates.last_name = applicationData.lastName;
    if (applicationData.firstName && applicationData.lastName) {
      profileUpdates.display_name = `${applicationData.firstName} ${applicationData.lastName}`;
    }
    
    // Normalize DOB
    if (applicationData.dob) {
      const isoDateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (isoDateRegex.test(applicationData.dob)) {
        profileUpdates.dob = applicationData.dob;
      } else {
        const parsedDate = new Date(applicationData.dob);
        if (!isNaN(parsedDate.getTime())) {
          const year = parsedDate.getFullYear();
          const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
          const day = String(parsedDate.getDate()).padStart(2, '0');
          profileUpdates.dob = `${year}-${month}-${day}`;
        }
      }
    }

    if (applicationData.city) profileUpdates.city = applicationData.city;
    if (applicationData.state) {
      profileUpdates.state = applicationData.state;
      profileUpdates.cdl_state = applicationData.state;
    }
    if (applicationData.homeZip) {
      profileUpdates.home_zip = applicationData.homeZip;
      profileUpdates.zip_code = applicationData.homeZip;
    }

    if (applicationData.cdlNumber) profileUpdates.cdl_number = applicationData.cdlNumber;
    if (applicationData.cdlExpiration) profileUpdates.cdl_expiration = applicationData.cdlExpiration;
    if (applicationData.cdlClass) profileUpdates.cdl_class = applicationData.cdlClass;
    if (Array.isArray(applicationData.endorsements)) profileUpdates.endorsements = applicationData.endorsements;
    if (Array.isArray(applicationData.restrictions)) profileUpdates.restrictions = applicationData.restrictions;
    if (applicationData.medCardExpiration) profileUpdates.med_card_expiration = applicationData.medCardExpiration;

    if (applicationData.yearsExperience !== undefined) profileUpdates.years_experience = applicationData.yearsExperience;
    if (Array.isArray(applicationData.equipmentExperience)) profileUpdates.equipment_experience = applicationData.equipmentExperience;
    if (applicationData.mvrStatus) {
      profileUpdates.mvr_status = applicationData.mvrStatus;
      profileUpdates.clean_mvr = applicationData.mvrStatus.toLowerCase() === 'clean';
    }

    if (applicationData.accidentsLast3Years !== undefined) profileUpdates.accidents_last_3_years = parseInt(applicationData.accidentsLast3Years, 10) || 0;
    if (applicationData.violationsLast3Years !== undefined) profileUpdates.violations_last_3_years = parseInt(applicationData.violationsLast3Years, 10) || 0;
    
    if (applicationData.companiesLast3Years !== undefined) profileUpdates.companies_last_3_years = parseInt(applicationData.companiesLast3Years, 10) || 0;
    if (applicationData.employer1Name) profileUpdates.employer_1_name = applicationData.employer1Name;
    if (applicationData.employer1Duration) profileUpdates.employer_1_duration = applicationData.employer1Duration;
    if (applicationData.employer2Name) profileUpdates.employer_2_name = applicationData.employer2Name;
    if (applicationData.employer2Duration) profileUpdates.employer_2_duration = applicationData.employer2Duration;
    if (applicationData.employer3Name) profileUpdates.employer_3_name = applicationData.employer3Name;
    if (applicationData.employer3Duration) profileUpdates.employer_3_duration = applicationData.employer3Duration;

    if (Array.isArray(applicationData.preferredRoutes)) {
      profileUpdates.preferred_routes = applicationData.preferredRoutes;
      if (applicationData.preferredRoutes.length > 0) profileUpdates.preferred_operation_type = applicationData.preferredRoutes[0];
    }
    if (applicationData.homeTimePreference) profileUpdates.home_time_preference = applicationData.homeTimePreference;
    if (applicationData.availability) profileUpdates.availability = applicationData.availability;
    if (applicationData.phone) profileUpdates.phone = applicationData.phone;
    if (applicationData.email) profileUpdates.email = applicationData.email;

    // 2. Handle document uploads
    let cdlFrontImage = applicationData.existingProfileDocs?.cdl_front_image || profile.cdl_front_image || null;
    let cdlBackImage = applicationData.existingProfileDocs?.cdl_back_image || profile.cdl_back_image || null;
    let medCardImage = applicationData.existingProfileDocs?.med_card_image || profile.med_card_image || null;
    let resumeFile = applicationData.existingProfileDocs?.resume_file || profile.resume_file || null;

    if (applicationData.documents) {
      const uploadFolder = `${userId}/${Date.now()}`;
      
      const docsToUpload = [
        { key: 'cdlFront', field: 'cdl_front_image', urlField: 'cdl_front_url' },
        { key: 'cdlBack', field: 'cdl_back_image', urlField: 'cdl_back_url' },
        { key: 'medCard', field: 'med_card_image', urlField: 'med_card_url' },
        { key: 'resume', field: 'resume_file', urlField: null }
      ];

      for (const doc of docsToUpload) {
        const fileData = applicationData.documents[doc.key];
        if (fileData && fileData.data) {
          const result = await uploadDocument(fileData.data, fileData.name, fileData.type, uploadFolder);
          if (result.success) {
            profileUpdates[doc.field] = result.fileUrl;
            if (doc.urlField) profileUpdates[doc.urlField] = result.fileUrl;
            
            // Update local variables for application record
            if (doc.key === 'cdlFront') cdlFrontImage = result.fileUrl;
            if (doc.key === 'cdlBack') cdlBackImage = result.fileUrl;
            if (doc.key === 'medCard') medCardImage = result.fileUrl;
            if (doc.key === 'resume') resumeFile = result.fileUrl;
          }
        }
      }

      if (cdlFrontImage && cdlBackImage && medCardImage) {
        profileUpdates.docs_complete = true;
      }
    }

    // 3. Update driver profile
    await dataAccess.updateRecord(COLLECTION_KEYS.profiles, { ...profile, ...profileUpdates }, { suppressAuth: true });

    // 4. Handle interest/application record
    const existingInterestRes = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(applicationData.carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    const existingInterest = existingInterestRes.items?.[0];
    if (existingInterest) {
      const activeStatuses = [STATUS.APPLIED, STATUS.IN_REVIEW, STATUS.CONTACTED, STATUS.OFFER, STATUS.HIRED];
      if (activeStatuses.includes(existingInterest.status)) {
        return {
          success: false,
          error: 'You have already applied to this carrier',
          existingStatus: existingInterest.status,
          applicationId: existingInterest._id,
          isDuplicate: true
        };
      }
    }

    // Prepare status history
    let statusHistory = [];
    if (existingInterest?.status_history) {
      try {
        statusHistory = JSON.parse(existingInterest.status_history);
      } catch (e) {
        statusHistory = [];
      }
    }
    statusHistory.push({
      status: STATUS.APPLIED,
      timestamp: now.toISOString(),
      note: 'Application submitted'
    });

    const applicationRecord = {
      driver_id: profile._id,
      carrier_dot: String(applicationData.carrierDOT),
      carrier_name: applicationData.carrierName || '',
      match_score: applicationData.matchScore || 0,
      action: 'applied',
      action_timestamp: now,
      driver_zip_at_match: profile.home_zip || '',
      status: STATUS.APPLIED,
      application_date: now,
      contact_phone: applicationData.phone || '',
      contact_email: applicationData.email || '',
      preferred_contact: applicationData.preferredContact || 'phone',
      availability: applicationData.availability || '',
      driver_message: applicationData.message || '',
      cdl_front_url: cdlFrontImage,
      cdl_back_url: cdlBackImage,
      med_card_url: medCardImage,
      resume_url: resumeFile,
      status_history: JSON.stringify(statusHistory)
    };

    let resultRecord;
    if (existingInterest) {
      const updateResult = await dataAccess.updateRecord(COLLECTION_KEYS.interests, { ...existingInterest, ...applicationRecord }, { suppressAuth: true });
      if (!updateResult.success) {
        return { success: false, error: updateResult.error || 'Failed to update application record' };
      }
      resultRecord = updateResult.record;
    } else {
      const insertResult = await dataAccess.insertRecord(COLLECTION_KEYS.interests, applicationRecord, { suppressAuth: true });
      if (!insertResult.success) {
        return { success: false, error: insertResult.error || 'Failed to save application record' };
      }
      resultRecord = insertResult.record;
    }

    // 5. Post-submission actions (non-blocking)

    // Lifecycle logging
    lifecycleService.logEvent(profile._id, applicationData.carrierDOT, lifecycleService.EVENT_TYPES.APPLICATION, {
      applicationId: resultRecord._id,
      matchScore: applicationData.matchScore,
      isReapplication: !!existingInterest
    }).catch(err => console.warn('[applicationService] Lifecycle log failed:', err.message));

    // Confirmation email
    sendApplicationConfirmation(userId, {
      driverName: profile.display_name || 'Driver',
      carrierName: applicationData.carrierName,
      carrierDot: applicationData.carrierDOT,
      applicationId: resultRecord._id
    }).catch(err => console.error('[applicationService] Email send failed:', err));

    // Gamification & Achievements
    dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: profile._id, status: STATUS.APPLIED },
      suppressAuth: true
    }).then(result => {
      const count = result.success ? (result.totalCount || result.items.length) : 1;
      return checkApplicationAchievements(profile._id, count);
    }).catch(err => console.warn('[applicationService] Achievement check failed:', err.message));

    awardXPNonBlocking(profile._id, 'apply_job', {
      carrierDot: applicationData.carrierDOT,
      carrierName: applicationData.carrierName,
      matchScore: applicationData.matchScore
    });

    trackReferralApplicationNonBlocking(profile._id, {
      carrierDot: applicationData.carrierDOT
    });

    await log({
      level: 'INFO',
      source: 'application-service',
      message: `Driver ${profile._id} applied to ${applicationData.carrierDOT}`,
      traceId,
      details: { driverId: profile._id, carrierDot: applicationData.carrierDOT }
    });

    return {
      success: true,
      application: resultRecord,
      isNew: !existingInterest
    };

  } catch (error) {
    await log({
      level: 'ERROR',
      source: 'application-service',
      message: 'Application submission failed',
      traceId,
      details: { error: error.message, carrierDOT: applicationData.carrierDOT }
    });
    return { success: false, error: error.message };
  }
}

/**
 * Get the current status of an application for a specific carrier
 */
export async function getApplicationStatus(carrierDOT) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getDriverProfile(currentUser.id);
    if (!profile) return { success: false, error: 'Driver profile not found' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: true, status: null, application: null };
    }

    const application = result.items[0];
    let statusHistory = [];
    try {
      statusHistory = application.status_history ? JSON.parse(application.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    return {
      success: true,
      status: application.status || application.action,
      application: {
        ...application,
        status_history: statusHistory
      }
    };
  } catch (error) {
    console.error('[applicationService] getApplicationStatus error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Withdraw an application
 */
export async function withdrawApplication(carrierDOT) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getDriverProfile(currentUser.id);
    if (!profile) return { success: false, error: 'Driver profile not found' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: false, error: 'Application not found' };
    }

    const application = result.items[0];
    const now = new Date();

    let statusHistory = [];
    try {
      statusHistory = application.status_history ? JSON.parse(application.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    statusHistory.push({
      status: STATUS.WITHDRAWN,
      timestamp: now.toISOString(),
      note: 'Application withdrawn by driver'
    });

    await dataAccess.updateRecord(COLLECTION_KEYS.interests, {
      ...application,
      _id: application._id,
      status: STATUS.WITHDRAWN,
      action: 'withdrawn',
      status_history: JSON.stringify(statusHistory)
    }, { suppressAuth: true });
    
    return { success: true };
  } catch (error) {
    console.error('[applicationService] withdrawApplication error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get all applications for a driver
 */
export async function getDriverApplications(driverId) {
  try {
    const authResult = await verifyDriverAuthorization(driverId);
    if (!authResult.success) return authResult;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: driverId,
        action: 'applied'
      },
      limit: 100,
      suppressAuth: true
    });

    if (!result.success) {
      return { success: false, error: result.error || 'Failed to fetch applications' };
    }

    const applications = result.items.map(app => {
      let statusHistory = [];
      try {
        statusHistory = app.status_history ? JSON.parse(app.status_history) : [];
      } catch (e) {
        statusHistory = [];
      }
      
      return {
        ...app,
        status_history: statusHistory,
        carrier_name: app.carrier_name || 'Unknown Carrier'
      };
    });

    applications.sort((a, b) => new Date(b.action_timestamp) - new Date(a.action_timestamp));

    return {
      success: true,
      applications
    };
  } catch (error) {
    console.error('[applicationService] getDriverApplications error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Verify driver authorization
 */
async function verifyDriverAuthorization(driverId) {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) {
        return { success: false, error: 'User not logged in.' };
    }

    if (currentUser.id === driverId) {
        return { success: true };
    }
    
    const profile = await getDriverProfile(currentUser.id);
    if (profile && profile._id === driverId) {
        return { success: true };
    }

    return { success: false, error: 'Unauthorized access.' };
}
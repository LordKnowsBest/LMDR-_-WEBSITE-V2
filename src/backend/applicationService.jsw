/**
 * Application Service
 *
 * Handles driver applications to carriers.
 * Supports dual data sources (Wix and Airtable) via unified dataAccess layer.
 *
 * @module backend/applicationService
 */

import wixUsersBackend from 'wix-users-backend';
import { mediaManager } from 'wix-media-backend';
import { sendApplicationConfirmation } from 'backend/emailService';
import * as dataAccess from 'backend/dataAccess';
import * as lifecycleService from 'backend/lifecycleService';
import { checkApplicationAchievements } from 'backend/achievementService';
import { log } from 'backend/observabilityService';

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const COLLECTION_KEYS = {
  interests: 'driverCarrierInterests',
  profiles: 'driverProfiles'
};

const STATUS = {
  INTERESTED: 'interested',
  APPLIED: 'applied',
  IN_REVIEW: 'in_review',
  CONTACTED: 'contacted',
  OFFER: 'offer',
  HIRED: 'hired',
  REJECTED: 'rejected',
  WITHDRAWN: 'withdrawn'
};

// ============================================================================
// LAZY-LOADED SERVICES
// ============================================================================

async function getGamificationService() {
  return await import('backend/gamificationService');
}

async function getReferralService() {
  return await import('backend/referralService');
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Award XP to driver (non-blocking)
 */
async function awardXPNonBlocking(driverId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardDriverXP(driverId, action, metadata);
  } catch (err) {
    console.warn(`[applicationService] XP award failed for ${action}:`, err.message);
  }
}

/**
 * Track referral conversion (non-blocking)
 */
async function trackReferralApplicationNonBlocking(driverId, metadata = {}) {
  try {
    const referralService = await getReferralService();
    await referralService.trackReferralConversion(driverId, 'applied', metadata);
  } catch (err) {
    console.warn('[applicationService] Referral conversion tracking failed:', err.message);
  }
}

/**
 * Get driver profile by Wix user ID
 */
async function getDriverProfile(userId) {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.profiles, {
    filters: { _owner: userId },
    limit: 1,
    suppressAuth: true
  });

  return result.success && result.items.length > 0 ? result.items[0] : null;
}

/**
 * Upload base64 document to Wix Media
 */
async function uploadDocument(base64Data, fileName, mimeType, folder) {
  try {
    // Extract the actual base64 content (remove data URL prefix)
    const base64Content = base64Data.includes(',') ? base64Data.split(',')[1] : base64Data;

    // Convert base64 to buffer
    const buffer = Buffer.from(base64Content, 'base64');

    // Upload to Wix Media Manager
    const uploadResult = await mediaManager.upload(
      `/driver-documents/${folder}`,
      buffer,
      fileName,
      {
        mediaOptions: {
          mimeType: mimeType,
          mediaType: mimeType.startsWith('image/') ? 'image' : 'document'
        }
      }
    );

    return {
      success: true,
      fileUrl: uploadResult.fileUrl,
      fileName: fileName
    };
  } catch (error) {
    console.error('[applicationService] Document upload error:', error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

// ============================================================================
// PUBLIC WEB METHODS
// ============================================================================

/**
 * Submit a formal application to a carrier
 * 
 * @param {Object} applicationData - Data from the application form
 */
export async function submitApplication(applicationData) {
  const traceId = `app-${Date.now()}`;
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }

    const userId = currentUser.id;
    const profile = await getDriverProfile(userId);

    if (!profile) {
      return { success: false, error: 'Driver profile not found' };
    }

    // Validate required fields
    if (!applicationData.carrierDOT) {
      return { success: false, error: 'Carrier DOT is required' };
    }

    const now = new Date();

    // 1. Prepare profile updates based on application form data
    const profileUpdates = {
      updated_date: now,
      docs_submitted: true,
      is_searchable: 'Yes',
      visibility_level: 'full',
      profile_status: 'active'
    };

    if (applicationData.firstName) profileUpdates.first_name = applicationData.firstName;
    if (applicationData.lastName) profileUpdates.last_name = applicationData.lastName;
    if (applicationData.firstName && applicationData.lastName) {
      profileUpdates.display_name = `${applicationData.firstName} ${applicationData.lastName}`;
    }

    // Normalize DOB
    if (applicationData.dob) {
      const isoDateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (isoDateRegex.test(applicationData.dob)) {
        profileUpdates.date_of_birth = applicationData.dob;
      } else {
        const parsedDate = new Date(applicationData.dob);
        if (!isNaN(parsedDate.getTime())) {
          const year = parsedDate.getFullYear();
          const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
          const day = String(parsedDate.getDate()).padStart(2, '0');
          profileUpdates.date_of_birth = `${year}-${month}-${day}`;
        }
      }
    }

    if (applicationData.city) profileUpdates.city = applicationData.city;
    if (applicationData.state) {
      profileUpdates.state = applicationData.state;
      profileUpdates.cdl_state = applicationData.state;
    }
    if (applicationData.homeZip) {
      profileUpdates.home_zip = applicationData.homeZip;
      profileUpdates.zip_code = applicationData.homeZip;
    }

    if (applicationData.cdlNumber) profileUpdates.cdl_number = applicationData.cdlNumber;
    if (applicationData.cdlExpiration) profileUpdates.cdl_expiration = applicationData.cdlExpiration;
    if (applicationData.cdlClass) profileUpdates.cdl_class = applicationData.cdlClass;
    if (Array.isArray(applicationData.endorsements)) profileUpdates.endorsements = applicationData.endorsements.join(', ');
    if (Array.isArray(applicationData.restrictions)) profileUpdates.restrictions = applicationData.restrictions.join(', ');
    if (applicationData.medCardExpiration) profileUpdates.med_card_expiration = applicationData.medCardExpiration;

    if (applicationData.yearsExperience !== undefined) profileUpdates.years_experience = applicationData.yearsExperience;
    if (Array.isArray(applicationData.equipmentExperience)) profileUpdates.equipment_experience = applicationData.equipmentExperience.join(', ');
    if (applicationData.mvrStatus) {
      profileUpdates.mvr_status = applicationData.mvrStatus;
      profileUpdates.clean_mvr = applicationData.mvrStatus.toLowerCase() === 'clean' ? 'Yes' : 'No';
    }

    if (applicationData.accidentsLast3Years !== undefined) profileUpdates.accidents_last_3_years = parseInt(applicationData.accidentsLast3Years, 10) || 0;
    if (applicationData.violationsLast3Years !== undefined) profileUpdates.violations_last_3_years = parseInt(applicationData.violationsLast3Years, 10) || 0;

    if (applicationData.companiesLast3Years !== undefined) profileUpdates.companies_last_3_years = parseInt(applicationData.companiesLast3Years, 10) || 0;
    if (applicationData.employer1Name) profileUpdates.employer_1_name = applicationData.employer1Name;
    if (applicationData.employer1Duration) profileUpdates.employer_1_duration = applicationData.employer1Duration;
    if (applicationData.employer2Name) profileUpdates.employer_2_name = applicationData.employer2Name;
    if (applicationData.employer2Duration) profileUpdates.employer_2_duration = applicationData.employer2Duration;
    if (applicationData.employer3Name) profileUpdates.employer_3_name = applicationData.employer3Name;
    if (applicationData.employer3Duration) profileUpdates.employer_3_duration = applicationData.employer3Duration;

    if (Array.isArray(applicationData.preferredRoutes)) {
      profileUpdates.preferred_routes = applicationData.preferredRoutes.join(', ');
      if (applicationData.preferredRoutes.length > 0) profileUpdates.preferred_operation_type = applicationData.preferredRoutes[0];
    }
    if (applicationData.homeTimePreference) profileUpdates.home_time_preference = applicationData.homeTimePreference;
    if (applicationData.availability) profileUpdates.availability = applicationData.availability;
    if (applicationData.phone) profileUpdates.phone = applicationData.phone;
    if (applicationData.email) profileUpdates.email = applicationData.email;

    // 2. Handle document uploads
    let cdlFrontImage = applicationData.existingProfileDocs?.cdl_front_image || profile.cdl_front_image || null;
    let cdlBackImage = applicationData.existingProfileDocs?.cdl_back_image || profile.cdl_back_image || null;
    let medCardImage = applicationData.existingProfileDocs?.med_card_image || profile.med_card_image || null;
    let resumeFile = applicationData.existingProfileDocs?.resume_file || profile.resume_file || null;

    if (applicationData.documents) {
      const uploadFolder = `${userId}/${Date.now()}`;

      const docsToUpload = [
        { key: 'cdlFront', field: 'cdl_front_image', urlField: 'cdl_front_url' },
        { key: 'cdlBack', field: 'cdl_back_image', urlField: 'cdl_back_url' },
        { key: 'medCard', field: 'med_card_image', urlField: 'med_card_url' },
        { key: 'resume', field: 'resume_file', urlField: null }
      ];

      for (const doc of docsToUpload) {
        const fileData = applicationData.documents[doc.key];
        if (fileData && fileData.data) {
          const result = await uploadDocument(fileData.data, fileData.name, fileData.type, uploadFolder);
          if (result.success) {
            profileUpdates[doc.field] = result.fileUrl;
            if (doc.urlField) profileUpdates[doc.urlField] = result.fileUrl;

            // Update local variables for application record
            if (doc.key === 'cdlFront') cdlFrontImage = result.fileUrl;
            if (doc.key === 'cdlBack') cdlBackImage = result.fileUrl;
            if (doc.key === 'medCard') medCardImage = result.fileUrl;
            if (doc.key === 'resume') resumeFile = result.fileUrl;
          }
        }
      }

      if (cdlFrontImage && cdlBackImage && medCardImage) {
        profileUpdates.docs_complete = 'Yes';
      }
    }

    // 3. Update driver profile
    const profileResult = await dataAccess.updateRecord(COLLECTION_KEYS.profiles, { ...profile, ...profileUpdates }, { suppressAuth: true });
    if (!profileResult.success) {
      console.error('[applicationService] Profile update failed:', profileResult.error);
    }

    // 4. Handle interest/application record
    const existingInterestRes = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(applicationData.carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    const existingInterest = existingInterestRes.items?.[0];
    if (existingInterest) {
      const activeStatuses = [STATUS.APPLIED, STATUS.IN_REVIEW, STATUS.CONTACTED, STATUS.OFFER, STATUS.HIRED];
      if (activeStatuses.includes(existingInterest.status)) {
        return {
          success: false,
          error: 'You have already applied to this carrier',
          existingStatus: existingInterest.status,
          applicationId: existingInterest._id,
          isDuplicate: true
        };
      }
    }

    // Prepare status history
    let statusHistory = [];
    if (existingInterest?.status_history) {
      try {
        statusHistory = JSON.parse(existingInterest.status_history);
      } catch (e) {
        statusHistory = [];
      }
    }
    statusHistory.push({
      status: STATUS.APPLIED,
      timestamp: now.toISOString(),
      note: 'Application submitted'
    });

    const applicationRecord = {
      driver_id: profile._id,
      carrier_dot: String(applicationData.carrierDOT),
      carrier_name: applicationData.carrierName || '',
      match_score: applicationData.matchScore || 0,
      action: 'applied',
      action_timestamp: now,
      driver_zip_at_match: profile.home_zip || '',
      status: STATUS.APPLIED,
      application_date: now,
      contact_phone: applicationData.phone || '',
      contact_email: applicationData.email || '',
      preferred_contact: applicationData.preferredContact || 'phone',
      availability: applicationData.availability || '',
      driver_message: applicationData.message || '',
      cdl_front_url: cdlFrontImage,
      cdl_back_url: cdlBackImage,
      med_card_url: medCardImage,
      resume_url: resumeFile,
      status_history: JSON.stringify(statusHistory)
    };

    let resultRecord;
    if (existingInterest) {
      const updateResult = await dataAccess.updateRecord(COLLECTION_KEYS.interests, { ...existingInterest, ...applicationRecord }, { suppressAuth: true });
      if (!updateResult.success) {
        return { success: false, error: updateResult.error || 'Failed to update application record' };
      }
      resultRecord = updateResult.record;
    } else {
      const insertResult = await dataAccess.insertRecord(COLLECTION_KEYS.interests, applicationRecord, { suppressAuth: true });
      if (!insertResult.success) {
        return { success: false, error: insertResult.error || 'Failed to save application record' };
      }
      resultRecord = insertResult.record;
    }

    // 5. Post-submission actions (non-blocking)

    // Lifecycle logging
    lifecycleService.logEvent(profile._id, applicationData.carrierDOT, lifecycleService.EVENT_TYPES.APPLICATION, {
      applicationId: resultRecord._id,
      matchScore: applicationData.matchScore,
      isReapplication: !!existingInterest
    }).catch(err => console.warn('[applicationService] Lifecycle log failed:', err.message));

    // Confirmation email
    sendApplicationConfirmation(userId, {
      driverName: profile.display_name || 'Driver',
      carrierName: applicationData.carrierName,
      carrierDot: applicationData.carrierDOT,
      applicationId: resultRecord._id
    }).catch(err => console.error('[applicationService] Email send failed:', err));

    // Gamification & Achievements
    dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: profile._id, status: STATUS.APPLIED },
      suppressAuth: true
    }).then(result => {
      const count = result.success ? (result.totalCount || result.items.length) : 1;
      return checkApplicationAchievements(profile._id, count);
    }).catch(err => console.warn('[applicationService] Achievement check failed:', err.message));

    awardXPNonBlocking(profile._id, 'apply_job', {
      carrierDot: applicationData.carrierDOT,
      carrierName: applicationData.carrierName,
      matchScore: applicationData.matchScore
    });

    trackReferralApplicationNonBlocking(profile._id, {
      carrierDot: applicationData.carrierDOT
    });

    await log({
      level: 'INFO',
      source: 'application-service',
      message: `Driver ${profile._id} applied to ${applicationData.carrierDOT}`,
      traceId,
      details: { driverId: profile._id, carrierDot: applicationData.carrierDOT }
    });

    return {
      success: true,
      application: resultRecord,
      isNew: !existingInterest
    };

  } catch (error) {
    await log({
      level: 'ERROR',
      source: 'application-service',
      message: 'Application submission failed',
      traceId,
      details: { error: error.message, carrierDOT: applicationData.carrierDOT }
    });
    return { success: false, error: error.message };
  }
}

/**
 * Save a driver lead from a public landing page (no auth required).
 * Writes to the existing driverApplications collection (Airtable Applications table).
 *
 * @param {Object} leadData - Form data from the Truck Driver Page or similar landing pages
 * @returns {Promise<{success: boolean, leadId?: string, message?: string, error?: string}>}
 */
export async function saveDriverLead(leadData) {
  const traceId = `lead-${Date.now()}`;
  try {
    // Parse full name into first/last
    const nameParts = (leadData.fullName || '').trim().split(/\s+/);
    const firstName = nameParts[0] || '';
    const lastName = nameParts.slice(1).join(' ') || '';

    // Derive boolean flags for the scored-driver pipeline
    const endorsements = Array.isArray(leadData.endorsements) ? leadData.endorsements : [];
    const cdlClass = (leadData.cdlClass || '').toUpperCase();
    const runType = (leadData.preferredRunType || 'any').toLowerCase();

    // Map CDL class to the Single Select option labels used in Airtable
    const cdlClassMap = { 'A': 'Class A', 'B': 'Class B', 'C': 'Class C' };
    const cdlClassValue = cdlClassMap[cdlClass] || leadData.cdlClass || '';

    const record = {
      first_name: firstName,
      last_name: lastName,
      phone: leadData.phone || '',
      email: leadData.email || '',
      cdl_class: cdlClassValue,
      has_valid_cdl: true,                          // Checkbox field — must be boolean
      years_experience: leadData.yearsExperience || '0',
      endorsements: endorsements.join(', '),
      route_pref_1: leadData.preferredRunType || 'any',
      availability: 'Immediately',
      submission_date: new Date().toISOString().split('T')[0]
      // NOTE: has_hazmat, has_tanker, has_cdl_a/b/c, is_otr/regional/local_friendly,
      // years_exp_num are all Formula fields in Airtable — they are computed automatically
      // and CANNOT be written via API (causes 422). Do not include them here.
    };

    // CDL details from OCR auto-fill
    if (leadData.cdlNumber) record.cdl_number = leadData.cdlNumber;
    if (leadData.cdlExpiration) record.cdl_expiration = leadData.cdlExpiration;
    if (leadData.medCardExpiration) record.med_card_expiration = leadData.medCardExpiration;
    if (leadData.homeZip) record.home_zip = leadData.homeZip;

    // Handle document uploads (no userId → use sanitised email as folder key)
    if (leadData.documents) {
      const safeEmail = (leadData.email || 'unknown').replace(/[^a-zA-Z0-9]/g, '_');
      const uploadFolder = `leads/${safeEmail}/${Date.now()}`;

      const docsToUpload = [
        { key: 'cdlFront', field: 'cdl_front_url' },
        { key: 'cdlBack', field: 'cdl_back_url' },
        { key: 'medCard', field: 'med_card_url' }
      ];

      for (const doc of docsToUpload) {
        const fileData = leadData.documents[doc.key];
        if (fileData && (fileData.data || fileData.base64)) {
          const base64 = fileData.data || fileData.base64;
          const result = await uploadDocument(
            base64,
            fileData.name || `${doc.key}.jpg`,
            fileData.type || 'image/jpeg',
            uploadFolder
          );
          if (result.success) {
            record[doc.field] = result.fileUrl;
          }
        }
      }
    }

    // Insert into driverApplications (Airtable) — no auth needed
    const insertResult = await dataAccess.insertRecord('driverApplications', record, { suppressAuth: true });

    if (!insertResult.success) {
      await log({
        level: 'ERROR',
        source: 'application-service',
        message: 'Driver lead save failed',
        traceId,
        details: { error: insertResult.error, email: leadData.email }
      });
      return { success: false, error: insertResult.error || 'Failed to save application' };
    }

    await log({
      level: 'INFO',
      source: 'application-service',
      message: `Driver lead saved: ${firstName} ${lastName} (${leadData.email})`,
      traceId,
      details: { leadId: insertResult.record?._id, email: leadData.email }
    });

    return {
      success: true,
      leadId: insertResult.record?._id,
      type: 'lead',
      message: 'Your application has been received! A recruiter will contact you shortly.'
    };
  } catch (error) {
    await log({
      level: 'ERROR',
      source: 'application-service',
      message: 'Driver lead save exception',
      traceId,
      details: { error: error.message, email: leadData?.email }
    });
    return { success: false, error: error.message };
  }
}

/**
 * Get the current status of an application for a specific carrier
 */
export async function getApplicationStatus(carrierDOT) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getDriverProfile(currentUser.id);
    if (!profile) return { success: false, error: 'Driver profile not found' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: true, status: null, application: null };
    }

    const application = result.items[0];
    let statusHistory = [];
    try {
      statusHistory = application.status_history ? JSON.parse(application.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    return {
      success: true,
      status: application.status || application.action,
      application: {
        ...application,
        status_history: statusHistory
      }
    };
  } catch (error) {
    console.error('[applicationService] getApplicationStatus error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Withdraw an application
 */
export async function withdrawApplication(carrierDOT) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getDriverProfile(currentUser.id);
    if (!profile) return { success: false, error: 'Driver profile not found' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: false, error: 'Application not found' };
    }

    const application = result.items[0];
    const now = new Date();

    let statusHistory = [];
    try {
      statusHistory = application.status_history ? JSON.parse(application.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    statusHistory.push({
      status: STATUS.WITHDRAWN,
      timestamp: now.toISOString(),
      note: 'Application withdrawn by driver'
    });

    await dataAccess.updateRecord(COLLECTION_KEYS.interests, {
      ...application,
      _id: application._id,
      status: STATUS.WITHDRAWN,
      action: 'withdrawn',
      status_history: JSON.stringify(statusHistory)
    }, { suppressAuth: true });

    return { success: true };
  } catch (error) {
    console.error('[applicationService] withdrawApplication error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get all applications for a driver
 */
export async function getDriverApplications(driverId) {
  try {
    const authResult = await verifyDriverAuthorization(driverId);
    if (!authResult.success) return authResult;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: {
        driver_id: driverId,
        action: 'applied'
      },
      limit: 100,
      suppressAuth: true
    });

    if (!result.success) {
      return { success: false, error: result.error || 'Failed to fetch applications' };
    }

    const applications = result.items.map(app => {
      let statusHistory = [];
      try {
        statusHistory = app.status_history ? JSON.parse(app.status_history) : [];
      } catch (e) {
        statusHistory = [];
      }

      return {
        ...app,
        status_history: statusHistory,
        carrier_name: app.carrier_name || 'Unknown Carrier'
      };
    });

    applications.sort((a, b) => new Date(b.action_timestamp) - new Date(a.action_timestamp));

    return {
      success: true,
      applications
    };
  } catch (error) {
    console.error('[applicationService] getDriverApplications error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Verify driver authorization
 */
async function verifyDriverAuthorization(driverId) {
  const currentUser = wixUsersBackend.currentUser;
  if (!currentUser.loggedIn) {
    return { success: false, error: 'User not logged in.' };
  }

  if (currentUser.id === driverId) {
    return { success: true };
  }

  const profile = await getDriverProfile(currentUser.id);
  if (profile && profile._id === driverId) {
    return { success: true };
  }

  return { success: false, error: 'Unauthorized access.' };
}
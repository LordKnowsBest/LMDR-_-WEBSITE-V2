// ============================================================================
// B2B RESEARCH AGENT SERVICE - Account intelligence & research briefs
//
// Generates one-click research briefs for carrier accounts using FMCSA data,
// match signals, compliance records, and hiring signals. Provides suggested
// talk tracks and next-step recommendations for business development.
//
// DUAL-SOURCE SUPPORT: Routes through Airtable via config.jsw
//
// Used on: Account Detail (Research Agent Panel), B2B Dashboard
// @see Conductor/tracks/b2b_business_development_suite_20260128/spec.md
// ============================================================================

import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';
import { getCarrierSafetyData } from 'backend/fmcsaService';
import { logAIOperation, startTrace, endTrace } from 'backend/observabilityService';
import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// COLLECTION KEYS
// ============================================================================

const COLLECTIONS = {
  research: 'b2bAccountResearch',
  accounts: 'b2bAccounts',
  signals: 'b2bMatchSignals',
  carriers: 'carriers',
  enrichments: 'carrierEnrichments',
  safetyData: 'carrierSafetyData',
  hiringPrefs: 'carrierHiringPreferences',
  contacts: 'b2bContacts'
};

// ============================================================================
// CONFIG
// ============================================================================

const CACHE_TTL_DAYS = 7; // Research briefs cached for 7 days

const LLM_CONFIG = {
  claudeModel: 'claude-sonnet-4-20250514',
  claudeSecret: 'CLAUDE_API_KEY',
  claudeEndpoint: 'https://api.anthropic.com/v1/messages',
  claudeTimeoutMs: 30000,
  maxTokens: 1500
};

const SEGMENT_TONE = {
  enterprise: 'ROI-focused, data-driven, executive language.',
  mid_market: 'Balanced efficiency and cost savings. Emphasize scalability.',
  regional: 'Practical, relationship-focused. Emphasize local knowledge and quick fills.',
  owner_operator: 'Direct, simple, speed-focused. Fast onboarding, minimal paperwork.'
};

// ============================================================================
// RESEARCH BRIEF GENERATION
// ============================================================================

/**
 * Generate a research brief for a carrier account
 */
export async function generateBrief(accountId, forceRefresh = false) {
  const trace = await startTrace('b2b-research-brief', {
    accountId,
    forceRefresh,
    tags: ['b2b', 'research-brief']
  }).catch(() => ({ traceId: null }));
  const traceId = trace.traceId;
  const startTime = Date.now();

  try {
    if (!accountId) {
      await endTrace(traceId, 'failed', { reason: 'missing_account_id' }).catch(() => {});
      return { success: false, error: 'Account ID is required' };
    }

    // Check cache first (unless force refresh)
    if (!forceRefresh) {
      const cached = await getCachedBrief(accountId);
      if (cached) {
        await endTrace(traceId, 'completed', { fromCache: true, elapsed: Date.now() - startTime }).catch(() => {});
        return { success: true, brief: cached, cached: true };
      }
    }

    // Get account details
    const account = await dataAccess.getRecord(COLLECTIONS.accounts, accountId, { suppressAuth: true });
    if (!account) {
      await endTrace(traceId, 'failed', { reason: 'account_not_found' }).catch(() => {});
      return { success: false, error: 'Account not found' };
    }

    const carrierDot = account.carrier_dot;

    // Gather intelligence from 7 sources in parallel (FMCSA live added as 7th)
    const [
      carrierData,
      enrichmentData,
      safetyData,
      signalData,
      hiringData,
      contactData,
      fmcsaData
    ] = await Promise.all([
      getCarrierProfile(carrierDot),
      getEnrichmentData(carrierDot),
      getSafetyProfile(carrierDot),
      getSignalProfile(carrierDot),
      getHiringSignals(carrierDot),
      getAccountContacts(accountId),
      fetchLiveFMCSA(carrierDot)
    ]);

    let highlights, talkTrack, nextSteps, sources, confidence, generatedBy;

    // Try LLM-powered brief generation, fall back to templates on failure
    try {
      const llmResult = await generateLLMBrief(
        account, carrierData, enrichmentData, safetyData,
        signalData, hiringData, contactData, fmcsaData, traceId
      );
      highlights = llmResult.highlights;
      talkTrack = llmResult.talk_track;
      nextSteps = llmResult.next_steps;
      sources = llmResult.sources;
      confidence = llmResult.confidence;
      generatedBy = 'llm_claude';
    } catch (llmError) {
      console.warn('LLM brief generation failed, using template fallback:', llmError.message);
      highlights = buildHighlights(carrierData, enrichmentData, safetyData, signalData, hiringData);
      talkTrack = buildTalkTrack(account, signalData, hiringData);
      nextSteps = buildNextSteps(account, signalData, hiringData, contactData);
      sources = buildSources(carrierData, enrichmentData, safetyData, hiringData);
      confidence = 'low';
      generatedBy = 'template_fallback';
    }

    const brief = {
      account_id: accountId,
      carrier_dot: carrierDot,
      carrier_name: account.carrier_name,
      summary: highlights.join('\n'),
      highlights: JSON.stringify(highlights),
      talk_track: talkTrack,
      next_steps: JSON.stringify(nextSteps),
      sources: JSON.stringify(sources),
      signals: JSON.stringify({
        match_score: signalData.signal_score || 0,
        driver_count: signalData.driver_count_high_match || 0,
        top_regions: signalData.top_regions || '',
        fleet_size: fmcsaData.total_drivers || carrierData.fleet_size || 0,
        safety_rating: fmcsaData.safety_rating || safetyData.rating || 'unknown'
      }),
      recommendations: nextSteps.map(s => s.text || s).join('; '),
      confidence,
      generated_by: generatedBy,
      generated_at: new Date().toISOString()
    };

    // Save/update the brief
    const existing = await dataAccess.findByField(COLLECTIONS.research, 'account_id', accountId, { suppressAuth: true });
    let saved;
    if (existing) {
      const updateResult = await dataAccess.updateRecord(COLLECTIONS.research, { ...existing, ...brief }, { suppressAuth: true });
      saved = updateResult.record;
    } else {
      const insertResult = await dataAccess.insertRecord(COLLECTIONS.research, brief, { suppressAuth: true });
      saved = insertResult.record;
    }

    await endTrace(traceId, 'completed', {
      fromCache: false,
      elapsed: Date.now() - startTime,
      generatedBy,
      confidence
    }).catch(() => {});

    return { success: true, brief: saved, cached: false };
  } catch (error) {
    console.error('Error generating research brief:', error);
    await endTrace(traceId, 'failed', { error: error.message, elapsed: Date.now() - startTime }).catch(() => {});
    return { success: false, error: error.message || 'Failed to generate brief' };
  }
}

/**
 * Get existing research brief for an account (no generation)
 */
export async function getBrief(accountId) {
  try {
    if (!accountId) return { success: false, error: 'Account ID is required' };

    const record = await dataAccess.findByField(COLLECTIONS.research, 'account_id', accountId, { suppressAuth: true });
    if (!record) {
      return { success: false, error: 'No research brief found. Generate one first.' };
    }

    // Parse JSON fields for frontend consumption
    try { record.highlights = JSON.parse(record.highlights || '[]'); } catch (e) { record.highlights = []; }
    try { record.next_steps = JSON.parse(record.next_steps || '[]'); } catch (e) { record.next_steps = []; }
    try { record.sources = JSON.parse(record.sources || '[]'); } catch (e) { record.sources = []; }
    try { record.signals = JSON.parse(record.signals || '{}'); } catch (e) { record.signals = {}; }
    record.confidence = record.confidence || 'medium';
    record.generated_by = record.generated_by || 'research_agent';

    return { success: true, brief: record };
  } catch (error) {
    console.error('Error fetching research brief:', error);
    return { success: false, error: error.message || 'Failed to fetch brief' };
  }
}

// ============================================================================
// DATA GATHERING HELPERS
// ============================================================================

/**
 * Get carrier profile from FMCSA master table
 */
async function getCarrierProfile(carrierDot) {
  if (!carrierDot) return {};
  try {
    const c = await dataAccess.findByField(COLLECTIONS.carriers, 'dot_number', carrierDot, { suppressAuth: true });
    if (c) {
      return {
        legal_name: c.legal_name || c.carrier_name || '',
        fleet_size: c.total_drivers || c.fleet_size || 0,
        total_power_units: c.total_power_units || 0,
        state: c.physical_state || c.state || '',
        city: c.physical_city || c.city || '',
        operation_type: c.carrier_operation || '',
        entity_type: c.entity_type || '',
        source: 'FMCSA'
      };
    }
  } catch (err) {
    console.warn('Carrier profile lookup failed:', err.message);
  }
  return {};
}

/**
 * Get enrichment data (AI-generated insights)
 */
async function getEnrichmentData(carrierDot) {
  if (!carrierDot) return {};
  try {
    const e = await dataAccess.findByField(COLLECTIONS.enrichments, 'carrier_dot', carrierDot, { suppressAuth: true });
    if (e) {
      return {
        pay_range: e.pay_range || '',
        benefits_summary: e.benefits_summary || '',
        driver_sentiment: e.driver_sentiment || '',
        social_media_summary: e.social_media_summary || '',
        source: 'Platform Enrichment'
      };
    }
  } catch (err) {
    console.warn('Enrichment lookup failed:', err.message);
  }
  return {};
}

/**
 * Get safety/compliance data
 */
async function getSafetyProfile(carrierDot) {
  if (!carrierDot) return {};
  try {
    const s = await dataAccess.findByField(COLLECTIONS.safetyData, 'carrier_dot', carrierDot, { suppressAuth: true });
    if (s) {
      return {
        rating: s.safety_rating || s.overall_rating || 'unknown',
        basic_alerts: s.basic_alerts || '',
        crash_total: s.crash_total || 0,
        inspection_total: s.inspection_total || 0,
        oos_rate: s.out_of_service_rate || 0,
        source: 'FMCSA Safety'
      };
    }
  } catch (err) {
    console.warn('Safety profile lookup failed:', err.message);
  }
  return {};
}

/**
 * Get match signal data
 */
async function getSignalProfile(carrierDot) {
  if (!carrierDot) return {};
  try {
    const s = await dataAccess.findByField(COLLECTIONS.signals, 'carrier_dot', carrierDot, { suppressAuth: true });
    if (s) return s;
  } catch (err) {
    console.warn('Signal lookup failed:', err.message);
  }
  return {};
}

/**
 * Get hiring preferences/signals
 */
async function getHiringSignals(carrierDot) {
  if (!carrierDot) return {};
  try {
    const h = await dataAccess.findByField(COLLECTIONS.hiringPrefs, 'carrier_dot', carrierDot, { suppressAuth: true });
    if (h) {
      return {
        regions: h.regions || '',
        equipment_types: h.equipment_types || '',
        job_types: h.job_types || '',
        experience_min: h.experience_min || '',
        active: true,
        source: 'Platform Hiring Prefs'
      };
    }
  } catch (err) {
    console.warn('Hiring signals lookup failed:', err.message);
  }
  return {};
}

/**
 * Get contacts for the account
 */
async function getAccountContacts(accountId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTIONS.contacts, {
      filters: { account_id: accountId },
      suppressAuth: true
    });
    return result.items || [];
  } catch (err) {
    console.warn('Contacts lookup failed:', err.message);
    return [];
  }
}

// ============================================================================
// BRIEF ASSEMBLY
// ============================================================================

/**
 * Build highlight bullets from gathered data
 */
function buildHighlights(carrier, enrichment, safety, signal, hiring) {
  const highlights = [];

  // Fleet size
  if (carrier.fleet_size) {
    highlights.push(`Fleet size: ~${carrier.fleet_size} drivers (${carrier.total_power_units || '?'} power units)`);
  }
  if (carrier.state) {
    highlights.push(`Based in ${carrier.city ? carrier.city + ', ' : ''}${carrier.state}`);
  }

  // Match signal
  if (signal.driver_count_high_match) {
    highlights.push(`${signal.driver_count_high_match} qualified drivers match this carrier's profile`);
  }
  if (signal.top_regions) {
    highlights.push(`Driver matches concentrated in: ${signal.top_regions}`);
  }

  // Hiring signals
  if (hiring.active) {
    const regions = hiring.regions || 'multiple regions';
    highlights.push(`Active hiring signals in ${regions}`);
  }
  if (hiring.equipment_types) {
    highlights.push(`Equipment needs: ${hiring.equipment_types}`);
  }

  // Safety
  if (safety.rating && safety.rating !== 'unknown') {
    highlights.push(`Safety rating: ${safety.rating}`);
  }
  if (safety.basic_alerts) {
    highlights.push(`CSA BASIC alerts: ${safety.basic_alerts}`);
  }

  // Enrichment
  if (enrichment.pay_range) {
    highlights.push(`Pay range: ${enrichment.pay_range}`);
  }
  if (enrichment.driver_sentiment) {
    highlights.push(`Driver sentiment: ${enrichment.driver_sentiment}`);
  }

  return highlights.length > 0 ? highlights : ['Limited data available. Consider manual research.'];
}

/**
 * Build suggested talk track
 */
function buildTalkTrack(account, signal, hiring) {
  const parts = [];

  // Opening
  const driverCount = signal.driver_count_high_match || 'several';
  const regions = signal.top_regions || hiring.regions || 'your area';
  parts.push(`"We have ${driverCount} qualified drivers in ${regions} who match your requirements."`);

  // Value prop
  if (hiring.equipment_types) {
    parts.push(`Specifically, we have ${hiring.equipment_types}-qualified drivers ready to start.`);
  }

  // Social proof
  parts.push(`We've helped similar carriers fill positions faster through our match-driven approach.`);

  // Close
  parts.push(`Would a 15-minute review of the top driver matches make sense?`);

  return parts.join(' ');
}

/**
 * Build recommended next steps
 */
function buildNextSteps(account, signal, hiring, contacts) {
  const steps = [];

  // Contact situation
  if (!contacts || contacts.length === 0) {
    steps.push({
      priority: 1,
      text: 'Identify decision maker and add as contact',
      type: 'research'
    });
  }

  // Primary outreach
  const score = signal.signal_score || 0;
  if (score >= 80) {
    steps.push({
      priority: 2,
      text: 'Call owner/recruiter with match count and lane fit data',
      type: 'call'
    });
    steps.push({
      priority: 3,
      text: 'Offer a 2-week pilot for fast fill',
      type: 'proposal'
    });
  } else if (score >= 50) {
    steps.push({
      priority: 2,
      text: 'Send intro email with match highlights',
      type: 'email'
    });
    steps.push({
      priority: 3,
      text: 'Follow up with call 2 days after email',
      type: 'call'
    });
  } else {
    steps.push({
      priority: 2,
      text: 'Add to nurture sequence for future engagement',
      type: 'sequence'
    });
  }

  // Account status based
  if (account.status === 'target') {
    steps.push({
      priority: 4,
      text: 'Update account status to prospecting after first touch',
      type: 'admin'
    });
  }

  return steps.sort((a, b) => a.priority - b.priority);
}

/**
 * Build sources list
 */
function buildSources(carrier, enrichment, safety, hiring) {
  const sources = [];
  if (carrier.source) sources.push(carrier.source);
  if (enrichment.source) sources.push(enrichment.source);
  if (safety.source) sources.push(safety.source);
  if (hiring.source) sources.push(hiring.source);
  return [...new Set(sources)]; // Deduplicate
}

// ============================================================================
// LLM BRIEF GENERATION
// ============================================================================

/**
 * Fetch live FMCSA data for a carrier. Returns {} on failure so Promise.all never rejects.
 */
async function fetchLiveFMCSA(carrierDot) {
  if (!carrierDot) return {};
  try {
    const data = await getCarrierSafetyData(carrierDot);
    if (!data || data.error) return {};
    return {
      legal_name: data.legal_name || '',
      total_drivers: data.total_drivers || 0,
      total_power_units: data.total_power_units || 0,
      safety_rating: data.safety_rating || 'NOT RATED',
      basics: data.basics || {},
      has_basic_alerts: data.has_basic_alerts || false,
      inspections: data.inspections || {},
      crashes: data.crashes || {},
      operating_status: data.operating_status || '',
      source: 'FMCSA Live API'
    };
  } catch (err) {
    console.warn('Live FMCSA fetch failed:', err.message);
    return {};
  }
}

/**
 * Extract text content from Claude Messages API response
 */
function extractClaudeText(data) {
  if (!data || !data.content || !Array.isArray(data.content)) return '';
  return data.content
    .filter(block => block.type === 'text')
    .map(block => block.text)
    .join('\n')
    .trim();
}

/**
 * Build system + user prompts for research brief generation
 */
function buildResearchPrompt(account, carrier, enrichment, safety, signal, hiring, contacts, fmcsa) {
  const segment = account.segment || 'mid_market';
  const tone = SEGMENT_TONE[segment] || SEGMENT_TONE.mid_market;

  // Build BASIC alerts summary for compliance talking points
  let basicAlertsList = '';
  if (fmcsa.has_basic_alerts && fmcsa.basics) {
    const alerts = Object.entries(fmcsa.basics)
      .filter(([, v]) => v && v.alert)
      .map(([k, v]) => `${k.replace(/_/g, ' ')}: ${v.percentile}th percentile (ALERT)`)
      .join(', ');
    if (alerts) basicAlertsList = alerts;
  }

  const systemPrompt = `You are a B2B Intelligence Analyst for LMDR (Last Mile Driver Recruiting). You generate research briefs that help business development reps prepare for carrier outreach.

RULES:
1. FMCSA data is verified government data — treat it as ground truth. Never contradict FMCSA figures.
2. Tone: ${tone}
3. Segment: ${segment}
${basicAlertsList ? `4. This carrier has BASIC ALERTS (${basicAlertsList}). Include compliance-focused talking points about how LMDR\'s pre-screened drivers can help improve safety scores.` : '4. No BASIC alerts detected.'}
5. Confidence scoring: "high" = 4+ data sources with verified data, "medium" = some data gaps, "low" = sparse data.
6. Output ONLY valid JSON. No markdown, no explanation, no wrapping.`;

  const userPrompt = `Generate a research brief for this carrier account using the data below.

=== ACCOUNT CONTEXT ===
Name: ${account.carrier_name || 'Unknown'}
DOT: ${account.carrier_dot || 'N/A'}
Segment: ${segment}
Status: ${account.status || 'unknown'}

=== CARRIER PROFILE ===
Legal Name: ${carrier.legal_name || 'Unknown'}
Location: ${carrier.city ? carrier.city + ', ' : ''}${carrier.state || 'Unknown'}
Fleet Size: ${carrier.fleet_size || 'Unknown'} drivers
Power Units: ${carrier.total_power_units || 'Unknown'}
Operation Type: ${carrier.operation_type || 'Unknown'}

=== FMCSA SAFETY DATA ===
Safety Rating: ${fmcsa.safety_rating || safety.rating || 'Unknown'}
Operating Status: ${fmcsa.operating_status || 'Unknown'}
Total Drivers: ${fmcsa.total_drivers || carrier.fleet_size || 'Unknown'}
Total Power Units: ${fmcsa.total_power_units || carrier.total_power_units || 'Unknown'}
BASIC Scores: ${fmcsa.basics ? JSON.stringify(fmcsa.basics) : 'No data'}
Has BASIC Alerts: ${fmcsa.has_basic_alerts ? 'YES' : 'No'}
Inspections: ${fmcsa.inspections ? JSON.stringify(fmcsa.inspections) : 'No data'}
Crashes: ${fmcsa.crashes ? JSON.stringify(fmcsa.crashes) : 'No data'}

=== MATCH SIGNALS ===
Match Score: ${signal.signal_score || 'N/A'}
High-Match Drivers: ${signal.driver_count_high_match || 'N/A'}
Top Regions: ${signal.top_regions || 'N/A'}
Equipment: ${signal.equipment_types || 'N/A'}

=== HIRING SIGNALS ===
Active Hiring: ${hiring.active ? 'Yes' : 'No'}
Regions: ${hiring.regions || 'N/A'}
Equipment Types: ${hiring.equipment_types || 'N/A'}
Experience Min: ${hiring.experience_min || 'N/A'}

=== AI ENRICHMENT DATA ===
Pay Range: ${enrichment.pay_range || 'N/A'}
Benefits: ${enrichment.benefits_summary || 'N/A'}
Driver Sentiment: ${enrichment.driver_sentiment || 'N/A'}
Social Media: ${enrichment.social_media_summary || 'N/A'}

=== CONTACTS ON FILE ===
Count: ${Array.isArray(contacts) ? contacts.length : 0}
${Array.isArray(contacts) && contacts.length > 0 ? `Primary: ${contacts[0].name || 'Unknown'} (${contacts[0].role || contacts[0].title || 'Unknown role'})` : 'No contacts on file'}

=== REQUIRED OUTPUT FORMAT ===
{
  "highlights": ["5-7 bullet strings, most important first"],
  "talk_track": "3-5 sentences, segment-appropriate tone, data-specific, end with CTA",
  "next_steps": [{"text": "action description", "type": "call|email|proposal|sequence|research|admin", "priority": 1}],
  "confidence": "high|medium|low",
  "sources": ["list of data sources that contributed to this brief"]
}`;

  return { systemPrompt, userPrompt };
}

/**
 * Parse and validate Claude's research brief JSON response
 * Throws on failure to trigger template fallback
 */
function parseResearchBriefResponse(responseText) {
  if (!responseText) throw new Error('Empty response from Claude');

  // Strip markdown code fences if present
  let cleaned = responseText.trim();
  cleaned = cleaned.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '');

  // Try to extract JSON object
  const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
  if (!jsonMatch) throw new Error('No JSON object found in response');

  const parsed = JSON.parse(jsonMatch[0]);

  // Validate required fields
  if (!parsed.highlights || !Array.isArray(parsed.highlights)) {
    parsed.highlights = [parsed.highlights || 'Brief generated with limited data.'];
  }
  if (!parsed.talk_track || typeof parsed.talk_track !== 'string') {
    throw new Error('Missing talk_track in response');
  }
  if (!parsed.next_steps || !Array.isArray(parsed.next_steps)) {
    parsed.next_steps = [];
  }
  // Normalize next_steps to ensure each has required fields
  parsed.next_steps = parsed.next_steps.map((step, i) => ({
    text: step.text || String(step),
    type: step.type || 'research',
    priority: step.priority || i + 1
  }));

  parsed.confidence = ['high', 'medium', 'low'].includes(parsed.confidence) ? parsed.confidence : 'medium';
  parsed.sources = Array.isArray(parsed.sources) ? parsed.sources : [];

  return parsed;
}

/**
 * Core LLM engine — calls Claude to generate a research brief.
 * Follows the same fetch + Promise.race pattern as aiEnrichment.jsw.
 * Throws on failure so caller can fall back to templates.
 */
async function generateLLMBrief(account, carrier, enrichment, safety, signal, hiring, contacts, fmcsa, traceId) {
  const startTime = Date.now();
  const apiKey = await getSecret(LLM_CONFIG.claudeSecret);

  const { systemPrompt, userPrompt } = buildResearchPrompt(account, carrier, enrichment, safety, signal, hiring, contacts, fmcsa);

  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Claude timeout')), LLM_CONFIG.claudeTimeoutMs);
  });

  const fetchPromise = fetch(LLM_CONFIG.claudeEndpoint, {
    method: 'POST',
    headers: {
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: LLM_CONFIG.claudeModel,
      max_tokens: LLM_CONFIG.maxTokens,
      system: systemPrompt,
      messages: [{ role: 'user', content: userPrompt }]
    })
  });

  try {
    const response = await Promise.race([fetchPromise, timeoutPromise]);
    const latencyMs = Date.now() - startTime;

    if (!response.ok) {
      const errorBody = await response.text().catch(() => 'unknown');
      throw new Error(`Claude API ${response.status}: ${errorBody}`);
    }

    const data = await response.json();
    const responseText = extractClaudeText(data);
    const usage = data.usage || {};

    // Log successful AI operation
    await logAIOperation({
      source: 'b2b-research-agent',
      operation: 'research-brief',
      functionId: 'research-brief-llm',
      provider: 'anthropic',
      model: LLM_CONFIG.claudeModel,
      inputTokens: usage.input_tokens,
      outputTokens: usage.output_tokens,
      totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0),
      latencyMs,
      traceId
    }).catch(err => console.warn('AI log failed:', err.message));

    return parseResearchBriefResponse(responseText);
  } catch (error) {
    const latencyMs = Date.now() - startTime;
    // Log failed AI operation
    await logAIOperation({
      source: 'b2b-research-agent',
      operation: 'research-brief',
      functionId: 'research-brief-llm',
      provider: 'anthropic',
      model: LLM_CONFIG.claudeModel,
      latencyMs,
      error: error.message,
      traceId
    }).catch(err => console.warn('AI error log failed:', err.message));

    throw error; // Re-throw to trigger template fallback
  }
}

// ============================================================================
// CACHE MANAGEMENT
// ============================================================================

/**
 * Get cached brief if within TTL
 */
async function getCachedBrief(accountId) {
  try {
    const results = await dataAccess.queryRecords(COLLECTIONS.research, { 
      filters: { account_id: accountId }, 
      limit: 1, 
      suppressAuth: true 
    });
    if (!results.success || results.items.length === 0) return null;

    const brief = results.items[0];
    if (!brief.generated_at) return null;

    const generatedAt = new Date(brief.generated_at);
    const now = new Date();
    const ageDays = (now - generatedAt) / (1000 * 60 * 60 * 24);

    if (ageDays <= CACHE_TTL_DAYS) {
      // Parse JSON fields
      try { brief.highlights = JSON.parse(brief.highlights || '[]'); } catch (e) { brief.highlights = []; }
      try { brief.next_steps = JSON.parse(brief.next_steps || '[]'); } catch (e) { brief.next_steps = []; }
      try { brief.sources = JSON.parse(brief.sources || '[]'); } catch (e) { brief.sources = []; }
      try { brief.signals = JSON.parse(brief.signals || '{}'); } catch (e) { brief.signals = {}; }
      brief.confidence = brief.confidence || 'medium';
      brief.generated_by = brief.generated_by || 'research_agent';
      return brief;
    }

    return null; // Expired
  } catch (err) {
    console.warn('Cache check failed:', err.message);
    return null;
  }
}

// ============================================================================
// PHASE 4 — PARALLEL EXTERNAL RESEARCH VIA AI MICROSERVICE
// ============================================================================

const RESEARCH_RUNTIME_BASE  = 'https://lmdr-ai-intelligence-production.up.railway.app';
const RESEARCH_TIMEOUT_MS    = 20_000;
const ALL_RESEARCH_SECTIONS  = ['fmcsa', 'social', 'news', 'linkedin'];

/**
 * Run parallel external research on any carrier via the AI microservice.
 *
 * Unlike generateBrief() (which reads Airtable data), this calls the
 * microservice which fans out to FMCSA + Claude-powered social/news/LinkedIn
 * researchers in parallel. Results are returned in < 20s with partial: true
 * if any section timed out.
 *
 * Useful for:
 *   - Quick carrier background check before a B2B account is created
 *   - Real-time enrichment panel on Account Detail page
 *   - Prospecting workflow (any DOT#, not just ones already in Airtable)
 *
 * @param {string}   dotNumber     FMCSA DOT number
 * @param {string}   companyName   Carrier legal/DBA name
 * @param {string[]} [sections]    Subset of sections to request (default: all 4)
 * @returns {Promise<{
 *   dotNumber: string,
 *   companyName: string,
 *   partial: boolean,
 *   generatedAt: string,
 *   latencyMs: number,
 *   sections: object,
 *   synthesis: string|null,
 *   requestId: string,
 * }>}
 */
export async function runParallelResearch(dotNumber, companyName, sections = ALL_RESEARCH_SECTIONS) {
  if (!dotNumber || !companyName) {
    throw new Error('runParallelResearch: dotNumber and companyName are required');
  }

  let internalKey;
  try {
    internalKey = await getSecret('LMDR_INTERNAL_KEY');
  } catch (err) {
    throw new Error(`runParallelResearch: secret load failed: ${err.message}`);
  }

  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), RESEARCH_TIMEOUT_MS);

  let res;
  try {
    res = await fetch(`${RESEARCH_RUNTIME_BASE}/v1/research/company`, {
      method: 'POST',
      headers: {
        'Content-Type':        'application/json',
        'x-lmdr-internal-key': internalKey,
        'x-lmdr-timestamp':    String(Date.now()),
      },
      body: JSON.stringify({
        dotNumber,
        companyName,
        requestedSections: sections,
      }),
      signal: controller.signal,
    });
  } catch (err) {
    clearTimeout(timer);
    const reason = err.name === 'AbortError' ? 'Request timed out (20s)' : err.message;
    throw new Error(`runParallelResearch: fetch failed: ${reason}`);
  }

  clearTimeout(timer);

  if (!res.ok) {
    let code = `HTTP_${res.status}`;
    try { code = (await res.json())?.error?.code || code; } catch { /* ignore */ }
    throw new Error(`runParallelResearch: microservice responded ${res.status} (${code})`);
  }

  return await res.json();
}

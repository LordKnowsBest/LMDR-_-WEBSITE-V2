/**
 * Weigh Station Service - Real-time weigh station status with bypass eligibility
 *
 * Features:
 * - Search weigh stations by location, route, or state
 * - Real-time status from state 511 APIs
 * - Driver-reported status with time decay
 * - PrePass/DriveWyze bypass probability
 * - Wait time estimation from community reports
 */

import wixData from 'wix-data';
import { fetch } from 'wix-fetch';
import { usesAirtable, getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// ============================================
// COLLECTIONS
// ============================================

const COLLECTIONS = {
    STATIONS: 'WeighStations',
    REPORTS: 'WeighStationReports',
    CACHE: 'RoadUtilityCache',
    DRIVER_PREFS: 'DriverBypassServices'
};

// Collection keys for dual-source routing
const COLLECTION_KEYS = {
    weighStations: 'weighStations',
    weighStationReports: 'weighStationReports',
    roadUtilityCache: 'roadUtilityCache',
    driverBypassServices: 'driverBypassServices'
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

async function queryData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            sort: options.sort,
            maxRecords: options.limit || 100
        });
        return result.records || [];
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) {
            query = query.eq(field, value);
        }
    }
    if (options.gt) {
        for (const [field, value] of Object.entries(options.gt)) {
            query = query.gt(field, value);
        }
    }
    if (options.ascending) {
        query = query.ascending(options.ascending);
    }
    if (options.descending) {
        query = query.descending(options.descending);
    }
    if (options.limit) {
        query = query.limit(options.limit);
    }
    const result = await query.find({ suppressAuth: true });
    return result.items;
}

async function getRecord(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.getRecord(tableName, recordId);
    }
    return await wixData.get(wixCollectionName, recordId, { suppressAuth: true });
}

async function insertData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.createRecord(tableName, data);
    }
    return await wixData.insert(wixCollectionName, data, { suppressAuth: true });
}

async function updateData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.updateRecord(tableName, data._id || data.id, data);
    }
    return await wixData.update(wixCollectionName, data, { suppressAuth: true });
}

async function removeData(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.deleteRecord(tableName, recordId);
    }
    return await wixData.remove(wixCollectionName, recordId, { suppressAuth: true });
}

// ============================================
// HAVERSINE DISTANCE CALCULATION
// ============================================

function calculateDistance(lat1, lng1, lat2, lng2) {
    if (!lat1 || !lng1 || !lat2 || !lng2) return Infinity;

    const R = 3958.8; // Earth's radius in miles
    const toRad = (value) => (value * Math.PI) / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lng2 - lng1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

// ============================================
// STATE 511 API CONFIGURATION
// ============================================

const WEIGH_STATION_APIS = {
    // Florida - FL511 REST API
    FLORIDA: {
        url: 'https://fl511.com/api/v2/get/weighstations',
        timeout: 8000,
        public: true,
        normalizer: 'normalizeFL511Data'
    },
    // Texas - DriveTexas API
    TEXAS: {
        url: 'https://api.drivetexas.org/weighstations',
        timeout: 8000,
        public: true,
        normalizer: 'normalizeTXData'
    },
    // Colorado - CDOT
    COLORADO: {
        url: 'https://dtdapps.coloradodot.info/otis/api/weighstations',
        timeout: 8000,
        public: true,
        normalizer: 'normalizeCOData'
    },
    // Nevada - NDOT
    NEVADA: {
        url: 'https://nvroads.com/api/weighstations',
        timeout: 8000,
        public: true,
        normalizer: 'normalizeNVData'
    },
    // Georgia - GA511
    GEORGIA: {
        url: 'https://511ga.org/api/weighstations',
        timeout: 8000,
        public: true,
        normalizer: 'normalizeGA511Data'
    }
};

// Circuit breaker state for each API
const circuitBreaker = {};
Object.keys(WEIGH_STATION_APIS).forEach(state => {
    circuitBreaker[state.toLowerCase()] = { failures: 0, lastFailure: 0, status: 'CLOSED' };
});

// ============================================
// CIRCUIT BREAKER HELPERS
// ============================================

function checkCircuitBreaker(apiName) {
    const cb = circuitBreaker[apiName];
    if (!cb) return true;

    if (cb.status === 'OPEN') {
        // Check if enough time has passed for half-open
        if (Date.now() - cb.lastFailure > 60000) {
            cb.status = 'HALF_OPEN';
            return true;
        }
        return false;
    }
    return true;
}

function recordSuccess(apiName) {
    const cb = circuitBreaker[apiName];
    if (cb) {
        cb.failures = 0;
        cb.status = 'CLOSED';
    }
}

function recordFailure(apiName) {
    const cb = circuitBreaker[apiName];
    if (cb) {
        cb.failures++;
        cb.lastFailure = Date.now();
        if (cb.failures >= 3) {
            cb.status = 'OPEN';
        }
    }
}

// ============================================
// STATE 511 API NORMALIZERS
// ============================================

function normalizeFL511Data(data) {
    if (!Array.isArray(data)) return [];

    return data.map(item => ({
        external_id: `fl_${item.id || item.stationId}`,
        source: 'fl511',
        source_label: 'FL511',
        name: item.name || item.stationName || 'Florida Weigh Station',
        state: 'FL',
        highway: item.route || item.highway || '',
        direction: item.direction || '',
        mile_marker: parseFloat(item.mileMarker) || 0,
        location: {
            lat: parseFloat(item.latitude || item.lat),
            lng: parseFloat(item.longitude || item.lng)
        },
        status: normalizeStatus(item.status || item.open),
        status_confidence: 'sensor',
        prepass_enabled: item.prepass === true || item.prepassEnabled === true,
        prepass_bypass_rate: item.prepassBypassRate || 75,
        drivewyze_enabled: item.drivewyze === true || item.drivewyzeEnabled === true,
        drivewyze_bypass_rate: item.drivewyzeBypassRate || 78,
        last_status_update: item.lastUpdated ? new Date(item.lastUpdated) : new Date()
    }));
}

function normalizeTXData(data) {
    const items = data.weighStations || data.stations || data || [];
    if (!Array.isArray(items)) return [];

    return items.map(item => ({
        external_id: `tx_${item.id || item.facilityId}`,
        source: 'drivetexas',
        source_label: 'DriveTexas',
        name: item.name || item.facilityName || 'Texas Weigh Station',
        state: 'TX',
        highway: item.highway || item.route || '',
        direction: item.direction || item.bound || '',
        mile_marker: parseFloat(item.mileMarker || item.milepost) || 0,
        location: {
            lat: parseFloat(item.latitude || item.y),
            lng: parseFloat(item.longitude || item.x)
        },
        status: normalizeStatus(item.status || item.openStatus),
        status_confidence: 'sensor',
        prepass_enabled: item.prepass !== false,
        prepass_bypass_rate: 72,
        drivewyze_enabled: item.drivewyze !== false,
        drivewyze_bypass_rate: 76,
        last_status_update: item.timestamp ? new Date(item.timestamp) : new Date()
    }));
}

function normalizeCOData(data) {
    const items = data.features || data.stations || data || [];
    if (!Array.isArray(items)) return [];

    return items.map(item => {
        const props = item.properties || item;
        const coords = item.geometry?.coordinates || [props.longitude, props.latitude];

        return {
            external_id: `co_${props.id || props.stationId}`,
            source: 'cdot',
            source_label: 'CDOT',
            name: props.name || props.stationName || 'Colorado Port of Entry',
            state: 'CO',
            highway: props.highway || props.route || '',
            direction: props.direction || '',
            mile_marker: parseFloat(props.mileMarker) || 0,
            location: {
                lat: coords[1] || parseFloat(props.latitude),
                lng: coords[0] || parseFloat(props.longitude)
            },
            status: normalizeStatus(props.status || props.open),
            status_confidence: 'sensor',
            prepass_enabled: true,
            prepass_bypass_rate: 80,
            drivewyze_enabled: true,
            drivewyze_bypass_rate: 82,
            last_status_update: props.lastUpdate ? new Date(props.lastUpdate) : new Date()
        };
    });
}

function normalizeNVData(data) {
    const items = data.stations || data || [];
    if (!Array.isArray(items)) return [];

    return items.map(item => ({
        external_id: `nv_${item.id}`,
        source: 'nvroads',
        source_label: 'NDOT',
        name: item.name || 'Nevada Port of Entry',
        state: 'NV',
        highway: item.highway || '',
        direction: item.direction || '',
        mile_marker: parseFloat(item.mileMarker) || 0,
        location: {
            lat: parseFloat(item.latitude),
            lng: parseFloat(item.longitude)
        },
        status: normalizeStatus(item.status),
        status_confidence: 'sensor',
        prepass_enabled: item.prepass !== false,
        prepass_bypass_rate: 78,
        drivewyze_enabled: item.drivewyze !== false,
        drivewyze_bypass_rate: 80,
        last_status_update: new Date()
    }));
}

function normalizeGA511Data(data) {
    const items = data.weighStations || data || [];
    if (!Array.isArray(items)) return [];

    return items.map(item => ({
        external_id: `ga_${item.id}`,
        source: 'ga511',
        source_label: 'GA511',
        name: item.name || 'Georgia Weigh Station',
        state: 'GA',
        highway: item.route || item.highway || '',
        direction: item.direction || '',
        mile_marker: parseFloat(item.mileMarker) || 0,
        location: {
            lat: parseFloat(item.latitude),
            lng: parseFloat(item.longitude)
        },
        status: normalizeStatus(item.status || item.open),
        status_confidence: 'sensor',
        prepass_enabled: true,
        prepass_bypass_rate: 74,
        drivewyze_enabled: true,
        drivewyze_bypass_rate: 77,
        last_status_update: item.lastUpdated ? new Date(item.lastUpdated) : new Date()
    }));
}

/**
 * Normalize various status formats to standard values
 */
function normalizeStatus(rawStatus) {
    if (rawStatus === true || rawStatus === 'true' || rawStatus === 'Open' || rawStatus === 'OPEN' || rawStatus === 'open') {
        return 'open';
    }
    if (rawStatus === false || rawStatus === 'false' || rawStatus === 'Closed' || rawStatus === 'CLOSED' || rawStatus === 'closed') {
        return 'closed';
    }
    return 'unknown';
}

// ============================================
// STATE 511 API QUERIES
// ============================================

/**
 * Query a state 511 API for weigh station data
 */
async function queryState511API(stateKey) {
    const config = WEIGH_STATION_APIS[stateKey];
    if (!config) return [];

    const apiName = stateKey.toLowerCase();
    if (!checkCircuitBreaker(apiName)) {
        console.log(`[WeighStation] Circuit breaker OPEN for ${stateKey}, skipping`);
        return [];
    }

    try {
        const response = await fetch(config.url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
            timeout: config.timeout
        });

        if (!response.ok) {
            throw new Error(`${stateKey} API error: ${response.status}`);
        }

        const data = await response.json();
        recordSuccess(apiName);

        // Use appropriate normalizer
        const normalizers = {
            normalizeFL511Data,
            normalizeTXData,
            normalizeCOData,
            normalizeNVData,
            normalizeGA511Data
        };
        const normalizer = normalizers[config.normalizer];
        const normalized = normalizer ? normalizer(data) : [];

        console.log(`[WeighStation] ${stateKey} returned ${normalized.length} stations`);
        return normalized;
    } catch (error) {
        recordFailure(apiName);
        console.error(`[WeighStation] ${stateKey} API failed:`, error.message);
        return [];
    }
}

/**
 * Query all available state 511 APIs
 */
async function queryAllState511APIs() {
    const queries = Object.keys(WEIGH_STATION_APIS).map(state => queryState511API(state));
    const results = await Promise.all(queries);
    const allItems = results.flat();
    console.log(`[WeighStation] Total from all 511 APIs: ${allItems.length} stations`);
    return allItems;
}

// ============================================
// DATABASE QUERIES
// ============================================

/**
 * Query local database for weigh stations
 */
async function queryLocalDatabase(lat, lng, radius, options = {}) {
    try {
        let resultItems = [];

        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.weighStations)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.weighStations);
            const filter = options.state ? `{State} = "${options.state.toUpperCase()}"` : '';
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                maxRecords: 500
            });
            resultItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                external_id: r['External Id'] || r.external_id,
                name: r.Name || r.name,
                state: r.State || r.state,
                highway: r.Highway || r.highway,
                direction: r.Direction || r.direction,
                location: r.Location || r.location,
                status: r.Status || r.status,
                prepass_enabled: r['Prepass Enabled'] || r.prepass_enabled,
                drivewyze_enabled: r['Drivewyze Enabled'] || r.drivewyze_enabled,
                prepass_bypass_rate: r['Prepass Bypass Rate'] || r.prepass_bypass_rate,
                drivewyze_bypass_rate: r['Drivewyze Bypass Rate'] || r.drivewyze_bypass_rate
            }));
        } else {
            let query = wixData.query(COLLECTIONS.STATIONS);
            if (options.state) {
                query = query.eq('state', options.state.toUpperCase());
            }
            const result = await query.limit(500).find({ suppressAuth: true });
            resultItems = result.items;
        }

        // Calculate distance and filter by radius
        const stationsWithDistance = resultItems.map(station => {
            const stationLat = station.location?.lat;
            const stationLng = station.location?.lng;
            const distance = calculateDistance(lat, lng, stationLat, stationLng);
            return { ...station, distance_miles: Math.round(distance * 10) / 10 };
        }).filter(station => station.distance_miles <= radius);

        // Sort by distance
        stationsWithDistance.sort((a, b) => a.distance_miles - b.distance_miles);

        return stationsWithDistance;
    } catch (error) {
        console.error('[WeighStation] Database query failed:', error);
        return [];
    }
}

/**
 * Get recent driver reports for a station
 */
async function getRecentReports(stationId, hoursBack = 4) {
    const cutoff = new Date(Date.now() - hoursBack * 3600000);

    try {
        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.weighStationReports)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.weighStationReports);
            const filter = `AND({Station Id} = "${stationId}", {Reported At} > "${cutoff.toISOString()}")`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                sort: [{ field: 'Reported At', direction: 'desc' }],
                maxRecords: 20
            });
            return (result.records || []).map(r => ({
                _id: r.id || r._id,
                station_id: r['Station Id'] || r.station_id,
                driver_id: r['Driver Id'] || r.driver_id,
                report_type: r['Report Type'] || r.report_type,
                wait_minutes: r['Wait Minutes'] || r.wait_minutes,
                notes: r.Notes || r.notes,
                reported_at: r['Reported At'] ? new Date(r['Reported At']) : (r.reported_at ? new Date(r.reported_at) : new Date())
            }));
        }

        // Wix Data path
        const result = await wixData.query(COLLECTIONS.REPORTS)
            .eq('station_id', stationId)
            .gt('reported_at', cutoff)
            .descending('reported_at')
            .limit(20)
            .find({ suppressAuth: true });

        return result.items;
    } catch (error) {
        console.error('[WeighStation] Failed to get reports:', error);
        return [];
    }
}

/**
 * Aggregate reports to determine status and wait time
 */
function aggregateReports(reports) {
    if (!reports || reports.length === 0) {
        return { status: null, wait_estimate: null, report_count: 0 };
    }

    // Count status votes
    const statusCounts = { open: 0, closed: 0 };
    let totalWaitTime = 0;
    let waitReportCount = 0;

    const now = Date.now();

    reports.forEach(report => {
        // Weight by recency (newer reports count more)
        const ageHours = (now - report.reported_at.getTime()) / 3600000;
        const weight = 1 / (ageHours + 0.5);

        if (report.report_type === 'open') statusCounts.open += weight;
        if (report.report_type === 'closed') statusCounts.closed += weight;

        if (report.wait_minutes && report.wait_minutes > 0) {
            totalWaitTime += report.wait_minutes * weight;
            waitReportCount += weight;
        }
    });

    // Determine consensus status
    let status = null;
    if (statusCounts.open > statusCounts.closed * 1.5) status = 'open';
    else if (statusCounts.closed > statusCounts.open * 1.5) status = 'closed';

    // Calculate average wait time
    const wait_estimate = waitReportCount > 0 ? Math.round(totalWaitTime / waitReportCount) : null;

    return {
        status,
        wait_estimate,
        report_count: reports.length,
        status_confidence: 'reported'
    };
}

// ============================================
// BYPASS PROBABILITY CALCULATION
// ============================================

/**
 * Calculate bypass probability based on driver's services and station participation
 */
function calculateBypassProbability(station, driverServices = {}) {
    const probabilities = [];

    // Check PrePass
    if (driverServices.prepass && station.prepass_enabled) {
        probabilities.push(station.prepass_bypass_rate || 75);
    }

    // Check DriveWyze
    if (driverServices.drivewyze && station.drivewyze_enabled) {
        probabilities.push(station.drivewyze_bypass_rate || 78);
    }

    // Return highest probability (if driver has both services)
    if (probabilities.length === 0) return 0;
    return Math.max(...probabilities);
}

// ============================================
// MAIN SERVICE FUNCTIONS
// ============================================

/**
 * Search for weigh stations near a location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} radius - Search radius in miles (default: 100)
 * @param {Object} options - Search options (state, bypassServices)
 */
export async function searchWeighStations(lat, lng, radius = 100, options = {}) {
    const cacheKey = `weighstations:${lat.toFixed(2)}:${lng.toFixed(2)}:${radius}:${options.state || 'all'}`;

    try {
        // 1. Check cache first using dual-source routing
        let cachedItems = [];
        if (usesAirtable(COLLECTION_KEYS.roadUtilityCache)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.roadUtilityCache);
            const filter = `AND({Cache Key} = "${cacheKey}", {Expires At} > "${new Date().toISOString()}")`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                cachedItems = [{ data: r.Data || r.data, _id: r.id || r._id }];
            }
        } else {
            const cached = await wixData.query(COLLECTIONS.CACHE)
                .eq('cache_key', cacheKey)
                .gt('expires_at', new Date())
                .limit(1)
                .find({ suppressAuth: true });
            cachedItems = cached.items;
        }

        if (cachedItems.length > 0) {
            console.log('[WeighStation] Cache hit');
            const items = cachedItems[0].data;

            // Enrich with bypass probability
            const enriched = items.map(station => ({
                ...station,
                bypass_probability: calculateBypassProbability(station, options.bypassServices)
            }));

            return { success: true, items: enriched, fromCache: true };
        }

        // 2. Query local database
        const dbStations = await queryLocalDatabase(lat, lng, radius, options);

        // 3. Try to get real-time status from 511 APIs
        let liveData = [];
        if (!options.state || ['FL', 'TX', 'CO', 'NV', 'GA'].includes(options.state.toUpperCase())) {
            liveData = await queryAllState511APIs();
        }

        // 4. Merge live data with database (prefer live data)
        const mergedStations = mergeStationData(dbStations, liveData);

        // 5. Calculate distance and filter by radius
        const stationsWithDistance = mergedStations.map(station => {
            const stationLat = station.location?.lat;
            const stationLng = station.location?.lng;
            const distance = calculateDistance(lat, lng, stationLat, stationLng);
            return { ...station, distance_miles: Math.round(distance * 10) / 10 };
        }).filter(station => station.distance_miles <= radius);

        // 6. Sort by distance
        stationsWithDistance.sort((a, b) => a.distance_miles - b.distance_miles);

        // 7. Enrich with recent reports
        const enrichedStations = await Promise.all(
            stationsWithDistance.slice(0, 50).map(async (station) => {
                const reports = await getRecentReports(station._id || station.external_id);
                const reportData = aggregateReports(reports);

                // Use reported status if no sensor data
                if (!station.status || station.status === 'unknown') {
                    station.status = reportData.status || 'unknown';
                    station.status_confidence = reportData.status ? 'reported' : 'unknown';
                }

                return {
                    ...station,
                    wait_estimate: reportData.wait_estimate,
                    report_count: reportData.report_count,
                    bypass_probability: calculateBypassProbability(station, options.bypassServices)
                };
            })
        );

        // 8. Cache results (10-minute TTL) using dual-source routing
        const expiry = new Date();
        expiry.setMinutes(expiry.getMinutes() + 10);

        const cacheRecord = {
            cache_key: cacheKey,
            cache_type: 'weighstation',
            data: enrichedStations,
            expires_at: expiry
        };

        await insertData(COLLECTION_KEYS.roadUtilityCache, COLLECTIONS.CACHE, cacheRecord)
            .catch(err => console.error('[WeighStation] Cache insert failed:', err));

        return { success: true, items: enrichedStations };
    } catch (error) {
        console.error('[WeighStation] searchWeighStations failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Merge database stations with live API data
 * Prioritizes live data for status updates
 */
function mergeStationData(dbStations, liveStations) {
    const merged = new Map();

    // Add database stations first
    dbStations.forEach(station => {
        const key = station.external_id || `${station.state}_${station.highway}_${station.direction}`;
        merged.set(key, station);
    });

    // Overlay live data (updates status and timestamps)
    liveStations.forEach(station => {
        const key = station.external_id;
        if (merged.has(key)) {
            const existing = merged.get(key);
            merged.set(key, {
                ...existing,
                status: station.status,
                status_confidence: station.status_confidence,
                last_status_update: station.last_status_update
            });
        } else {
            merged.set(key, station);
        }
    });

    return Array.from(merged.values());
}

/**
 * Get weigh stations along a route
 * @param {Array} routePoints - Array of {lat, lng} waypoints
 * @param {Object} options - Search options
 */
export async function getWeighStationsAlongRoute(routePoints, options = {}) {
    if (!Array.isArray(routePoints) || routePoints.length < 2) {
        return { success: false, error: 'Invalid route points' };
    }

    try {
        const allStations = [];
        const seenIds = new Set();
        const corridorRadius = options.corridorRadius || 15; // miles from route

        // Check stations near each waypoint
        for (const point of routePoints) {
            const result = await searchWeighStations(point.lat, point.lng, corridorRadius, options);
            if (result.success) {
                for (const station of result.items) {
                    const id = station._id || station.external_id;
                    if (!seenIds.has(id)) {
                        allStations.push(station);
                        seenIds.add(id);
                    }
                }
            }
        }

        // Sort by position along route (simplified: by first waypoint distance)
        return { success: true, items: allStations };
    } catch (error) {
        console.error('[WeighStation] getWeighStationsAlongRoute failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get detailed status for a specific station
 * @param {string} stationId - Station ID
 */
export async function getStationStatus(stationId) {
    if (!stationId) {
        return { success: false, error: 'Station ID is required' };
    }

    try {
        // Use dual-source routing
        const station = await getRecord(COLLECTION_KEYS.weighStations, COLLECTIONS.STATIONS, stationId);
        if (!station) {
            return { success: false, error: 'Station not found' };
        }

        // Normalize field names from Airtable
        const normalizedStation = {
            _id: station._id || station.id,
            external_id: station.external_id || station['External Id'],
            name: station.name || station.Name,
            state: station.state || station.State,
            highway: station.highway || station.Highway,
            direction: station.direction || station.Direction,
            location: station.location || station.Location,
            status: station.status || station.Status,
            prepass_enabled: station.prepass_enabled || station['Prepass Enabled'],
            drivewyze_enabled: station.drivewyze_enabled || station['Drivewyze Enabled']
        };

        // Get recent reports
        const reports = await getRecentReports(stationId);
        const reportData = aggregateReports(reports);

        return {
            success: true,
            station: {
                ...normalizedStation,
                wait_estimate: reportData.wait_estimate,
                report_count: reportData.report_count,
                recent_reports: reports.slice(0, 5)
            }
        };
    } catch (error) {
        console.error('[WeighStation] getStationStatus failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Submit a driver report for a station
 * @param {string} stationId - Station ID
 * @param {Object} report - Report data (driver_id, report_type, wait_minutes, notes)
 */
export async function reportStationStatus(stationId, report) {
    if (!stationId) {
        return { success: false, error: 'Station ID is required' };
    }
    if (!report.driver_id) {
        return { success: false, error: 'Driver ID is required' };
    }
    if (!report.report_type || !['open', 'closed', 'long_wait', 'quick', 'scales_only'].includes(report.report_type)) {
        return { success: false, error: 'Invalid report type' };
    }

    try {
        // Rate limiting: 1 report per station per hour per driver using dual-source routing
        const oneHourAgo = new Date(Date.now() - 3600000);
        let recentReportCount = 0;

        if (usesAirtable(COLLECTION_KEYS.weighStationReports)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.weighStationReports);
            const filter = `AND({Station Id} = "${stationId}", {Driver Id} = "${report.driver_id}", {Reported At} > "${oneHourAgo.toISOString()}")`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                maxRecords: 1
            });
            recentReportCount = (result.records || []).length;
        } else {
            const recentReports = await wixData.query(COLLECTIONS.REPORTS)
                .eq('station_id', stationId)
                .eq('driver_id', report.driver_id)
                .gt('reported_at', oneHourAgo)
                .limit(1)
                .find({ suppressAuth: true });
            recentReportCount = recentReports.items.length;
        }

        if (recentReportCount > 0) {
            return { success: false, error: 'You have already reported for this station in the last hour' };
        }

        // Create report record
        const reportRecord = {
            station_id: stationId,
            driver_id: report.driver_id,
            report_type: report.report_type,
            wait_minutes: report.wait_minutes || null,
            notes: report.notes || '',
            reported_at: new Date(),
            driver_location: report.driver_location || null,
            expires_at: new Date(Date.now() + 4 * 3600000) // 4 hour TTL
        };

        // Use dual-source routing for insert
        const result = await insertData(COLLECTION_KEYS.weighStationReports, COLLECTIONS.REPORTS, reportRecord);

        // Update station's last_report_update timestamp using dual-source routing
        await updateData(COLLECTION_KEYS.weighStations, COLLECTIONS.STATIONS, {
            _id: stationId,
            last_report_update: new Date()
        }).catch(err => console.warn('[WeighStation] Failed to update station timestamp:', err));

        // Invalidate cache for this area
        invalidateCache(stationId).catch(err => console.warn('[WeighStation] Cache invalidation failed:', err));

        return { success: true, reportId: result._id || result.id };
    } catch (error) {
        console.error('[WeighStation] reportStationStatus failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Invalidate cache entries related to a station
 */
async function invalidateCache(stationId) {
    // Get station to find its location using dual-source routing
    const station = await getRecord(COLLECTION_KEYS.weighStations, COLLECTIONS.STATIONS, stationId).catch(() => null);
    if (!station) return;

    // Delete cache entries that might include this station using dual-source routing
    // Simple approach: delete all weighstation caches (they're short-lived anyway)
    if (usesAirtable(COLLECTION_KEYS.roadUtilityCache)) {
        const tableName = getAirtableTableName(COLLECTION_KEYS.roadUtilityCache);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: `{Cache Type} = "weighstation"`,
            maxRecords: 100
        });
        for (const cache of (result.records || [])) {
            await airtable.deleteRecord(tableName, cache.id || cache._id).catch(() => {});
        }
    } else {
        const caches = await wixData.query(COLLECTIONS.CACHE)
            .eq('cache_type', 'weighstation')
            .find({ suppressAuth: true });

        for (const cache of caches.items) {
            await wixData.remove(COLLECTIONS.CACHE, cache._id, { suppressAuth: true }).catch(() => {});
        }
    }
}

/**
 * Get weigh stations by state
 * @param {string} state - 2-letter state code
 */
export async function getStationsByState(state) {
    if (!state || state.length !== 2) {
        return { success: false, error: 'Invalid state code' };
    }

    try {
        let resultItems = [];

        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.weighStations)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.weighStations);
            const filter = `{State} = "${state.toUpperCase()}"`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                sort: [{ field: 'Highway', direction: 'asc' }, { field: 'Direction', direction: 'asc' }],
                maxRecords: 100
            });
            resultItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                external_id: r['External Id'] || r.external_id,
                name: r.Name || r.name,
                state: r.State || r.state,
                highway: r.Highway || r.highway,
                direction: r.Direction || r.direction,
                location: r.Location || r.location,
                status: r.Status || r.status,
                prepass_enabled: r['Prepass Enabled'] || r.prepass_enabled,
                drivewyze_enabled: r['Drivewyze Enabled'] || r.drivewyze_enabled
            }));
        } else {
            const result = await wixData.query(COLLECTIONS.STATIONS)
                .eq('state', state.toUpperCase())
                .ascending('highway')
                .ascending('direction')
                .limit(100)
                .find({ suppressAuth: true });
            resultItems = result.items;
        }

        return { success: true, items: resultItems };
    } catch (error) {
        console.error('[WeighStation] getStationsByState failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get driver's saved bypass service preferences
 * @param {string} driverId - Driver user ID
 */
export async function getDriverBypassServices(driverId) {
    if (!driverId) {
        return { success: true, services: { prepass: false, drivewyze: false } };
    }

    try {
        let resultItems = [];

        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.driverBypassServices)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.driverBypassServices);
            const filter = `{Driver Id} = "${driverId}"`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                maxRecords: 1
            });
            resultItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                driver_id: r['Driver Id'] || r.driver_id,
                prepass: r.Prepass !== undefined ? r.Prepass : (r.prepass || false),
                drivewyze: r.Drivewyze !== undefined ? r.Drivewyze : (r.drivewyze || false)
            }));
        } else {
            const result = await wixData.query(COLLECTIONS.DRIVER_PREFS)
                .eq('driver_id', driverId)
                .limit(1)
                .find({ suppressAuth: true });
            resultItems = result.items;
        }

        if (resultItems.length > 0) {
            return {
                success: true,
                services: {
                    prepass: resultItems[0].prepass || false,
                    drivewyze: resultItems[0].drivewyze || false
                }
            };
        }

        return { success: true, services: { prepass: false, drivewyze: false } };
    } catch (error) {
        console.error('[WeighStation] getDriverBypassServices failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Save driver's bypass service preferences
 * @param {string} driverId - Driver user ID
 * @param {Object} services - { prepass: boolean, drivewyze: boolean }
 */
export async function saveDriverBypassServices(driverId, services) {
    if (!driverId) {
        return { success: false, error: 'Driver ID is required' };
    }

    try {
        // Check if record exists using dual-source routing
        let existingRecord = null;

        if (usesAirtable(COLLECTION_KEYS.driverBypassServices)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.driverBypassServices);
            const filter = `{Driver Id} = "${driverId}"`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                existingRecord = { _id: result.records[0].id || result.records[0]._id };
            }
        } else {
            const existing = await wixData.query(COLLECTIONS.DRIVER_PREFS)
                .eq('driver_id', driverId)
                .limit(1)
                .find({ suppressAuth: true });
            if (existing.items.length > 0) {
                existingRecord = { _id: existing.items[0]._id };
            }
        }

        const record = {
            driver_id: driverId,
            prepass: services.prepass || false,
            drivewyze: services.drivewyze || false,
            updated_at: new Date()
        };

        if (existingRecord) {
            record._id = existingRecord._id;
            await updateData(COLLECTION_KEYS.driverBypassServices, COLLECTIONS.DRIVER_PREFS, record);
        } else {
            await insertData(COLLECTION_KEYS.driverBypassServices, COLLECTIONS.DRIVER_PREFS, record);
        }

        return { success: true };
    } catch (error) {
        console.error('[WeighStation] saveDriverBypassServices failed:', error);
        return { success: false, error: error.message };
    }
}

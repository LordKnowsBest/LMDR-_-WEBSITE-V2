import * as dataAccess from 'backend/dataAccess';
import { getResponseTimeBadgeForStats } from 'backend/badgeService';

/**
 * Get responsiveness stats for a specific carrier
 */
export async function getRecruiterStats(dotNumber) {
    try {
        const dotString = String(dotNumber);

        const result = await dataAccess.queryRecords('driverCarrierInterests', {
            filters: {
                carrier_dot: dotString,
                recruiter_response_time: { ne: null }
            },
            limit: 1000,
            suppressAuth: true
        });

        const interactions = result.items || [];

        if (interactions.length === 0) {
            return {
                dot_number: dotString,
                avg_response_hours: null,
                total_interactions: 0,
                badge: null
            };
        }

        const totalHours = interactions.reduce((sum, item) => sum + (item.recruiter_response_time || 0), 0);
        const avg = totalHours / interactions.length;

        // Use centralized badge calculation from badgeService for consistency
        const badgeInfo = getResponseTimeBadgeForStats(avg);

        return {
            dot_number: dotString,
            avg_response_hours: Math.round(avg * 10) / 10,
            total_interactions: interactions.length,
            badge: badgeInfo.badge,
            badge_color: badgeInfo.badge_color
        };
    } catch (error) {
        console.error(`❌ Error calculating recruiter stats for ${dotNumber}:`, error.message);
        return {
            dot_number: String(dotNumber),
            error: error.message
        };
    }
}

/**
 * Batch get responsiveness stats for multiple carriers in a single query
 * @param {Array<string|number>} dotNumbers - Array of DOT numbers
 * @returns {Object} Map of dotNumber → stats object
 */
export async function getRecruiterStatsBatch(dotNumbers) {
    if (!dotNumbers || dotNumbers.length === 0) return {};

    try {
        const dotStrings = dotNumbers.map(d => String(d));

        const result = await dataAccess.queryRecords('driverCarrierInterests', {
            filters: {
                carrier_dot: { hasSome: dotStrings },
                recruiter_response_time: { ne: null }
            },
            limit: 1000,
            suppressAuth: true
        });

        const interactions = result.items || [];

        // Group by carrier_dot
        const grouped = {};
        for (const item of interactions) {
            const dot = item.carrier_dot;
            if (!grouped[dot]) grouped[dot] = [];
            grouped[dot].push(item.recruiter_response_time || 0);
        }

        // Compute stats per carrier
        const statsMap = {};
        for (const dot of dotStrings) {
            const times = grouped[dot];
            if (!times || times.length === 0) {
                statsMap[dot] = {
                    dot_number: dot,
                    avg_response_hours: null,
                    total_interactions: 0,
                    badge: null
                };
                continue;
            }
            const avg = times.reduce((s, t) => s + t, 0) / times.length;
            const badgeInfo = getResponseTimeBadgeForStats(avg);
            statsMap[dot] = {
                dot_number: dot,
                avg_response_hours: Math.round(avg * 10) / 10,
                total_interactions: times.length,
                badge: badgeInfo.badge,
                badge_color: badgeInfo.badge_color
            };
        }

        return statsMap;
    } catch (error) {
        console.error('❌ Error batch calculating recruiter stats:', error.message);
        return {};
    }
}

/**
 * Match Explanation Service
 *
 * Provides transparent explanations to drivers about why they matched with specific carriers.
 * "Why You Matched" - Inverts the recruiter rationale to show value to the driver.
 *
 * @module backend/matchExplanationService
 */

import { calculateDriverMatchScore } from 'backend/driverScoring';
import { getDriverProfile } from 'backend/driverProfiles';
import { currentUser } from 'wix-users-backend';
import { startTrace, endTrace, log } from 'backend/observabilityService';
import * as dataAccess from 'backend/dataAccess';
import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';

// ============================================================================
// PUBLIC API
// ============================================================================

/**
 * Get detailed match explanation for a specific driver and carrier
 *
 * @param {string} driverId - The driver's ID
 * @param {string} carrierDot - The carrier's DOT number
 * @returns {Promise<Object>} Explanation object with rationale and tips
 */
export async function getMatchExplanationForDriver(driverId, carrierDot) {
    const traceId = startTrace('getMatchExplanationForDriver');
    
    try {
        // 1. Authorization Check
        if (currentUser.id !== driverId) {
             // console.warn('Auth mismatch in match explanation');
        }

        // 2. Fetch Driver Profile
        const driverProfile = await getDriverProfile(driverId);
        if (!driverProfile) {
            throw new Error('Driver profile not found');
        }

        // 3. Fetch Carrier Preferences using dataAccess
        let result = await dataAccess.queryRecords('carrierHiringPreferences', {
            filters: {
                carrier_dot: String(carrierDot),
                is_active: true
            },
            limit: 1,
            suppressAuth: true
        });

        // Backward-compatible fallback for test/legacy records without is_active.
        if (!result.items?.length) {
            result = await dataAccess.queryRecords('carrierHiringPreferences', {
                filters: {
                    carrier_dot: String(carrierDot)
                },
                limit: 1,
                suppressAuth: true
            });
        }

        const prefs = result.items?.[0];
        
        if (!prefs) {
            return {
                success: false,
                error: 'Carrier hiring preferences not found',
                explanation: getDefaultExplanation()
            };
        }

        // 4. Calculate Score & Rationale
        const scoreResult = calculateDriverMatchScore(driverProfile, prefs);

        // 5. Generate Driver-Facing Explanations
        const explanation = generateDriverFriendlyExplanation(scoreResult, driverProfile, prefs);

        // 6. Fetch cached AI enrichment for the carrier (if available)
        let cachedEnrichment = null;
        try {
            const enrichResult = await dataAccess.queryRecords('carrierEnrichments', {
                filters: { dot_number: String(carrierDot) },
                limit: 1,
                suppressAuth: true
            });
            cachedEnrichment = enrichResult.items?.[0] || null;
        } catch (enrichErr) {
            // Non-blocking — proceed without enrichment
        }

        // 7. Generate LLM narrative via Groq (3s timeout, falls back gracefully)
        try {
            const llmNarrative = await generateLLMNarrative(driverProfile, prefs, scoreResult, cachedEnrichment, carrierDot);
            if (llmNarrative) {
                explanation.llm_narrative = llmNarrative;
            }
        } catch (llmErr) {
            // Non-blocking — explanation still works without narrative
            log('warn', 'LLM narrative generation failed (non-blocking)', { carrierDot, error: llmErr.message });
        }

        endTrace(traceId);
        return {
            success: true,
            carrierDot,
            overallScore: scoreResult.overallScore,
            explanation
        };

    } catch (error) {
        log('error', 'Failed to generate match explanation', { driverId, carrierDot, error: error.message });
        endTrace(traceId, { error: error.message });
        return {
            success: false,
            error: error.message,
            explanation: getDefaultExplanation()
        };
    }
}

// ============================================================================
// LLM NARRATIVE GENERATION
// ============================================================================

async function generateLLMNarrative(driver, prefs, scoreResult, enrichment, carrierDot) {
    const groqApiKey = await getSecret('GROQ_API_KEY');
    if (!groqApiKey) return null;

    const driverName = driver.display_name || driver.first_name || 'You';
    const carrierName = prefs.carrier_name || prefs.company_name || `Carrier DOT ${carrierDot}`;
    const city = prefs.phy_city || prefs.city || '';
    const state = prefs.phy_state || prefs.state || '';
    const fleetSize = prefs.fleet_size || prefs.nbr_power_unit || 'N/A';
    const operationType = prefs.operation_type || prefs.carrier_operation || 'N/A';

    // Score context
    const overallScore = Math.round(scoreResult.overallScore || 0);
    const scores = scoreResult.scores || {};
    const scoreLines = Object.entries(scores)
        .map(([k, v]) => `  - ${k}: ${Math.round(v)}%`)
        .join('\n');

    // FMCSA / safety context
    const safetyRating = prefs.safety_rating || 'Not Rated';
    const driverOos = prefs.driver_oos_rate != null ? `${prefs.driver_oos_rate}%` : 'N/A';
    const vehicleOos = prefs.vehicle_oos_rate != null ? `${prefs.vehicle_oos_rate}%` : 'N/A';
    const crashes = prefs.total_crashes != null ? prefs.total_crashes : 'N/A';

    // AI enrichment context
    let enrichmentSection = '';
    if (enrichment) {
        const pros = enrichment.sentiment_pros || enrichment.pros || '';
        const cons = enrichment.sentiment_cons || enrichment.cons || '';
        const pay = enrichment.pay_cpm_range || '';
        const sentiment = enrichment.driver_sentiment || '';
        const opportunity = enrichment.hiring_opportunity || '';
        const summary = enrichment.ai_summary || '';
        enrichmentSection = `
AI Enrichment (from web research):
  - Driver Sentiment: ${sentiment}
  - Pay Range (CPM): ${pay}
  - Hiring Opportunity: ${opportunity}
  - Pros: ${pros}
  - Cons: ${cons}
  - Summary: ${summary}`;
    }

    const prompt = `You are an AI assistant helping a CDL truck driver understand why a specific carrier is a great match for them.

Driver Profile:
  - Name: ${driverName}
  - CDL Class: ${driver.cdl_class || 'N/A'}
  - Years Experience: ${driver.years_experience || 'N/A'}
  - Home Zip: ${driver.home_zip || driver.zip_code || 'N/A'}
  - Preferred Operation: ${driver.operation_type || driver.preferred_operation || 'N/A'}
  - Min CPM: ${driver.min_cpm || 'N/A'}
  - Max Acceptable Turnover: ${driver.max_turnover || 'N/A'}%

Carrier: ${carrierName}
  - Location: ${city}, ${state}
  - Fleet Size: ${fleetSize} trucks
  - Operation Type: ${operationType}
  - Safety Rating: ${safetyRating}
  - Driver OOS Rate: ${driverOos} (national avg: 5.51%)
  - Vehicle OOS Rate: ${vehicleOos} (national avg: 20.72%)
  - Total Crashes (24mo): ${crashes}
${enrichmentSection}

Match Scores (overall: ${overallScore}%):
${scoreLines}

Write a 4-6 sentence "Why This Job" narrative addressed directly to ${driverName}.
Requirements:
1. Start with the driver's name or "You" personally
2. Mention 2-3 specific data points (safety rating, pay range, fleet size, sentiment highlights)
3. Explain WHY this specific carrier matches this specific driver based on their preferences
4. End with an encouraging call-to-action
5. Keep it conversational, warm, and specific — not generic
6. Do NOT use bullet points — write in flowing prose paragraphs`;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);

    try {
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${groqApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'llama-3.3-70b-versatile',
                messages: [
                    { role: 'system', content: 'You are an expert career coach for CDL truck drivers. Be specific, warm, and data-driven.' },
                    { role: 'user', content: prompt }
                ],
                max_tokens: 300,
                temperature: 0.7,
            }),
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errText = await response.text();
            log('warn', 'Groq API error in match explanation', { status: response.status, body: errText });
            return null;
        }

        const json = await response.json();
        const narrative = json.choices?.[0]?.message?.content?.trim();
        return narrative || null;
    } catch (fetchErr) {
        clearTimeout(timeoutId);
        if (fetchErr.name === 'AbortError') {
            log('warn', 'Groq LLM narrative timed out after 3s', { carrierDot });
        } else {
            log('warn', 'Groq fetch error in match explanation', { error: fetchErr.message, carrierDot });
        }
        return null;
    }
}

function generateDriverFriendlyExplanation(scoreResult, driver, prefs) {
    const { scores, weights } = scoreResult;
    
    // Categories to explain
    const categories = [
        { key: 'qualifications', label: 'Qualifications' },
        { key: 'experience', label: 'Experience' },
        { key: 'location', label: 'Location' },
        { key: 'availability', label: 'Availability' },
        { key: 'salaryFit', label: 'Pay Match' }
    ];

    const categoryDetails = categories.map(cat => {
        const score = scores[cat.key] || 0;
        const weight = weights[cat.key] || 0;
        const fitParams = { driver, prefs, score };
        
        return {
            key: cat.key,
            label: cat.label,
            score,
            weight,
            text: getCategoryText(cat.key, fitParams),
            status: getStatusFromScore(score)
        };
    });

    // Generate overall Tip
    const tip = generateMatchTip(scoreResult, prefs, driver);

    return {
        summary: `You are a ${getMatchStrengthLabel(scoreResult.overallScore)} match for their requirements.`,
        categories: categoryDetails,
        tip
    };
}

function getStatusFromScore(score) {
    if (score >= 90) return 'perfect';
    if (score >= 70) return 'good';
    if (score >= 50) return 'average';
    return 'gap';
}

function getMatchStrengthLabel(score) {
    if (score >= 90) return 'Strong';
    if (score >= 75) return 'Good';
    if (score >= 60) return 'Potential';
    return 'Partial';
}

function getCategoryText(key, { driver, prefs, score }) {
    if (score >= 90) {
        switch (key) {
            case 'qualifications': return `You match all required CDL types and endorsements (Class ${driver.cdl_class})`;
            case 'experience': return `Your ${driver.years_experience} years experience meets their requirements`;
            case 'location': return `You live within their priority hiring zone`;
            case 'availability': return `Your start date matches their urgency`;
            case 'salaryFit': return `Your pay expectations align with their offer`;
        }
    } else if (score >= 50) {
        switch (key) {
            case 'qualifications': return `You have the CDL class but may miss an endorsement`;
            case 'experience': return `You meet the minimum, but they prefer more experience`;
            case 'location': return `You are within hiring distance but outside priority zone`;
            case 'availability': return `Availability is acceptable`;
            case 'salaryFit': return `Pay is close to your expectation`;
        }
    } else {
        switch (key) {
            case 'qualifications': return `Missing required endorsements`;
            case 'experience': return `Less experience than preferred`;
            case 'location': return `Outside preferred hiring radius`;
            case 'availability': return `Start date doesn't match urgency`;
            case 'salaryFit': return `Offer may be below your expectation`;
        }
    }
    return 'Criterion evaluation';
}

function generateMatchTip(scoreResult, prefs, driver) {
    const { scores } = scoreResult;
    
    if (scores.qualifications < 100) {
        const driverEndorsements = driver?.endorsements || [];
        const missing = prefs.required_endorsements?.filter(e => !driverEndorsements.includes(e));
        if (missing && missing.length > 0) {
            return `Tip: Getting your ${missing[0]} endorsement would make you a perfect fit.`;
        }
    }
    
    if (scores.experience < 100 && scores.experience > 50) {
        return `Tip: Highlight your specific equipment experience in your bio.`;
    }
    
    return `Tip: Keep your profile updated to maintain this match score.`;
}

function getDefaultExplanation() {
    return {
        summary: "We calculated this match based on your profile.",
        categories: [],
        tip: "Complete your profile to see more details."
    };
}

import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    adminUsers: 'adminUsers',
    auditLog: 'auditLog',
    reviews: 'carrierReviews',
    jobs: 'jobPostings',
    driverProfiles: 'driverProfiles'
};

// ============================================================================
// HELPER: Admin Authorization
// ============================================================================

async function requireAdmin() {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) throw new Error('Unauthorized');

    const email = await currentUser.getEmail();
    // AdminUsers is pinned to Wix in configData
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.adminUsers, {
        filters: { email, status: 'active' }, limit: 1, suppressAuth: true
    });

    if (!result.items?.length) throw new Error('Forbidden');
    return result.items[0];
}

async function logModerationAction(action, targetType, targetId, details) {
    try {
        const admin = await requireAdmin();
        await dataAccess.insertRecord(COLLECTION_KEYS.auditLog, {
            timestamp: new Date(), adminId: admin._id, adminEmail: admin.email,
            action, targetType, targetId, details: details || {}
        }, { suppressAuth: true });
    } catch (error) { }
}

// ============================================================================
// MODERATION QUEUE
// ============================================================================

export async function getModerationQueue(filters = {}) {
    await requireAdmin();
    const queue = [];
    const type = filters.type || 'all';

    try {
        if (type === 'all' || type === 'reviews') {
            const res = await dataAccess.queryRecords(COLLECTION_KEYS.reviews, { filters: { status: 'pending' }, limit: 50, suppressAuth: true });
            (res.items || []).forEach(item => queue.push({ id: item._id, type: 'review', title: `Review for ${item.carrier_name || 'Carrier'}`, subtitle: `By ${item.reviewer_name || 'Anonymous'}`, status: 'pending', timestamp: item._createdDate, data: item }));
        }

        if (type === 'all' || type === 'jobs') {
            const res = await dataAccess.queryRecords(COLLECTION_KEYS.jobs, { filters: { status: 'pending' }, limit: 50, suppressAuth: true });
            (res.items || []).forEach(item => queue.push({ id: item._id, type: 'job', title: item.title, subtitle: item.carrier_name, status: 'pending', timestamp: item._createdDate, data: item }));
        }

        if (type === 'all' || type === 'documents') {
            const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, { filters: { profile_status: 'active' }, sort: [{ field: 'updated_date', direction: 'desc' }], limit: 50, suppressAuth: true });
            (res.items || []).forEach(p => {
                if (p.cdl_front_image && (!p.cdl_front_status || p.cdl_front_status === 'pending')) queue.push({ id: p._id, type: 'document', subtype: 'cdl_front', title: 'CDL Front', subtitle: p.display_name, status: 'pending', timestamp: p.updated_date, data: p.cdl_front_image });
                if (p.cdl_back_image && (!p.cdl_back_status || p.cdl_back_status === 'pending')) queue.push({ id: p._id, type: 'document', subtype: 'cdl_back', title: 'CDL Back', subtitle: p.display_name, status: 'pending', timestamp: p.updated_date, data: p.cdl_back_image });
            });
        }

        queue.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        return { items: queue, total: queue.length };
    } catch (error) { throw new Error('Failed to fetch moderation queue'); }
}

export async function updateReviewStatus(reviewId, status, reason = '') {
    await requireAdmin();
    const review = await dataAccess.getRecord(COLLECTION_KEYS.reviews, reviewId, { suppressAuth: true });
    if (!review) throw new Error('Not found');
    await dataAccess.updateRecord(COLLECTION_KEYS.reviews, { ...review, status, moderation_reason: reason, moderated_at: new Date() }, { suppressAuth: true });
    await logModerationAction('updateReview', 'review', reviewId, { status, reason });
    return { success: true };
}

export async function updateJobStatus(jobId, status) {
    await requireAdmin();
    const job = await dataAccess.getRecord(COLLECTION_KEYS.jobs, jobId, { suppressAuth: true });
    if (!job) throw new Error('Not found');
    await dataAccess.updateRecord(COLLECTION_KEYS.jobs, { ...job, status, moderated_at: new Date() }, { suppressAuth: true });
    await logModerationAction('updateJob', 'job', jobId, { status });
    return { success: true };
}

export async function updateDocumentStatus(driverId, docType, status, reason = '') {
    await requireAdmin();
    const profile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, driverId, { suppressAuth: true });
    if (!profile) throw new Error('Not found');
    const update = { ...profile, _id: driverId, [`${docType}_status`]: status, [`${docType}_rejection_reason`]: status === 'rejected' ? reason : null };
    await dataAccess.updateRecord(COLLECTION_KEYS.driverProfiles, update, { suppressAuth: true });
    await logModerationAction('updateDocument', 'driver_document', driverId, { docType, status, reason });
    return { success: true };
}

export async function getModerationStats() {
    await requireAdmin();
    try {
        const [reviewsRes, jobsRes] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.reviews, { status: 'pending' }),
            dataAccess.countRecords(COLLECTION_KEYS.jobs, { status: 'pending' })
        ]);
        return { pendingReviews: reviewsRes, pendingJobs: jobsRes, totalPending: reviewsRes + jobsRes };
    } catch (error) { return { totalPending: 0 }; }
}


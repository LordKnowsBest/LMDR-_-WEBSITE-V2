import { v4 as uuidv4 } from 'uuid';
import * as dataAccess from 'backend/dataAccess';
import * as emailService from 'backend/emailService';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    documentRequests: 'documentRequests',
    onboardingWorkflows: 'onboardingWorkflows',
    driverProfiles: 'driverProfiles'
};

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
    // Document types enum
    documentTypes: {
        CDL_FRONT: 'cdl_front',
        CDL_BACK: 'cdl_back',
        MVR: 'mvr',
        PSP: 'psp',
        MEDICAL_CARD: 'medical_card',
        DRUG_TEST_CONSENT: 'drug_test_consent',
        EMPLOYMENT_APP: 'employment_app',
        W4: 'w4',
        I9: 'i9',
        DIRECT_DEPOSIT: 'direct_deposit',
        SOCIAL_SECURITY: 'social_security',
        EMPLOYMENT_HISTORY: 'employment_history',
        PROOF_OF_ADDRESS: 'proof_of_address',
        CUSTOM: 'custom'
    },

    // Document status enum
    status: {
        REQUESTED: 'requested',
        UPLOADED: 'uploaded',
        VERIFIED: 'verified',
        REJECTED: 'rejected'
    },

    // File validation
    allowedMimeTypes: ['application/pdf', 'image/jpeg', 'image/png'],
    maxFileSizeBytes: 10 * 1024 * 1024, // 10MB

    // Token settings
    tokenExpiryHours: 48,

    // Reminder sequence (days after initial request)
    reminderSequence: [2, 5, 7],

    // Expiration warning threshold (days)
    expirationWarningDays: 30,

    // Documents that have expiration dates
    expiringDocTypes: ['cdl_front', 'cdl_back', 'medical_card'],

    // Required documents (block completion if missing)
    requiredDocTypes: ['cdl_front', 'cdl_back', 'mvr', 'medical_card']
};

// ============================================================================
// DOCUMENT TYPE METADATA
// ============================================================================

const DOCUMENT_METADATA = {
    cdl_front: { displayName: 'CDL Front', description: 'Please upload a clear photo of the front of your CDL', isRequired: true, hasExpiration: true },
    cdl_back: { displayName: 'CDL Back', description: 'Please upload a clear photo of the back of your CDL', isRequired: true, hasExpiration: true },
    mvr: { displayName: 'Motor Vehicle Record (MVR)', description: 'Request your Motor Vehicle Record from your state DMV', isRequired: true, hasExpiration: false },
    psp: { displayName: 'Pre-Employment Screening Program (PSP)', description: 'Request your PSP report from psp.fmcsa.dot.gov', isRequired: false, hasExpiration: false },
    medical_card: { displayName: 'DOT Medical Card', description: 'Upload your current DOT Medical Card', isRequired: true, hasExpiration: true },
    drug_test_consent: { displayName: 'Drug Test Consent Form', description: 'Sign and upload the drug test consent form', isRequired: false, hasExpiration: false },
    employment_app: { displayName: 'Employment Application', description: 'Complete and upload the employment application', isRequired: false, hasExpiration: false },
    w4: { displayName: 'W-4 Tax Form', description: 'Complete and upload your W-4 tax form', isRequired: false, hasExpiration: false },
    i9: { displayName: 'I-9 Employment Eligibility', description: 'Complete and upload your I-9 Employment Eligibility form', isRequired: false, hasExpiration: false },
    direct_deposit: { displayName: 'Direct Deposit Authorization', description: 'Upload direct deposit authorization', isRequired: false, hasExpiration: false },
    social_security: { displayName: 'Social Security Card', description: 'Upload a copy of your Social Security Card', isRequired: false, hasExpiration: false },
    employment_history: { displayName: 'Employment History (10 years)', description: 'Provide your employment history for the last 10 years', isRequired: false, hasExpiration: false },
    proof_of_address: { displayName: 'Proof of Address', description: 'Upload a utility bill or bank statement', isRequired: false, hasExpiration: false },
    custom: { displayName: 'Custom Document', description: 'Please upload the requested document', isRequired: false, hasExpiration: false }
};

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function generateUploadToken(expiryHours = CONFIG.tokenExpiryHours) {
    const token = `tok_${Date.now()}_${uuidv4().replace(/-/g, '')}`;
    const expiry = new Date();
    expiry.setHours(expiry.getHours() + expiryHours);
    return { token, expiry: expiry.toISOString() };
}

function isTokenValid(tokenExpiry) {
    return tokenExpiry ? new Date(tokenExpiry) > new Date() : false;
}

function isValidFileType(mimeType) {
    return CONFIG.allowedMimeTypes.includes(mimeType);
}

function isValidFileSize(sizeBytes) {
    return sizeBytes > 0 && sizeBytes <= CONFIG.maxFileSizeBytes;
}

function getDocumentMetadata(docType) {
    return DOCUMENT_METADATA[docType] || DOCUMENT_METADATA.custom;
}

function generateFileHash(data) {
    return `sha256_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;
}

// ============================================================================
// REQUEST DOCUMENTS
// ============================================================================

export async function requestDocuments(workflowId, documentTypes) {
    if (!workflowId || !Array.isArray(documentTypes) || documentTypes.length === 0) return { success: false, error: 'Missing required fields' };

    const validTypes = Object.values(CONFIG.documentTypes);
    for (const docType of documentTypes) if (!validTypes.includes(docType)) return { success: false, error: `Invalid document type: ${docType}` };

    try {
        const workflow = await dataAccess.getRecord(COLLECTION_KEYS.onboardingWorkflows, workflowId, { suppressAuth: true });
        if (!workflow) return { success: false, error: 'Workflow not found' };

        const now = new Date();
        const requestIds = [];
        const { token, expiry } = generateUploadToken();

        for (const docType of documentTypes) {
            const metadata = getDocumentMetadata(docType);
            const docRequest = {
                workflow_id: workflowId, driver_id: workflow.driver_id, document_type: docType,
                display_name: metadata.displayName, description: metadata.description,
                is_required: CONFIG.requiredDocTypes.includes(docType), status: CONFIG.status.REQUESTED,
                upload_token: token, upload_token_expiry: expiry, _createdDate: now, _updatedDate: now
            };
            const inserted = await dataAccess.insertRecord(COLLECTION_KEYS.documentRequests, docRequest, { suppressAuth: true });
            if (inserted.success) requestIds.push(inserted.record._id);
        }

        await dataAccess.updateRecord(COLLECTION_KEYS.onboardingWorkflows, {
            ...workflow, documents_status: 'pending', status: 'documents_requested', _updatedDate: now
        }, { suppressAuth: true });

        return { success: true, requestIds, uploadPortalUrl: `https://lastmilecdl.com/document-upload?token=${token}`, token, tokenExpiry: expiry };
    } catch (error) {
        console.error('[DocumentCollection] Error requesting documents:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// GET DOCUMENT STATUS
// ============================================================================

export async function getDocumentStatus(workflowId) {
    if (!workflowId) return { success: false, error: 'workflowId is required' };
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, { filters: { workflow_id: workflowId }, suppressAuth: true });
        const documents = result.items || [];
        
        const summary = {
            total: documents.length,
            requested: documents.filter(d => d.status === CONFIG.status.REQUESTED).length,
            uploaded: documents.filter(d => d.status === CONFIG.status.UPLOADED).length,
            verified: documents.filter(d => d.status === CONFIG.status.VERIFIED).length,
            rejected: documents.filter(d => d.status === CONFIG.status.REJECTED).length
        };

        const requiredDocs = documents.filter(d => d.is_required);
        summary.isComplete = requiredDocs.length > 0 && requiredDocs.every(d => d.status === CONFIG.status.VERIFIED);
        summary.hasRejections = summary.rejected > 0;

        return { success: true, documents, summary };
    } catch (error) {
        console.error('[DocumentCollection] Error getting document status:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// UPLOAD DOCUMENT
// ============================================================================

export async function uploadDocument(token, documentType, fileData) {
    if (!token || !documentType || !fileData) return { success: false, error: 'Missing required fields' };
    if (!isValidFileType(fileData.mimeType)) return { success: false, error: 'Invalid file type' };
    if (!isValidFileSize(fileData.size)) return { success: false, error: 'Invalid file size' };

    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, {
            filters: { upload_token: token, document_type: documentType },
            limit: 1, suppressAuth: true
        });

        if (!result.success || result.items.length === 0) return { success: false, error: 'Invalid token or document type' };
        const docRequest = result.items[0];

        if (!isTokenValid(docRequest.upload_token_expiry)) return { success: false, error: 'Upload token has expired' };
        if (docRequest.status === CONFIG.status.VERIFIED) return { success: false, error: 'Document already verified' };

        const fileHash = generateFileHash(fileData.url || fileData.content);
        const now = new Date();
        const updatedDoc = {
            ...docRequest, status: CONFIG.status.UPLOADED, 
            file_url: fileData.url || `https://media.wix.com/v1/${fileHash}`,
            file_hash: fileHash, submitted_date: now, _updatedDate: now
        };

        await dataAccess.updateRecord(COLLECTION_KEYS.documentRequests, updatedDoc, { suppressAuth: true });
        return { success: true, documentId: docRequest._id, status: CONFIG.status.UPLOADED, verificationStatus: 'pending_review' };
    } catch (error) {
        console.error('[DocumentCollection] Error uploading document:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// VERIFY DOCUMENT
// ============================================================================

export async function verifyDocument(documentId, verifierId, status, notes = null) {
    if (!documentId || !verifierId || !status) return { success: false, error: 'Missing required fields' };
    if (status === CONFIG.status.REJECTED && !notes) return { success: false, error: 'Rejection reason required' };

    try {
        const docRequest = await dataAccess.getRecord(COLLECTION_KEYS.documentRequests, documentId, { suppressAuth: true });
        if (!docRequest) return { success: false, error: 'Document not found' };
        if (docRequest.status !== CONFIG.status.UPLOADED) return { success: false, error: 'Document not in uploaded state' };

        const now = new Date();
        const updatedDoc = { ...docRequest, status, verified_date: now, verified_by: verifierId, rejection_reason: status === CONFIG.status.REJECTED ? notes : null, _updatedDate: now };
        await dataAccess.updateRecord(COLLECTION_KEYS.documentRequests, updatedDoc, { suppressAuth: true });

        await updateWorkflowDocumentStatus(docRequest.workflow_id);
        return { success: true, documentId, status, verifiedBy: verifierId, verifiedAt: now.toISOString() };
    } catch (error) {
        console.error('[DocumentCollection] Error verifying document:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// SEND DOCUMENT REMINDER
// ============================================================================

export async function sendDocumentReminder(documentId) {
    if (!documentId) return { success: false, error: 'documentId is required' };
    try {
        const docRequest = await dataAccess.getRecord(COLLECTION_KEYS.documentRequests, documentId, { suppressAuth: true });
        if (!docRequest) return { success: false, error: 'Document not found' };
        if (![CONFIG.status.REQUESTED, CONFIG.status.REJECTED].includes(docRequest.status)) return { success: false, error: 'Invalid state for reminder' };

        const currentCount = docRequest.reminder_sent_count || 0;
        if (currentCount >= CONFIG.reminderSequence.length) return { success: false, error: 'Max reminders reached' };

        const { token, expiry } = generateUploadToken(48);
        const now = new Date();
        const updatedDoc = { ...docRequest, reminder_sent_count: currentCount + 1, last_reminder_date: now, upload_token: token, upload_token_expiry: expiry, _updatedDate: now };
        await dataAccess.updateRecord(COLLECTION_KEYS.documentRequests, updatedDoc, { suppressAuth: true });

        const driverProfile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, docRequest.driver_id, { suppressAuth: true });
        if (driverProfile?.wix_member_id) {
            await emailService.sendDocumentReminderEmail(driverProfile.wix_member_id, {
                documentName: docRequest.display_name,
                uploadUrl: `https://lastmilecdl.com/document-upload?token=${token}`,
                driverName: driverProfile.display_name || 'Driver'
            });
        }

        return { success: true, documentId, reminderNumber: currentCount + 1 };
    } catch (error) {
        console.error('[DocumentCollection] Error sending reminder:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// CHECK DOCUMENT EXPIRATION
// ============================================================================

export async function checkDocumentExpiration(documentId) {
    if (!documentId) return { success: false, error: 'documentId is required' };
    try {
        const docRequest = await dataAccess.getRecord(COLLECTION_KEYS.documentRequests, documentId, { suppressAuth: true });
        if (!docRequest) return { success: false, error: 'Document not found' };
        if (!CONFIG.expiringDocTypes.includes(docRequest.document_type)) return { success: true, hasExpiration: false };

        if (!docRequest.expiration_date) return { success: true, hasExpiration: true, message: 'Expiration not set' };

        const daysUntil = Math.ceil((new Date(docRequest.expiration_date) - new Date()) / (1000 * 60 * 60 * 24));
        const status = daysUntil < 0 ? 'expired' : (daysUntil <= CONFIG.expirationWarningDays ? 'expiring_soon' : 'valid');

        return { success: true, documentId, hasExpiration: true, status, daysUntilExpiry: Math.max(0, daysUntil) };
    } catch (error) {
        console.error('[DocumentCollection] Error checking expiration:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// GET OCR EXTRACTED DATA
// ============================================================================

export async function getDocumentOcrData(documentId) {
    if (!documentId) return { success: false, error: 'documentId is required' };
    try {
        const docRequest = await dataAccess.getRecord(COLLECTION_KEYS.documentRequests, documentId, { suppressAuth: true });
        if (!docRequest) return { success: false, error: 'Document not found' };
        return { success: true, documentId, ocrData: docRequest.ocr_data || null, hasOcrData: !!docRequest.ocr_data };
    } catch (error) {
        console.error('[DocumentCollection] Error getting OCR data:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// CHECK DRIVER DOCUMENT EXPIRATIONS
// ============================================================================

export async function checkDriverDocumentExpirations(driverId) {
    if (!driverId) return { success: false, error: 'driverId is required' };
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, {
            filters: { driver_id: driverId, status: CONFIG.status.VERIFIED, document_type: { hasSome: CONFIG.expiringDocTypes } },
            suppressAuth: true
        });
        
        const now = new Date();
        const expiring = [], expired = [];
        (result.items || []).forEach(doc => {
            if (!doc.expiration_date) return;
            const daysUntil = Math.ceil((new Date(doc.expiration_date) - now) / (1000 * 60 * 60 * 24));
            if (daysUntil < 0) expired.push({ documentId: doc._id, type: doc.document_type, name: doc.display_name, daysExpired: Math.abs(daysUntil) });
            else if (daysUntil <= CONFIG.expirationWarningDays) expiring.push({ documentId: doc._id, type: doc.document_type, name: doc.display_name, daysUntil });
        });

        return { success: true, driverId, expiredDocuments: expired, expiringDocuments: expiring, hasExpiredDocs: expired.length > 0, hasExpiringDocs: expiring.length > 0 };
    } catch (error) {
        console.error('[DocumentCollection] Error checking driver expirations:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// HELPER: UPDATE WORKFLOW DOCUMENT STATUS
// ============================================================================

async function updateWorkflowDocumentStatus(workflowId) {
    try {
        const statusResult = await getDocumentStatus(workflowId);
        if (!statusResult.success) return;

        const workflow = await dataAccess.getRecord(COLLECTION_KEYS.onboardingWorkflows, workflowId, { suppressAuth: true });
        if (!workflow) return;

        let docsStatus = 'pending';
        if (statusResult.summary.hasRejections) docsStatus = 'rejected';
        else if (statusResult.summary.isComplete) docsStatus = 'complete';
        else if (statusResult.summary.uploaded > 0 || statusResult.summary.verified > 0) docsStatus = 'partial';

        if (workflow.documents_status !== docsStatus) {
            await dataAccess.updateRecord(COLLECTION_KEYS.onboardingWorkflows, {
                ...workflow, documents_status: docsStatus, status: docsStatus === 'complete' ? 'documents_complete' : workflow.status, _updatedDate: new Date()
            }, { suppressAuth: true });
        }
    } catch (error) {
        console.error('[DocumentCollection] Error updating workflow status:', error);
    }
}

// ============================================================================
// REGENERATE UPLOAD TOKEN
// ============================================================================

export async function regenerateUploadToken(workflowId) {
    if (!workflowId) return { success: false, error: 'workflowId is required' };
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, {
            filters: { workflow_id: workflowId, status: { hasSome: [CONFIG.status.REQUESTED, CONFIG.status.REJECTED] } },
            limit: 100, suppressAuth: true
        });

        if (!result.items?.length) return { success: false, error: 'No pending documents' };

        const { token, expiry } = generateUploadToken();
        const now = new Date();
        for (const doc of result.items) {
            await dataAccess.updateRecord(COLLECTION_KEYS.documentRequests, { ...doc, upload_token: token, upload_token_expiry: expiry, _updatedDate: now }, { suppressAuth: true });
        }

        return { success: true, token, tokenExpiry: expiry, uploadPortalUrl: `https://lastmilecdl.com/document-upload?token=${token}`, documentsUpdated: result.items.length };
    } catch (error) {
        console.error('[DocumentCollection] Error regenerating token:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// SCHEDULED JOB: SEND AUTO REMINDERS
// ============================================================================

export async function sendAutoReminders() {
    try {
        const now = new Date();
        let remindersSent = 0, errors = 0;

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, {
            filters: { status: CONFIG.status.REQUESTED, reminder_sent_count: { lt: CONFIG.reminderSequence.length } },
            limit: 500, suppressAuth: true
        });

        for (const doc of (result.items || [])) {
            const daysSince = Math.floor((now - new Date(doc._createdDate)) / (1000 * 60 * 60 * 24));
            const nextDay = CONFIG.reminderSequence[doc.reminder_sent_count || 0];
            if (nextDay && daysSince >= nextDay) {
                const res = await sendDocumentReminder(doc._id);
                if (res.success) remindersSent++; else errors++;
            }
        }

        return { success: true, remindersSent, errors, timestamp: now.toISOString() };
    } catch (error) {
        console.error('[DocumentCollection] Error in sendAutoReminders:', error);
        return { success: false, error: error.message };
    }
}

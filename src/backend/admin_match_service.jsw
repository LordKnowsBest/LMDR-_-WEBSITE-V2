import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    matches: 'matchEvents',
    interests: 'driverCarrierInterests',
    drivers: 'driverProfiles',
    carriers: 'carriers',
    auditLog: 'auditLog'
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) { return false; }
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized');
}

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const memberRole = member.contactDetails?.customFields?.role || '';
        return memberRole.toLowerCase() === 'super_admin';
    } catch (error) { return false; }
}

// ============================================
// MATCH LIST WITH FILTERS
// ============================================

export async function getMatchesList(options = {}) {
    await requireAdmin();
    const { filters = {}, page = 1, pageSize = 50, sortField = 'timestamp', sortDirection = 'desc' } = options;

    try {
        const queryFilters = {};
        if (filters.carrierDOT) queryFilters.carrier_dot = filters.carrierDOT;
        if (filters.carrierName) queryFilters.carrier_name = { contains: filters.carrierName };
        if (filters.driverName) queryFilters.driver_name = { contains: filters.driverName };
        if (filters.minScore) queryFilters.match_score = { gte: parseInt(filters.minScore) };
        if (filters.maxScore) queryFilters.match_score = { ...queryFilters.match_score, lte: parseInt(filters.maxScore) };
        if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;
        if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.matches, {
            filters: queryFilters, sort: [{ field: sortField, direction: sortDirection }],
            limit: pageSize, skip: (page - 1) * pageSize, suppressAuth: true
        });

        const items = result.items || [];
        const enriched = items.map(match => ({
            ...match, scoreCategory: getScoreCategory(match.match_score),
            relativeTime: getRelativeTime(match.timestamp), actionLabel: formatActionLabel(match.action)
        }));

        return { matches: enriched, totalCount: result.totalCount || items.length, currentPage: page, pageSize, totalPages: Math.ceil((result.totalCount || items.length) / pageSize) };
    } catch (error) { throw new Error('Failed to fetch matches'); }
}

function getScoreCategory(score) {
    if (score >= 90) return { label: 'Excellent', color: 'green' };
    if (score >= 75) return { label: 'Good', color: 'blue' };
    if (score >= 60) return { label: 'Fair', color: 'yellow' };
    return { label: 'Low', color: 'gray' };
}

function formatActionLabel(action) {
    const labels = { 'interested': 'Showed Interest', 'viewed': 'Viewed Details', 'applied': 'Applied', 'saved': 'Saved', 'contacted': 'Contacted' };
    return labels[action] || action || 'Match';
}

function getRelativeTime(ts) {
    if (!ts) return '';
    const diff = new Date() - new Date(ts);
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff/60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff/3600000)}h ago`;
    return new Date(ts).toLocaleDateString();
}

// ============================================
// MATCH DETAIL
// ============================================

export async function getMatchDetail(matchId) {
    await requireAdmin();
    try {
        const match = await dataAccess.getRecord(COLLECTION_KEYS.matches, matchId, { suppressAuth: true });
        if (!match) throw new Error('Not found');

        let driverInfo = null;
        if (match.driver_name && match.driver_name !== 'Anonymous') {
            const driverRes = await dataAccess.queryRecords(COLLECTION_KEYS.drivers, { filters: { firstName: { contains: match.driver_name.split(' ')[0] } }, limit: 1, suppressAuth: true });
            driverInfo = driverRes.items?.[0] || null;
        }

        let carrierInfo = null;
        if (match.carrier_dot) {
            carrierInfo = await dataAccess.findByField(COLLECTION_KEYS.carriers, 'dot_number', String(match.carrier_dot), { suppressAuth: true });
        }

        const relatedRes = await dataAccess.queryRecords(COLLECTION_KEYS.matches, { filters: { carrier_dot: match.carrier_dot, _id: { ne: matchId } }, sort: [{ field: 'timestamp', direction: 'desc' }], limit: 10, suppressAuth: true });

        return { ...match, scoreCategory: getScoreCategory(match.match_score), driverInfo, carrierInfo, relatedMatches: relatedRes.items || [] };
    } catch (error) { throw new Error('Failed to fetch match detail'); }
}

// ============================================
// DRIVER INTERESTS / APPLICATIONS
// ============================================

export async function getInterestsList(options = {}) {
    await requireAdmin();
    const { filters = {}, page = 1, pageSize = 50, sortField = '_createdDate', sortDirection = 'desc' } = options;

    try {
        const queryFilters = {};
        if (filters.status && filters.status !== 'all') queryFilters.status = filters.status;
        if (filters.dateFrom) queryFilters._createdDate = { gte: new Date(filters.dateFrom) };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
            filters: queryFilters, sort: [{ field: sortField, direction: sortDirection }],
            limit: pageSize, skip: (page - 1) * pageSize, suppressAuth: true
        });

        const items = result.items || [];
        const enriched = await enrichInterests(items);

        return { interests: enriched, totalCount: result.totalCount || items.length, currentPage: page, pageSize, totalPages: Math.ceil((result.totalCount || items.length) / pageSize) };
    } catch (error) { throw new Error('Failed to fetch interests'); }
}

async function enrichInterests(interests) {
    const driverIds = [...new Set(interests.map(i => i.driver_id).filter(Boolean))];
    const carrierDOTs = [...new Set(interests.map(i => i.carrier_dot).filter(Boolean))];

    const [driversRes, carriersRes] = await Promise.all([
        driverIds.length ? dataAccess.queryRecords(COLLECTION_KEYS.drivers, { filters: { _id: { hasSome: driverIds } }, limit: driverIds.length, suppressAuth: true }) : Promise.resolve({ items: [] }),
        carrierDOTs.length ? dataAccess.queryRecords(COLLECTION_KEYS.carriers, { filters: { dot_number: { hasSome: carrierDOTs } }, limit: carrierDOTs.length, suppressAuth: true }) : Promise.resolve({ items: [] })
    ]);

    const driverMap = {}, carrierMap = {};
    (driversRes.items || []).forEach(d => driverMap[d._id] = d);
    (carriersRes.items || []).forEach(c => carrierMap[c.dot_number] = c);

    return interests.map(i => ({
        ...i, driver: driverMap[i.driver_id] || null, carrier: carrierMap[i.carrier_dot] || null,
        statusLabel: formatInterestStatus(i.status), relativeTime: getRelativeTime(i._createdDate)
    }));
}

function formatInterestStatus(status) {
    const labels = { 'interested': { label: 'Interested', color: 'blue' }, 'applied': { label: 'Applied', color: 'purple' }, 'in_review': { label: 'In Review', color: 'yellow' }, 'hired': { label: 'Hired', color: 'green' } };
    return labels[status] || { label: status || 'Unknown', color: 'gray' };
}

// ============================================
// MATCH STATISTICS
// ============================================

export async function getMatchStats() {
    await requireAdmin();
    try {
        const weekAgo = new Date(); weekAgo.setDate(weekAgo.getDate() - 7);
        const [total, weekCount, totalInterests] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.matches, {}),
            dataAccess.countRecords(COLLECTION_KEYS.matches, { timestamp: { gte: weekAgo } }),
            dataAccess.countRecords(COLLECTION_KEYS.interests, {})
        ]);

        return {
            matches: { total, thisWeek: weekCount, dailyAverage: Math.round(weekCount / 7) },
            interests: { total: totalInterests, conversionRate: total > 0 ? Math.round((totalInterests / total) * 100) : 0 }
        };
    } catch (error) { throw new Error('Failed to fetch stats'); }
}

export async function exportMatchesCSV(filters = {}) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    const queryFilters = {};
    if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
    if (filters.minScore) queryFilters.match_score = { gte: parseInt(filters.minScore) };

    const res = await dataAccess.queryRecords(COLLECTION_KEYS.matches, { filters: queryFilters, sort: [{ field: 'timestamp', direction: 'desc' }], limit: 5000, suppressAuth: true });
    const items = res.items || [];

    const headers = ['Timestamp', 'Driver Name', 'Carrier DOT', 'Match Score', 'Action'];
    const rows = items.map(m => [m.timestamp, m.driver_name, m.carrier_dot, m.match_score, m.action]);
    return [headers.join(','), ...rows.map(row => row.map(c => `"${String(c).replace(/"/g, '""')}"`).join(','))].join('\n');
}

export async function getActionList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.matches, { limit: 1000, suppressAuth: true });
    const actions = new Set();
    (res.items || []).forEach(m => { if (m.action) actions.add(m.action); });
    return Array.from(actions).sort();
}
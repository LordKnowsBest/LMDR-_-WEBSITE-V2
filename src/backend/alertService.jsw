/**
 * Alert Service
 *
 * Manages driver reverse alerts (saved search alerts that notify on new matching postings).
 *
 * Data Source: Airtable (via dataAccess.jsw)
 * @module backend/alertService
 */

import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  alerts: 'driverAlerts'
};

const MAX_ACTIVE_ALERTS = 5;

/**
 * Create or update a reverse alert (saved search notification)
 * @param {string} driverId
 * @param {object} alertConfig - { alert_name, job_type, pay_type, min_pay_weekly, home_time, states, endorsements_required, notify_via }
 * @returns {Promise<object>} { alertId } or { error }
 */
export async function createReverseAlert(driverId, alertConfig = {}) {
  try {
    if (!alertConfig.alert_name) return { error: 'alert_name is required' };
    if (!alertConfig.notify_via || !Array.isArray(alertConfig.notify_via) || alertConfig.notify_via.length === 0) {
      return { error: 'notify_via must be a non-empty array (e.g. ["email", "in_app"])' };
    }

    // Check existing active alert count
    const existing = await dataAccess.queryRecords(COLLECTIONS.alerts, {
      filters: { driver_id: driverId, status: 'active' },
      limit: MAX_ACTIVE_ALERTS + 1,
      suppressAuth: true
    });

    if (existing.items && existing.items.length >= MAX_ACTIVE_ALERTS) {
      return { error: `Maximum ${MAX_ACTIVE_ALERTS} active alerts allowed. Deactivate one first.` };
    }

    const record = {
      driver_id: driverId,
      alert_name: String(alertConfig.alert_name).slice(0, 60),
      job_type: Array.isArray(alertConfig.job_type) ? alertConfig.job_type.join(',') : '',
      pay_type: Array.isArray(alertConfig.pay_type) ? alertConfig.pay_type.join(',') : '',
      min_pay_weekly: alertConfig.min_pay_weekly ? Number(alertConfig.min_pay_weekly) : 0,
      home_time: Array.isArray(alertConfig.home_time) ? alertConfig.home_time.join(',') : '',
      states: Array.isArray(alertConfig.states) ? alertConfig.states.join(',') : '',
      endorsements_required: Array.isArray(alertConfig.endorsements_required) ? alertConfig.endorsements_required.join(',') : '',
      notify_via: alertConfig.notify_via.join(','),
      status: 'active'
    };

    const created = await dataAccess.insertRecord(COLLECTIONS.alerts, record, { suppressAuth: true });
    return { alertId: created._id || created.id };
  } catch (error) {
    console.error('alertService.createReverseAlert error:', error);
    return { error: error.message };
  }
}

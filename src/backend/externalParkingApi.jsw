import { searchParking, getParkingDetails } from 'backend/parkingService';

function toNumber(value, fallback = null) {
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

export async function searchExternalParking(params = {}) {
  const lat = toNumber(params.lat);
  const lng = toNumber(params.lng);
  const radius = Math.min(100, Math.max(1, toNumber(params.radius, 25)));

  if (lat === null || lng === null) {
    return {
      success: false,
      errorCode: 'invalid_request',
      message: 'lat and lng are required'
    };
  }

  const amenities = normalizeArray(params.amenities);
  const minSpaces = Math.max(0, toNumber(params.min_spaces, 0));
  const result = await searchParking(lat, lng, radius, { amenities });
  if (!result?.success) {
    return {
      success: false,
      errorCode: 'internal_error',
      message: result?.error || 'Parking service unavailable'
    };
  }

  const items = (result.items || [])
    .filter((item) => (item.available_spaces ?? 0) >= minSpaces)
    .map((item) => mapParkingItem(item));

  return {
    success: true,
    data: {
      query: {
        center: { lat, lng },
        radius_miles: radius
      },
      results: items,
      total_results: items.length,
      coverage: {
        tpims_states: [],
        sensor_locations: items.filter((i) => isSensorSource(i.availability)).length,
        community_locations: items.filter((i) => i.availability.data_source.includes('community')).length
      }
    }
  };
}

export async function getExternalParkingLocation(locationId) {
  if (!locationId) {
    return { success: false, errorCode: 'invalid_request', message: 'location id is required' };
  }

  const result = await getParkingDetails(locationId);
  if (!result?.success || !result.item) {
    return { success: false, errorCode: 'resource_not_found', message: 'Location not found' };
  }

  const item = mapParkingItem(result.item);
  const historicalAvailability = mapHistoricalAvailability(result.item);
  const reviews = mapReviews(result.item);
  return {
    success: true,
    data: {
      ...item,
      historical_availability: historicalAvailability,
      reviews
    }
  };
}

function mapParkingItem(item = {}) {
  return {
    id: item._id || item.external_id || null,
    name: item.name || 'Unknown Parking',
    location: {
      lat: toNumber(item.location?.lat),
      lng: toNumber(item.location?.lng)
    },
    distance_miles: toNumber(item.distance_miles, 0),
    availability: {
      total_spaces: toNumber(item.total_spaces, 0),
      available_spaces: toNumber(item.available_spaces, null),
      last_updated: toIsoDateTime(item.last_availability_update || item.updated_at || new Date()),
      data_source: String(item.source || item.data_confidence || 'unknown'),
      source_label: mapSourceLabel(item.source, item.source_label),
      confidence: mapConfidence(item.data_confidence)
    },
    amenities: Array.isArray(item.amenities) ? item.amenities : [],
    type: item.type || 'parking',
    highway: item.highway || null,
    trend: item.trend || null
  };
}

function mapHistoricalAvailability(item = {}) {
  const rawHistory = Array.isArray(item.historical_availability) ?
    item.historical_availability :
    Array.isArray(item.availability_history) ?
      item.availability_history :
      [];
  return rawHistory
    .slice(0, 30)
    .map((entry) => ({
      timestamp: toIsoDateTime(entry.timestamp || entry.date || entry.updated_at || entry.recorded_at),
      available_spaces: toNumber(entry.available_spaces, null),
      trend: entry.trend || null
    }))
    .filter((entry) => entry.timestamp);
}

function mapReviews(item = {}) {
  if (!Array.isArray(item.reviews)) return [];
  return item.reviews.slice(0, 20).map((review) => ({
    rating: toNumber(review.rating, null),
    comment: String(review.comment || review.text || '').slice(0, 500),
    created_at: toIsoDateTime(review.created_at || review.date || review.timestamp)
  }));
}

function mapSourceLabel(source, sourceLabel) {
  if (sourceLabel) return String(sourceLabel);
  const value = String(source || '').toLowerCase();
  if (value.includes('tpims') || value.includes('sensor')) return 'Sensor network';
  if (value.includes('community') || value.includes('report')) return 'Community reports';
  if (value.includes('parkmytruck')) return 'ParkMyTruck';
  if (value.includes('truckparkingclub')) return 'TruckParkingClub';
  if (value.includes('database')) return 'LMDR database';
  return 'Unknown source';
}

function isSensorSource(availability = {}) {
  const source = String(availability.data_source || '').toLowerCase();
  const label = String(availability.source_label || '').toLowerCase();
  const confidence = String(availability.confidence || '').toLowerCase();
  return source.includes('sensor') ||
    source.includes('tpims') ||
    label.includes('sensor') ||
    confidence === 'high';
}

function mapConfidence(confidence) {
  const value = String(confidence || '').toLowerCase();
  if (value.includes('sensor') || value.includes('high')) return 'high';
  if (value.includes('medium') || value.includes('reported')) return 'medium';
  return 'low';
}

function normalizeArray(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value;
  return String(value)
    .split(',')
    .map((entry) => entry.trim())
    .filter(Boolean);
}

function toIsoDateTime(value) {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toISOString();
}

/**
 * Parking Service - Truck parking finder and reporting
 */

import wixData from 'wix-data';
import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';
import { calculateDistance } from 'backend/locationService';

// ... existing collections ...

// ============================================
// EXTERNAL API CONFIGURATION
// ============================================

const API_CONFIG = {
    TRUCK_PARKING_CLUB: {
        baseUrl: 'https://api.truckparkingclub.com/v1',
        timeout: 5000,
        rateLimitPerMin: 100
    },
    // TPIMS - Truck Parking Information Management System (FHWA)
    // Real sensor data from 300+ locations across major freight corridors
    TPIMS: {
        // OHGO (Ohio) - Requires API key
        OHGO: {
            baseUrl: 'https://publicapi.ohgo.com/api/v1',
            timeout: 8000,
            rateLimitPerMin: 60,
            secretKey: 'OHGO_API_KEY'
        },
        // Wisconsin 511 - Requires API key
        WI_511: {
            baseUrl: 'https://511wi.gov/api',
            timeout: 8000,
            rateLimitPerMin: 10,
            secretKey: 'WI_511_API_KEY'
        },
        // ========================================
        // PUBLIC FEEDS (No API Key Required!)
        // ========================================
        // Indiana - GeoJSON format, 19 sites on I-65, I-69, I-70
        INDIANA: {
            dynamicUrl: 'https://content.trafficwise.org/json/tpims.json',
            staticUrl: 'https://content.trafficwise.org/json/rest_area.json',
            timeout: 8000,
            public: true
        },
        // Kentucky - TRIMARC, 14 sites on I-65, I-71, I-75
        KENTUCKY: {
            dynamicUrl: 'http://www.trimarc.org/dat/tpims/TPIMS_Dynamic.json',
            staticUrl: 'http://www.trimarc.org/dat/tpims/TPIMS_Static.json',
            timeout: 8000,
            public: true
        },
        // Minnesota - MnDOT IRIS, 7 sites on I-94, I-35
        MINNESOTA: {
            dynamicUrl: 'http://iris.dot.state.mn.us/iris/TPIMS_dynamic',
            timeout: 8000,
            public: true
        },
        // Illinois - TravelMidwest, bonus coverage
        ILLINOIS: {
            dynamicUrl: 'https://truckparking.travelmidwest.com/TPIMS_Dynamic.json',
            staticUrl: 'https://truckparking.travelmidwest.com/TPIMS_Static.json',
            timeout: 8000,
            public: true
        },
        // ========================================
        // SOUTHERN STATES
        // ========================================
        // Arizona 511 - I-10 TPAS corridor (4 rest areas with sensors)
        ARIZONA: {
            baseUrl: 'https://www.az511.com',
            endpoint: '/api/restareas',
            timeout: 8000,
            rateLimitPerMin: 10,
            secretKey: 'AZ_511_API_KEY'
        },
        // Georgia 511 - I-75, I-85, I-20, I-95 rest areas
        GEORGIA: {
            baseUrl: 'https://511ga.org',
            endpoint: '/api/restareas',
            timeout: 8000,
            rateLimitPerMin: 10,
            secretKey: 'GA_511_API_KEY'
        },
        // California - Caltrans GIS Rest Areas (static locations)
        CALIFORNIA: {
            baseUrl: 'https://services.gis.ca.gov/arcgis/rest/services/Transportation/Rest_Areas/MapServer/0/query',
            timeout: 10000,
            public: true
        }
    }
};

// Simple circuit breaker state
const circuitBreaker = {
    truckParkingClub: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    ohgo: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    wi511: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    indiana: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    kentucky: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    minnesota: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    illinois: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    georgia: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    arizona: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    california: { failures: 0, lastFailure: 0, status: 'CLOSED' }
};

/**
 * Query external TruckParkingClub API for real-time data
 */
async function queryTruckParkingClubAPI(lat, lng, radius) {
    // Check circuit breaker
    if (circuitBreaker.truckParkingClub.status === 'OPEN') {
        if (Date.now() - circuitBreaker.truckParkingClub.lastFailure > 60000) {
            circuitBreaker.truckParkingClub.status = 'HALF_OPEN';
        } else {
            throw new Error('Circuit breaker is OPEN for TruckParkingClub');
        }
    }

    try {
        const apiKey = await getSecret('TRUCK_PARKING_CLUB_API_KEY');
        const response = await fetch(`${API_CONFIG.TRUCK_PARKING_CLUB.baseUrl}/parking/search?lat=${lat}&lng=${lng}&radius=${radius}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Accept': 'application/json'
            },
            timeout: API_CONFIG.TRUCK_PARKING_CLUB.timeout
        });

        if (!response.ok) {
            throw new Error(`TruckParkingClub API error: ${response.status}`);
        }

        const data = await response.json();
        
        // Reset circuit breaker on success
        circuitBreaker.truckParkingClub.failures = 0;
        circuitBreaker.truckParkingClub.status = 'CLOSED';

        return normalizeParkingData(data.results, 'truckparkingclub');
    } catch (error) {
        circuitBreaker.truckParkingClub.failures++;
        circuitBreaker.truckParkingClub.lastFailure = Date.now();
        if (circuitBreaker.truckParkingClub.failures >= 5) {
            circuitBreaker.truckParkingClub.status = 'OPEN';
        }
        console.error('[ParkingService] TruckParkingClub API failed:', error.message);
        throw error;
    }
}

// ============================================
// TPIMS API FUNCTIONS (Real Sensor Data)
// ============================================

/**
 * Query OHGO (Ohio) TPIMS API for real-time truck parking data
 * Provides sensor-based availability from 16+ rest areas on I-70, I-75
 */
async function queryOHGOAPI(lat, lng, radius) {
    // Check circuit breaker
    if (circuitBreaker.ohgo.status === 'OPEN') {
        if (Date.now() - circuitBreaker.ohgo.lastFailure > 60000) {
            circuitBreaker.ohgo.status = 'HALF_OPEN';
        } else {
            console.log('[TPIMS] OHGO circuit breaker is OPEN, skipping');
            return [];
        }
    }

    try {
        const apiKey = await getSecret(API_CONFIG.TPIMS.OHGO.secretKey).catch(() => null);
        if (!apiKey) {
            console.log('[TPIMS] No OHGO API key configured, skipping');
            return [];
        }

        // Use radius parameter: lat,lng,miles
        const url = `${API_CONFIG.TPIMS.OHGO.baseUrl}/truck-parking?radius=${lat},${lng},${radius}&page-all=true`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `APIKEY ${apiKey}`,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`OHGO API error: ${response.status}`);
        }

        const data = await response.json();

        // Reset circuit breaker on success
        circuitBreaker.ohgo.failures = 0;
        circuitBreaker.ohgo.status = 'CLOSED';

        console.log(`[TPIMS] OHGO returned ${data.results?.length || 0} truck parking locations`);
        return normalizeOHGOData(data.results || []);
    } catch (error) {
        circuitBreaker.ohgo.failures++;
        circuitBreaker.ohgo.lastFailure = Date.now();
        if (circuitBreaker.ohgo.failures >= 3) {
            circuitBreaker.ohgo.status = 'OPEN';
        }
        console.error('[TPIMS] OHGO API failed:', error.message);
        return [];
    }
}

/**
 * Normalize OHGO truck parking data to standard format
 */
function normalizeOHGOData(results) {
    if (!Array.isArray(results)) return [];

    return results.map(item => ({
        external_id: `ohgo_${item.Id}`,
        source: 'ohgo_tpims',
        source_label: 'ODOT Sensors',
        name: item.Description || item.Location || 'Ohio Rest Area',
        location: {
            lat: parseFloat(item.Latitude),
            lng: parseFloat(item.Longitude)
        },
        address: {
            full: item.Address || '',
            city: '',
            state: 'OH'
        },
        total_spaces: parseInt(item.Capacity) || 0,
        available_spaces: item.ReportedAvailable !== null ? parseInt(item.ReportedAvailable) : null,
        is_open: item.Open !== false,
        amenities: ['restroom'], // Ohio rest areas have restrooms
        avg_rating: 0,
        last_availability_update: item.LastReported ? new Date(item.LastReported) : new Date(),
        data_confidence: 'sensor', // Real sensor data!
        highway: item.Location || ''
    }));
}

/**
 * Query Wisconsin 511 TPIMS API
 */
async function queryWI511API(lat, lng, radius) {
    if (circuitBreaker.wi511.status === 'OPEN') {
        if (Date.now() - circuitBreaker.wi511.lastFailure > 60000) {
            circuitBreaker.wi511.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const apiKey = await getSecret(API_CONFIG.TPIMS.WI_511.secretKey).catch(() => null);
        if (!apiKey) return [];

        const url = `${API_CONFIG.TPIMS.WI_511.baseUrl}/GetTruckParking?key=${apiKey}&format=json`;

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`WI 511 API error: ${response.status}`);

        const data = await response.json();

        circuitBreaker.wi511.failures = 0;
        circuitBreaker.wi511.status = 'CLOSED';

        console.log(`[TPIMS] WI 511 returned ${data.length || 0} truck parking locations`);
        return normalizeWI511Data(data || []);
    } catch (error) {
        circuitBreaker.wi511.failures++;
        circuitBreaker.wi511.lastFailure = Date.now();
        if (circuitBreaker.wi511.failures >= 3) {
            circuitBreaker.wi511.status = 'OPEN';
        }
        console.error('[TPIMS] WI 511 API failed:', error.message);
        return [];
    }
}

/**
 * Normalize Wisconsin 511 truck parking data
 */
function normalizeWI511Data(results) {
    if (!Array.isArray(results)) return [];

    return results.map(item => ({
        external_id: `wi511_${item.id || item.Id}`,
        source: 'wi_tpims',
        source_label: 'WisDOT Sensors',
        name: item.name || item.Name || 'Wisconsin Rest Area',
        location: {
            lat: parseFloat(item.latitude || item.Latitude),
            lng: parseFloat(item.longitude || item.Longitude)
        },
        address: {
            full: item.address || '',
            city: '',
            state: 'WI'
        },
        total_spaces: parseInt(item.capacity || item.Capacity) || 0,
        available_spaces: item.availableSpaces !== undefined ? parseInt(item.availableSpaces) : null,
        is_open: true,
        amenities: ['restroom'],
        avg_rating: 0,
        last_availability_update: item.lastUpdated ? new Date(item.lastUpdated) : new Date(),
        data_confidence: 'sensor',
        highway: item.route || ''
    }));
}

// ============================================
// PUBLIC TPIMS FEEDS (No API Key Required!)
// ============================================

/**
 * Query Indiana TPIMS - GeoJSON format
 * Coverage: I-65, I-69, I-70 (19 sites)
 */
async function queryIndianaTPIMS() {
    if (circuitBreaker.indiana.status === 'OPEN') {
        if (Date.now() - circuitBreaker.indiana.lastFailure > 60000) {
            circuitBreaker.indiana.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.INDIANA.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Indiana TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.indiana.failures = 0;
        circuitBreaker.indiana.status = 'CLOSED';

        console.log(`[TPIMS] Indiana returned ${data.features?.length || 0} locations`);
        return normalizeIndianaData(data.features || []);
    } catch (error) {
        circuitBreaker.indiana.failures++;
        circuitBreaker.indiana.lastFailure = Date.now();
        if (circuitBreaker.indiana.failures >= 3) circuitBreaker.indiana.status = 'OPEN';
        console.error('[TPIMS] Indiana failed:', error.message);
        return [];
    }
}

function normalizeIndianaData(features) {
    return features.map(f => {
        const props = f.properties || {};
        const coords = f.geometry?.coordinates || [0, 0];
        // Parse availability from message1 (can be number, "LOW", or "X")
        let available = null;
        if (props.message1 && !isNaN(parseInt(props.message1))) {
            available = parseInt(props.message1);
        } else if (props.message1 === 'LOW') {
            available = 5; // Estimate low as 5
        }

        return {
            external_id: `in_${props.device_nbr || f.id}`,
            source: 'indiana_tpims',
            source_label: 'INDOT Sensors',
            name: props.title || props.description || 'Indiana Rest Area',
            location: { lat: coords[1], lng: coords[0] },
            address: { state: 'IN' },
            total_spaces: parseInt(props.message3) || 0,
            available_spaces: available,
            is_open: props.message1 !== 'X',
            amenities: ['restroom'],
            data_confidence: 'sensor',
            highway: props.route || '',
            last_availability_update: props.ontime ? new Date(props.ontime) : new Date()
        };
    });
}

/**
 * Query Kentucky TPIMS - MAASTO standard format
 * Coverage: I-65, I-71, I-75 (14 sites)
 */
async function queryKentuckyTPIMS() {
    if (circuitBreaker.kentucky.status === 'OPEN') {
        if (Date.now() - circuitBreaker.kentucky.lastFailure > 60000) {
            circuitBreaker.kentucky.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.KENTUCKY.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Kentucky TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.kentucky.failures = 0;
        circuitBreaker.kentucky.status = 'CLOSED';

        console.log(`[TPIMS] Kentucky returned ${Array.isArray(data) ? data.length : 0} locations`);
        return normalizeMAASTO(data, 'KY', 'kentucky_tpims', 'KYTC Sensors');
    } catch (error) {
        circuitBreaker.kentucky.failures++;
        circuitBreaker.kentucky.lastFailure = Date.now();
        if (circuitBreaker.kentucky.failures >= 3) circuitBreaker.kentucky.status = 'OPEN';
        console.error('[TPIMS] Kentucky failed:', error.message);
        return [];
    }
}

/**
 * Query Minnesota TPIMS - MAASTO standard format
 * Coverage: I-94, I-35 (7 sites)
 */
async function queryMinnesotaTPIMS() {
    if (circuitBreaker.minnesota.status === 'OPEN') {
        if (Date.now() - circuitBreaker.minnesota.lastFailure > 60000) {
            circuitBreaker.minnesota.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.MINNESOTA.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Minnesota TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.minnesota.failures = 0;
        circuitBreaker.minnesota.status = 'CLOSED';

        console.log(`[TPIMS] Minnesota returned ${Array.isArray(data) ? data.length : 0} locations`);
        return normalizeMAASTO(data, 'MN', 'minnesota_tpims', 'MnDOT Sensors');
    } catch (error) {
        circuitBreaker.minnesota.failures++;
        circuitBreaker.minnesota.lastFailure = Date.now();
        if (circuitBreaker.minnesota.failures >= 3) circuitBreaker.minnesota.status = 'OPEN';
        console.error('[TPIMS] Minnesota failed:', error.message);
        return [];
    }
}

/**
 * Query Illinois TPIMS - MAASTO standard format
 * Coverage: I-80, I-55, I-57 corridor
 */
async function queryIllinoisTPIMS() {
    if (circuitBreaker.illinois.status === 'OPEN') {
        if (Date.now() - circuitBreaker.illinois.lastFailure > 60000) {
            circuitBreaker.illinois.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.ILLINOIS.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Illinois TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.illinois.failures = 0;
        circuitBreaker.illinois.status = 'CLOSED';

        console.log(`[TPIMS] Illinois returned ${Array.isArray(data) ? data.length : 0} locations`);
        return normalizeMAASTO(data, 'IL', 'illinois_tpims', 'IDOT Sensors');
    } catch (error) {
        circuitBreaker.illinois.failures++;
        circuitBreaker.illinois.lastFailure = Date.now();
        if (circuitBreaker.illinois.failures >= 3) circuitBreaker.illinois.status = 'OPEN';
        console.error('[TPIMS] Illinois failed:', error.message);
        return [];
    }
}

// ============================================
// SOUTHERN STATES TPIMS FEEDS
// ============================================

/**
 * Query Arizona 511 TPIMS - I-10 TPAS corridor
 * Coverage: I-10, I-40, I-17 rest areas with truck parking sensors
 */
async function queryArizonaTPIMS() {
    if (circuitBreaker.arizona.status === 'OPEN') {
        if (Date.now() - circuitBreaker.arizona.lastFailure > 60000) {
            circuitBreaker.arizona.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        // AZ511 uses public REST API for rest areas
        const url = `${API_CONFIG.TPIMS.ARIZONA.baseUrl}${API_CONFIG.TPIMS.ARIZONA.endpoint}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Arizona TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.arizona.failures = 0;
        circuitBreaker.arizona.status = 'CLOSED';

        console.log(`[TPIMS] Arizona returned ${Array.isArray(data) ? data.length : data.restAreas?.length || 0} locations`);
        return normalizeArizonaData(data.restAreas || data || []);
    } catch (error) {
        circuitBreaker.arizona.failures++;
        circuitBreaker.arizona.lastFailure = Date.now();
        if (circuitBreaker.arizona.failures >= 3) circuitBreaker.arizona.status = 'OPEN';
        console.error('[TPIMS] Arizona failed:', error.message);
        return [];
    }
}

/**
 * Normalize Arizona 511 rest area data
 */
function normalizeArizonaData(data) {
    if (!Array.isArray(data)) return [];

    return data.map(item => {
        // AZ511 format: TotalTruckSpaces, AvailableTruckSpaces
        const total = parseInt(item.TotalTruckSpaces || item.totalTruckSpaces || 0);
        const available = item.AvailableTruckSpaces !== undefined
            ? parseInt(item.AvailableTruckSpaces)
            : (item.availableTruckSpaces !== undefined ? parseInt(item.availableTruckSpaces) : null);

        return {
            external_id: `az_${item.Id || item.id || item.RestAreaId}`,
            source: 'arizona_tpims',
            source_label: 'ADOT Sensors',
            name: item.Name || item.name || item.Description || 'Arizona Rest Area',
            location: {
                lat: parseFloat(item.Latitude || item.latitude || item.Lat || 0),
                lng: parseFloat(item.Longitude || item.longitude || item.Lng || 0)
            },
            address: {
                city: item.City || item.city || '',
                state: 'AZ'
            },
            total_spaces: total,
            available_spaces: available,
            is_open: item.Open !== false && item.Status !== 'Closed',
            amenities: parseArizonaAmenities(item),
            data_confidence: available !== null ? 'sensor' : 'static',
            highway: item.Route || item.route || item.Highway || '',
            last_availability_update: item.LastUpdated ? new Date(item.LastUpdated) : new Date()
        };
    });
}

function parseArizonaAmenities(item) {
    const amenities = ['restroom'];
    if (item.HasFuel || item.hasFuel) amenities.push('fuel');
    if (item.HasFood || item.hasFood) amenities.push('food');
    if (item.HasShowers || item.hasShowers) amenities.push('showers');
    if (item.PetArea || item.petArea) amenities.push('pet_area');
    return amenities;
}

/**
 * Query Georgia 511 TPIMS - I-75, I-85, I-20, I-95
 * Georgia has 17 welcome centers and rest areas along major interstates
 */
async function queryGeorgiaTPIMS() {
    if (circuitBreaker.georgia.status === 'OPEN') {
        if (Date.now() - circuitBreaker.georgia.lastFailure > 60000) {
            circuitBreaker.georgia.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        // GA511 REST API endpoint
        const url = `${API_CONFIG.TPIMS.GEORGIA.baseUrl}${API_CONFIG.TPIMS.GEORGIA.endpoint}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Georgia TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.georgia.failures = 0;
        circuitBreaker.georgia.status = 'CLOSED';

        console.log(`[TPIMS] Georgia returned ${Array.isArray(data) ? data.length : data.restAreas?.length || 0} locations`);
        return normalizeGeorgiaData(data.restAreas || data || []);
    } catch (error) {
        circuitBreaker.georgia.failures++;
        circuitBreaker.georgia.lastFailure = Date.now();
        if (circuitBreaker.georgia.failures >= 3) circuitBreaker.georgia.status = 'OPEN';
        console.error('[TPIMS] Georgia failed:', error.message);
        return [];
    }
}

/**
 * Normalize Georgia 511 rest area data
 */
function normalizeGeorgiaData(data) {
    if (!Array.isArray(data)) return [];

    return data.map(item => {
        // GA511 format varies - handle common patterns
        const total = parseInt(item.TruckSpaces || item.truckSpaces || item.capacity || 0);
        const available = item.AvailableSpaces !== undefined
            ? parseInt(item.AvailableSpaces)
            : (item.availableSpaces !== undefined ? parseInt(item.availableSpaces) : null);

        return {
            external_id: `ga_${item.Id || item.id || item.RestAreaId}`,
            source: 'georgia_tpims',
            source_label: 'GDOT',
            name: item.Name || item.name || item.Description || 'Georgia Rest Area',
            location: {
                lat: parseFloat(item.Latitude || item.latitude || item.Lat || 0),
                lng: parseFloat(item.Longitude || item.longitude || item.Lng || 0)
            },
            address: {
                city: item.City || item.city || '',
                state: 'GA'
            },
            total_spaces: total,
            available_spaces: available,
            is_open: item.Open !== false && item.Status !== 'Closed',
            amenities: parseGeorgiaAmenities(item),
            data_confidence: available !== null ? 'sensor' : 'static',
            highway: item.Route || item.route || item.Interstate || '',
            last_availability_update: item.LastUpdated ? new Date(item.LastUpdated) : new Date()
        };
    });
}

function parseGeorgiaAmenities(item) {
    const amenities = ['restroom'];
    if (item.Vending || item.vending) amenities.push('vending');
    if (item.PicnicArea || item.picnicArea) amenities.push('picnic');
    if (item.PetArea || item.petArea) amenities.push('pet_area');
    if (item.WiFi || item.wifi) amenities.push('wifi');
    return amenities;
}

/**
 * Query California Caltrans Rest Areas - ArcGIS REST service
 * Coverage: All California rest areas (static locations)
 * Note: Caltrans doesn't provide real-time availability, but has accurate location data
 */
async function queryCaliforniaRestAreas() {
    if (circuitBreaker.california.status === 'OPEN') {
        if (Date.now() - circuitBreaker.california.lastFailure > 60000) {
            circuitBreaker.california.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        // ArcGIS REST query - get all features as JSON
        const params = new URLSearchParams({
            where: '1=1',
            outFields: '*',
            returnGeometry: 'true',
            f: 'json'
        });

        const url = `${API_CONFIG.TPIMS.CALIFORNIA.baseUrl}?${params.toString()}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`California REST Areas error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.california.failures = 0;
        circuitBreaker.california.status = 'CLOSED';

        console.log(`[TPIMS] California returned ${data.features?.length || 0} rest areas`);
        return normalizeCaliforniaData(data.features || []);
    } catch (error) {
        circuitBreaker.california.failures++;
        circuitBreaker.california.lastFailure = Date.now();
        if (circuitBreaker.california.failures >= 3) circuitBreaker.california.status = 'OPEN';
        console.error('[TPIMS] California failed:', error.message);
        return [];
    }
}

/**
 * Normalize California Caltrans ArcGIS data
 */
function normalizeCaliforniaData(features) {
    if (!Array.isArray(features)) return [];

    return features.map(feature => {
        const props = feature.attributes || {};
        const geom = feature.geometry || {};

        // Caltrans provides static data - no real-time availability
        return {
            external_id: `ca_${props.OBJECTID || props.RestAreaID}`,
            source: 'california_caltrans',
            source_label: 'Caltrans',
            name: props.NAME || props.Name || props.REST_AREA_NAME || 'California Rest Area',
            location: {
                lat: geom.y || parseFloat(props.LATITUDE || 0),
                lng: geom.x || parseFloat(props.LONGITUDE || 0)
            },
            address: {
                city: props.CITY || props.City || '',
                county: props.COUNTY || props.County || '',
                state: 'CA'
            },
            total_spaces: parseInt(props.TRUCK_SPACES || props.TruckSpaces || 0),
            available_spaces: null, // Caltrans doesn't provide real-time availability
            is_open: props.STATUS !== 'Closed' && props.OPEN !== 'No',
            amenities: parseCaliforniaAmenities(props),
            data_confidence: 'static', // No sensor data, just location info
            highway: props.ROUTE || props.Route || props.HIGHWAY || '',
            last_availability_update: new Date() // Static data
        };
    });
}

function parseCaliforniaAmenities(props) {
    const amenities = [];
    if (props.RESTROOMS === 'Yes' || props.Restrooms) amenities.push('restroom');
    if (props.VENDING === 'Yes' || props.Vending) amenities.push('vending');
    if (props.PICNIC === 'Yes' || props.PicnicArea) amenities.push('picnic');
    if (props.PET_AREA === 'Yes' || props.PetArea) amenities.push('pet_area');
    if (props.WATER === 'Yes' || props.Water) amenities.push('water');
    if (props.PHONES === 'Yes' || props.Phones) amenities.push('phone');
    if (props.HANDICAP === 'Yes' || props.Handicap) amenities.push('accessible');
    if (amenities.length === 0) amenities.push('restroom'); // Default
    return amenities;
}

/**
 * Normalize MAASTO standard format (used by KY, MN, IL)
 * Schema: siteId, timeStamp, reportedAvailable, trend, open, trustData, capacity
 */
function normalizeMAASTO(data, state, source, sourceLabel) {
    if (!Array.isArray(data)) return [];

    return data.map(item => {
        // Parse availability - can be number string, "Low", or "Unknown"
        let available = null;
        if (item.reportedAvailable && !isNaN(parseInt(item.reportedAvailable))) {
            available = parseInt(item.reportedAvailable);
        } else if (item.reportedAvailable === 'Low') {
            available = 5;
        }

        // Extract highway from siteId (e.g., "KY00065IS..." -> I-65)
        const highway = extractHighwayFromSiteId(item.siteId);

        return {
            external_id: `${state.toLowerCase()}_${item.siteId}`,
            source: source,
            source_label: sourceLabel,
            name: item.siteName || `${state} Rest Area`,
            location: {
                lat: item.latitude || item.location?.latitude || 0,
                lng: item.longitude || item.location?.longitude || 0
            },
            address: {
                city: item.city || item.location?.city || '',
                state: state
            },
            total_spaces: parseInt(item.capacity) || 0,
            available_spaces: available,
            is_open: item.open === true || item.open === 'true',
            amenities: item.amenities || ['restroom'],
            data_confidence: item.trustData ? 'sensor' : 'estimated',
            highway: highway,
            trend: item.trend || null,
            last_availability_update: item.timeStamp ? new Date(item.timeStamp) : new Date()
        };
    });
}

function extractHighwayFromSiteId(siteId) {
    if (!siteId) return '';
    // Format: KY00065IS... -> extract route number after state code
    const match = siteId.match(/\d{5}(IS|US|SH)(\d+)/);
    if (match) {
        const type = match[1] === 'IS' ? 'I-' : match[1] === 'US' ? 'US-' : 'SR-';
        return type + parseInt(match[2]);
    }
    return '';
}

/**
 * Aggregate TPIMS data from all available state sources
 * This is the main entry point for real sensor data
 */
async function queryAllTPIMSSources(lat, lng, radius) {
    // Query ALL available TPIMS sources in parallel
    // MAASTO Midwest (6 states): IN, KY, MN, IL, OH, WI
    // Southern/Western (3 states): AZ, GA, CA
    const tpimsQueries = [
        // === MAASTO MIDWEST ===
        // Public feeds (no key required)
        queryIndianaTPIMS(),
        queryKentuckyTPIMS(),
        queryMinnesotaTPIMS(),
        queryIllinoisTPIMS(),
        // API key feeds - gracefully fail if no key
        queryOHGOAPI(lat, lng, radius),
        queryWI511API(lat, lng, radius),
        // === SOUTHERN/WESTERN STATES ===
        // Arizona - I-10 TPAS corridor
        queryArizonaTPIMS(),
        // Georgia - I-75, I-85, I-20, I-95
        queryGeorgiaTPIMS(),
        // California - Caltrans static rest areas
        queryCaliforniaRestAreas()
    ];

    const results = await Promise.all(tpimsQueries);
    const allItems = results.flat();

    console.log(`[TPIMS] Total locations from all 9 sources: ${allItems.length}`);
    return allItems;
}

/**
 * Normalize data from different sources into a standard format
 */
function normalizeParkingData(results, source) {
    if (!Array.isArray(results)) return [];

    return results.map(item => ({
        external_id: item.id || item.external_id,
        source: source,
        name: item.name,
        location: {
            lat: item.latitude || item.lat || item.location?.lat,
            lng: item.longitude || item.lng || item.location?.lng
        },
        address: item.address || {},
        total_spaces: item.total_spaces || 0,
        available_spaces: item.available_spaces || null,
        amenities: item.amenities || [],
        avg_rating: item.rating || 0,
        last_availability_update: item.updated_at || new Date()
    }));
}

const COLLECTIONS = {
    LOCATIONS: 'ParkingLocations',
    REPORTS: 'ParkingReports',
    CACHE: 'RoadUtilityCache'
};

/**
 * Fallback query to ParkMyTruck API
 */
async function queryParkMyTruckAPI(lat, lng, radius) {
    try {
        const apiKey = await getSecret('PARK_MY_TRUCK_API_KEY').catch(() => null);
        if (!apiKey) return []; // Skip if no key

        const response = await fetch(`https://api.parkmytruck.com/v1/search?lat=${lat}&lng=${lng}&radius=${radius}`, {
            headers: { 'X-API-Key': apiKey }
        });

        if (!response.ok) return [];
        const data = await response.json();
        return normalizeParkingData(data.locations, 'parkmytruck');
    } catch (err) {
        return [];
    }
}

/**
 * Query state DOT APIs for rest area status
 * Now integrated with TPIMS for real sensor data
 */
async function queryStateDOTAPIs(lat, lng, radius) {
    // Query all TPIMS sources (OHGO, WI 511, etc.)
    // These provide real-time sensor data from federally-funded systems
    try {
        const tpimsData = await queryAllTPIMSSources(lat, lng, radius);
        return tpimsData;
    } catch (error) {
        console.error('[ParkingService] TPIMS query failed:', error.message);
        return [];
    }
}

/**
 * Search for truck parking near a location
 * @param {number} lat 
 * @param {number} lng 
 * @param {number} radius 
 * @param {Object} filters 
 */
export async function searchParking(lat, lng, radius = 25, filters = {}) {
    const cacheKey = `parking:${lat.toFixed(2)}:${lng.toFixed(2)}:${radius}:${JSON.stringify(filters)}`;
    
    try {
        // 1. Check cache first
        const cached = await wixData.query(COLLECTIONS.CACHE)
            .eq('cache_key', cacheKey)
            .gt('expires_at', new Date())
            .limit(1)
            .find({ suppressAuth: true });
            
        if (cached.items.length > 0) {
            return { success: true, items: cached.items[0].data, fromCache: true };
        }

        // 2. Cache miss: Fetch from multiple sources
        const sources = [
            queryTruckParkingClubAPI(lat, lng, radius).catch(() => []),
            queryParkMyTruckAPI(lat, lng, radius),
            queryStateDOTAPIs(lat, lng, radius),
            // Also include local database locations
            wixData.query(COLLECTIONS.LOCATIONS).limit(100).find({ suppressAuth: true }).then(res => res.items)
        ];

        const allResults = await Promise.all(sources);
        const mergedItems = flattenAndMerge(allResults);

        // Calculate distance and filter by radius
        const filteredItems = mergedItems.map(item => {
            const distance = calculateDistance(lat, lng, item.location.lat, item.location.lng);
            return { ...item, distance_miles: parseFloat(distance.toFixed(2)) };
        }).filter(item => item.distance_miles <= radius);

        // Filter by amenities
        let finalItems = filteredItems;
        if (filters.amenities && Array.isArray(filters.amenities) && filters.amenities.length > 0) {
            finalItems = filteredItems.filter(item => 
                filters.amenities.every(amenity => item.amenities && item.amenities.includes(amenity))
            );
        }

        // Sort by distance
        finalItems.sort((a, b) => a.distance_miles - b.distance_miles);

        // 3. Store in cache
        const expiry = new Date();
        expiry.setMinutes(expiry.getMinutes() + 5);
        
        await wixData.insert(COLLECTIONS.CACHE, {
            cache_key: cacheKey,
            cache_type: 'parking',
            data: finalItems,
            expires_at: expiry
        }, { suppressAuth: true }).catch(err => console.error('Failed to update cache:', err));

        return { success: true, items: finalItems };
    } catch (error) {
        console.error('[ParkingService] searchParking failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Deduplicate and merge results from multiple sources
 * Prioritizes sensor data over estimates
 */
function flattenAndMerge(sourceResults) {
    const merged = new Map();

    // Data confidence ranking (higher = better)
    const confidenceRank = {
        'sensor': 3,      // Real TPIMS sensor data
        'reported': 2,    // Community reports
        'estimated': 1,   // Algorithm estimates
        'unknown': 0      // No data
    };

    sourceResults.flat().forEach(item => {
        // Use coordinates as key for deduplication
        const key = `${item.location.lat.toFixed(3)}:${item.location.lng.toFixed(3)}`;

        if (!merged.has(key)) {
            merged.set(key, item);
        } else {
            const existing = merged.get(key);
            const existingConfidence = confidenceRank[existing.data_confidence] || 0;
            const newConfidence = confidenceRank[item.data_confidence] || 0;

            // Prefer higher confidence data
            if (newConfidence > existingConfidence) {
                merged.set(key, { ...existing, ...item });
            } else if (newConfidence === existingConfidence) {
                // Same confidence: prefer the one with availability data
                if (item.available_spaces !== null && existing.available_spaces === null) {
                    merged.set(key, { ...existing, ...item });
                }
            }
        }
    });

    return Array.from(merged.values());
}

/**
 * Get data source label for UI display
 */
function getSourceLabel(source) {
    const labels = {
        // MAASTO Midwest
        'ohgo_tpims': 'ODOT Sensors',
        'wi_tpims': 'WisDOT Sensors',
        'indiana_tpims': 'INDOT Sensors',
        'kentucky_tpims': 'KYTC Sensors',
        'minnesota_tpims': 'MnDOT Sensors',
        'illinois_tpims': 'IDOT Sensors',
        // Southern/Western
        'arizona_tpims': 'ADOT Sensors',
        'georgia_tpims': 'GDOT',
        'california_caltrans': 'Caltrans',
        // Other sources
        'truckparkingclub': 'TruckParkingClub',
        'parkmytruck': 'ParkMyTruck',
        'community': 'Driver Reports',
        'database': 'LMDR Database'
    };
    return labels[source] || 'Unknown';
}

/**
 * Get detailed info for a specific parking location
 * @param {string} locationId 
 */
export async function getParkingDetails(locationId) {
    if (!locationId) return { success: false, error: 'locationId is required' };
    
    try {
        const item = await wixData.get(COLLECTIONS.LOCATIONS, locationId, { suppressAuth: true });
        if (!item) return { success: false, error: 'Location not found' };
        
        return { success: true, item };
    } catch (error) {
        console.error('[ParkingService] getParkingDetails failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Submit a parking availability report
 * @param {string} locationId 
 * @param {Object} report 
 */
export async function reportParkingAvailability(locationId, report) {
    if (!locationId) return { success: false, error: 'locationId is required' };
    if (!report.driver_id) return { success: false, error: 'driver_id is required' };
    if (typeof report.spaces_available !== 'number' || report.spaces_available < 0) {
        return { success: false, error: 'Invalid spaces available' };
    }

    // Rate limiting: 1 report per location per hour per driver
    const oneHourAgo = new Date(Date.now() - 3600000);
    try {
        const recentReports = await wixData.query(COLLECTIONS.REPORTS)
            .eq('location_id', locationId)
            .eq('driver_id', report.driver_id)
            .gt('reported_at', oneHourAgo)
            .limit(1)
            .find({ suppressAuth: true });

        if (recentReports.items.length > 0) {
            return { success: false, error: 'You have already reported for this location in the last hour' };
        }

        const record = {
            location_id: locationId,
            driver_id: report.driver_id,
            spaces_available: report.spaces_available,
            notes: report.notes || '',
            reported_at: new Date()
        };

        const result = await wixData.insert(COLLECTIONS.REPORTS, record, { suppressAuth: true });
        
        // Trigger availability estimation update (async)
        updateEstimatedAvailability(locationId).catch(err => console.error('Failed to update estimation:', err));

        return { success: true, reportId: result._id };
    } catch (error) {
        console.error('[ParkingService] reportParkingAvailability failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Update the estimated availability for a location based on recent reports
 */
async function updateEstimatedAvailability(locationId) {
    const twoHoursAgo = new Date(Date.now() - 7200000);
    
    const reports = await wixData.query(COLLECTIONS.REPORTS)
        .eq('location_id', locationId)
        .gt('reported_at', twoHoursAgo)
        .descending('reported_at')
        .limit(10)
        .find({ suppressAuth: true });

    if (reports.items.length === 0) return;

    // Simple aggregation: average of recent reports weighted by recency
    let totalWeightedSpaces = 0;
    let totalWeight = 0;
    const now = Date.now();

    reports.items.forEach(report => {
        const ageHours = (now - report.reported_at.getTime()) / 3600000;
        const weight = 1 / (ageHours + 0.5); // Decay weight
        totalWeightedSpaces += report.spaces_available * weight;
        totalWeight += weight;
    });

    const estimatedSpaces = Math.round(totalWeightedSpaces / totalWeight);

    await wixData.update(COLLECTIONS.LOCATIONS, {
        _id: locationId,
        available_spaces: estimatedSpaces,
        availability_confidence: 'estimated',
        last_availability_update: new Date()
    }, { suppressAuth: true });
}

/**
 * Calculate availability status (available, limited, full, unknown)
 */
function calculateAvailabilityStatus(item) {
    if (item.available_spaces === null) return 'unknown';
    
    const ratio = item.total_spaces > 0 ? item.available_spaces / item.total_spaces : 1;
    
    if (item.available_spaces === 0) return 'full';
    if (ratio < 0.1 || item.available_spaces < 5) return 'limited';
    return 'available';
}

/**
 * Get parking along a route
 * @param {Array} routePoints 
 * @param {Object} options 
 */
export async function getParkingAlongRoute(routePoints, options = {}) {
    // Basic implementation: find parking near start, middle, and end
    // A full implementation would check along the entire corridor
    if (!Array.isArray(routePoints) || routePoints.length < 2) {
        return { success: false, error: 'Invalid route points' };
    }

    // Simplified: check near all waypoints provided
    const allResults = [];
    const seenIds = new Set();

    for (const point of routePoints) {
        const nearPoint = await searchParking(point.lat, point.lng, options.radius || 10, options.filters);
        if (nearPoint.success) {
            for (const item of nearPoint.items) {
                if (!seenIds.has(item._id)) {
                    allResults.push(item);
                    seenIds.add(item._id);
                }
            }
        }
    }

    return { success: true, items: allResults };
}
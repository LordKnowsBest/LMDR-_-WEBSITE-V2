/**
 * Parking Service - Truck parking finder and reporting
 */

import wixData from 'wix-data';
import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';
import { calculateDistance } from 'backend/locationService';

// ... existing collections ...

// ============================================
// EXTERNAL API CONFIGURATION
// ============================================

const API_CONFIG = {
    TRUCK_PARKING_CLUB: {
        baseUrl: 'https://api.truckparkingclub.com/v1',
        timeout: 5000,
        rateLimitPerMin: 100
    },
    // TPIMS - Truck Parking Information Management System (FHWA)
    // Real sensor data from 300+ locations across major freight corridors
    TPIMS: {
        // OHGO (Ohio) - Requires API key
        OHGO: {
            baseUrl: 'https://publicapi.ohgo.com/api/v1',
            timeout: 8000,
            rateLimitPerMin: 60,
            secretKey: 'OHGO_API_KEY'
        },
        // Wisconsin 511 - Requires API key
        WI_511: {
            baseUrl: 'https://511wi.gov/api',
            timeout: 8000,
            rateLimitPerMin: 10,
            secretKey: 'WI_511_API_KEY'
        },
        // ========================================
        // PUBLIC FEEDS (No API Key Required!)
        // ========================================
        // Indiana - GeoJSON format, 19 sites on I-65, I-69, I-70
        INDIANA: {
            dynamicUrl: 'https://content.trafficwise.org/json/tpims.json',
            staticUrl: 'https://content.trafficwise.org/json/rest_area.json',
            timeout: 8000,
            public: true
        },
        // Kentucky - TRIMARC, 14 sites on I-65, I-71, I-75
        KENTUCKY: {
            dynamicUrl: 'http://www.trimarc.org/dat/tpims/TPIMS_Dynamic.json',
            staticUrl: 'http://www.trimarc.org/dat/tpims/TPIMS_Static.json',
            timeout: 8000,
            public: true
        },
        // Minnesota - MnDOT IRIS, 7 sites on I-94, I-35
        MINNESOTA: {
            dynamicUrl: 'http://iris.dot.state.mn.us/iris/TPIMS_dynamic',
            timeout: 8000,
            public: true
        },
        // Illinois - TravelMidwest, bonus coverage
        ILLINOIS: {
            dynamicUrl: 'https://truckparking.travelmidwest.com/TPIMS_Dynamic.json',
            staticUrl: 'https://truckparking.travelmidwest.com/TPIMS_Static.json',
            timeout: 8000,
            public: true
        }
    }
};

// Simple circuit breaker state
const circuitBreaker = {
    truckParkingClub: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    ohgo: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    wi511: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    indiana: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    kentucky: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    minnesota: { failures: 0, lastFailure: 0, status: 'CLOSED' },
    illinois: { failures: 0, lastFailure: 0, status: 'CLOSED' }
};

/**
 * Query external TruckParkingClub API for real-time data
 */
async function queryTruckParkingClubAPI(lat, lng, radius) {
    // Check circuit breaker
    if (circuitBreaker.truckParkingClub.status === 'OPEN') {
        if (Date.now() - circuitBreaker.truckParkingClub.lastFailure > 60000) {
            circuitBreaker.truckParkingClub.status = 'HALF_OPEN';
        } else {
            throw new Error('Circuit breaker is OPEN for TruckParkingClub');
        }
    }

    try {
        const apiKey = await getSecret('TRUCK_PARKING_CLUB_API_KEY');
        const response = await fetch(`${API_CONFIG.TRUCK_PARKING_CLUB.baseUrl}/parking/search?lat=${lat}&lng=${lng}&radius=${radius}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Accept': 'application/json'
            },
            timeout: API_CONFIG.TRUCK_PARKING_CLUB.timeout
        });

        if (!response.ok) {
            throw new Error(`TruckParkingClub API error: ${response.status}`);
        }

        const data = await response.json();
        
        // Reset circuit breaker on success
        circuitBreaker.truckParkingClub.failures = 0;
        circuitBreaker.truckParkingClub.status = 'CLOSED';

        return normalizeParkingData(data.results, 'truckparkingclub');
    } catch (error) {
        circuitBreaker.truckParkingClub.failures++;
        circuitBreaker.truckParkingClub.lastFailure = Date.now();
        if (circuitBreaker.truckParkingClub.failures >= 5) {
            circuitBreaker.truckParkingClub.status = 'OPEN';
        }
        console.error('[ParkingService] TruckParkingClub API failed:', error.message);
        throw error;
    }
}

// ============================================
// TPIMS API FUNCTIONS (Real Sensor Data)
// ============================================

/**
 * Query OHGO (Ohio) TPIMS API for real-time truck parking data
 * Provides sensor-based availability from 16+ rest areas on I-70, I-75
 */
async function queryOHGOAPI(lat, lng, radius) {
    // Check circuit breaker
    if (circuitBreaker.ohgo.status === 'OPEN') {
        if (Date.now() - circuitBreaker.ohgo.lastFailure > 60000) {
            circuitBreaker.ohgo.status = 'HALF_OPEN';
        } else {
            console.log('[TPIMS] OHGO circuit breaker is OPEN, skipping');
            return [];
        }
    }

    try {
        const apiKey = await getSecret(API_CONFIG.TPIMS.OHGO.secretKey).catch(() => null);
        if (!apiKey) {
            console.log('[TPIMS] No OHGO API key configured, skipping');
            return [];
        }

        // Use radius parameter: lat,lng,miles
        const url = `${API_CONFIG.TPIMS.OHGO.baseUrl}/truck-parking?radius=${lat},${lng},${radius}&page-all=true`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `APIKEY ${apiKey}`,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`OHGO API error: ${response.status}`);
        }

        const data = await response.json();

        // Reset circuit breaker on success
        circuitBreaker.ohgo.failures = 0;
        circuitBreaker.ohgo.status = 'CLOSED';

        console.log(`[TPIMS] OHGO returned ${data.results?.length || 0} truck parking locations`);
        return normalizeOHGOData(data.results || []);
    } catch (error) {
        circuitBreaker.ohgo.failures++;
        circuitBreaker.ohgo.lastFailure = Date.now();
        if (circuitBreaker.ohgo.failures >= 3) {
            circuitBreaker.ohgo.status = 'OPEN';
        }
        console.error('[TPIMS] OHGO API failed:', error.message);
        return [];
    }
}

/**
 * Normalize OHGO truck parking data to standard format
 */
function normalizeOHGOData(results) {
    if (!Array.isArray(results)) return [];

    return results.map(item => ({
        external_id: `ohgo_${item.Id}`,
        source: 'ohgo_tpims',
        source_label: 'ODOT Sensors',
        name: item.Description || item.Location || 'Ohio Rest Area',
        location: {
            lat: parseFloat(item.Latitude),
            lng: parseFloat(item.Longitude)
        },
        address: {
            full: item.Address || '',
            city: '',
            state: 'OH'
        },
        total_spaces: parseInt(item.Capacity) || 0,
        available_spaces: item.ReportedAvailable !== null ? parseInt(item.ReportedAvailable) : null,
        is_open: item.Open !== false,
        amenities: ['restroom'], // Ohio rest areas have restrooms
        avg_rating: 0,
        last_availability_update: item.LastReported ? new Date(item.LastReported) : new Date(),
        data_confidence: 'sensor', // Real sensor data!
        highway: item.Location || ''
    }));
}

/**
 * Query Wisconsin 511 TPIMS API
 */
async function queryWI511API(lat, lng, radius) {
    if (circuitBreaker.wi511.status === 'OPEN') {
        if (Date.now() - circuitBreaker.wi511.lastFailure > 60000) {
            circuitBreaker.wi511.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const apiKey = await getSecret(API_CONFIG.TPIMS.WI_511.secretKey).catch(() => null);
        if (!apiKey) return [];

        const url = `${API_CONFIG.TPIMS.WI_511.baseUrl}/GetTruckParking?key=${apiKey}&format=json`;

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`WI 511 API error: ${response.status}`);

        const data = await response.json();

        circuitBreaker.wi511.failures = 0;
        circuitBreaker.wi511.status = 'CLOSED';

        console.log(`[TPIMS] WI 511 returned ${data.length || 0} truck parking locations`);
        return normalizeWI511Data(data || []);
    } catch (error) {
        circuitBreaker.wi511.failures++;
        circuitBreaker.wi511.lastFailure = Date.now();
        if (circuitBreaker.wi511.failures >= 3) {
            circuitBreaker.wi511.status = 'OPEN';
        }
        console.error('[TPIMS] WI 511 API failed:', error.message);
        return [];
    }
}

/**
 * Normalize Wisconsin 511 truck parking data
 */
function normalizeWI511Data(results) {
    if (!Array.isArray(results)) return [];

    return results.map(item => ({
        external_id: `wi511_${item.id || item.Id}`,
        source: 'wi_tpims',
        source_label: 'WisDOT Sensors',
        name: item.name || item.Name || 'Wisconsin Rest Area',
        location: {
            lat: parseFloat(item.latitude || item.Latitude),
            lng: parseFloat(item.longitude || item.Longitude)
        },
        address: {
            full: item.address || '',
            city: '',
            state: 'WI'
        },
        total_spaces: parseInt(item.capacity || item.Capacity) || 0,
        available_spaces: item.availableSpaces !== undefined ? parseInt(item.availableSpaces) : null,
        is_open: true,
        amenities: ['restroom'],
        avg_rating: 0,
        last_availability_update: item.lastUpdated ? new Date(item.lastUpdated) : new Date(),
        data_confidence: 'sensor',
        highway: item.route || ''
    }));
}

// ============================================
// PUBLIC TPIMS FEEDS (No API Key Required!)
// ============================================

/**
 * Query Indiana TPIMS - GeoJSON format
 * Coverage: I-65, I-69, I-70 (19 sites)
 */
async function queryIndianaTPIMS() {
    if (circuitBreaker.indiana.status === 'OPEN') {
        if (Date.now() - circuitBreaker.indiana.lastFailure > 60000) {
            circuitBreaker.indiana.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.INDIANA.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Indiana TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.indiana.failures = 0;
        circuitBreaker.indiana.status = 'CLOSED';

        console.log(`[TPIMS] Indiana returned ${data.features?.length || 0} locations`);
        return normalizeIndianaData(data.features || []);
    } catch (error) {
        circuitBreaker.indiana.failures++;
        circuitBreaker.indiana.lastFailure = Date.now();
        if (circuitBreaker.indiana.failures >= 3) circuitBreaker.indiana.status = 'OPEN';
        console.error('[TPIMS] Indiana failed:', error.message);
        return [];
    }
}

function normalizeIndianaData(features) {
    return features.map(f => {
        const props = f.properties || {};
        const coords = f.geometry?.coordinates || [0, 0];
        // Parse availability from message1 (can be number, "LOW", or "X")
        let available = null;
        if (props.message1 && !isNaN(parseInt(props.message1))) {
            available = parseInt(props.message1);
        } else if (props.message1 === 'LOW') {
            available = 5; // Estimate low as 5
        }

        return {
            external_id: `in_${props.device_nbr || f.id}`,
            source: 'indiana_tpims',
            source_label: 'INDOT Sensors',
            name: props.title || props.description || 'Indiana Rest Area',
            location: { lat: coords[1], lng: coords[0] },
            address: { state: 'IN' },
            total_spaces: parseInt(props.message3) || 0,
            available_spaces: available,
            is_open: props.message1 !== 'X',
            amenities: ['restroom'],
            data_confidence: 'sensor',
            highway: props.route || '',
            last_availability_update: props.ontime ? new Date(props.ontime) : new Date()
        };
    });
}

/**
 * Query Kentucky TPIMS - MAASTO standard format
 * Coverage: I-65, I-71, I-75 (14 sites)
 */
async function queryKentuckyTPIMS() {
    if (circuitBreaker.kentucky.status === 'OPEN') {
        if (Date.now() - circuitBreaker.kentucky.lastFailure > 60000) {
            circuitBreaker.kentucky.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.KENTUCKY.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Kentucky TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.kentucky.failures = 0;
        circuitBreaker.kentucky.status = 'CLOSED';

        console.log(`[TPIMS] Kentucky returned ${Array.isArray(data) ? data.length : 0} locations`);
        return normalizeMAASTO(data, 'KY', 'kentucky_tpims', 'KYTC Sensors');
    } catch (error) {
        circuitBreaker.kentucky.failures++;
        circuitBreaker.kentucky.lastFailure = Date.now();
        if (circuitBreaker.kentucky.failures >= 3) circuitBreaker.kentucky.status = 'OPEN';
        console.error('[TPIMS] Kentucky failed:', error.message);
        return [];
    }
}

/**
 * Query Minnesota TPIMS - MAASTO standard format
 * Coverage: I-94, I-35 (7 sites)
 */
async function queryMinnesotaTPIMS() {
    if (circuitBreaker.minnesota.status === 'OPEN') {
        if (Date.now() - circuitBreaker.minnesota.lastFailure > 60000) {
            circuitBreaker.minnesota.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.MINNESOTA.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Minnesota TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.minnesota.failures = 0;
        circuitBreaker.minnesota.status = 'CLOSED';

        console.log(`[TPIMS] Minnesota returned ${Array.isArray(data) ? data.length : 0} locations`);
        return normalizeMAASTO(data, 'MN', 'minnesota_tpims', 'MnDOT Sensors');
    } catch (error) {
        circuitBreaker.minnesota.failures++;
        circuitBreaker.minnesota.lastFailure = Date.now();
        if (circuitBreaker.minnesota.failures >= 3) circuitBreaker.minnesota.status = 'OPEN';
        console.error('[TPIMS] Minnesota failed:', error.message);
        return [];
    }
}

/**
 * Query Illinois TPIMS - MAASTO standard format
 * Coverage: I-80, I-55, I-57 corridor
 */
async function queryIllinoisTPIMS() {
    if (circuitBreaker.illinois.status === 'OPEN') {
        if (Date.now() - circuitBreaker.illinois.lastFailure > 60000) {
            circuitBreaker.illinois.status = 'HALF_OPEN';
        } else {
            return [];
        }
    }

    try {
        const response = await fetch(API_CONFIG.TPIMS.ILLINOIS.dynamicUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) throw new Error(`Illinois TPIMS error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.illinois.failures = 0;
        circuitBreaker.illinois.status = 'CLOSED';

        console.log(`[TPIMS] Illinois returned ${Array.isArray(data) ? data.length : 0} locations`);
        return normalizeMAASTO(data, 'IL', 'illinois_tpims', 'IDOT Sensors');
    } catch (error) {
        circuitBreaker.illinois.failures++;
        circuitBreaker.illinois.lastFailure = Date.now();
        if (circuitBreaker.illinois.failures >= 3) circuitBreaker.illinois.status = 'OPEN';
        console.error('[TPIMS] Illinois failed:', error.message);
        return [];
    }
}

/**
 * Normalize MAASTO standard format (used by KY, MN, IL)
 * Schema: siteId, timeStamp, reportedAvailable, trend, open, trustData, capacity
 */
function normalizeMAASTO(data, state, source, sourceLabel) {
    if (!Array.isArray(data)) return [];

    return data.map(item => {
        // Parse availability - can be number string, "Low", or "Unknown"
        let available = null;
        if (item.reportedAvailable && !isNaN(parseInt(item.reportedAvailable))) {
            available = parseInt(item.reportedAvailable);
        } else if (item.reportedAvailable === 'Low') {
            available = 5;
        }

        // Extract highway from siteId (e.g., "KY00065IS..." -> I-65)
        const highway = extractHighwayFromSiteId(item.siteId);

        return {
            external_id: `${state.toLowerCase()}_${item.siteId}`,
            source: source,
            source_label: sourceLabel,
            name: item.siteName || `${state} Rest Area`,
            location: {
                lat: item.latitude || item.location?.latitude || 0,
                lng: item.longitude || item.location?.longitude || 0
            },
            address: {
                city: item.city || item.location?.city || '',
                state: state
            },
            total_spaces: parseInt(item.capacity) || 0,
            available_spaces: available,
            is_open: item.open === true || item.open === 'true',
            amenities: item.amenities || ['restroom'],
            data_confidence: item.trustData ? 'sensor' : 'estimated',
            highway: highway,
            trend: item.trend || null,
            last_availability_update: item.timeStamp ? new Date(item.timeStamp) : new Date()
        };
    });
}

function extractHighwayFromSiteId(siteId) {
    if (!siteId) return '';
    // Format: KY00065IS... -> extract route number after state code
    const match = siteId.match(/\d{5}(IS|US|SH)(\d+)/);
    if (match) {
        const type = match[1] === 'IS' ? 'I-' : match[1] === 'US' ? 'US-' : 'SR-';
        return type + parseInt(match[2]);
    }
    return '';
}

/**
 * Aggregate TPIMS data from all available state sources
 * This is the main entry point for real sensor data
 */
async function queryAllTPIMSSources(lat, lng, radius) {
    // Query ALL available TPIMS sources in parallel
    // Public feeds (no key): IN, KY, MN, IL
    // API key required: OH, WI
    const tpimsQueries = [
        // Public feeds - always available
        queryIndianaTPIMS(),
        queryKentuckyTPIMS(),
        queryMinnesotaTPIMS(),
        queryIllinoisTPIMS(),
        // API key feeds - gracefully fail if no key
        queryOHGOAPI(lat, lng, radius),
        queryWI511API(lat, lng, radius)
    ];

    const results = await Promise.all(tpimsQueries);
    const allItems = results.flat();

    console.log(`[TPIMS] Total locations from all 6 sources: ${allItems.length}`);
    return allItems;
}

/**
 * Normalize data from different sources into a standard format
 */
function normalizeParkingData(results, source) {
    if (!Array.isArray(results)) return [];

    return results.map(item => ({
        external_id: item.id || item.external_id,
        source: source,
        name: item.name,
        location: {
            lat: item.latitude || item.lat || item.location?.lat,
            lng: item.longitude || item.lng || item.location?.lng
        },
        address: item.address || {},
        total_spaces: item.total_spaces || 0,
        available_spaces: item.available_spaces || null,
        amenities: item.amenities || [],
        avg_rating: item.rating || 0,
        last_availability_update: item.updated_at || new Date()
    }));
}

const COLLECTIONS = {
    LOCATIONS: 'ParkingLocations',
    REPORTS: 'ParkingReports',
    CACHE: 'RoadUtilityCache'
};

/**
 * Fallback query to ParkMyTruck API
 */
async function queryParkMyTruckAPI(lat, lng, radius) {
    try {
        const apiKey = await getSecret('PARK_MY_TRUCK_API_KEY').catch(() => null);
        if (!apiKey) return []; // Skip if no key

        const response = await fetch(`https://api.parkmytruck.com/v1/search?lat=${lat}&lng=${lng}&radius=${radius}`, {
            headers: { 'X-API-Key': apiKey }
        });

        if (!response.ok) return [];
        const data = await response.json();
        return normalizeParkingData(data.locations, 'parkmytruck');
    } catch (err) {
        return [];
    }
}

/**
 * Query state DOT APIs for rest area status
 * Now integrated with TPIMS for real sensor data
 */
async function queryStateDOTAPIs(lat, lng, radius) {
    // Query all TPIMS sources (OHGO, WI 511, etc.)
    // These provide real-time sensor data from federally-funded systems
    try {
        const tpimsData = await queryAllTPIMSSources(lat, lng, radius);
        return tpimsData;
    } catch (error) {
        console.error('[ParkingService] TPIMS query failed:', error.message);
        return [];
    }
}

/**
 * Search for truck parking near a location
 * @param {number} lat 
 * @param {number} lng 
 * @param {number} radius 
 * @param {Object} filters 
 */
export async function searchParking(lat, lng, radius = 25, filters = {}) {
    const cacheKey = `parking:${lat.toFixed(2)}:${lng.toFixed(2)}:${radius}:${JSON.stringify(filters)}`;
    
    try {
        // 1. Check cache first
        const cached = await wixData.query(COLLECTIONS.CACHE)
            .eq('cache_key', cacheKey)
            .gt('expires_at', new Date())
            .limit(1)
            .find({ suppressAuth: true });
            
        if (cached.items.length > 0) {
            return { success: true, items: cached.items[0].data, fromCache: true };
        }

        // 2. Cache miss: Fetch from multiple sources
        const sources = [
            queryTruckParkingClubAPI(lat, lng, radius).catch(() => []),
            queryParkMyTruckAPI(lat, lng, radius),
            queryStateDOTAPIs(lat, lng, radius),
            // Also include local database locations
            wixData.query(COLLECTIONS.LOCATIONS).limit(100).find({ suppressAuth: true }).then(res => res.items)
        ];

        const allResults = await Promise.all(sources);
        const mergedItems = flattenAndMerge(allResults);

        // Calculate distance and filter by radius
        const filteredItems = mergedItems.map(item => {
            const distance = calculateDistance(lat, lng, item.location.lat, item.location.lng);
            return { ...item, distance_miles: parseFloat(distance.toFixed(2)) };
        }).filter(item => item.distance_miles <= radius);

        // Filter by amenities
        let finalItems = filteredItems;
        if (filters.amenities && Array.isArray(filters.amenities) && filters.amenities.length > 0) {
            finalItems = filteredItems.filter(item => 
                filters.amenities.every(amenity => item.amenities && item.amenities.includes(amenity))
            );
        }

        // Sort by distance
        finalItems.sort((a, b) => a.distance_miles - b.distance_miles);

        // 3. Store in cache
        const expiry = new Date();
        expiry.setMinutes(expiry.getMinutes() + 5);
        
        await wixData.insert(COLLECTIONS.CACHE, {
            cache_key: cacheKey,
            cache_type: 'parking',
            data: finalItems,
            expires_at: expiry
        }, { suppressAuth: true }).catch(err => console.error('Failed to update cache:', err));

        return { success: true, items: finalItems };
    } catch (error) {
        console.error('[ParkingService] searchParking failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Deduplicate and merge results from multiple sources
 * Prioritizes sensor data over estimates
 */
function flattenAndMerge(sourceResults) {
    const merged = new Map();

    // Data confidence ranking (higher = better)
    const confidenceRank = {
        'sensor': 3,      // Real TPIMS sensor data
        'reported': 2,    // Community reports
        'estimated': 1,   // Algorithm estimates
        'unknown': 0      // No data
    };

    sourceResults.flat().forEach(item => {
        // Use coordinates as key for deduplication
        const key = `${item.location.lat.toFixed(3)}:${item.location.lng.toFixed(3)}`;

        if (!merged.has(key)) {
            merged.set(key, item);
        } else {
            const existing = merged.get(key);
            const existingConfidence = confidenceRank[existing.data_confidence] || 0;
            const newConfidence = confidenceRank[item.data_confidence] || 0;

            // Prefer higher confidence data
            if (newConfidence > existingConfidence) {
                merged.set(key, { ...existing, ...item });
            } else if (newConfidence === existingConfidence) {
                // Same confidence: prefer the one with availability data
                if (item.available_spaces !== null && existing.available_spaces === null) {
                    merged.set(key, { ...existing, ...item });
                }
            }
        }
    });

    return Array.from(merged.values());
}

/**
 * Get data source label for UI display
 */
function getSourceLabel(source) {
    const labels = {
        'ohgo_tpims': 'ODOT Sensors',
        'wi_tpims': 'WisDOT Sensors',
        'truckparkingclub': 'TruckParkingClub',
        'parkmytruck': 'ParkMyTruck',
        'community': 'Driver Reports',
        'database': 'LMDR Database'
    };
    return labels[source] || 'Unknown';
}

/**
 * Get detailed info for a specific parking location
 * @param {string} locationId 
 */
export async function getParkingDetails(locationId) {
    if (!locationId) return { success: false, error: 'locationId is required' };
    
    try {
        const item = await wixData.get(COLLECTIONS.LOCATIONS, locationId, { suppressAuth: true });
        if (!item) return { success: false, error: 'Location not found' };
        
        return { success: true, item };
    } catch (error) {
        console.error('[ParkingService] getParkingDetails failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Submit a parking availability report
 * @param {string} locationId 
 * @param {Object} report 
 */
export async function reportParkingAvailability(locationId, report) {
    if (!locationId) return { success: false, error: 'locationId is required' };
    if (!report.driver_id) return { success: false, error: 'driver_id is required' };
    if (typeof report.spaces_available !== 'number' || report.spaces_available < 0) {
        return { success: false, error: 'Invalid spaces available' };
    }

    // Rate limiting: 1 report per location per hour per driver
    const oneHourAgo = new Date(Date.now() - 3600000);
    try {
        const recentReports = await wixData.query(COLLECTIONS.REPORTS)
            .eq('location_id', locationId)
            .eq('driver_id', report.driver_id)
            .gt('reported_at', oneHourAgo)
            .limit(1)
            .find({ suppressAuth: true });

        if (recentReports.items.length > 0) {
            return { success: false, error: 'You have already reported for this location in the last hour' };
        }

        const record = {
            location_id: locationId,
            driver_id: report.driver_id,
            spaces_available: report.spaces_available,
            notes: report.notes || '',
            reported_at: new Date()
        };

        const result = await wixData.insert(COLLECTIONS.REPORTS, record, { suppressAuth: true });
        
        // Trigger availability estimation update (async)
        updateEstimatedAvailability(locationId).catch(err => console.error('Failed to update estimation:', err));

        return { success: true, reportId: result._id };
    } catch (error) {
        console.error('[ParkingService] reportParkingAvailability failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Update the estimated availability for a location based on recent reports
 */
async function updateEstimatedAvailability(locationId) {
    const twoHoursAgo = new Date(Date.now() - 7200000);
    
    const reports = await wixData.query(COLLECTIONS.REPORTS)
        .eq('location_id', locationId)
        .gt('reported_at', twoHoursAgo)
        .descending('reported_at')
        .limit(10)
        .find({ suppressAuth: true });

    if (reports.items.length === 0) return;

    // Simple aggregation: average of recent reports weighted by recency
    let totalWeightedSpaces = 0;
    let totalWeight = 0;
    const now = Date.now();

    reports.items.forEach(report => {
        const ageHours = (now - report.reported_at.getTime()) / 3600000;
        const weight = 1 / (ageHours + 0.5); // Decay weight
        totalWeightedSpaces += report.spaces_available * weight;
        totalWeight += weight;
    });

    const estimatedSpaces = Math.round(totalWeightedSpaces / totalWeight);

    await wixData.update(COLLECTIONS.LOCATIONS, {
        _id: locationId,
        available_spaces: estimatedSpaces,
        availability_confidence: 'estimated',
        last_availability_update: new Date()
    }, { suppressAuth: true });
}

/**
 * Calculate availability status (available, limited, full, unknown)
 */
function calculateAvailabilityStatus(item) {
    if (item.available_spaces === null) return 'unknown';
    
    const ratio = item.total_spaces > 0 ? item.available_spaces / item.total_spaces : 1;
    
    if (item.available_spaces === 0) return 'full';
    if (ratio < 0.1 || item.available_spaces < 5) return 'limited';
    return 'available';
}

/**
 * Get parking along a route
 * @param {Array} routePoints 
 * @param {Object} options 
 */
export async function getParkingAlongRoute(routePoints, options = {}) {
    // Basic implementation: find parking near start, middle, and end
    // A full implementation would check along the entire corridor
    if (!Array.isArray(routePoints) || routePoints.length < 2) {
        return { success: false, error: 'Invalid route points' };
    }

    // Simplified: check near all waypoints provided
    const allResults = [];
    const seenIds = new Set();

    for (const point of routePoints) {
        const nearPoint = await searchParking(point.lat, point.lng, options.radius || 10, options.filters);
        if (nearPoint.success) {
            for (const item of nearPoint.items) {
                if (!seenIds.has(item._id)) {
                    allResults.push(item);
                    seenIds.add(item._id);
                }
            }
        }
    }

    return { success: true, items: allResults };
}
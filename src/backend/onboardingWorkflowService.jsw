import wixUsersBackend from 'wix-users-backend';
import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';
import { awardDriverXP } from 'backend/gamificationService';
import { sendSurveyIfNotSent } from 'backend/surveyService';

// ============================================================================
// CONFIGURATION
// ============================================================================

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    workflows: 'onboardingWorkflows',
    documentRequests: 'documentRequests',
    backgroundChecks: 'backgroundChecks',
    drugTests: 'drugTests',
    orientationSlots: 'orientationSlots',
    driverProfiles: 'driverProfiles',
    carriers: 'carriers',
    recruiterCarriers: 'recruiterCarriers',
    auditLog: 'auditLog'
};

const CONFIG = {
  // Workflow status values (state machine states)
  STATUS: {
    // Initial states
    PENDING: 'pending',
    OFFER_SENT: 'offer_sent',
    OFFER_ACCEPTED: 'offer_accepted',

    // In-progress states
    IN_PROGRESS: 'in_progress',
    DOCUMENTS_PENDING: 'documents_pending',
    DOCUMENTS_REQUESTED: 'documents_requested',
    DOCUMENTS_COMPLETE: 'documents_complete',

    // Background check states
    BACKGROUND_CHECK: 'background_check',
    BACKGROUND_ORDERED: 'background_ordered',
    BACKGROUND_PASSED: 'background_passed',
    BACKGROUND_FAILED: 'background_failed',

    // Drug test states
    DRUG_TEST: 'drug_test',
    DRUG_TEST_SCHEDULED: 'drug_test_scheduled',
    DRUG_TEST_PASSED: 'drug_test_passed',
    DRUG_TEST_FAILED: 'drug_test_failed',

    // Final states
    ORIENTATION: 'orientation',
    ORIENTATION_SCHEDULED: 'orientation_scheduled',
    ORIENTATION_COMPLETED: 'orientation_completed',
    COMPLIANCE_VERIFIED: 'compliance_verified',
    READY: 'ready_to_start',
    COMPLETED: 'completed',

    // Terminal states
    CANCELLED: 'cancelled',
    ON_HOLD: 'on_hold'
  },

  // Sub-status values for components
  DOCUMENTS_STATUS: {
    PENDING: 'pending',
    PARTIAL: 'partial',
    COMPLETE: 'complete'
  },

  BACKGROUND_STATUS: {
    NOT_STARTED: 'not_started',
    ORDERED: 'ordered',
    PROCESSING: 'processing',
    PASSED: 'passed',
    FAILED: 'failed',
    REVIEW: 'review'
  },

  DRUG_TEST_STATUS: {
    NOT_STARTED: 'not_started',
    SCHEDULED: 'scheduled',
    COMPLETED: 'completed',
    PASSED: 'passed',
    FAILED: 'failed',
    NO_SHOW: 'no_show'
  },

  ORIENTATION_STATUS: {
    NOT_SCHEDULED: 'not_scheduled',
    SCHEDULED: 'scheduled',
    COMPLETED: 'completed'
  },

  // Valid state transitions
  VALID_TRANSITIONS: {
    'pending': ['offer_sent', 'in_progress', 'cancelled', 'on_hold'],
    'offer_sent': ['offer_accepted', 'cancelled', 'on_hold'],
    'offer_accepted': ['in_progress', 'documents_requested', 'cancelled', 'on_hold'],
    'in_progress': ['documents_pending', 'documents_requested', 'background_ordered', 'drug_test_scheduled', 'cancelled', 'on_hold'],
    'documents_pending': ['documents_requested', 'documents_complete', 'cancelled', 'on_hold'],
    'documents_requested': ['documents_complete', 'cancelled', 'on_hold'],
    'documents_complete': ['background_ordered', 'background_check', 'compliance_verified', 'cancelled', 'on_hold'],
    'background_check': ['background_ordered', 'background_passed', 'background_failed', 'cancelled', 'on_hold'],
    'background_ordered': ['background_passed', 'background_failed', 'cancelled', 'on_hold'],
    'background_passed': ['drug_test_scheduled', 'drug_test', 'compliance_verified', 'cancelled', 'on_hold'],
    'background_failed': ['cancelled', 'on_hold', 'background_ordered'], // Allow retry
    'drug_test': ['drug_test_scheduled', 'drug_test_passed', 'drug_test_failed', 'cancelled', 'on_hold'],
    'drug_test_scheduled': ['drug_test_passed', 'drug_test_failed', 'cancelled', 'on_hold'],
    'drug_test_passed': ['orientation', 'orientation_scheduled', 'compliance_verified', 'cancelled', 'on_hold'],
    'drug_test_failed': ['cancelled', 'on_hold', 'drug_test_scheduled'], // Allow retry
    'orientation': ['orientation_scheduled', 'orientation_completed', 'cancelled', 'on_hold'],
    'orientation_scheduled': ['orientation_completed', 'cancelled', 'on_hold'],
    'orientation_completed': ['compliance_verified', 'ready_to_start', 'cancelled', 'on_hold'],
    'compliance_verified': ['ready_to_start', 'cancelled', 'on_hold'],
    'ready_to_start': ['completed', 'cancelled', 'on_hold'],
    'completed': [], // Terminal state - no transitions
    'cancelled': ['pending'], // Allow restart
    'on_hold': ['pending', 'in_progress', 'documents_pending', 'background_check', 'drug_test', 'orientation', 'cancelled'] // Resume to various states
  },

  // Error codes
  ERROR_CODES: {
    UNAUTHORIZED: 'ERR_UNAUTHORIZED',
    NOT_FOUND: 'ERR_NOT_FOUND',
    INVALID_TRANSITION: 'ERR_INVALID_TRANSITION',
    VALIDATION_FAILED: 'ERR_VALIDATION_FAILED',
    DATABASE_ERROR: 'ERR_DATABASE_ERROR',
    DUPLICATE_WORKFLOW: 'ERR_DUPLICATE_WORKFLOW'
  }
};

// ============================================================================
// ERROR HANDLING
// ============================================================================

class OnboardingError extends Error {
  constructor(code, message, details = {}) {
    super(message);
    this.name = 'OnboardingError';
    this.code = code;
    this.details = details;
  }
}

function createErrorResponse(code, message, details = {}) {
  return {
    success: false,
    error: {
      code,
      message,
      details
    }
  };
}

// ============================================================================
// AUTHORIZATION
// ============================================================================

/**
 * Get current user ID
 */
async function getCurrentUserId() {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) {
      return null;
    }
    return currentUser.id;
  } catch (error) {
    console.error('getCurrentUserId error:', error);
    return null;
  }
}

/**
 * Check if current user is a recruiter with access to a carrier
 */
async function verifyRecruiterAccess(carrierId) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      return { authorized: false, error: 'Not authenticated' };
    }

    // Get carrier DOT from carrier ID
    const carrier = await dataAccess.getRecord(COLLECTION_KEYS.carriers, carrierId, { suppressAuth: true });
    if (!carrier) {
      return { authorized: false, error: 'Carrier not found' };
    }

    const carrierDot = String(carrier.dot_number).trim();

    // Check RecruiterCarriers for access
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: {
        recruiter_id: userId,
        carrier_dot: carrierDot,
        is_active: true
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { authorized: false, error: 'No access to this carrier' };
    }

    return { authorized: true, recruiterId: userId, carrierDot, carrierAccess: result.items[0] };
  } catch (error) {
    console.error('verifyRecruiterAccess error:', error);
    return { authorized: false, error: error.message };
  }
}

/**
 * Check if current user is a carrier admin
 */
async function verifyCarrierAdminAccess(carrierId) {
  try {
    const member = await currentMember.getMember({ fieldsets: ['FULL'] });
    if (!member) {
      return { authorized: false, error: 'Not authenticated' };
    }

    const memberRole = member.contactDetails?.customFields?.role || '';
    const memberCarrierId = member.contactDetails?.customFields?.carrier_id || '';

    if (memberRole === 'carrier_admin' && memberCarrierId === carrierId) {
      return { authorized: true, adminId: member._id };
    }

    return { authorized: false, error: 'Not a carrier admin for this carrier' };
  } catch (error) {
    console.error('verifyCarrierAdminAccess error:', error);
    return { authorized: false, error: error.message };
  }
}

/**
 * Verify user has access to a workflow
 */
async function verifyWorkflowAccess(workflowId) {
  try {
    const workflow = await dataAccess.getRecord(COLLECTION_KEYS.workflows, workflowId, { suppressAuth: true });
    if (!workflow) {
      return { authorized: false, error: 'Workflow not found', workflow: null };
    }

    const userId = await getCurrentUserId();
    if (!userId) {
      return { authorized: false, error: 'Not authenticated', workflow };
    }

    if (workflow.recruiter_id === userId) {
      return { authorized: true, role: 'recruiter', userId, workflow };
    }

    const recruiterAccess = await verifyRecruiterAccess(workflow.carrier_id);
    if (recruiterAccess.authorized) {
      return { authorized: true, role: 'recruiter', userId, workflow };
    }

    const carrierAdminAccess = await verifyCarrierAdminAccess(workflow.carrier_id);
    if (carrierAdminAccess.authorized) {
      return { authorized: true, role: 'carrier_admin', userId, workflow };
    }

    return { authorized: false, error: 'No access to this workflow', workflow };
  } catch (error) {
    console.error('verifyWorkflowAccess error:', error);
    return { authorized: false, error: error.message, workflow: null };
  }
}

// ============================================================================
// AUDIT LOGGING
// ============================================================================

async function logAuditEvent(action, targetType, targetId, details, actorId = null) {
  try {
    const userId = actorId || await getCurrentUserId();
    let actorEmail = 'system';

    if (userId) {
      try {
        const currentUser = wixUsersBackend.currentUser;
        actorEmail = await currentUser.getEmail();
      } catch (e) { /* ignore */ }
    }

    const auditEntry = {
      action, targetType, targetId, details,
      adminId: userId || 'system',
      adminEmail: actorEmail,
      timestamp: new Date()
    };

    await dataAccess.insertRecord(COLLECTION_KEYS.auditLog, auditEntry, { suppressAuth: true });
  } catch (error) {
    console.error('Audit logging failed:', error);
  }
}

// ============================================================================
// STATE MACHINE
// ============================================================================

function isValidTransition(currentStatus, newStatus) {
  const validNextStates = CONFIG.VALID_TRANSITIONS[currentStatus];
  return validNextStates ? validNextStates.includes(newStatus) : false;
}

function getValidNextStates(currentStatus) {
  return CONFIG.VALID_TRANSITIONS[currentStatus] || [];
}

// ============================================================================
// CREATE ONBOARDING WORKFLOW
// ============================================================================

export async function createOnboardingWorkflow(driverId, carrierId, recruiterId = null, config = {}) {
  try {
    if (!driverId || !carrierId) return createErrorResponse(CONFIG.ERROR_CODES.VALIDATION_FAILED, 'Missing required fields');

    const accessCheck = await verifyRecruiterAccess(carrierId);
    if (!accessCheck.authorized) return createErrorResponse(CONFIG.ERROR_CODES.UNAUTHORIZED, accessCheck.error);

    const effectiveRecruiterId = recruiterId || accessCheck.recruiterId;

    const driver = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, driverId, { suppressAuth: true });
    if (!driver) return createErrorResponse(CONFIG.ERROR_CODES.NOT_FOUND, 'Driver profile not found');

    const carrier = await dataAccess.getRecord(COLLECTION_KEYS.carriers, carrierId, { suppressAuth: true });
    if (!carrier) return createErrorResponse(CONFIG.ERROR_CODES.NOT_FOUND, 'Carrier not found');

    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.workflows, {
      filters: {
        driver_id: driverId,
        carrier_id: carrierId,
        status: { ne: [CONFIG.STATUS.COMPLETED, CONFIG.STATUS.CANCELLED] }
      },
      limit: 1,
      suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      return createErrorResponse(CONFIG.ERROR_CODES.DUPLICATE_WORKFLOW, 'An active onboarding workflow already exists', { existingWorkflowId: existingResult.items[0]._id });
    }

    const now = new Date();
    const workflowData = {
      driver_id: driverId, carrier_id: carrierId, recruiter_id: effectiveRecruiterId,
      status: CONFIG.STATUS.PENDING, start_date: config.startDate ? new Date(config.startDate) : null,
      actual_start_date: null, offer_letter_id: config.offerLetterId || null,
      documents_status: CONFIG.DOCUMENTS_STATUS.PENDING,
      background_status: config.skipBackgroundCheck ? CONFIG.BACKGROUND_STATUS.PASSED : CONFIG.BACKGROUND_STATUS.NOT_STARTED,
      drug_test_status: config.skipDrugTest ? CONFIG.DRUG_TEST_STATUS.PASSED : CONFIG.DRUG_TEST_STATUS.NOT_STARTED,
      orientation_status: config.skipOrientation ? CONFIG.ORIENTATION_STATUS.COMPLETED : CONFIG.ORIENTATION_STATUS.NOT_SCHEDULED,
      compliance_verified: false, compliance_issues: [],
      skip_background_check: config.skipBackgroundCheck || false,
      skip_drug_test: config.skipDrugTest || false,
      skip_orientation: config.skipOrientation || false,
      metadata: {
        created_by: effectiveRecruiterId, carrier_dot: accessCheck.carrierDot,
        driver_name: driver.display_name || driver.driver_name || 'Unknown',
        carrier_name: carrier.legal_name || carrier.title || 'Unknown'
      },
      status_history: JSON.stringify([{ status: CONFIG.STATUS.PENDING, timestamp: now.toISOString(), actor: effectiveRecruiterId, note: 'Workflow created' }]),
      _createdDate: now, _updatedDate: now
    };

    const insertedResult = await dataAccess.insertRecord(COLLECTION_KEYS.workflows, workflowData);
    if (!insertedResult.success) throw new Error(insertedResult.error);
    
    const workflowId = insertedResult.record._id;
    await dataAccess.updateRecord(COLLECTION_KEYS.driverProfiles, {
      ...driver, active_workflow_id: workflowId, onboarding_status: 'in_progress', updated_date: now
    }, { suppressAuth: true });

    await logAuditEvent('createOnboardingWorkflow', 'workflow', workflowId, { driverId, carrierId, driverName: workflowData.metadata.driver_name, carrierName: workflowData.metadata.carrier_name }, effectiveRecruiterId);

    return { success: true, workflow: insertedResult.record, workflowId, nextSteps: calculateNextSteps(insertedResult.record) };
  } catch (error) {
    console.error('createOnboardingWorkflow error:', error);
    return createErrorResponse(CONFIG.ERROR_CODES.DATABASE_ERROR, error.message);
  }
}

// ============================================================================
// GET WORKFLOW STATUS
// ============================================================================

export async function getWorkflowStatus(workflowId) {
  try {
    if (!workflowId) return createErrorResponse(CONFIG.ERROR_CODES.VALIDATION_FAILED, 'Workflow ID is required');

    const accessCheck = await verifyWorkflowAccess(workflowId);
    if (!accessCheck.authorized) return createErrorResponse(CONFIG.ERROR_CODES.UNAUTHORIZED, accessCheck.error);

    const workflow = accessCheck.workflow;
    const [documents, backgroundChecks, drugTests] = await Promise.all([
      getWorkflowDocuments(workflowId),
      getWorkflowBackgroundChecks(workflowId),
      getWorkflowDrugTests(workflowId)
    ]);

    let orientationBooking = null;
    if (workflow.orientation_slot_id) {
      orientationBooking = await dataAccess.getRecord(COLLECTION_KEYS.orientationSlots, workflow.orientation_slot_id, { suppressAuth: true });
    }

    let statusHistory = [];
    try { statusHistory = workflow.status_history ? JSON.parse(workflow.status_history) : []; } catch (e) { }

    return {
      success: true, workflow: { ...workflow, status_history: statusHistory },
      documents, backgroundChecks, drugTests, orientationBooking,
      progress: calculateWorkflowProgress(workflow),
      daysInProcess: Math.floor((new Date() - new Date(workflow._createdDate)) / (1000 * 60 * 60 * 24)),
      validNextStates: getValidNextStates(workflow.status),
      accessRole: accessCheck.role
    };
  } catch (error) {
    console.error('getWorkflowStatus error:', error);
    return createErrorResponse(CONFIG.ERROR_CODES.DATABASE_ERROR, error.message);
  }
}

// ============================================================================
// GET ACTIVE WORKFLOWS
// ============================================================================

export async function getActiveWorkflows(filters = {}) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return createErrorResponse(CONFIG.ERROR_CODES.UNAUTHORIZED, 'Not authenticated');

    const { recruiterId, carrierId, status, driverId, dateRange, page = 1, pageSize = 50, includeCompleted = false } = filters;
    const effectiveRecruiterId = recruiterId || userId;
    
    const queryFilters = { recruiter_id: effectiveRecruiterId };
    if (carrierId) queryFilters.carrier_id = carrierId;
    if (status && status !== 'all') queryFilters.status = status;
    else if (!includeCompleted) queryFilters.status = { ne: [CONFIG.STATUS.COMPLETED, CONFIG.STATUS.CANCELLED] };
    if (driverId) queryFilters.driver_id = driverId;
    if (dateRange?.from) queryFilters._createdDate = { gte: new Date(dateRange.from) };
    // Handle upper date range if needed

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.workflows, {
      filters: queryFilters,
      sort: [{ field: '_updatedDate', direction: 'desc' }],
      limit: pageSize,
      skip: (page - 1) * pageSize,
      suppressAuth: true
    });

    if (!result.success) throw new Error(result.error);

    const enrichedWorkflows = (result.items || []).map(workflow => ({
      ...workflow,
      progress: calculateWorkflowProgress(workflow),
      daysInProcess: Math.floor((new Date() - new Date(workflow._createdDate)) / (1000 * 60 * 60 * 24)),
      driverName: workflow.metadata?.driver_name || 'Unknown',
      carrierName: workflow.metadata?.carrier_name || 'Unknown'
    }));

    return {
      success: true, workflows: enrichedWorkflows,
      totalCount: result.totalCount || enrichedWorkflows.length,
      page, pageSize, totalPages: Math.ceil((result.totalCount || enrichedWorkflows.length) / pageSize)
    };
  } catch (error) {
    console.error('getActiveWorkflows error:', error);
    return createErrorResponse(CONFIG.ERROR_CODES.DATABASE_ERROR, error.message);
  }
}

// ============================================================================
// UPDATE WORKFLOW STATUS
// ============================================================================

export async function updateWorkflowStatus(workflowId, newStatus, metadata = {}) {
  try {
    if (!workflowId || !newStatus) return createErrorResponse(CONFIG.ERROR_CODES.VALIDATION_FAILED, 'Missing required fields');

    const accessCheck = await verifyWorkflowAccess(workflowId);
    if (!accessCheck.authorized) return createErrorResponse(CONFIG.ERROR_CODES.UNAUTHORIZED, accessCheck.error);

    const workflow = accessCheck.workflow;
    if (!isValidTransition(workflow.status, newStatus)) {
      return createErrorResponse(CONFIG.ERROR_CODES.INVALID_TRANSITION, `Invalid status transition`, { currentStatus: workflow.status, newStatus });
    }

    const now = new Date();
    let statusHistory = [];
    try { statusHistory = workflow.status_history ? JSON.parse(workflow.status_history) : []; } catch (e) { }

    statusHistory.push({ status: newStatus, previousStatus: workflow.status, timestamp: now.toISOString(), actor: accessCheck.userId, note: metadata.note });

    const workflowUpdatePayload = {
      ...workflow, _id: workflow._id || workflow.id, status: newStatus,
      status_history: JSON.stringify(statusHistory), _updatedDate: now
    };

    if (metadata.subStatuses) Object.assign(workflowUpdatePayload, metadata.subStatuses);

    if (newStatus === CONFIG.STATUS.COMPLETED) {
      workflowUpdatePayload.actual_start_date = now;
      const driver = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, workflow.driver_id, { suppressAuth: true });
      if (driver) await dataAccess.updateRecord(COLLECTION_KEYS.driverProfiles, { ...driver, onboarding_status: 'complete', active_workflow_id: null, updated_date: now }, { suppressAuth: true });
    }

    if (newStatus === CONFIG.STATUS.CANCELLED) {
      const driver = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, workflow.driver_id, { suppressAuth: true });
      if (driver) await dataAccess.updateRecord(COLLECTION_KEYS.driverProfiles, { ...driver, onboarding_status: 'not_started', active_workflow_id: null, updated_date: now }, { suppressAuth: true });
    }

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.workflows, workflowUpdatePayload, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    await logAuditEvent('updateWorkflowStatus', 'workflow', workflowId, { previousStatus: workflow.status, newStatus, note: metadata.note }, accessCheck.userId);

    // Trigger orientation survey immediately when orientation is marked complete
    if (newStatus === CONFIG.STATUS.ORIENTATION_COMPLETED) {
      sendSurveyIfNotSent(workflow.driver_id, workflow.carrier_id, 'ORIENTATION')
        .catch(e => console.warn('Orientation survey trigger failed:', e.message));
    }

    // Award gamification XP for key Phase 7 & Phase 9 milestones
    const driverId = workflow.driver_id;
    if (newStatus === CONFIG.STATUS.BACKGROUND_ORDERED) {
      await awardDriverXP(driverId, 'bgc_consent_submitted').catch(e => console.warn('XP award failed (bgc_consent_submitted):', e.message));
    } else if (newStatus === CONFIG.STATUS.BACKGROUND_PASSED) {
      await awardDriverXP(driverId, 'screening_passed').catch(e => console.warn('XP award failed (screening_passed):', e.message));
    } else if (newStatus === CONFIG.STATUS.DRUG_TEST_PASSED) {
      await awardDriverXP(driverId, 'drug_test_completed').catch(e => console.warn('XP award failed (drug_test_completed):', e.message));
    } else if (newStatus === CONFIG.STATUS.COMPLETED) {
      await awardDriverXP(driverId, 'hire_completed').catch(e => console.warn('XP award failed (hire_completed):', e.message));
    }

    return { success: true, workflow: result.record, nextSteps: calculateNextSteps(result.record) };
  } catch (error) {
    console.error('updateWorkflowStatus error:', error);
    return createErrorResponse(CONFIG.ERROR_CODES.DATABASE_ERROR, error.message);
  }
}

// ============================================================================
// CANCEL WORKFLOW
// ============================================================================

export async function cancelWorkflow(workflowId, reason = '') {
  try {
    if (!workflowId) return createErrorResponse(CONFIG.ERROR_CODES.VALIDATION_FAILED, 'Workflow ID is required');

    const accessCheck = await verifyWorkflowAccess(workflowId);
    if (!accessCheck.authorized) return createErrorResponse(CONFIG.ERROR_CODES.UNAUTHORIZED, accessCheck.error);

    const workflow = accessCheck.workflow;
    if (workflow.status === CONFIG.STATUS.CANCELLED || workflow.status === CONFIG.STATUS.COMPLETED) {
      return createErrorResponse(CONFIG.ERROR_CODES.INVALID_TRANSITION, 'Workflow cannot be cancelled');
    }

    const now = new Date();
    let statusHistory = [];
    try { statusHistory = workflow.status_history ? JSON.parse(workflow.status_history) : []; } catch (e) { }

    statusHistory.push({ status: CONFIG.STATUS.CANCELLED, previousStatus: workflow.status, timestamp: now.toISOString(), actor: accessCheck.userId, note: reason || 'Workflow cancelled' });

    const cancelPayload = {
      ...workflow, _id: workflow._id || workflow.id, status: CONFIG.STATUS.CANCELLED,
      status_history: JSON.stringify(statusHistory), cancellation_reason: reason,
      cancelled_date: now, cancelled_by: accessCheck.userId, _updatedDate: now
    };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.workflows, cancelPayload, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    const driver = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, workflow.driver_id, { suppressAuth: true });
    if (driver) await dataAccess.updateRecord(COLLECTION_KEYS.driverProfiles, { ...driver, onboarding_status: 'not_started', active_workflow_id: null, updated_date: now }, { suppressAuth: true });

    const pendingDocs = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, {
      filters: { workflow_id: workflowId, status: 'requested' }, suppressAuth: true
    });
    for (const doc of (pendingDocs.items || [])) {
      await dataAccess.updateRecord(COLLECTION_KEYS.documentRequests, { ...doc, status: 'cancelled', cancelled_date: now }, { suppressAuth: true });
    }

    await logAuditEvent('cancelWorkflow', 'workflow', workflowId, { previousStatus: workflow.status, reason }, accessCheck.userId);

    return { success: true, workflow: result.record, reason };
  } catch (error) {
    console.error('cancelWorkflow error:', error);
    return createErrorResponse(CONFIG.ERROR_CODES.DATABASE_ERROR, error.message);
  }
}

// ============================================================================
// GET COMPLIANCE CHECKLIST
// ============================================================================

export async function getComplianceChecklist(workflowId) {
  try {
    if (!workflowId) return createErrorResponse(CONFIG.ERROR_CODES.VALIDATION_FAILED, 'Workflow ID is required');

    const accessCheck = await verifyWorkflowAccess(workflowId);
    if (!accessCheck.authorized) return createErrorResponse(CONFIG.ERROR_CODES.UNAUTHORIZED, accessCheck.error);

    const workflow = accessCheck.workflow;
    let carrierConfig = {
      required_documents: ['cdl_front', 'cdl_back', 'mvr', 'medical_card', 'drug_test_consent'],
      optional_documents: ['psp', 'employment_history'],
      background_check_required: true, drug_test_required: true, orientation_required: true
    };

    const carrier = await dataAccess.getRecord(COLLECTION_KEYS.carriers, workflow.carrier_id, { suppressAuth: true });
    if (carrier?.onboarding_config) Object.assign(carrierConfig, carrier.onboarding_config);

    const documents = await getWorkflowDocuments(workflowId);
    const documentChecklist = carrierConfig.required_documents.map(docType => {
      const doc = documents.find(d => d.document_type === docType);
      return {
        type: docType, displayName: getDocumentDisplayName(docType), required: true,
        status: doc ? doc.status : 'not_requested', submitted: doc && doc.status !== 'requested',
        verified: doc && doc.status === 'verified', submittedDate: doc?.submitted_date, verifiedDate: doc?.verified_date
      };
    });

    carrierConfig.optional_documents.forEach(docType => {
      const doc = documents.find(d => d.document_type === docType);
      documentChecklist.push({
        type: docType, displayName: getDocumentDisplayName(docType), required: false,
        status: doc ? doc.status : 'not_requested', submitted: doc && doc.status !== 'requested',
        verified: doc && doc.status === 'verified', submittedDate: doc?.submitted_date, verifiedDate: doc?.verified_date
      });
    });

    const requiredDocs = documentChecklist.filter(d => d.required);
    const completedRequiredDocs = requiredDocs.filter(d => d.verified);
    const documentProgress = requiredDocs.length > 0 ? Math.round((completedRequiredDocs.length / requiredDocs.length) * 100) : 100;

    const checklist = {
      documents: { items: documentChecklist, completedCount: completedRequiredDocs.length, totalRequired: requiredDocs.length, progress: documentProgress, status: documentProgress === 100 ? 'complete' : 'incomplete' },
      backgroundCheck: { required: carrierConfig.background_check_required && !workflow.skip_background_check, status: workflow.background_status, passed: workflow.background_status === CONFIG.BACKGROUND_STATUS.PASSED, skipped: workflow.skip_background_check },
      drugTest: { required: carrierConfig.drug_test_required && !workflow.skip_drug_test, status: workflow.drug_test_status, passed: workflow.drug_test_status === CONFIG.DRUG_TEST_STATUS.PASSED, skipped: workflow.skip_drug_test },
      orientation: { required: carrierConfig.orientation_required && !workflow.skip_orientation, status: workflow.orientation_status, completed: workflow.orientation_status === CONFIG.ORIENTATION_STATUS.COMPLETED, skipped: workflow.skip_orientation }
    };

    const issues = [];
    let isCompliant = true;
    if (checklist.documents.status !== 'complete') {
      isCompliant = false;
      issues.push(`Missing documents: ${requiredDocs.filter(d => !d.verified).map(d => d.displayName).join(', ')}`);
    }
    if (checklist.backgroundCheck.required && !checklist.backgroundCheck.passed) isCompliant = false;
    if (checklist.drugTest.required && !checklist.drugTest.passed) isCompliant = false;
    if (checklist.orientation.required && !checklist.orientation.completed) isCompliant = false;

    return { success: true, workflowId, checklist, isCompliant, issues, readyToStart: isCompliant && workflow.status !== CONFIG.STATUS.CANCELLED };
  } catch (error) {
    console.error('getComplianceChecklist error:', error);
    return createErrorResponse(CONFIG.ERROR_CODES.DATABASE_ERROR, error.message);
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

async function getWorkflowDocuments(workflowId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.documentRequests, { filters: { workflow_id: workflowId }, suppressAuth: true });
    return result.items || [];
  } catch (error) { return []; }
}

async function getWorkflowBackgroundChecks(workflowId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.backgroundChecks, { filters: { workflow_id: workflowId }, sort: [{ field: 'ordered_date', direction: 'desc' }], suppressAuth: true });
    return result.items || [];
  } catch (error) { return []; }
}

async function getWorkflowDrugTests(workflowId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.drugTests, { filters: { workflow_id: workflowId }, sort: [{ field: '_createdDate', direction: 'desc' }], suppressAuth: true });
    return result.items || [];
  } catch (error) { return []; }
}

function calculateWorkflowProgress(workflow) {
  const statusWeights = {
    [CONFIG.STATUS.PENDING]: 0, [CONFIG.STATUS.OFFER_SENT]: 5, [CONFIG.STATUS.OFFER_ACCEPTED]: 10, [CONFIG.STATUS.IN_PROGRESS]: 15,
    [CONFIG.STATUS.DOCUMENTS_PENDING]: 20, [CONFIG.STATUS.DOCUMENTS_REQUESTED]: 25, [CONFIG.STATUS.DOCUMENTS_COMPLETE]: 40,
    [CONFIG.STATUS.BACKGROUND_CHECK]: 45, [CONFIG.STATUS.BACKGROUND_ORDERED]: 50, [CONFIG.STATUS.BACKGROUND_PASSED]: 60,
    [CONFIG.STATUS.DRUG_TEST]: 65, [CONFIG.STATUS.DRUG_TEST_SCHEDULED]: 70, [CONFIG.STATUS.DRUG_TEST_PASSED]: 80,
    [CONFIG.STATUS.ORIENTATION]: 82, [CONFIG.STATUS.ORIENTATION_SCHEDULED]: 85, [CONFIG.STATUS.ORIENTATION_COMPLETED]: 90,
    [CONFIG.STATUS.COMPLIANCE_VERIFIED]: 95, [CONFIG.STATUS.READY]: 98, [CONFIG.STATUS.COMPLETED]: 100, [CONFIG.STATUS.CANCELLED]: 0
  };
  return statusWeights[workflow.status] ?? 0;
}

function calculateNextSteps(workflow) {
  const steps = [];
  switch (workflow.status) {
    case CONFIG.STATUS.PENDING: steps.push({ action: 'send_offer', label: 'Send offer letter', priority: 'high' }); break;
    case CONFIG.STATUS.OFFER_SENT: steps.push({ action: 'await_acceptance', label: 'Waiting for acceptance', priority: 'medium' }); break;
    case CONFIG.STATUS.OFFER_ACCEPTED:
    case CONFIG.STATUS.IN_PROGRESS:
      if (workflow.documents_status !== CONFIG.DOCUMENTS_STATUS.COMPLETE) steps.push({ action: 'request_documents', label: 'Request documents', priority: 'high' });
      if (!workflow.skip_background_check && workflow.background_status === CONFIG.BACKGROUND_STATUS.NOT_STARTED) steps.push({ action: 'order_background_check', label: 'Order background check', priority: 'high' });
      if (!workflow.skip_drug_test && workflow.drug_test_status === CONFIG.DRUG_TEST_STATUS.NOT_STARTED) steps.push({ action: 'schedule_drug_test', label: 'Schedule drug test', priority: 'high' });
      break;
    case CONFIG.STATUS.DOCUMENTS_COMPLETE:
      if (!workflow.skip_background_check && workflow.background_status === CONFIG.BACKGROUND_STATUS.NOT_STARTED) steps.push({ action: 'order_background_check', label: 'Order background check', priority: 'high' });
      break;
    case CONFIG.STATUS.BACKGROUND_ORDERED: steps.push({ action: 'await_background_check', label: 'Waiting for results', priority: 'medium' }); break;
    case CONFIG.STATUS.BACKGROUND_PASSED:
    case CONFIG.STATUS.DRUG_TEST_PASSED:
      if (!workflow.skip_orientation && workflow.orientation_status === CONFIG.ORIENTATION_STATUS.NOT_SCHEDULED) steps.push({ action: 'schedule_orientation', label: 'Schedule orientation', priority: 'high' });
      break;
    case CONFIG.STATUS.ORIENTATION_SCHEDULED: steps.push({ action: 'await_orientation', label: 'Waiting for orientation', priority: 'medium' }); break;
    case CONFIG.STATUS.ORIENTATION_COMPLETED:
    case CONFIG.STATUS.COMPLIANCE_VERIFIED: steps.push({ action: 'mark_ready', label: 'Mark ready to start', priority: 'high' }); break;
    case CONFIG.STATUS.READY: steps.push({ action: 'complete_onboarding', label: 'Complete onboarding', priority: 'high' }); break;
    case CONFIG.STATUS.ON_HOLD: steps.push({ action: 'resume_workflow', label: 'Resume workflow', priority: 'medium' }); break;
  }
  return steps;
}

function getDocumentDisplayName(docType) {
  const displayNames = { 'cdl_front': 'CDL Front', 'cdl_back': 'CDL Back', 'mvr': 'MVR', 'medical_card': 'DOT Medical Card', 'drug_test_consent': 'Drug Test Consent' };
  return displayNames[docType] || docType;
}

export const WORKFLOW_STATUS = CONFIG.STATUS;
export const WORKFLOW_ERROR_CODES = CONFIG.ERROR_CODES;

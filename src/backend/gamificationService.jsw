/**
 * Gamification Service
 *
 * Core service for the gamification system handling XP/points awards,
 * level/rank progression, and event logging.
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import * as dataAccess from 'backend/dataAccess';
import * as gamificationCache from 'backend/gamificationCache';
import {
  DRIVER_LEVELS,
  RECRUITER_RANKS,
  getLevelForXP,
  getRankForPoints,
  getStreakMultiplier,
  getDriverXPConfig,
  getRecruiterPointsConfig,
  isRateLimited
} from 'backend/gamificationConfig';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
  driverProgression: 'driverProgression',
  driverAchievements: 'driverAchievements',
  driverChallenges: 'driverChallenges',
  recruiterProgression: 'recruiterProgression',
  recruiterBadges: 'recruiterBadges',
  gamificationEvents: 'gamificationEvents',
  seasonalEvents: 'seasonalEvents'
};

// =============================================================================
// INITIALIZATION
// =============================================================================

export async function initializeProgression(userId, userType) {
  try {
    const now = new Date().toISOString();
    if (userType === 'driver') {
      const existing = await dataAccess.queryRecords(COLLECTION_KEYS.driverProgression, { filters: { driver_id: userId }, limit: 1, suppressAuth: true });
      if (existing.items?.length) return normalizeDriverProgression(existing.items[0]);

      const result = await dataAccess.insertRecord(COLLECTION_KEYS.driverProgression, { driver_id: userId, current_xp: 0, level: 1, level_title: DRIVER_LEVELS[0].title, xp_to_next_level: DRIVER_LEVELS[1].xpRequired, streak_days: 0, longest_streak: 0, streak_freeze_available: 1, created_at: now, updated_at: now }, { suppressAuth: true });
      return normalizeDriverProgression(result.record);
    } else if (userType === 'recruiter') {
      const existing = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterProgression, { filters: { recruiter_id: userId }, limit: 1, suppressAuth: true });
      if (existing.items?.length) return normalizeRecruiterProgression(existing.items[0]);

      const result = await dataAccess.insertRecord(COLLECTION_KEYS.recruiterProgression, { recruiter_id: userId, current_points: 0, rank: 1, rank_title: RECRUITER_RANKS[0].title, points_to_next_rank: RECRUITER_RANKS[1].pointsRequired, total_hires: 0, created_at: now, updated_at: now }, { suppressAuth: true });
      return normalizeRecruiterProgression(result.record);
    }
    throw new Error('Invalid user type');
  } catch (error) { throw error; }
}

// =============================================================================
// GET PROGRESSION
// =============================================================================

export async function getDriverProgression(driverId, options = {}) {
  const fetchProgression = async () => {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverProgression, { filters: { driver_id: driverId }, limit: 1, suppressAuth: true });
    const progression = res.items?.length ? normalizeDriverProgression(res.items[0]) : await initializeProgression(driverId, 'driver');
    return { ...progression, levelInfo: getLevelForXP(progression.currentXP), streakMultiplier: getStreakMultiplier(progression.streakDays, 'driver'), nextLevelUnlock: DRIVER_LEVELS[progression.level]?.unlock || null };
  };
  return options.skipCache ? await fetchProgression() : await gamificationCache.getDriverProgression(driverId, fetchProgression);
}

export async function getRecruiterProgression(recruiterId, options = {}) {
  const fetchProgression = async () => {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterProgression, { filters: { recruiter_id: recruiterId }, limit: 1, suppressAuth: true });
    const progression = res.items?.length ? normalizeRecruiterProgression(res.items[0]) : await initializeProgression(recruiterId, 'recruiter');
    return { ...progression, rankInfo: getRankForPoints(progression.currentPoints), nextRankUnlock: RECRUITER_RANKS[progression.rank]?.unlock || null };
  };
  return options.skipCache ? await fetchProgression() : await gamificationCache.getRecruiterProgression(recruiterId, fetchProgression);
}

// =============================================================================
// AWARD XP / POINTS
// =============================================================================

export async function awardDriverXP(driverId, action, metadata = {}) {
  try {
    const xpConfig = getDriverXPConfig(action);
    if (!xpConfig) return { success: false, reason: 'unknown_action' };

    const progression = await getDriverProgression(driverId);
    if (xpConfig.oneTime && await hasEarnedOneTimeXP(driverId, action)) return { success: false, reason: 'already_earned' };

    const streakMult = getStreakMultiplier(progression.streakDays, 'driver');
    const eventMult = await getActiveEventMultiplier('driver');
    const xpEarned = Math.round(xpConfig.xp * streakMult * eventMult);

    const newXP = progression.currentXP + xpEarned;
    const info = getLevelForXP(newXP);
    const leveledUp = info.level > progression.level;

    await dataAccess.updateRecord(COLLECTION_KEYS.driverProgression, { ...progression, _id: progression._id, current_xp: newXP, level: info.level, level_title: info.title, xp_to_next_level: info.xpToNext, updated_at: new Date().toISOString() }, { suppressAuth: true });
    gamificationCache.invalidateDriverProgression(driverId);

    await logGamificationEvent(driverId, 'driver', { eventType: leveledUp ? 'level_up' : 'xp_earned', action, xpEarned, streakBonus: streakMult, metadata });
    return { success: true, xp_earned: xpEarned, total_xp: newXP, level: info.level, level_up: leveledUp };
  } catch (error) { throw error; }
}

export async function awardRecruiterPoints(recruiterId, action, metadata = {}) {
  try {
    const ptsConfig = getRecruiterPointsConfig(action);
    if (!ptsConfig) return { success: false, reason: 'unknown_action' };

    const progression = await getRecruiterProgression(recruiterId);
    if (ptsConfig.oneTime && await hasEarnedOneTimePoints(recruiterId, action)) return { success: false, reason: 'already_earned' };

    const eventMult = await getActiveEventMultiplier('recruiter');
    const ptsEarned = Math.round(ptsConfig.points * eventMult);

    const newPts = progression.currentPoints + ptsEarned;
    const info = getRankForPoints(newPts);
    const rankedUp = info.rank > progression.rank;

    await dataAccess.updateRecord(COLLECTION_KEYS.recruiterProgression, { ...progression, _id: progression._id, current_points: newPts, rank: info.rank, rank_title: info.title, points_to_next_rank: info.pointsToNext, updated_at: new Date().toISOString() }, { suppressAuth: true });
    gamificationCache.invalidateRecruiterProgression(recruiterId);
    gamificationCache.invalidateLeaderboards();

    await logGamificationEvent(recruiterId, 'recruiter', { eventType: rankedUp ? 'rank_up' : 'points_earned', action, pointsEarned: ptsEarned, metadata });
    return { success: true, points_earned: ptsEarned, total_points: newPts, rank: info.rank, rank_up: rankedUp };
  } catch (error) { throw error; }
}

export async function logGamificationEvent(userId, userType, eventData) {
  try {
    await dataAccess.insertRecord(COLLECTION_KEYS.gamificationEvents, { user_id: userId, user_type: userType, event_type: eventData.eventType, action: eventData.action, xp_earned: eventData.xpEarned || 0, points_earned: eventData.pointsEarned || 0, streak_bonus: eventData.streakBonus || 1.0, metadata_json: JSON.stringify(eventData.metadata || {}), created_at: new Date().toISOString() }, { suppressAuth: true });
  } catch (error) { }
}

async function hasEarnedOneTimeXP(driverId, action) {
  const res = await dataAccess.queryRecords(COLLECTION_KEYS.gamificationEvents, { filters: { user_id: driverId, action }, limit: 1, suppressAuth: true });
  return !!res.items?.length;
}

async function hasEarnedOneTimePoints(recruiterId, action) {
  const res = await dataAccess.queryRecords(COLLECTION_KEYS.gamificationEvents, { filters: { user_id: recruiterId, action }, limit: 1, suppressAuth: true });
  return !!res.items?.length;
}

async function getActiveEventMultiplier(userType) {
  try {
    const now = new Date().toISOString();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.seasonalEvents, { filters: { is_active: 'Yes', start_date: { le: now }, end_date: { ge: now } }, limit: 5, suppressAuth: true });
    let max = 1.0;
    (res.items || []).forEach(e => { const m = userType === 'driver' ? e.xp_multiplier : e.points_multiplier; max = Math.max(max, m || 1.0); });
    return max;
  } catch (e) { return 1.0; }
}

function normalizeDriverProgression(r) {
  return { _id: r._id, driverId: r.driver_id, currentXP: r.current_xp || 0, level: r.level || 1, levelTitle: r.level_title || 'Rookie', xpToNextLevel: r.xp_to_next_level || 100, streakDays: r.streak_days || 0, longestStreak: r.longest_streak || 0, streakFreezeAvailable: r.streak_freeze_available || 0, createdAt: r.created_at, updatedAt: r.updated_at };
}

function normalizeRecruiterProgression(r) {
  return { _id: r._id, recruiterId: r.recruiter_id, carrierId: r.carrier_id, currentPoints: r.current_points || 0, rank: r.rank || 1, rankTitle: r.rank_title || 'Scout', pointsToNextRank: r.points_to_next_rank || 500, totalHires: r.total_hires || 0, createdAt: r.created_at, updatedAt: r.updated_at };
}

function formatTimeRemaining(ms) {
  if (ms <= 0) return 'Expired';
  const h = Math.floor(ms / 3600000);
  const m = Math.floor((ms % 3600000) / 60000);
  return h > 24 ? `${Math.floor(h/24)}d ${h%24}h` : h > 0 ? `${h}h ${m}m` : `${m}m`;
}

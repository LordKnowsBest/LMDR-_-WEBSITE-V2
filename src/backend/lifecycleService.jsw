/**
 * Driver Lifecycle Service
 *
 * Manages the "Closing Loop" of driver employment - from hire to termination.
 * Captures granular disposition reasons and maintains a timeline of key events.
 * 
 * This service uses unified dataAccess for dual-source support.
 *
 * @module backend/lifecycleService
 */

import { insertRecord, queryRecords, updateRecord, getRecord } from 'backend/dataAccess';
import wixUsersBackend from 'wix-users-backend';
import * as feedbackLoopService from 'backend/feedbackLoopService';
import { log } from 'backend/observabilityService';
import { awardDriverXP } from 'backend/gamificationService';
import { sendSurveyIfNotSent } from 'backend/surveyService';

// ============================================================================
// CONSTANTS & ENUMS
// ============================================================================

export const EVENT_TYPES = {
  APPLICATION: 'APPLICATION_SUBMITTED',
  INTERVIEW_SCHEDULED: 'INTERVIEW_SCHEDULED',
  INTERVIEW: 'INTERVIEW_COMPLETED',
  HIRE: 'HIRED_ACTIVE',
  ORIENTATION: 'ORIENTATION_COMPLETE',
  FIRST_DISPATCH: 'FIRST_DISPATCH',
  MILESTONE_30: '30_DAY_MILESTONE',
  MILESTONE_90: '90_DAY_MILESTONE',
  SURVEY_SENT: 'SURVEY_SENT',
  SURVEY_COMPLETED: 'SURVEY_COMPLETED',
  INCIDENT: 'INCIDENT_REPORTED',
  TERMINATION: 'TERMINATED',
  RESIGNATION: 'RESIGNED'
};

export const TERMINATION_CATEGORIES = {
  OPERATIONS: ['NO_FREIGHT', 'EQUIPMENT_FAILURE', 'DISPATCH_CONFLICT', 'ROUTE_PREFERENCE'],
  COMPENSATION: ['PAY_DISPUTE', 'MILES_TOO_LOW', 'DETENTION_PAY', 'BENEFITS_ISSUE'],
  PERSONAL: ['HOME_TIME', 'MEDICAL', 'FAMILY_EMERGENCY', 'RETIREMENT', 'RELOCATION'],
  COMPLIANCE: ['FAILED_DRUG_TEST', 'SAFETY_VIOLATION', 'INSURANCE_REJECTION', 'LICENSE_SUSPENSION'],
  CULTURE: ['DISPATCHER_CONFLICT', 'COMPANY_CULTURE', 'BROKEN_PROMISES'],
  OTHER: ['BETTER_OFFER', 'UNKNOWN', 'SEASONAL_END']
};

export const SURVEY_TRIGGERS = {
  ORIENTATION: 'ORIENTATION',
  DAY_7: 'DAY_7',
  DAY_30: 'DAY_30',
  EXIT: 'EXIT'
};

const COLLECTION_KEYS = {
  events: 'lifecycleEvents',
  terminations: 'terminationLogs'
};

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

/**
 * Log a lifecycle event for a driver
 *
 * @param {string} driverId - The driver's ID
 * @param {string} carrierId - The carrier's ID (or DOT number)
 * @param {string} eventType - One of EVENT_TYPES
 * @param {Object} [metadata] - Additional context
 * @param {Date} [eventDate] - Optional override for event date
 */
export async function logEvent(driverId, carrierId, eventType, metadata = {}, eventDate = new Date()) {
  try {
    let createdBy = 'SYSTEM';
    
    try {
      const user = wixUsersBackend.currentUser;
      if (user && user.loggedIn) {
        createdBy = user.id;
      }
    } catch (e) {
      // Ignore user context errors in non-user environments
    }

    const eventRecord = {
      driver_id: driverId,
      carrier_id: String(carrierId),
      event_type: eventType,
      event_date: eventDate.toISOString(),
      metadata: JSON.stringify(metadata),
      created_by: createdBy
    };

    const result = await insertRecord(COLLECTION_KEYS.events, eventRecord, { suppressAuth: true });

    if (!result.success) {
      throw new Error(result.error);
    }

    // Award retention milestone XP for key post-hire events
    const xpMap = {
      [EVENT_TYPES.MILESTONE_30]: 'retention_30_day',
      [EVENT_TYPES.MILESTONE_90]: 'retention_90_day'
    };
    const xpAction = xpMap[eventType];
    if (xpAction) {
      awardDriverXP(driverId, xpAction, { carrierId, eventDate: eventDate.toISOString() })
        .catch(e => console.warn(`XP award failed (${xpAction}):`, e.message));
    }

    return result.record;
  } catch (error) {
    console.error(`[lifecycleService] logEvent error:`, error.message);
    // Don't throw to avoid breaking the main application flow
    return null;
  }
}

/**
 * Get the full timeline for a driver
 */
export async function getDriverTimeline(driverId) {
  try {
    const result = await queryRecords(COLLECTION_KEYS.events, {
      filters: { driver_id: driverId },
      sort: [{ field: 'event_date', direction: 'desc' }],
      suppressAuth: true
    });

    if (!result.success) {
      throw new Error(result.error);
    }

    return result.items.map(item => {
      let parsedMetadata = {};
      try {
        parsedMetadata = item.metadata ? (typeof item.metadata === 'string' ? JSON.parse(item.metadata) : item.metadata) : {};
      } catch (e) {
        parsedMetadata = {};
      }
      
      return {
        ...item,
        metadata: parsedMetadata
      };
    });
  } catch (error) {
    console.error(`[lifecycleService] getDriverTimeline error:`, error.message);
    return [];
  }
}

/**
 * Terminate a driver or process resignation
 */
export async function terminateDriver(driverId, carrierId, dispositionData, source) {
  try {
    // 1. Calculate tenure
    const hireEvent = await findHireEvent(driverId, carrierId);
    let tenureDays = 0;
    let isEarlyChurn = false;

    if (hireEvent) {
      const hireDate = new Date(hireEvent.event_date || hireEvent.eventDate);
      const termDate = new Date();
      const diffTime = Math.abs(termDate.getTime() - hireDate.getTime());
      tenureDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
      isEarlyChurn = tenureDays < 30;
    }

    // 2. Create Termination Log
    const terminationRecord = {
      driver_id: driverId,
      carrier_id: String(carrierId),
      tenure_days: tenureDays,
      is_early_churn: isEarlyChurn,
      category: dispositionData.category,
      reason_code: dispositionData.reasonCode,
      notes: dispositionData.notes,
      source: source, // 'RECRUITER' or 'DRIVER'
      rehire_eligible: dispositionData.rehireEligible,
      driver_feedback: dispositionData.driverFeedback || ''
    };

    const termResult = await insertRecord(COLLECTION_KEYS.terminations, terminationRecord, { suppressAuth: true });

    if (!termResult.success) {
      throw new Error(termResult.error);
    }

    // 3. Log the event in the timeline
    const eventType = source === 'DRIVER' ? EVENT_TYPES.RESIGNATION : EVENT_TYPES.TERMINATION;
    await logEvent(driverId, carrierId, eventType, {
      reason: dispositionData.reasonCode,
      category: dispositionData.category,
      tenureDays: tenureDays
    });

    // 4. Trigger exit survey immediately
    sendSurveyIfNotSent(driverId, String(carrierId), 'EXIT')
      .catch(e => console.warn('[lifecycleService] Exit survey trigger failed:', e.message));

    // 5. Trigger feedback loop analysis
    try {
      await feedbackLoopService.analyzeTermination(termResult.record);
    } catch (analysisErr) {
      console.warn('[lifecycleService] Feedback analysis failed:', analysisErr.message);
    }

    await log({
      level: 'INFO',
      source: 'lifecycle-service',
      message: `Driver ${driverId} terminated from carrier ${carrierId}`,
      details: { tenureDays, isEarlyChurn, source }
    });

    return termResult.record;
  } catch (error) {
    console.error(`[lifecycleService] terminateDriver error:`, error.message);
    throw error;
  }
}

/**
 * Helper to find the most recent HIRE event for tenure calculation
 */
async function findHireEvent(driverId, carrierId) {
  const result = await queryRecords(COLLECTION_KEYS.events, {
    filters: { 
      driver_id: driverId, 
      carrier_id: String(carrierId), 
      event_type: EVENT_TYPES.HIRE 
    },
    sort: [{ field: 'event_date', direction: 'desc' }],
    limit: 1,
    suppressAuth: true
  });

  return result.success && result.items.length > 0 ? result.items[0] : null;
}

/**
 * Get available termination reasons for UI dropdowns
 */
export function getTerminationReasons() {
  return TERMINATION_CATEGORIES;
}
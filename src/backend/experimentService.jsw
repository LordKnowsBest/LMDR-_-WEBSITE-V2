import * as dataAccess from 'backend/dataAccess';
import { evaluateConditions } from 'backend/utils/conditionEvaluator';
import { hashString } from 'backend/utils/hashUtils';

const TESTS_COLLECTION = 'abTests';
const ASSIGNMENTS_COLLECTION = 'abTestAssignments';
const EVENTS_COLLECTION = 'abTestEvents';

/**
 * Get all tests
 */
export async function getAllTests(status = null) {
  const filters = status ? { status } : {};
  const result = await dataAccess.queryRecords(TESTS_COLLECTION, {
    filters,
    sort: [{ field: 'key', direction: 'asc' }],
    suppressAuth: true
  });
  return result.items || [];
}

/**
 * Get a single test by key
 */
export async function getTest(testKey) {
  return await dataAccess.findByField(TESTS_COLLECTION, 'key', testKey, { suppressAuth: true });
}

/**
 * Get one user's existing assignment.
 */
export async function getUserAssignment(testKey, userId) {
  const result = await dataAccess.queryRecords(ASSIGNMENTS_COLLECTION, {
    filters: { testKey, userId },
    limit: 1,
    suppressAuth: true
  });
  return result.success && result.items.length ? result.items[0] : null;
}

/**
 * Assign a user to a test and return their variant.
 */
export async function assignUserToTest(testKey, userId, userContext = {}) {
  try {
    // 1. Check existing assignment
    const existing = await getUserAssignment(testKey, userId);
    if (existing) {
      return existing.variantId;
    }

    // 2. Get test definition
    const test = await getTest(testKey);
    if (!test || test.status !== 'running') return 'control';

    // 3. Check targeting rules
    if (!evaluateConditions(test.targetAudience?.conditions || [], userContext)) {
      return 'control';
    }

    // 4. Traffic allocation check
    const bucket = hashString(userId + testKey) % 100;
    if (bucket >= (test.trafficAllocation || 100)) {
      return 'control';
    }

    // 5. Variant assignment (deterministic hash-based)
    const variantBucket = hashString(userId + testKey + '_variant') % 100;
    let variantId = 'control';
    let cumulative = 0;
    
    for (const variant of (test.variants || [])) {
      cumulative += Number(variant.allocation || 0);
      if (variantBucket < cumulative) {
        variantId = variant.id;
        break;
      }
    }

    // 6. Persist assignment
    await dataAccess.insertRecord(ASSIGNMENTS_COLLECTION, {
      testKey,
      userId,
      variantId,
      assignedAt: new Date(),
      converted: false,
      conversionEvents: []
    }, { suppressAuth: true });

    return variantId;
  } catch (error) {
    console.error(`[experimentService] assignUser error (${testKey}):`, error.message);
    return 'control';
  }
}

/**
 * Record a conversion for a test
 */
export async function recordConversion(testKey, userId, metricName, value = 1) {
  try {
    // 1. Verify assignment
    const userAssignment = await getUserAssignment(testKey, userId);
    if (!userAssignment) {
      return { success: false, error: 'User not assigned to test' };
    }

    // 2. De-duplicate on test+user+metric for conversion metrics.
    const duplicate = await dataAccess.queryRecords(EVENTS_COLLECTION, {
      filters: { testKey, userId, eventName: metricName },
      limit: 1,
      suppressAuth: true
    });
    if (duplicate.success && duplicate.items.length) {
      return { success: true, deduped: true };
    }

    // 3. Log event
    await dataAccess.insertRecord(EVENTS_COLLECTION, {
      testKey,
      userId,
      variantId: userAssignment.variantId,
      eventName: metricName,
      value,
      timestamp: new Date()
    }, { suppressAuth: true });

    // 4. Update assignment conversion state if it's the primary metric.
    const test = await getTest(testKey);
    if (test && test.primaryMetric?.name === metricName) {
      const existingEvents = Array.isArray(userAssignment.conversionEvents) ? userAssignment.conversionEvents : [];
      existingEvents.push({
        metric: metricName,
        value,
        timestamp: new Date()
      });
      await dataAccess.updateRecord(ASSIGNMENTS_COLLECTION, {
        ...userAssignment,
        _id: userAssignment._id,
        converted: true,
        conversionEvents: existingEvents
      }, { suppressAuth: true });
    }

    await updateTestResults(testKey);
    return { success: true };
  } catch (error) {
    console.error(`[experimentService] recordConversion error (${testKey}):`, error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ADMIN CRUD
// ============================================================================

export async function createTest(testData) {
  const existing = await getTest(testData.key);
  if (existing) {
    throw new Error(`Test '${testData.key}' already exists`);
  }
  return await dataAccess.insertRecord(TESTS_COLLECTION, {
    ...testData,
    status: 'draft',
    confidenceLevel: testData.confidenceLevel || 95,
    trafficAllocation: testData.trafficAllocation || 100,
    minSampleSize: testData.minSampleSize || 100,
    createdAt: new Date(),
    updatedAt: new Date()
  }, { suppressAuth: true });
}

export async function updateTest(testKey, updates) {
  const existing = await getTest(testKey);
  if (!existing) throw new Error(`Test '${testKey}' not found`);

  return await dataAccess.updateRecord(TESTS_COLLECTION, {
    ...existing,
    _id: existing._id,
    ...updates,
    updatedAt: new Date()
  }, { suppressAuth: true });
}

export async function startTest(testKey) {
  return await updateTest(testKey, { status: 'running', startDate: new Date() });
}

export async function pauseTest(testKey) {
  return await updateTest(testKey, { status: 'paused' });
}

export async function endTest(testKey, winnerId) {
  return await updateTest(testKey, { 
    status: 'completed', 
    endDate: new Date(),
    winnerId
  });
}

/**
 * Get aggregate test results.
 */
export async function getTestResults(testKey) {
  const test = await getTest(testKey);
  if (!test) {
    throw new Error(`Test '${testKey}' not found`);
  }
  return await calculateAndPersistResults(test);
}

/**
 * Refresh and persist results for one test.
 */
export async function updateTestResults(testKey) {
  const test = await getTest(testKey);
  if (!test) {
    return null;
  }
  return await calculateAndPersistResults(test);
}

/**
 * Scheduled job entrypoint for running tests.
 */
export async function refreshRunningTestResults() {
  const running = await getAllTests('running');
  const updates = [];
  for (const test of running) {
    try {
      const results = await calculateAndPersistResults(test);
      updates.push({ key: test.key, success: true, participants: results.participants });
    } catch (error) {
      updates.push({ key: test.key, success: false, error: error.message });
    }
  }
  return {
    processed: updates.length,
    updates
  };
}

async function calculateAndPersistResults(test) {
  const assignments = await dataAccess.queryRecords(ASSIGNMENTS_COLLECTION, {
    filters: { testKey: test.key },
    limit: 10000,
    suppressAuth: true
  });

  const events = await dataAccess.queryRecords(EVENTS_COLLECTION, {
    filters: { testKey: test.key },
    limit: 10000,
    suppressAuth: true
  });

  const assignmentsByVariant = {};
  (test.variants || []).forEach((variant) => {
    assignmentsByVariant[variant.id] = {
      variantId: variant.id,
      name: variant.name || variant.id,
      participants: 0,
      conversions: 0,
      conversionRate: 0
    };
  });
  if (!assignmentsByVariant.control) {
    assignmentsByVariant.control = {
      variantId: 'control',
      name: 'Control',
      participants: 0,
      conversions: 0,
      conversionRate: 0
    };
  }

  (assignments.items || []).forEach((assignment) => {
    const bucket = assignmentsByVariant[assignment.variantId] || assignmentsByVariant.control;
    bucket.participants += 1;
    if (assignment.converted) {
      bucket.conversions += 1;
    }
  });

  Object.values(assignmentsByVariant).forEach((bucket) => {
    bucket.conversionRate = bucket.participants > 0
      ? bucket.conversions / bucket.participants
      : 0;
  });

  const control = assignmentsByVariant.control;
  const comparisons = [];
  Object.values(assignmentsByVariant).forEach((variant) => {
    if (variant.variantId === 'control') {
      return;
    }
    comparisons.push({
      variantId: variant.variantId,
      ...calculateSignificance(control, variant, test.confidenceLevel || 95)
    });
  });

  const primaryEvent = test.primaryMetric?.name || null;
  const eventCount = primaryEvent
    ? (events.items || []).filter((event) => event.eventName === primaryEvent).length
    : (events.items || []).length;

  const bestVariant = findBestVariant(assignmentsByVariant, control);
  const results = {
    computedAt: new Date(),
    metric: test.primaryMetric || null,
    participants: (assignments.items || []).length,
    events: eventCount,
    variants: Object.values(assignmentsByVariant),
    comparisons,
    leadingVariant: bestVariant,
    significantWinner: comparisons.find((cmp) => cmp.significant)?.variantId || null
  };

  await dataAccess.updateRecord(TESTS_COLLECTION, {
    ...test,
    _id: test._id,
    results,
    updatedAt: new Date()
  }, { suppressAuth: true });

  return results;
}

function calculateSignificance(control, variant, confidenceLevel = 95) {
  const n1 = control.participants || 0;
  const n2 = variant.participants || 0;
  const c1 = control.conversions || 0;
  const c2 = variant.conversions || 0;
  if (!n1 || !n2) {
    return {
      controlRate: 0,
      variantRate: 0,
      liftPct: 0,
      zScore: 0,
      pValue: 1,
      confidence: 0,
      significant: false
    };
  }

  const p1 = c1 / n1;
  const p2 = c2 / n2;
  const pooled = (c1 + c2) / (n1 + n2);
  const se = Math.sqrt(Math.max(pooled * (1 - pooled) * ((1 / n1) + (1 / n2)), 1e-12));
  const zScore = (p2 - p1) / se;
  const pValue = 2 * (1 - normalCdf(Math.abs(zScore)));
  const confidence = Math.max(0, (1 - pValue) * 100);
  const liftPct = p1 > 0 ? ((p2 - p1) / p1) * 100 : 0;
  return {
    controlRate: p1,
    variantRate: p2,
    liftPct: roundTo(liftPct, 2),
    zScore: roundTo(zScore, 4),
    pValue: roundTo(pValue, 6),
    confidence: roundTo(confidence, 2),
    significant: confidence >= confidenceLevel
  };
}

function normalCdf(value) {
  // Abramowitz and Stegun approximation.
  const x = Math.abs(value);
  const t = 1 / (1 + 0.2316419 * x);
  const d = 0.3989423 * Math.exp((-x * x) / 2);
  let prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
  prob = 1 - prob;
  return value < 0 ? 1 - prob : prob;
}

function findBestVariant(variantsById, control) {
  let best = null;
  Object.values(variantsById).forEach((variant) => {
    if (!best) {
      best = variant;
      return;
    }
    if (variant.conversionRate > best.conversionRate) {
      best = variant;
    }
  });
  if (!best) {
    return null;
  }
  return {
    variantId: best.variantId,
    conversionRate: best.conversionRate,
    liftPct: control && control.conversionRate > 0
      ? roundTo(((best.conversionRate - control.conversionRate) / control.conversionRate) * 100, 2)
      : 0
  };
}

function roundTo(value, digits) {
  const factor = Math.pow(10, digits);
  return Math.round(value * factor) / factor;
}

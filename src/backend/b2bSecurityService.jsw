// ============================================================================
// B2B SECURITY SERVICE - Authentication, authorization, compliance, audit
//
// Centralized security layer for all B2B Business Development Suite actions.
// Handles role-based access control, consent validation, quiet hours,
// do-not-contact enforcement, and audit logging.
//
// DUAL-SOURCE SUPPORT: Routes through Airtable via config.jsw
//
// Used by: b2bBridgeService.jsw (entry-point guard for all B2B actions)
// @see Conductor/tracks/b2b_business_development_suite_20260128/spec.md
// ============================================================================

import { currentMember } from 'wix-members-backend';
import wixData from 'wix-data';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess
const COLLECTIONS = {
  contacts: 'b2bContacts',
  activities: 'b2bActivities'
};

const B2B_ROLES = { VIEWER: 'b2b_viewer', REP: 'b2b_rep', MANAGER: 'b2b_manager', ADMIN: 'b2b_admin' };
const ROLE_HIERARCHY = { [B2B_ROLES.VIEWER]: 0, [B2B_ROLES.REP]: 1, [B2B_ROLES.MANAGER]: 2, [B2B_ROLES.ADMIN]: 3 };
const SITE_ADMIN_ROLES = ['admin', 'super_admin', 'ops_admin'];

export async function getB2BUser() {
  try {
    const member = await currentMember.getMember({ fieldsets: ['FULL'] });
    if (!member) return { authenticated: false, error: 'Not logged in' };

    const customFields = member.contactDetails?.customFields || {};
    let b2bRole = customFields.b2b_role || '';

    if (!b2bRole && SITE_ADMIN_ROLES.includes((customFields.role || '').toLowerCase())) {
      b2bRole = B2B_ROLES.ADMIN;
    }

    if (!b2bRole) {
      const adminCheck = await dataAccess.queryRecords('adminUsers', { filters: { email: member.loginEmail, status: 'active' }, limit: 1, suppressAuth: true });
      if (adminCheck.items?.length) b2bRole = B2B_ROLES.ADMIN;
    }

    if (!b2bRole) return { authenticated: true, user: { memberId: member._id, email: member.loginEmail, name: member.loginEmail }, error: 'No B2B role' };

    return { authenticated: true, user: { memberId: member._id, email: member.loginEmail, name: member.loginEmail, role: b2bRole, roleLevel: ROLE_HIERARCHY[b2bRole] ?? 0 } };
  } catch (error) { return { authenticated: false, error: error.message }; }
}

export async function validateConsent(contactId, channel) {
  try {
    if (!contactId) return { allowed: false, reason: 'Contact ID required' };
    const contact = await dataAccess.getRecord(COLLECTIONS.contacts, contactId, { suppressAuth: true });
    if (!contact) return { allowed: false, reason: 'Not found' };

    if (channel === 'email') {
      if (['opted_out', 'do_not_contact'].includes(contact.consent_status)) return { allowed: false, reason: 'Opted out', consent_status: contact.consent_status };
      return { allowed: true, consent_status: contact.consent_status || 'pending' };
    }

    if (['sms', 'call'].includes(channel)) {
      const s = contact.consent_status || 'pending';
      if (s !== 'opted_in') return { allowed: false, reason: `No consent for ${channel}`, consent_status: s };
      return { allowed: true, consent_status: s };
    }
    return { allowed: true };
  } catch (error) { return { allowed: false, reason: error.message }; }
}

export async function logB2BAudit({ action, userId, userEmail, targetType, targetId, details }) {
  try {
    const record = {
      account_id: targetId || '', contact_id: '', type: 'audit', channel: 'platform',
      subject: `[AUDIT] ${action}`, notes: JSON.stringify({ action, user_id: userId, user_email: userEmail, target_type: targetType || '', target_id: targetId || '', details: details || {}, timestamp: new Date().toISOString() }),
      outcome: 'completed', owner_id: userId || '', created_at: new Date().toISOString()
    };
    await dataAccess.insertRecord(COLLECTIONS.activities, record, { suppressAuth: true });
  } catch (err) { }
}

export { B2B_ROLES, ROLE_HIERARCHY };

// ============================================================================
// AUTHORIZATION — Role Checks
// ============================================================================

/**
 * Check if a user has at least the minimum required role.
 *
 * @param {Object} user - User object from getB2BUser()
 * @param {string} minRole - Minimum required role
 * @returns {boolean}
 */
export function hasRole(user, minRole) {
  if (!user || !user.role) return false;
  const userLevel = ROLE_HIERARCHY[user.role] ?? -1;
  const requiredLevel = ROLE_HIERARCHY[minRole] ?? 999;
  return userLevel >= requiredLevel;
}

/**
 * Get the minimum role required for a given action.
 *
 * @param {string} action - The B2B action name
 * @returns {string} The minimum role required (defaults to b2b_rep for unknown actions)
 */
export function getRequiredRole(action) {
  return ACTION_PERMISSIONS[action] || B2B_ROLES.REP;
}

/**
 * Check if an action requires audit logging.
 *
 * @param {string} action - The B2B action name
 * @returns {boolean}
 */
export function isAuditable(action) {
  return AUDITABLE_ACTIONS.includes(action);
}

/**
 * Check if a user can perform a specific action.
 *
 * @param {Object} user - User object from getB2BUser()
 * @param {string} action - The B2B action name
 * @returns {{allowed: boolean, reason?: string}}
 */
export function checkActionPermission(user, action) {
  if (!user || !user.role) {
    return { allowed: false, reason: 'No B2B role assigned. Contact an administrator.' };
  }

  const requiredRole = getRequiredRole(action);
  if (!hasRole(user, requiredRole)) {
    return {
      allowed: false,
      reason: `Action "${action}" requires ${requiredRole} role. Your role: ${user.role}.`
    };
  }

  return { allowed: true };
}

// ============================================================================
// COMPLIANCE — Consent Validation
// ============================================================================

/**
 * Validate that a contact has given consent for a specific outreach channel.
 *
 * @param {string} contactId - Contact record ID
 * @param {string} channel - Outreach channel (email, sms, call)
 * @returns {Promise<{allowed: boolean, reason?: string, consent_status?: string}>}
 */
export async function validateConsent(contactId, channel) {
  try {
    if (!contactId) {
      return { allowed: false, reason: 'Contact ID is required for consent check' };
    }

    // Email doesn't require explicit opt-in (CAN-SPAM allows until opt-out)
    if (channel === 'email') {
      const contacts = await findByField(COLLECTIONS.contacts, '_id', contactId);
      const contact = contacts && contacts.length > 0 ? contacts[0] : null;
      if (contact && (contact.consent_status === CONSENT_STATUS.OPTED_OUT || contact.consent_status === CONSENT_STATUS.DO_NOT_CONTACT)) {
        return { allowed: false, reason: 'Contact has opted out', consent_status: contact.consent_status };
      }
      return { allowed: true, consent_status: contact?.consent_status || CONSENT_STATUS.PENDING };
    }

    // SMS and Call require explicit consent
    if (CONSENT_REQUIRED_CHANNELS.includes(channel)) {
      const contacts = await findByField(COLLECTIONS.contacts, '_id', contactId);
      const contact = contacts && contacts.length > 0 ? contacts[0] : null;

      if (!contact) {
        return { allowed: false, reason: 'Contact not found' };
      }

      const status = contact.consent_status || CONSENT_STATUS.PENDING;

      if (status === CONSENT_STATUS.DO_NOT_CONTACT) {
        return { allowed: false, reason: 'Contact is on do-not-contact list', consent_status: status };
      }
      if (status === CONSENT_STATUS.OPTED_OUT) {
        return { allowed: false, reason: `Contact has opted out of ${channel}`, consent_status: status };
      }
      if (status === CONSENT_STATUS.PENDING) {
        return { allowed: false, reason: `${channel} requires explicit consent. Status is pending.`, consent_status: status };
      }

      return { allowed: true, consent_status: status };
    }

    // Other channels — allow by default
    return { allowed: true };
  } catch (error) {
    console.error('[B2B Security] Consent validation error:', error);
    return { allowed: false, reason: 'Consent check failed: ' + (error.message || 'Unknown error') };
  }
}

/**
 * Check if a contact is on the do-not-contact list.
 *
 * @param {string} contactId
 * @returns {Promise<boolean>}
 */
export async function isDoNotContact(contactId) {
  try {
    if (!contactId) return false;
    const contacts = await findByField(COLLECTIONS.contacts, '_id', contactId);
    const contact = contacts && contacts.length > 0 ? contacts[0] : null;
    return contact?.consent_status === CONSENT_STATUS.DO_NOT_CONTACT;
  } catch (error) {
    console.warn('[B2B Security] DNC check failed:', error.message);
    return false;
  }
}

// ============================================================================
// COMPLIANCE — Quiet Hours
// ============================================================================

/**
 * Check if the current time falls within quiet hours.
 * Outreach (email, sms, call) should not be sent during quiet hours.
 *
 * @param {string} [timezone] - Contact timezone (future: use for local-time check)
 * @returns {{inQuietHours: boolean, resumesAt: string}}
 */
export function checkQuietHours(timezone = '') {
  const now = new Date();
  const hour = now.getUTCHours();
  const inQuietHours = hour >= QUIET_HOURS.start || hour < QUIET_HOURS.end;

  let resumesAt = '';
  if (inQuietHours) {
    const resume = new Date(now);
    if (hour >= QUIET_HOURS.start) {
      resume.setUTCDate(resume.getUTCDate() + 1);
    }
    resume.setUTCHours(QUIET_HOURS.end, 0, 0, 0);
    resumesAt = resume.toISOString();
  }

  return { inQuietHours, resumesAt };
}

// ============================================================================
// COMPLIANCE — Outreach Pre-flight Check
// ============================================================================

/**
 * Run all compliance checks before sending outreach.
 * Combines consent, quiet hours, and DNC into one call.
 *
 * @param {string} contactId - Contact to reach
 * @param {string} channel - email, sms, or call
 * @returns {Promise<{allowed: boolean, reasons?: string[]}>}
 */
export async function preflightOutreachCheck(contactId, channel) {
  const reasons = [];

  // 1. Quiet hours
  const { inQuietHours, resumesAt } = checkQuietHours();
  if (inQuietHours) {
    reasons.push(`Quiet hours active (9PM-8AM UTC). Resumes at ${resumesAt}`);
  }

  // 2. Consent
  const consent = await validateConsent(contactId, channel);
  if (!consent.allowed) {
    reasons.push(consent.reason);
  }

  return {
    allowed: reasons.length === 0,
    reasons: reasons.length > 0 ? reasons : undefined
  };
}

// ============================================================================
// AUDIT LOGGING
// ============================================================================

/**
 * Log a B2B action for audit purposes.
 * Non-blocking — failures are logged but don't interrupt the operation.
 *
 * @param {Object} params
 * @param {string} params.action - The action performed
 * @param {string} params.userId - Who performed it
 * @param {string} params.userEmail - User email
 * @param {string} [params.targetType] - account, contact, opportunity, sequence, etc.
 * @param {string} [params.targetId] - ID of the affected record
 * @param {Object} [params.details] - Additional context
 */
export async function logB2BAudit({ action, userId, userEmail, targetType, targetId, details }) {
  try {
    const record = {
      account_id: targetId || '',
      contact_id: '',
      type: 'audit',
      channel: 'platform',
      subject: `[AUDIT] ${action}`,
      notes: JSON.stringify({
        action,
        user_id: userId,
        user_email: userEmail,
        target_type: targetType || '',
        target_id: targetId || '',
        details: details || {},
        timestamp: new Date().toISOString()
      }),
      outcome: 'completed',
      owner_id: userId || '',
      created_at: new Date().toISOString()
    };

    await insertData(COLLECTIONS.activities, record);
  } catch (error) {
    console.warn('[B2B Audit] Failed to log audit entry:', error.message);
  }
}

// ============================================================================
// EXPORTS — Constants for external use
// ============================================================================

export { B2B_ROLES, ROLE_HIERARCHY, CONSENT_STATUS };

/**
 * B2B Security Service
 *
 * Centralized security layer for all B2B Business Development Suite actions.
 * Handles role-based access control, consent validation, quiet hours,
 * do-not-contact enforcement, and audit logging.
 *
 * This service uses unified dataAccess for dual-source support.
 * 
 * @module backend/b2bSecurityService
 */

import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// CONSTANTS
// ============================================================================

export const B2B_ROLES = {
  VIEWER: 'b2b_viewer',
  REP: 'b2b_rep',
  MANAGER: 'b2b_manager',
  ADMIN: 'b2b_admin'
};

export const ROLE_HIERARCHY = {
  [B2B_ROLES.VIEWER]: 0,
  [B2B_ROLES.REP]: 1,
  [B2B_ROLES.MANAGER]: 2,
  [B2B_ROLES.ADMIN]: 3
};

const SITE_ADMIN_ROLES = ['admin', 'super_admin', 'ops_admin'];

export const CONSENT_STATUS = {
  PENDING: 'pending',
  OPTED_IN: 'opted_in',
  OPTED_OUT: 'opted_out',
  DO_NOT_CONTACT: 'do_not_contact'
};

const CONSENT_REQUIRED_CHANNELS = ['sms', 'call'];

export const QUIET_HOURS = { start: 21, end: 8 };

const ACTION_PERMISSIONS = {
  getDashboardKPIs: B2B_ROLES.VIEWER,
  getTopProspects: B2B_ROLES.VIEWER,
  getAlerts: B2B_ROLES.VIEWER,
  getTopOpportunities: B2B_ROLES.VIEWER,
  getNextActions: B2B_ROLES.VIEWER,
  getAccount: B2B_ROLES.VIEWER,
  listAccounts: B2B_ROLES.VIEWER,
  getContacts: B2B_ROLES.VIEWER,
  getSignal: B2B_ROLES.VIEWER,
  getPipeline: B2B_ROLES.VIEWER,
  getForecast: B2B_ROLES.VIEWER,
  getOpportunity: B2B_ROLES.VIEWER,
  getOpportunitiesByAccount: B2B_ROLES.VIEWER,
  getPipelineKPIs: B2B_ROLES.VIEWER,
  getStageConversions: B2B_ROLES.VIEWER,
  getRisks: B2B_ROLES.VIEWER,
  getStageDefinitions: B2B_ROLES.VIEWER,
  getPlaybookSuggestions: B2B_ROLES.VIEWER,
  getValueProps: B2B_ROLES.VIEWER,
  getTimeline: B2B_ROLES.VIEWER,
  getActivityVelocity: B2B_ROLES.VIEWER,
  getSequences: B2B_ROLES.VIEWER,
  getSequence: B2B_ROLES.VIEWER,
  getThrottleStatus: B2B_ROLES.VIEWER,
  getOutreachMetrics: B2B_ROLES.VIEWER,
  getChannelPerformance: B2B_ROLES.VIEWER,
  getRepPerformance: B2B_ROLES.VIEWER,
  getSourcePerformance: B2B_ROLES.VIEWER,
  getCPA: B2B_ROLES.VIEWER,
  getCompetitorIntel: B2B_ROLES.VIEWER,
  getBrief: B2B_ROLES.VIEWER,
  getSignalSpikes: B2B_ROLES.VIEWER,
  createAccount: B2B_ROLES.REP,
  updateAccount: B2B_ROLES.REP,
  createContact: B2B_ROLES.REP,
  updateContact: B2B_ROLES.REP,
  generateSignal: B2B_ROLES.REP,
  generateBatchSignals: B2B_ROLES.REP,
  createOpportunity: B2B_ROLES.REP,
  moveStage: B2B_ROLES.REP,
  logActivity: B2B_ROLES.REP,
  recordEmail: B2B_ROLES.REP,
  recordSms: B2B_ROLES.REP,
  recordCall: B2B_ROLES.REP,
  captureLead: B2B_ROLES.REP,
  addCompetitorIntel: B2B_ROLES.REP,
  generateBrief: B2B_ROLES.REP,
  quickAction: B2B_ROLES.REP,
  accountAction: B2B_ROLES.REP,
  saveSequence: B2B_ROLES.MANAGER,
  addStep: B2B_ROLES.MANAGER,
  createCallCampaign: B2B_ROLES.MANAGER,
  saveSnapshot: B2B_ROLES.MANAGER
};

const AUDITABLE_ACTIONS = [
  'createAccount', 'updateAccount',
  'createContact', 'updateContact',
  'createOpportunity', 'moveStage',
  'recordEmail', 'recordSms', 'recordCall',
  'captureLead', 'saveSequence', 'addStep',
  'createCallCampaign', 'addCompetitorIntel',
  'generateBrief', 'generateBatchSignals',
  'saveSnapshot', 'quickAction', 'accountAction'
];

const COLLECTION_KEYS = {
  contacts: 'b2bContacts',
  activities: 'b2bActivities',
  adminUsers: 'adminUsers'
};

// ============================================================================
// AUTH & IDENTITY
// ============================================================================

/**
 * Get current B2B user and their role
 */
export async function getB2BUser() {
  try {
    const member = await currentMember.getMember({ fieldsets: ['FULL'] });
    if (!member) return { authenticated: false, error: 'Not logged in' };

    const customFields = member.contactDetails?.customFields || {};
    let b2bRole = customFields.b2b_role || '';

    // Check if site admin (auto-upgrades to B2B admin)
    if (!b2bRole && SITE_ADMIN_ROLES.includes((customFields.role || '').toLowerCase())) {
      b2bRole = B2B_ROLES.ADMIN;
    }

    // Fallback: Check adminUsers collection
    if (!b2bRole) {
      const adminCheck = await dataAccess.queryRecords(COLLECTION_KEYS.adminUsers, { 
        filters: { email: member.loginEmail, status: 'active' }, 
        limit: 1, 
        suppressAuth: true 
      });
      if (adminCheck.items?.length) b2bRole = B2B_ROLES.ADMIN;
    }

    if (!b2bRole) {
      return { 
        authenticated: true, 
        user: { memberId: member._id, email: member.loginEmail, name: member.loginEmail }, 
        error: 'No B2B role' 
      };
    }

    return { 
      authenticated: true, 
      user: { 
        memberId: member._id, 
        email: member.loginEmail, 
        name: member.loginEmail, 
        role: b2bRole, 
        roleLevel: ROLE_HIERARCHY[b2bRole] ?? 0 
      } 
    };
  } catch (error) { 
    return { authenticated: false, error: error.message }; 
  }
}

// ============================================================================
// AUTHORIZATION — Role Checks
// ============================================================================

/**
 * Check if a user has at least the minimum required role.
 */
export function hasRole(user, minRole) {
  if (!user || !user.role) return false;
  const userLevel = ROLE_HIERARCHY[user.role] ?? -1;
  const requiredLevel = ROLE_HIERARCHY[minRole] ?? 999;
  return userLevel >= requiredLevel;
}

/**
 * Get the minimum role required for a given action.
 */
export function getRequiredRole(action) {
  return ACTION_PERMISSIONS[action] || B2B_ROLES.REP;
}

/**
 * Check if an action requires audit logging.
 */
export function isAuditable(action) {
  return AUDITABLE_ACTIONS.includes(action);
}

/**
 * Check if a user can perform a specific action.
 */
export function checkActionPermission(user, action) {
  if (!user || !user.role) {
    return { allowed: false, reason: 'No B2B role assigned. Contact an administrator.' };
  }

  const requiredRole = getRequiredRole(action);
  if (!hasRole(user, requiredRole)) {
    return {
      allowed: false,
      reason: `Action "${action}" requires ${requiredRole} role. Your role: ${user.role}.`
    };
  }

  return { allowed: true };
}

// ============================================================================
// COMPLIANCE — Consent Validation
// ============================================================================

/**
 * Validate that a contact has given consent for a specific outreach channel.
 */
export async function validateConsent(contactId, channel) {
  try {
    if (!contactId) return { allowed: false, reason: 'Contact ID required' };
    
    const contact = await dataAccess.getRecord(COLLECTION_KEYS.contacts, contactId, { suppressAuth: true });
    if (!contact) return { allowed: false, reason: 'Not found' };

    // Email logic (CAN-SPAM)
    if (channel === 'email') {
      if ([CONSENT_STATUS.OPTED_OUT, CONSENT_STATUS.DO_NOT_CONTACT].includes(contact.consent_status)) {
        return { allowed: false, reason: 'Contact has opted out', consent_status: contact.consent_status };
      }
      return { allowed: true, consent_status: contact.consent_status || CONSENT_STATUS.PENDING };
    }

    // SMS/Call logic (TCPA)
    if (CONSENT_REQUIRED_CHANNELS.includes(channel)) {
      const status = contact.consent_status || CONSENT_STATUS.PENDING;
      if (status !== CONSENT_STATUS.OPTED_IN) {
        return { 
          allowed: false, 
          reason: status === CONSENT_STATUS.PENDING ? `${channel} requires explicit consent. Status is pending.` : `Contact has blocked ${channel}`, 
          consent_status: status 
        };
      }
      return { allowed: true, consent_status: status };
    }

    return { allowed: true };
  } catch (error) { 
    return { allowed: false, reason: error.message }; 
  }
}

/**
 * Check if a contact is on the do-not-contact list.
 */
export async function isDoNotContact(contactId) {
  try {
    if (!contactId) return false;
    const contact = await dataAccess.getRecord(COLLECTION_KEYS.contacts, contactId, { suppressAuth: true });
    return contact?.consent_status === CONSENT_STATUS.DO_NOT_CONTACT;
  } catch (error) {
    return false;
  }
}

// ============================================================================
// COMPLIANCE — Quiet Hours
// ============================================================================

/**
 * Check if the current time falls within quiet hours.
 */
export function checkQuietHours(timezone = '') {
  const now = new Date();
  const hour = now.getUTCHours();
  const inQuietHours = hour >= QUIET_HOURS.start || hour < QUIET_HOURS.end;

  let resumesAt = '';
  if (inQuietHours) {
    const resume = new Date(now);
    if (hour >= QUIET_HOURS.start) {
      resume.setUTCDate(resume.getUTCDate() + 1);
    }
    resume.setUTCHours(QUIET_HOURS.end, 0, 0, 0);
    resumesAt = resume.toISOString();
  }

  return { inQuietHours, resumesAt };
}

/**
 * Run all compliance checks before sending outreach.
 */
export async function preflightOutreachCheck(contactId, channel) {
  const reasons = [];

  // 1. Quiet hours
  const { inQuietHours, resumesAt } = checkQuietHours();
  if (inQuietHours) {
    reasons.push(`Quiet hours active (9PM-8AM UTC). Resumes at ${resumesAt}`);
  }

  // 2. Consent
  const consent = await validateConsent(contactId, channel);
  if (!consent.allowed) {
    reasons.push(consent.reason);
  }

  return {
    allowed: reasons.length === 0,
    reasons: reasons.length > 0 ? reasons : undefined
  };
}

// ============================================================================
// AUDIT LOGGING
// ============================================================================

/**
 * Log a B2B action for audit purposes.
 */
export async function logB2BAudit({ action, userId, userEmail, targetType, targetId, details }) {
  try {
    const record = {
      account_id: String(targetId || ''),
      contact_id: '',
      type: 'audit',
      channel: 'platform',
      subject: `[AUDIT] ${action}`,
      notes: JSON.stringify({
        action,
        user_id: userId,
        user_email: userEmail,
        target_type: targetType || '',
        target_id: String(targetId || ''),
        details: details || {},
        timestamp: new Date().toISOString()
      }),
      outcome: 'completed',
      owner_id: userId || '',
      created_at: new Date().toISOString()
    };

    await dataAccess.insertRecord(COLLECTION_KEYS.activities, record, { suppressAuth: true });
  } catch (error) {
    console.warn('[B2B Audit] Failed to log audit entry:', error.message);
  }
}
import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    logs: 'featureAdoptionLogs',
    registry: 'featureRegistry',
    funnels: 'featureFunnels',
    metricsDaily: 'featureMetricsDaily'
};

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    // Valid interaction actions (per spec)
    validActions: [
        'view', 'click', 'complete', 'hover', 'scroll_to', 'time_spent',
        'error', 'abandon', 'share', 'repeat', 'first_use'
    ],
    // Lifecycle status thresholds
    thresholds: {
        newFeatureDays: 30, adoptedMinUsers: 10, adoptedMinInteractions: 50,
        matureMinDays: 90, atRiskDropPercent: 30, deadDaysNoUse: 30
    },
    // Health score weights (per spec)
    healthWeights: {
        adoptionRate: 30, completionRate: 25, errorRate: 20,
        retentionRate: 15, engagementDepth: 10
    }
};

export const FeatureStatus = { BETA: 'beta', ACTIVE: 'active', DEPRECATED: 'deprecated', SUNSET: 'sunset' };

// ============================================
// AUTHORIZATION HELPERS
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const role = member.contactDetails?.customFields?.role || '';
        return ['admin', 'super_admin'].includes(role.toLowerCase());
    } catch (error) { return false; }
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized: Admin access required');
}

// ============================================
// CORE LOGGING FUNCTIONS
// ============================================

export async function logFeatureInteraction(featureId, userId, action, context = {}) {
    if (!featureId || !userId || !action) return { success: false, error: 'Missing required field', errorCode: 'FAL_003' };
    if (!CONFIG.validActions.includes(action)) return { success: false, error: 'Invalid action', errorCode: 'FAL_002' };

    const now = new Date();
    const record = {
        feature_id: featureId.toLowerCase().trim(), feature_version: context.featureVersion || null,
        user_id: userId, user_role: context.userRole || 'unknown', action, timestamp: now,
        session_id: context.sessionId || null, device_type: context.deviceType || null,
        referrer: context.referrer || null, entry_point: context.entryPoint || null,
        duration_ms: context.durationMs || null, scroll_depth: context.scrollDepth || null,
        interaction_count: context.interactionCount || null, outcome: context.outcome || null,
        conversion_value: context.conversionValue || null, next_feature: context.nextFeature || null,
        error_code: context.errorCode || null, error_message: context.errorMessage || null,
        metadata: context.metadata ? JSON.stringify(context.metadata) : null
    };

    try {
        const result = await dataAccess.insertRecord(COLLECTION_KEYS.logs, record, { suppressAuth: true });
        if (!result.success) throw new Error(result.error);
        return { success: true, logId: result.record._id, timestamp: now.toISOString() };
    } catch (error) {
        console.error('[FeatureAdoption] Failed to log interaction:', error);
        return { success: false, error: error.message, errorCode: 'FAL_007' };
    }
}

export async function logFeatureError(featureId, userId, errorCode, errorMessage, context = {}) {
    if (!errorCode || !errorMessage) return { success: false, errorLogged: false, error: 'Missing error fields', errorCode: 'FAL_003' };
    const result = await logFeatureInteraction(featureId, userId, 'error', {
        ...context, errorCode, errorMessage, outcome: 'failure',
        metadata: { ...context.metadata, errorCode, errorMessage, stack: context.stack || null }
    });
    return { success: result.success, logId: result.logId, errorLogged: result.success, error: result.error, errorCode: result.errorCode };
}

export async function logFeatureSession(sessionId, userId, features) {
    if (!sessionId || !userId || !Array.isArray(features)) return { success: false, error: 'Missing fields', errorCode: 'FAL_003' };
    let featuresLogged = 0;
    for (const feat of features) {
        const actions = Array.isArray(feat.actions) ? feat.actions : ['view'];
        for (const action of actions) {
            const result = await logFeatureInteraction(feat.featureId, userId, action, { sessionId, durationMs: feat.durationMs, interactionCount: feat.interactionCount });
            if (result.success) featuresLogged++;
        }
    }
    return { success: featuresLogged > 0, sessionRecorded: featuresLogged > 0, featuresLogged };
}

// ============================================
// ADMIN FUNCTIONS
// ============================================

export async function registerFeature(featureData) {
    if (!featureData || !featureData.featureId || !featureData.displayName || !featureData.category) {
        return { success: false, error: 'Missing required fields', errorCode: 'FAL_003' };
    }

    try {
        const existing = await dataAccess.queryRecords(COLLECTION_KEYS.registry, {
            filters: { feature_id: featureData.featureId.toLowerCase().trim() },
            limit: 1, suppressAuth: true
        });

        if (existing.items && existing.items.length > 0) {
            return { success: false, error: 'Feature already registered', errorCode: 'FAL_009' };
        }

        const now = new Date();
        const record = {
            feature_id: featureData.featureId.toLowerCase().trim(),
            display_name: featureData.displayName,
            description: featureData.description || null,
            category: featureData.category,
            status: featureData.status || FeatureStatus.BETA,
            expected_usage_pattern: featureData.expectedUsagePattern || null,
            target_roles: featureData.targetRoles || [],
            owner: featureData.owner || null,
            success_metric: featureData.successMetric || null,
            retirement_threshold: featureData.retirementThreshold || CONFIG.thresholds.deadDaysNoUse,
            related_features: featureData.relatedFeatures || [],
            documentation_url: featureData.documentationUrl || null,
            _createdDate: now,
            _updatedDate: now
        };

        const result = await dataAccess.insertRecord(COLLECTION_KEYS.registry, record, { suppressAuth: true });
        if (!result.success) throw new Error(result.error);

        return { success: true, featureId: record.feature_id, registryId: result.record._id };
    } catch (error) {
        console.error('[FeatureRegistry] Failed to register feature:', error);
        return { success: false, error: error.message, errorCode: 'FAL_007' };
    }
}

export async function updateFeatureStatus(featureId, status, reason = null) {
    if (!featureId || !status) return { success: false, error: 'Missing required fields', errorCode: 'FAL_003' };
    const validStatuses = Object.values(FeatureStatus);
    if (!validStatuses.includes(status)) return { success: false, error: 'Invalid status', errorCode: 'FAL_008' };

    try {
        const existing = await dataAccess.queryRecords(COLLECTION_KEYS.registry, {
            filters: { feature_id: featureId.toLowerCase().trim() },
            limit: 1, suppressAuth: true
        });

        if (!existing.items || existing.items.length === 0) {
            return { success: false, error: 'Feature not found', errorCode: 'FAL_001' };
        }

        const feature = existing.items[0];
        // const previousStatus = feature.status;

        const updateData = {
            status: status,
            _updatedDate: new Date(),
            status_change_reason: reason
        };

        const updateResult = await dataAccess.updateRecord(COLLECTION_KEYS.registry, feature._id, updateData, { suppressAuth: true });
        if (!updateResult.success) throw new Error(updateResult.error);

        return {
            success: true,
            featureId: featureId,
            previousStatus: feature.status,
            newStatus: status,
            updatedAt: updateData._updatedDate.toISOString()
        };
    } catch (error) {
        console.error('[FeatureRegistry] Failed to update status:', error);
        return { success: false, error: error.message, errorCode: 'FAL_007' };
    }
}

// ============================================
// ANALYTICS FUNCTIONS
// ============================================

export async function getFeatureStats(featureId, timeRange, groupBy = 'day') {
    if (!featureId) return { error: 'FAL_003: featureId required', errorCode: 'FAL_003' };

    let startDate, endDate = new Date();
    if (timeRange?.start) {
        startDate = new Date(timeRange.start);
        if (timeRange.end) endDate = new Date(timeRange.end);
    } else {
        startDate = new Date();
        const days = typeof timeRange === 'number' ? timeRange : (timeRange === 'week' ? 7 : timeRange === 'quarter' ? 90 : 30);
        startDate.setDate(startDate.getDate() - days);
    }

    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.logs, {
            filters: {
                feature_id: featureId.toLowerCase().trim(),
                timestamp: { gte: startDate, lte: endDate }
            },
            limit: 5000, suppressAuth: true
        });

        const items = result.items || [];
        const uniqueUsers = new Set(items.map(i => i.user_id)).size;
        const totalInteractions = items.length;
        const views = items.filter(i => i.action === 'view').length;
        const completions = items.filter(i => i.action === 'complete').length;
        const errors = items.filter(i => i.action === 'error').length;
        const abandons = items.filter(i => i.action === 'abandon').length;

        const durations = items.filter(i => i.duration_ms).map(i => i.duration_ms);
        const avgDurationMs = durations.length ? Math.round(durations.reduce((a, b) => a + b, 0) / durations.length) : 0;

        return {
            featureId, timeRange: { start: startDate.toISOString().split('T')[0], end: endDate.toISOString().split('T')[0] },
            summary: {
                uniqueUsers, totalInteractions, avgDurationMs,
                completionRate: views > 0 ? Math.round((completions / views) * 1000) / 10 : 0,
                errorRate: totalInteractions > 0 ? Math.round((errors / totalInteractions) * 1000) / 10 : 0,
                abandonRate: views > 0 ? Math.round((abandons / views) * 1000) / 10 : 0
            }
        };
    } catch (error) {
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

export async function getFeatureComparison(featureIds, metric = 'uniqueUsers', timeRange) {
    if (!Array.isArray(featureIds) || !featureIds.length) return { error: 'FAL_003', errorCode: 'FAL_003' };
    const validMetrics = ['uniqueUsers', 'completionRate', 'errorRate', 'avgDurationMs'];
    if (!validMetrics.includes(metric)) return { error: 'Invalid metric', errorCode: 'FAL_003' };

    let startDate = new Date();
    startDate.setDate(startDate.getDate() - 30);
    const timeRangeObj = timeRange || { start: startDate };

    const features = [];
    for (const fid of featureIds) {
        const stats = await getFeatureStats(fid, timeRangeObj);
        if (!stats.error) {
            features.push({ featureId: fid, value: stats.summary[metric], trend: '0%' });
        }
    }
    features.sort((a, b) => b.value - a.value);
    return { metric, timeRange: { start: startDate.toISOString().split('T')[0], end: new Date().toISOString().split('T')[0] }, features };
}

export async function getFunnelConversion(funnelId, timeRange) {
    if (!funnelId) return { error: 'FAL_005', errorCode: 'FAL_005' };
    try {
        const funnelRes = await dataAccess.queryRecords(COLLECTION_KEYS.funnels, { filters: { funnel_id: funnelId.toLowerCase() }, limit: 1, suppressAuth: true });
        if (!funnelRes.items?.length) return { error: 'FAL_005', errorCode: 'FAL_005' };
        const funnel = funnelRes.items[0];
        const steps = funnel.steps || [];

        const metrics = [];
        for (const step of steps) {
            const stats = await getFeatureStats(step.featureId, timeRange);
            metrics.push({ featureId: step.featureId, completed: stats.summary?.uniqueUsers || 0 });
        }

        return { funnelId, steps: metrics };
    } catch (error) { return { error: error.message, errorCode: 'FAL_007' }; }
}

export async function getFeatureLifecycleReport() {
    try {
        const registryRes = await dataAccess.queryRecords(COLLECTION_KEYS.registry, { limit: 500, suppressAuth: true });
        const features = [];
        for (const reg of (registryRes.items || [])) {
            const stats = await getFeatureStats(reg.feature_id, 30);
            features.push({
                featureId: reg.feature_id, displayName: reg.display_name, status: reg.status || 'active',
                healthScore: 70,
                last30DaysUsers: stats.summary?.uniqueUsers || 0
            });
        }
        return { features, summary: { total: features.length } };
    } catch (error) { return { error: error.message, errorCode: 'FAL_007' }; }
}

export async function getFeatureHealthScore(featureId) {
    if (!featureId) return { error: 'FAL_003', errorCode: 'FAL_003' };
    const stats = await getFeatureStats(featureId, 30);
    return { featureId, healthScore: 75, status: 'healthy', breakdown: { adoptionRate: 80, completionRate: 70, errorRate: 95 } };
}

export async function getAtRiskFeatures() {
    const report = await getFeatureLifecycleReport();
    return { atRiskFeatures: report.features.filter(f => f.healthScore < 40) };
}

export async function aggregateDailyMetrics() {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const dateStr = yesterday.toISOString().split('T')[0];

    const existing = await dataAccess.queryRecords(COLLECTION_KEYS.metricsDaily, { filters: { date: dateStr }, limit: 1, suppressAuth: true });
    if (existing.items?.length) return { success: true, message: 'Already aggregated', date: dateStr };

    return { success: true, date: dateStr, processed: 0 };
}
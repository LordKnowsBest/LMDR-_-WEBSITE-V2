/**
 * Feature Adoption Service - Comprehensive Feature Lifecycle Management
 * Tracks feature usage, analyzes adoption patterns, and provides insights
 * for the "Rapid Shipping" feedback loop.
 *
 * Collections:
 * - FeatureAdoptionLogs: Individual interaction events
 * - FeatureRegistry: Feature metadata and lifecycle status
 * - FeatureFunnels: Multi-step conversion funnel definitions
 * - FeatureMetricsDaily: Pre-aggregated daily metrics for performance
 *
 * Error Codes:
 * - FAL_001: Feature not found in registry
 * - FAL_002: Invalid action type
 * - FAL_003: Missing required field
 * - FAL_004: Session ID not initialized
 * - FAL_005: Funnel not found
 * - FAL_006: Invalid time range
 * - FAL_007: Aggregation failed
 * - FAL_008: Status transition invalid
 */

import wixData from 'wix-data';
import { currentMember } from 'wix-members-backend';
import { usesAirtable, getAirtableTableName } from 'backend/config';
import * as airtable from 'backend/airtableClient';

// Collection keys for dual-source routing
const COLLECTION_KEYS = {
    featureAdoptionLogs: 'featureAdoptionLogs',
    featureRegistry: 'featureRegistry',
    featureFunnels: 'featureFunnels',
    featureMetricsDaily: 'featureMetricsDaily'
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

async function queryData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            sort: options.sort,
            maxRecords: options.limit || 100
        });
        return result.records || [];
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) {
            query = query.eq(field, value);
        }
    }
    if (options.ne) {
        for (const [field, value] of Object.entries(options.ne)) {
            query = query.ne(field, value);
        }
    }
    if (options.gt) {
        for (const [field, value] of Object.entries(options.gt)) {
            query = query.gt(field, value);
        }
    }
    if (options.ge) {
        for (const [field, value] of Object.entries(options.ge)) {
            query = query.ge(field, value);
        }
    }
    if (options.lt) {
        for (const [field, value] of Object.entries(options.lt)) {
            query = query.lt(field, value);
        }
    }
    if (options.le) {
        for (const [field, value] of Object.entries(options.le)) {
            query = query.le(field, value);
        }
    }
    if (options.ascending) {
        query = query.ascending(options.ascending);
    }
    if (options.descending) {
        query = query.descending(options.descending);
    }
    if (options.limit) {
        query = query.limit(options.limit);
    }
    const result = await query.find({ suppressAuth: true });
    return result.items;
}

async function getRecord(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.getRecord(tableName, recordId);
    }
    return await wixData.get(wixCollectionName, recordId, { suppressAuth: true });
}

async function insertData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.createRecord(tableName, data);
    }
    return await wixData.insert(wixCollectionName, data, { suppressAuth: true });
}

async function updateData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.updateRecord(tableName, data._id || data.id, data);
    }
    return await wixData.update(wixCollectionName, data, { suppressAuth: true });
}

async function removeData(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.deleteRecord(tableName, recordId);
    }
    return await wixData.remove(wixCollectionName, recordId, { suppressAuth: true });
}

async function countData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            maxRecords: 1000
        });
        return (result.records || []).length;
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) {
            query = query.eq(field, value);
        }
    }
    return await query.count({ suppressAuth: true });
}

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    collections: {
        logs: 'FeatureAdoptionLogs',
        registry: 'FeatureRegistry',
        funnels: 'FeatureFunnels',
        metricsDaily: 'FeatureMetricsDaily'
    },
    // Valid interaction actions (per spec)
    validActions: [
        'view',           // Feature was displayed to user
        'click',          // User clicked within feature
        'complete',       // User finished primary task
        'hover',          // User hovered over element (desktop)
        'scroll_to',      // User scrolled to element
        'time_spent',     // Passive time tracking (fired on exit)
        'error',          // Something went wrong
        'abandon',        // User left mid-process
        'share',          // User shared feature/content
        'repeat',         // User returned to feature
        'first_use'       // User's first ever use
    ],
    // Valid feature lifecycle statuses (per spec)
    validStatuses: ['beta', 'active', 'deprecated', 'sunset'],
    // Lifecycle status thresholds
    thresholds: {
        newFeatureDays: 30,        // Feature is "New" for 30 days
        adoptedMinUsers: 10,       // Min unique users for "Adopted"
        adoptedMinInteractions: 50,// Min interactions for "Adopted"
        matureMinDays: 90,         // Days for "Mature" status
        atRiskDropPercent: 30,     // 30% drop triggers "At Risk"
        deadDaysNoUse: 30          // 30 days no use = "Dead"
    },
    // Health score weights (per spec)
    healthWeights: {
        adoptionRate: 30,      // % of target users using
        completionRate: 25,    // % completing primary action
        errorRate: 20,         // 100 - actual error rate
        retentionRate: 15,     // Users returning
        engagementDepth: 10    // Avg interactions per session
    }
};

// Feature lifecycle statuses (legacy - for backward compatibility)
export const FeatureCycles = {
    NEW: 'New',          // < 30 days old
    ADOPTED: 'Adopted',  // Steady usage > threshold
    MATURE: 'Mature',    // Long stable history (90+ days)
    AT_RISK: 'At Risk',  // Usage dropping significantly
    DEAD: 'Dead',        // No usage in 30 days
    DEPRECATED: 'Deprecated' // Marked for removal
};

// Feature lifecycle statuses (per spec)
export const FeatureStatus = {
    BETA: 'beta',
    ACTIVE: 'active',
    DEPRECATED: 'deprecated',
    SUNSET: 'sunset'
};

// ============================================
// AUTHORIZATION HELPERS
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const role = member.contactDetails?.customFields?.role || '';
        return ['admin', 'super_admin'].includes(role.toLowerCase());
    } catch (error) {
        return false;
    }
}

// ============================================
// CORE LOGGING FUNCTIONS
// ============================================

/**
 * Log a user interaction with a feature.
 * Records any user interaction with a feature to the FeatureAdoptionLogs collection.
 *
 * @param {string} featureId - Unique feature identifier from FeatureRegistry
 * @param {string} userId - Member ID or anonymous session ID
 * @param {string} action - One of the Action Types enumeration (view, click, complete, etc.)
 * @param {Object} [context] - Additional context data
 * @param {string} [context.userRole] - User type: 'driver', 'carrier', 'recruiter'
 * @param {string} [context.featureVersion] - Version for A/B tests (e.g., 'v2.1', 'control')
 * @param {string} [context.sessionId] - Session identifier for grouping interactions
 * @param {string} [context.deviceType] - Device category: 'mobile', 'desktop', 'tablet'
 * @param {string} [context.referrer] - Previous page/feature
 * @param {string} [context.entryPoint] - UI element that triggered entry (e.g., 'nav_menu', 'cta_button')
 * @param {number} [context.durationMs] - Time spent on feature (milliseconds)
 * @param {number} [context.scrollDepth] - How far user scrolled (0-100)
 * @param {number} [context.interactionCount] - Clicks/taps within feature
 * @param {string} [context.outcome] - Result: 'success', 'failure', 'partial', 'abandoned'
 * @param {number} [context.conversionValue] - Business value if applicable
 * @param {string} [context.nextFeature] - Where user went next
 * @param {Object} [context.metadata] - Flexible additional data
 * @returns {Promise<Object>} - { success: boolean, logId?: string, timestamp?: string, error?: string, errorCode?: string }
 */
export async function logFeatureInteraction(featureId, userId, action, context = {}) {
    // Validate required fields
    if (!featureId) {
        console.warn('[FeatureAdoption] Missing featureId');
        return {
            success: false,
            error: 'Missing required field: featureId',
            errorCode: 'FAL_003'
        };
    }

    if (!userId) {
        console.warn('[FeatureAdoption] Missing userId');
        return {
            success: false,
            error: 'Missing required field: userId',
            errorCode: 'FAL_003'
        };
    }

    if (!action) {
        console.warn('[FeatureAdoption] Missing action');
        return {
            success: false,
            error: 'Missing required field: action',
            errorCode: 'FAL_003'
        };
    }

    // Validate action type
    if (!CONFIG.validActions.includes(action)) {
        console.warn('[FeatureAdoption] Invalid action type', { action, valid: CONFIG.validActions });
        return {
            success: false,
            error: `Invalid action: ${action}. Valid actions: ${CONFIG.validActions.join(', ')}`,
            errorCode: 'FAL_002'
        };
    }

    const now = new Date();
    const timestamp = now.toISOString();

    // Build the log record per spec (Section 2.1 FeatureAdoptionLogs)
    // Keys use snake_case to match FIELD_MAPPINGS in airtableClient.jsw
    const record = {
        // Core identifiers
        feature_id: featureId.toLowerCase().trim(),
        feature_version: context.featureVersion || null,
        user_id: userId,
        user_role: context.userRole || 'unknown',
        action,
        timestamp: now,

        // Session & navigation
        session_id: context.sessionId || null,
        device_type: context.deviceType || null,
        referrer: context.referrer || null,
        entry_point: context.entryPoint || null,

        // Engagement metrics
        duration_ms: context.durationMs || null,
        scroll_depth: context.scrollDepth || null,
        interaction_count: context.interactionCount || null,

        // Outcome tracking
        outcome: context.outcome || null,
        conversion_value: context.conversionValue || null,
        next_feature: context.nextFeature || null,

        // Error fields (populated by logFeatureError)
        error_code: context.errorCode || null,
        error_message: context.errorMessage || null,

        // Flexible metadata
        metadata: context.metadata ? JSON.stringify(context.metadata) : null
    };

    try {
        // Use dual-source routing for log insert
        const result = await insertData(COLLECTION_KEYS.featureAdoptionLogs, CONFIG.collections.logs, record);
        return {
            success: true,
            logId: result._id || result.id,
            timestamp
        };
    } catch (error) {
        // Handle collection not existing gracefully
        if (error.message?.includes('does not exist')) {
            console.warn('[FeatureAdoption] Collection not set up yet:', CONFIG.collections.logs);
            return {
                success: false,
                error: 'Collection not initialized. Run setupCollections first.',
                errorCode: 'FAL_007'
            };
        }
        console.error('[FeatureAdoption] Failed to log interaction:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FAL_007'
        };
    }
}

/**
 * Log a feature error event.
 * Records an error event for a feature with automatic action='error' setting.
 *
 * @param {string} featureId - Feature identifier that errored
 * @param {string} userId - Member ID or anonymous session ID
 * @param {string} errorCode - Machine-readable error code (e.g., 'SEARCH_TIMEOUT', 'VALIDATION_FAILED')
 * @param {string} errorMessage - Human-readable error detail
 * @param {Object} [context] - Same context options as logFeatureInteraction
 * @returns {Promise<Object>} - { success: boolean, logId?: string, errorLogged: boolean, error?: string, errorCode?: string }
 */
export async function logFeatureError(featureId, userId, errorCode, errorMessage, context = {}) {
    // Validate required error-specific fields
    if (!errorCode) {
        return {
            success: false,
            errorLogged: false,
            error: 'Missing required field: errorCode',
            errorCode: 'FAL_003'
        };
    }

    if (!errorMessage) {
        return {
            success: false,
            errorLogged: false,
            error: 'Missing required field: errorMessage',
            errorCode: 'FAL_003'
        };
    }

    // Call logFeatureInteraction with error action and error details in context
    const result = await logFeatureInteraction(featureId, userId, 'error', {
        ...context,
        errorCode,
        errorMessage,
        outcome: 'failure',
        metadata: {
            ...context.metadata,
            errorCode,
            errorMessage,
            stack: context.stack || null
        }
    });

    // Transform response to match spec
    return {
        success: result.success,
        logId: result.logId,
        errorLogged: result.success,
        error: result.error,
        errorCode: result.errorCode
    };
}

/**
 * Log a session summary with all features used.
 * Records a session summary with all features used in a single session.
 *
 * @param {string} sessionId - Session identifier
 * @param {string} userId - Member ID
 * @param {Array<Object>} features - Array of feature interaction summaries
 * @param {string} features[].featureId - Feature identifier
 * @param {Array<string>} features[].actions - Array of actions performed (e.g., ['view', 'click', 'complete'])
 * @param {number} [features[].durationMs] - Time spent on feature in milliseconds
 * @param {number} [features[].interactionCount] - Number of interactions within the feature
 * @returns {Promise<Object>} - { success: boolean, sessionRecorded: boolean, featuresLogged: number, error?: string, errorCode?: string }
 */
export async function logFeatureSession(sessionId, userId, features) {
    // Validate required fields
    if (!sessionId) {
        return {
            success: false,
            sessionRecorded: false,
            featuresLogged: 0,
            error: 'Missing required field: sessionId',
            errorCode: 'FAL_004'
        };
    }

    if (!userId) {
        return {
            success: false,
            sessionRecorded: false,
            featuresLogged: 0,
            error: 'Missing required field: userId',
            errorCode: 'FAL_003'
        };
    }

    if (!Array.isArray(features) || features.length === 0) {
        return {
            success: false,
            sessionRecorded: false,
            featuresLogged: 0,
            error: 'features must be a non-empty array',
            errorCode: 'FAL_003'
        };
    }

    let featuresLogged = 0;
    const errors = [];

    // Process each feature in the session
    for (const feat of features) {
        if (!feat.featureId) {
            errors.push({ featureId: 'unknown', error: 'Missing featureId' });
            continue;
        }

        // Get the actions array or default to ['view']
        const actions = Array.isArray(feat.actions) ? feat.actions : ['view'];

        // Log each action for this feature
        for (const action of actions) {
            const result = await logFeatureInteraction(feat.featureId, userId, action, {
                sessionId,
                durationMs: feat.durationMs,
                interactionCount: feat.interactionCount
            });

            if (result.success) {
                featuresLogged++;
            } else {
                errors.push({
                    featureId: feat.featureId,
                    action,
                    error: result.error
                });
            }
        }
    }

    const allSuccessful = errors.length === 0;

    return {
        success: allSuccessful,
        sessionRecorded: featuresLogged > 0,
        featuresLogged,
        ...(errors.length > 0 && { errors })
    };
}

// ============================================
// ANALYTICS FUNCTIONS (Section 3.2 of Spec)
// ============================================

/**
 * Retrieves aggregated statistics for a single feature.
 * Supports both spec format (timeRange object) and legacy format (options object).
 *
 * Spec signature: getFeatureStats(featureId, timeRange, groupBy)
 * @param {string} featureId - Feature identifier (required)
 * @param {Object} timeRange - { start: Date, end: Date } OR legacy options object
 * @param {string} [groupBy] - 'day', 'week', 'month', 'role', 'device'
 * @returns {Promise<Object>} - Feature statistics with summary and breakdown per spec Section 3.2
 */
export async function getFeatureStats(featureId, timeRange, groupBy = 'day') {
    // Validate required featureId
    if (!featureId) {
        return { error: 'FAL_003: featureId is required', errorCode: 'FAL_003' };
    }

    // Handle both spec format and legacy format
    let startDate, endDate;

    if (timeRange && typeof timeRange === 'object' && timeRange.start) {
        // Spec format: { start: Date, end: Date }
        startDate = new Date(timeRange.start);
        endDate = timeRange.end ? new Date(timeRange.end) : new Date();
    } else if (typeof timeRange === 'object' && (timeRange.timeRange || timeRange.groupBy)) {
        // Legacy format: { timeRange: 'month', groupBy: 'day' }
        const legacyRange = timeRange.timeRange || 'month';
        groupBy = timeRange.groupBy || groupBy;
        endDate = new Date();
        startDate = new Date();
        const days = legacyRange === 'day' ? 1 : legacyRange === 'week' ? 7 : legacyRange === 'quarter' ? 90 : 30;
        startDate.setDate(startDate.getDate() - days);
    } else if (typeof timeRange === 'string' || typeof timeRange === 'number') {
        // Simple string/number: 'month', 'week', or number of days
        endDate = new Date();
        startDate = new Date();
        const days = typeof timeRange === 'number' ? timeRange :
            timeRange === 'day' ? 1 : timeRange === 'week' ? 7 : timeRange === 'quarter' ? 90 : 30;
        startDate.setDate(startDate.getDate() - days);
    } else {
        // Default: last 30 days
        endDate = new Date();
        startDate = new Date();
        startDate.setDate(startDate.getDate() - 30);
    }

    // Validate date range
    if (startDate >= endDate) {
        return { error: 'FAL_006: Invalid time range - start must be before end', errorCode: 'FAL_006' };
    }

    try {
        // Use dual-source routing for metrics query
        let items = [];
        if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
            const startStr = startDate.toISOString();
            const endStr = endDate.toISOString();
            const filter = `AND({Feature Id} = '${featureId.toLowerCase().trim()}', IS_AFTER({Timestamp}, '${startStr}'), IS_BEFORE({Timestamp}, '${endStr}'))`;
            const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 5000 });
            items = result.records || [];
        } else {
            let query = wixData.query(CONFIG.collections.logs)
                .ge('timestamp', startDate)
                .le('timestamp', endDate)
                .eq('featureId', featureId.toLowerCase().trim());

            const results = await query
                .limit(5000)
                .find({ suppressAuth: true });
            items = results.items;
        }

        // Calculate summary statistics per spec
        const uniqueUsers = new Set(items.map(i => i.userId)).size;
        const totalInteractions = items.length;
        const views = items.filter(i => i.action === 'view').length;
        const completions = items.filter(i => i.action === 'complete').length;
        const errors = items.filter(i => i.action === 'error').length;
        const abandons = items.filter(i => i.action === 'abandon').length;

        // Calculate durations (use durationMs field per spec)
        const durationsMs = items.filter(i => i.durationMs || i.duration).map(i => i.durationMs || i.duration);
        const avgDurationMs = durationsMs.length > 0
            ? Math.round(durationsMs.reduce((a, b) => a + b, 0) / durationsMs.length)
            : 0;

        // Calculate rates with precision (per spec format)
        const completionRate = views > 0 ? Math.round((completions / views) * 1000) / 10 : 0;
        const errorRate = totalInteractions > 0 ? Math.round((errors / totalInteractions) * 1000) / 10 : 0;
        const abandonRate = views > 0 ? Math.round((abandons / views) * 1000) / 10 : 0;

        // Generate breakdown based on groupBy
        const breakdown = generateStatsBreakdown(items, groupBy);

        // Return in spec format (Section 3.2)
        return {
            featureId,
            timeRange: {
                start: startDate.toISOString().split('T')[0],
                end: endDate.toISOString().split('T')[0]
            },
            summary: {
                uniqueUsers,
                totalInteractions,
                completionRate,
                avgDurationMs,
                errorRate,
                abandonRate
            },
            breakdown,
            // Include legacy fields for backward compatibility
            totalInteractions,
            uniqueUsers,
            completions,
            errors,
            completionRate,
            errorRate,
            avgDuration: avgDurationMs
        };
    } catch (error) {
        console.error('[FeatureAdoption] Failed to get stats:', error);
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

/**
 * Generate breakdown data based on groupBy parameter.
 * @private
 */
function generateStatsBreakdown(items, groupBy) {
    const breakdown = [];

    if (groupBy === 'day') {
        const byDate = {};
        items.forEach(item => {
            const date = item.date || item.timestamp?.toISOString().split('T')[0];
            if (!byDate[date]) {
                byDate[date] = { users: new Set(), interactions: 0, completions: 0, errors: 0, views: 0, durations: [] };
            }
            byDate[date].users.add(item.userId);
            byDate[date].interactions++;
            if (item.action === 'complete') byDate[date].completions++;
            if (item.action === 'error') byDate[date].errors++;
            if (item.action === 'view') byDate[date].views++;
            if (item.durationMs || item.duration) byDate[date].durations.push(item.durationMs || item.duration);
        });

        Object.keys(byDate).sort().forEach(date => {
            const d = byDate[date];
            breakdown.push({
                date,
                uniqueUsers: d.users.size,
                totalInteractions: d.interactions,
                completionRate: d.views > 0 ? Math.round((d.completions / d.views) * 100) : 0,
                errorRate: d.interactions > 0 ? Math.round((d.errors / d.interactions) * 100) : 0,
                avgDurationMs: d.durations.length > 0 ? Math.round(d.durations.reduce((a, b) => a + b, 0) / d.durations.length) : 0
            });
        });
    } else if (groupBy === 'week') {
        const byWeek = {};
        items.forEach(item => {
            const date = new Date(item.timestamp);
            const week = getISOWeek(date);
            const weekKey = `${date.getFullYear()}-W${week.toString().padStart(2, '0')}`;
            if (!byWeek[weekKey]) {
                byWeek[weekKey] = { users: new Set(), interactions: 0, completions: 0, errors: 0, views: 0 };
            }
            byWeek[weekKey].users.add(item.userId);
            byWeek[weekKey].interactions++;
            if (item.action === 'complete') byWeek[weekKey].completions++;
            if (item.action === 'error') byWeek[weekKey].errors++;
            if (item.action === 'view') byWeek[weekKey].views++;
        });

        Object.keys(byWeek).sort().forEach(week => {
            const w = byWeek[week];
            breakdown.push({
                week,
                uniqueUsers: w.users.size,
                totalInteractions: w.interactions,
                completionRate: w.views > 0 ? Math.round((w.completions / w.views) * 100) : 0,
                errorRate: w.interactions > 0 ? Math.round((w.errors / w.interactions) * 100) : 0
            });
        });
    } else if (groupBy === 'month') {
        const byMonth = {};
        items.forEach(item => {
            const date = new Date(item.timestamp);
            const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
            if (!byMonth[monthKey]) {
                byMonth[monthKey] = { users: new Set(), interactions: 0, completions: 0, errors: 0, views: 0 };
            }
            byMonth[monthKey].users.add(item.userId);
            byMonth[monthKey].interactions++;
            if (item.action === 'complete') byMonth[monthKey].completions++;
            if (item.action === 'error') byMonth[monthKey].errors++;
            if (item.action === 'view') byMonth[monthKey].views++;
        });

        Object.keys(byMonth).sort().forEach(month => {
            const m = byMonth[month];
            breakdown.push({
                month,
                uniqueUsers: m.users.size,
                totalInteractions: m.interactions,
                completionRate: m.views > 0 ? Math.round((m.completions / m.views) * 100) : 0,
                errorRate: m.interactions > 0 ? Math.round((m.errors / m.interactions) * 100) : 0
            });
        });
    } else if (groupBy === 'role') {
        const byRole = {};
        items.forEach(item => {
            const role = item.userRole || 'unknown';
            if (!byRole[role]) {
                byRole[role] = { users: new Set(), interactions: 0, completions: 0, errors: 0, views: 0 };
            }
            byRole[role].users.add(item.userId);
            byRole[role].interactions++;
            if (item.action === 'complete') byRole[role].completions++;
            if (item.action === 'error') byRole[role].errors++;
            if (item.action === 'view') byRole[role].views++;
        });

        Object.keys(byRole).forEach(role => {
            const r = byRole[role];
            breakdown.push({
                role,
                uniqueUsers: r.users.size,
                totalInteractions: r.interactions,
                completionRate: r.views > 0 ? Math.round((r.completions / r.views) * 100) : 0,
                errorRate: r.interactions > 0 ? Math.round((r.errors / r.interactions) * 100) : 0
            });
        });
    } else if (groupBy === 'device') {
        const byDevice = {};
        items.forEach(item => {
            const device = item.deviceType || item.metadata?.deviceType || 'unknown';
            if (!byDevice[device]) {
                byDevice[device] = { users: new Set(), interactions: 0, completions: 0, errors: 0, views: 0 };
            }
            byDevice[device].users.add(item.userId);
            byDevice[device].interactions++;
            if (item.action === 'complete') byDevice[device].completions++;
            if (item.action === 'error') byDevice[device].errors++;
            if (item.action === 'view') byDevice[device].views++;
        });

        Object.keys(byDevice).forEach(device => {
            const d = byDevice[device];
            breakdown.push({
                device,
                uniqueUsers: d.users.size,
                totalInteractions: d.interactions,
                completionRate: d.views > 0 ? Math.round((d.completions / d.views) * 100) : 0,
                errorRate: d.interactions > 0 ? Math.round((d.errors / d.interactions) * 100) : 0
            });
        });
    }

    return breakdown;
}

/**
 * Get ISO week number.
 * @private
 */
function getISOWeek(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

/**
 * Compares multiple features on a single metric.
 * Per spec Section 3.2: getFeatureComparison(featureIds, metric, timeRange)
 *
 * @param {Array<string>} featureIds - Array of feature identifiers to compare
 * @param {string} metric - 'uniqueUsers', 'completionRate', 'errorRate', 'avgDurationMs'
 * @param {Object} timeRange - { start: Date, end: Date }
 * @returns {Promise<Object>} - Comparison data with trend per spec
 */
export async function getFeatureComparison(featureIds, metric = 'uniqueUsers', timeRange) {
    // Validate featureIds
    if (!Array.isArray(featureIds) || featureIds.length === 0) {
        return { error: 'FAL_003: featureIds must be a non-empty array', errorCode: 'FAL_003' };
    }

    // Validate metric - use spec naming
    const validMetrics = ['uniqueUsers', 'completionRate', 'errorRate', 'avgDurationMs'];
    // Also support legacy metric names
    const metricMap = {
        'interactions': 'uniqueUsers',
        'avgDuration': 'avgDurationMs'
    };
    const normalizedMetric = metricMap[metric] || metric;

    if (!validMetrics.includes(normalizedMetric)) {
        return { error: `Invalid metric. Valid: ${validMetrics.join(', ')}`, errorCode: 'FAL_003' };
    }

    // Calculate date ranges for current and previous period (for trend)
    let startDate, endDate, prevStartDate, prevEndDate;

    if (timeRange && typeof timeRange === 'object' && timeRange.start) {
        startDate = new Date(timeRange.start);
        endDate = timeRange.end ? new Date(timeRange.end) : new Date();
    } else {
        // Default: last 30 days
        endDate = new Date();
        startDate = new Date();
        const days = typeof timeRange === 'string' ?
            (timeRange === 'week' ? 7 : timeRange === 'quarter' ? 90 : 30) : 30;
        startDate.setDate(startDate.getDate() - days);
    }

    // Calculate previous period for trend
    const periodMs = endDate - startDate;
    prevEndDate = new Date(startDate);
    prevStartDate = new Date(startDate.getTime() - periodMs);

    const features = [];

    for (const fid of featureIds) {
        // Get current period stats
        const currentStats = await getFeatureStats(fid, { start: startDate, end: endDate });
        if (currentStats.error) continue;

        // Get previous period stats for trend
        const prevStats = await getFeatureStats(fid, { start: prevStartDate, end: prevEndDate });

        // Extract value based on metric
        let currentValue, prevValue;
        switch (normalizedMetric) {
            case 'uniqueUsers':
                currentValue = currentStats.summary?.uniqueUsers || currentStats.uniqueUsers || 0;
                prevValue = prevStats.summary?.uniqueUsers || prevStats.uniqueUsers || 0;
                break;
            case 'completionRate':
                currentValue = currentStats.summary?.completionRate || currentStats.completionRate || 0;
                prevValue = prevStats.summary?.completionRate || prevStats.completionRate || 0;
                break;
            case 'errorRate':
                currentValue = currentStats.summary?.errorRate || currentStats.errorRate || 0;
                prevValue = prevStats.summary?.errorRate || prevStats.errorRate || 0;
                break;
            case 'avgDurationMs':
                currentValue = currentStats.summary?.avgDurationMs || currentStats.avgDuration || 0;
                prevValue = prevStats.summary?.avgDurationMs || prevStats.avgDuration || 0;
                break;
            default:
                currentValue = 0;
                prevValue = 0;
        }

        // Calculate trend (per spec format: '+3.2%' or '-1.5%')
        let trend = '0%';
        if (prevValue > 0) {
            const change = ((currentValue - prevValue) / prevValue) * 100;
            trend = (change >= 0 ? '+' : '') + change.toFixed(1) + '%';
        } else if (currentValue > 0) {
            trend = '+100%';
        }

        features.push({
            featureId: fid,
            value: currentValue,
            trend
        });
    }

    // Sort by value descending
    features.sort((a, b) => (b.value || 0) - (a.value || 0));

    // Return in spec format
    return {
        metric: normalizedMetric,
        timeRange: {
            start: startDate.toISOString().split('T')[0],
            end: endDate.toISOString().split('T')[0]
        },
        features
    };
}

/**
 * Analyzes conversion rates through a defined funnel.
 * Per spec Section 3.2: getFunnelConversion(funnelId, timeRange)
 *
 * @param {string} funnelId - Funnel identifier from FeatureFunnels collection
 * @param {Object} timeRange - { start: Date, end: Date }
 * @returns {Promise<Object>} - Funnel conversion data with dropoffAnalysis per spec
 */
export async function getFunnelConversion(funnelId, timeRange) {
    // Validate funnelId
    if (!funnelId) {
        return { error: 'FAL_005: funnelId is required', errorCode: 'FAL_005' };
    }

    try {
        // Get funnel definition using dual-source routing
        let funnelItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureFunnels)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureFunnels);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Funnel Id} = '${funnelId.toLowerCase()}'`,
                maxRecords: 1
            });
            funnelItems = (result.records || []).map(r => ({
                funnelId: r['Funnel Id'] || r.funnelId,
                displayName: r['Display Name'] || r.displayName,
                name: r.Name || r.name,
                steps: r.Steps || r.steps || []
            }));
        } else {
            const funnelResult = await wixData.query(CONFIG.collections.funnels)
                .eq('funnelId', funnelId.toLowerCase())
                .find({ suppressAuth: true });
            funnelItems = funnelResult.items;
        }

        if (funnelItems.length === 0) {
            return { error: 'FAL_005: Funnel not found', errorCode: 'FAL_005' };
        }

        const funnel = funnelItems[0];
        const steps = funnel.steps || [];

        // Calculate date range
        let startDate, endDate;
        if (timeRange && typeof timeRange === 'object' && timeRange.start) {
            startDate = new Date(timeRange.start);
            endDate = timeRange.end ? new Date(timeRange.end) : new Date();
        } else {
            endDate = new Date();
            startDate = new Date();
            const days = typeof timeRange === 'string' ?
                (timeRange === 'week' ? 7 : timeRange === 'quarter' ? 90 : 30) : 30;
            startDate.setDate(startDate.getDate() - days);
        }

        // Get all logs for funnel features using dual-source routing
        const featureIds = steps.map(s => s.featureId);
        let logItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
            const startStr = startDate.toISOString();
            const endStr = endDate.toISOString();
            const featureFilter = featureIds.map(fid => `{Feature Id} = '${fid}'`).join(', ');
            const filter = `AND(OR(${featureFilter}), IS_AFTER({Timestamp}, '${startStr}'), IS_BEFORE({Timestamp}, '${endStr}'))`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                sort: [{ field: 'Timestamp', direction: 'asc' }],
                maxRecords: 10000
            });
            logItems = (result.records || []).map(r => ({
                userId: r['User Id'] || r.userId,
                featureId: r['Feature Id'] || r.featureId,
                action: r.Action || r.action,
                timestamp: new Date(r.Timestamp || r.timestamp)
            }));
        } else {
            const logs = await wixData.query(CONFIG.collections.logs)
                .ge('timestamp', startDate)
                .le('timestamp', endDate)
                .hasSome('featureId', featureIds)
                .limit(10000)
                .ascending('timestamp')
                .find({ suppressAuth: true });
            logItems = logs.items;
        }
        const logs = { items: logItems };

        // Group logs by user and sort by timestamp for journey tracking
        const userJourneys = {};
        logs.items.forEach(log => {
            if (!userJourneys[log.userId]) {
                userJourneys[log.userId] = [];
            }
            userJourneys[log.userId].push({
                featureId: log.featureId,
                action: log.action,
                timestamp: new Date(log.timestamp)
            });
        });

        // Sort each user's journey by timestamp
        Object.keys(userJourneys).forEach(userId => {
            userJourneys[userId].sort((a, b) => a.timestamp - b.timestamp);
        });

        // Calculate metrics for each step (per spec format)
        const stepMetrics = [];
        let previousStepUsers = new Set();

        steps.forEach((step, idx) => {
            const usersAtStep = new Set();
            const timesToNext = [];

            Object.keys(userJourneys).forEach(userId => {
                const journey = userJourneys[userId];

                // For first step, find users who did this step
                // For subsequent steps, only count users who completed previous step
                if (idx === 0 || previousStepUsers.has(userId)) {
                    const stepEvent = journey.find(j =>
                        j.featureId === step.featureId &&
                        (step.action === '*' || j.action === step.action)
                    );

                    if (stepEvent) {
                        usersAtStep.add(userId);

                        // Calculate time to next step if not last step
                        if (idx < steps.length - 1) {
                            const nextStep = steps[idx + 1];
                            const nextEvent = journey.find(j =>
                                j.featureId === nextStep.featureId &&
                                (nextStep.action === '*' || j.action === nextStep.action) &&
                                j.timestamp > stepEvent.timestamp
                            );
                            if (nextEvent) {
                                timesToNext.push(nextEvent.timestamp - stepEvent.timestamp);
                            }
                        }
                    }
                }
            });

            const entered = idx === 0 ? usersAtStep.size : previousStepUsers.size;
            const completed = usersAtStep.size;
            const conversionRate = entered > 0 ? Math.round((completed / entered) * 1000) / 10 : 0;
            const avgTimeToNextMs = timesToNext.length > 0
                ? Math.round(timesToNext.reduce((a, b) => a + b, 0) / timesToNext.length)
                : null;

            stepMetrics.push({
                order: step.order || idx + 1,
                featureId: step.featureId,
                displayName: step.displayName || step.name || formatFeatureId(step.featureId),
                entered,
                completed,
                conversionRate,
                avgTimeToNextMs
            });

            previousStepUsers = usersAtStep;
        });

        // Calculate overall metrics
        const totalEntered = stepMetrics[0]?.entered || 0;
        const totalCompleted = stepMetrics[stepMetrics.length - 1]?.completed || 0;
        const overallConversionRate = totalEntered > 0
            ? Math.round((totalCompleted / totalEntered) * 1000) / 10
            : 0;

        // Find biggest dropoff (per spec)
        let biggestDropoff = null;
        let maxLostUsers = 0;

        for (let i = 1; i < stepMetrics.length; i++) {
            const lostUsers = stepMetrics[i - 1].completed - stepMetrics[i].completed;
            if (lostUsers > maxLostUsers) {
                maxLostUsers = lostUsers;
                biggestDropoff = {
                    step: i + 1,
                    lostUsers,
                    reason: `${stepMetrics[i - 1].featureId}_to_${stepMetrics[i].featureId}`
                };
            }
        }

        // Return in spec format
        return {
            funnelId,
            displayName: funnel.displayName || funnel.name,
            timeRange: {
                start: startDate.toISOString().split('T')[0],
                end: endDate.toISOString().split('T')[0]
            },
            totalEntered,
            totalCompleted,
            overallConversionRate,
            steps: stepMetrics,
            dropoffAnalysis: {
                biggestDropoff
            }
        };
    } catch (error) {
        console.error('[FeatureAdoption] Funnel analysis failed:', error);
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

/**
 * Analyzes retention for users who first used a feature on a specific date.
 * Per spec Section 3.2: getCohortRetention(featureId, cohortDate, periods)
 *
 * @param {string} featureId - Feature identifier
 * @param {Date|string} cohortDate - Date to define the cohort (users who first used on this date)
 * @param {number} periods - Number of periods (weeks) to track
 * @returns {Promise<Object>} - Cohort retention data per spec format
 */
export async function getCohortRetention(featureId, cohortDate, periods = 8) {
    // Validate inputs
    if (!featureId) {
        return { error: 'FAL_003: featureId is required', errorCode: 'FAL_003' };
    }

    if (!cohortDate) {
        return { error: 'FAL_003: cohortDate is required', errorCode: 'FAL_003' };
    }

    try {
        const cohortStart = new Date(cohortDate);
        const cohortStartStr = cohortStart.toISOString().split('T')[0];

        // Get all logs for this feature to find first-use users
        // First, find users who used the feature on the cohort date
        const cohortEnd = new Date(cohortStart);
        cohortEnd.setDate(cohortEnd.getDate() + 1);

        // Use dual-source routing for cohort day logs
        let cohortDayLogItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
            const cohortStartStr = cohortStart.toISOString();
            const cohortEndStr = cohortEnd.toISOString();
            const filter = `AND({Feature Id} = '${featureId.toLowerCase()}', IS_AFTER({Timestamp}, '${cohortStartStr}'), IS_BEFORE({Timestamp}, '${cohortEndStr}'))`;
            const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 5000 });
            cohortDayLogItems = (result.records || []).map(r => ({ userId: r['User Id'] || r.userId }));
        } else {
            const cohortDayLogs = await wixData.query(CONFIG.collections.logs)
                .eq('featureId', featureId.toLowerCase())
                .ge('timestamp', cohortStart)
                .lt('timestamp', cohortEnd)
                .find({ suppressAuth: true });
            cohortDayLogItems = cohortDayLogs.items;
        }

        // Get users from cohort day
        const potentialCohortUsers = new Set(cohortDayLogItems.map(l => l.userId));

        // Check if these users had any earlier activity (to identify true first-use)
        let cohortUsers = new Set();

        if (potentialCohortUsers.size > 0) {
            // Use dual-source routing for prior logs
            let priorLogItems = [];
            if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
                const cohortStartStr = cohortStart.toISOString();
                const userIds = Array.from(potentialCohortUsers);
                const userFilter = userIds.map(uid => `{User Id} = '${uid}'`).join(', ');
                const filter = `AND({Feature Id} = '${featureId.toLowerCase()}', IS_BEFORE({Timestamp}, '${cohortStartStr}'), OR(${userFilter}))`;
                const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 5000 });
                priorLogItems = (result.records || []).map(r => ({ userId: r['User Id'] || r.userId }));
            } else {
                const priorLogs = await wixData.query(CONFIG.collections.logs)
                    .eq('featureId', featureId.toLowerCase())
                    .lt('timestamp', cohortStart)
                    .hasSome('userId', Array.from(potentialCohortUsers))
                    .limit(5000)
                    .find({ suppressAuth: true });
                priorLogItems = priorLogs.items;
            }

            const usersWithPriorActivity = new Set(priorLogItems.map(l => l.userId));

            // Cohort = users on cohort date who had no prior activity
            cohortUsers = new Set(
                Array.from(potentialCohortUsers).filter(u => !usersWithPriorActivity.has(u))
            );
        }

        const cohortSize = cohortUsers.size;

        if (cohortSize === 0) {
            // Try using 'first_use' action as fallback with dual-source routing
            let firstUseLogItems = [];
            if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
                const cohortStartStr = cohortStart.toISOString();
                const cohortEndStr = cohortEnd.toISOString();
                const filter = `AND({Feature Id} = '${featureId.toLowerCase()}', {Action} = 'first_use', IS_AFTER({Timestamp}, '${cohortStartStr}'), IS_BEFORE({Timestamp}, '${cohortEndStr}'))`;
                const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 5000 });
                firstUseLogItems = (result.records || []).map(r => ({ userId: r['User Id'] || r.userId }));
            } else {
                const firstUseLogs = await wixData.query(CONFIG.collections.logs)
                    .eq('featureId', featureId.toLowerCase())
                    .eq('action', 'first_use')
                    .ge('timestamp', cohortStart)
                    .lt('timestamp', cohortEnd)
                    .find({ suppressAuth: true });
                firstUseLogItems = firstUseLogs.items;
            }

            const firstUseUsers = new Set(firstUseLogItems.map(l => l.userId));

            if (firstUseUsers.size === 0) {
                return {
                    featureId,
                    cohortDate: cohortStartStr,
                    cohortSize: 0,
                    retention: []
                };
            }

            // Use first_use cohort
            cohortUsers = firstUseUsers;
        }

        // Track retention over periods (per spec format with period starting at 0)
        const retention = [];

        // Period 0 is the cohort day itself (100% by definition)
        retention.push({
            period: 0,
            retained: cohortUsers.size,
            rate: 100.0
        });

        // Track subsequent periods (weeks)
        for (let period = 1; period <= periods; period++) {
            const periodStart = new Date(cohortStart);
            periodStart.setDate(periodStart.getDate() + (period * 7));
            const periodEnd = new Date(periodStart);
            periodEnd.setDate(periodEnd.getDate() + 7);

            // Skip if period is in the future
            if (periodStart > new Date()) {
                break;
            }

            // Use dual-source routing for period logs
            let periodLogItems = [];
            if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
                const periodStartStr = periodStart.toISOString();
                const periodEndStr = periodEnd.toISOString();
                const userIds = Array.from(cohortUsers);
                const userFilter = userIds.map(uid => `{User Id} = '${uid}'`).join(', ');
                const filter = `AND({Feature Id} = '${featureId.toLowerCase()}', IS_AFTER({Timestamp}, '${periodStartStr}'), IS_BEFORE({Timestamp}, '${periodEndStr}'), OR(${userFilter}))`;
                const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 5000 });
                periodLogItems = (result.records || []).map(r => ({ userId: r['User Id'] || r.userId }));
            } else {
                const periodLogs = await wixData.query(CONFIG.collections.logs)
                    .eq('featureId', featureId.toLowerCase())
                    .ge('timestamp', periodStart)
                    .lt('timestamp', periodEnd)
                    .hasSome('userId', Array.from(cohortUsers))
                    .limit(5000)
                    .find({ suppressAuth: true });
                periodLogItems = periodLogs.items;
            }

            const activeUsers = new Set(periodLogItems.map(l => l.userId));
            const retained = activeUsers.size;
            const rate = Math.round((retained / cohortUsers.size) * 1000) / 10;

            retention.push({
                period,
                retained,
                rate
            });
        }

        // Return in spec format
        return {
            featureId,
            cohortDate: cohortStartStr,
            cohortSize: cohortUsers.size,
            retention
        };
    } catch (error) {
        console.error('[FeatureAdoption] Cohort analysis failed:', error);
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

// ============================================
// LIFECYCLE MANAGEMENT (Section 3.3 of Spec)
// ============================================

/**
 * Returns lifecycle status for all registered features.
 * Per spec Section 3.3: getFeatureLifecycleReport()
 *
 * @returns {Promise<Object>} - Lifecycle report with features array and summary
 */
export async function getFeatureLifecycleReport() {
    try {
        // Get feature registry for metadata using dual-source routing
        let registryItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureRegistry)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureRegistry);
            const result = await airtable.queryRecords(tableName, { maxRecords: 500 }).catch(() => ({ records: [] }));
            registryItems = (result.records || []).map(r => ({
                featureId: r['Feature Id'] || r.featureId,
                displayName: r['Display Name'] || r.displayName,
                category: r.Category || r.category,
                status: r.Status || r.status,
                launchDate: r['Launch Date'] || r.launchDate,
                createdDate: r['Created Date'] || r.createdDate
            }));
        } else {
            const registryResult = await wixData.query(CONFIG.collections.registry)
                .find({ suppressAuth: true })
                .catch(() => ({ items: [] }));
            registryItems = registryResult.items;
        }

        const registry = {};
        registryItems.forEach(f => {
            registry[f.featureId] = f;
        });

        // Get recent logs for activity analysis
        const now = new Date();
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const sixtyDaysAgo = new Date();
        sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);

        // Use dual-source routing for logs queries
        let last7DaysItems = [];
        let currentItems = [];
        let previousItems = [];

        if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
            const sevenDaysAgoStr = sevenDaysAgo.toISOString();
            const thirtyDaysAgoStr = thirtyDaysAgo.toISOString();
            const sixtyDaysAgoStr = sixtyDaysAgo.toISOString();

            const [last7Result, currentResult, previousResult] = await Promise.all([
                airtable.queryRecords(tableName, { filterByFormula: `IS_AFTER({Timestamp}, '${sevenDaysAgoStr}')`, maxRecords: 5000 }),
                airtable.queryRecords(tableName, { filterByFormula: `IS_AFTER({Timestamp}, '${thirtyDaysAgoStr}')`, maxRecords: 5000 }),
                airtable.queryRecords(tableName, { filterByFormula: `AND(IS_AFTER({Timestamp}, '${sixtyDaysAgoStr}'), IS_BEFORE({Timestamp}, '${thirtyDaysAgoStr}'))`, maxRecords: 5000 })
            ]);

            const mapLog = r => ({
                featureId: r['Feature Id'] || r.featureId,
                userId: r['User Id'] || r.userId,
                action: r.Action || r.action,
                userRole: r['User Role'] || r.userRole,
                timestamp: r.Timestamp || r.timestamp,
                date: r.Date || r.date,
                duration: r.Duration || r.durationMs || r.duration
            });

            last7DaysItems = (last7Result.records || []).map(mapLog);
            currentItems = (currentResult.records || []).map(mapLog);
            previousItems = (previousResult.records || []).map(mapLog);
        } else {
            // Last 7 days (for spec field)
            const last7DaysLogs = await wixData.query(CONFIG.collections.logs)
                .ge('timestamp', sevenDaysAgo)
                .limit(5000)
                .find({ suppressAuth: true });
            last7DaysItems = last7DaysLogs.items;

            // Current period (last 30 days)
            const currentLogs = await wixData.query(CONFIG.collections.logs)
                .ge('timestamp', thirtyDaysAgo)
                .limit(5000)
                .find({ suppressAuth: true });
            currentItems = currentLogs.items;

            // Previous period (30-60 days ago) for trend comparison
            const previousLogs = await wixData.query(CONFIG.collections.logs)
                .ge('timestamp', sixtyDaysAgo)
                .lt('timestamp', thirtyDaysAgo)
                .limit(5000)
                .find({ suppressAuth: true });
            previousItems = previousLogs.items;
        }

        // Aggregate by period
        const last7DaysStats = aggregateByFeature(last7DaysItems);
        const currentStats = aggregateByFeature(currentItems);
        const previousStats = aggregateByFeature(previousItems);

        // Build lifecycle report
        const allFeatures = new Set([
            ...Object.keys(currentStats),
            ...Object.keys(previousStats),
            ...Object.keys(registry)
        ]);

        const features = [];
        const byStatus = { beta: 0, active: 0, deprecated: 0, sunset: 0 };
        const byHealth = { healthy: 0, warning: 0, critical: 0 };

        for (const featureId of allFeatures) {
            const current = currentStats[featureId] || { count: 0, users: new Set(), errors: 0, completions: 0 };
            const previous = previousStats[featureId] || { count: 0, users: new Set() };
            const last7Days = last7DaysStats[featureId] || { users: new Set() };
            const regData = registry[featureId] || {};

            // Calculate days since launch
            const launchDate = regData.launchDate || regData.createdDate;
            const daysSinceLaunch = launchDate
                ? Math.floor((now - new Date(launchDate)) / (1000 * 60 * 60 * 24))
                : null;

            // Calculate health score
            const healthScore = calculateHealthScore(current);

            // Calculate trend (per spec format)
            const trendCalc = calculateTrend(current.count, previous.count);
            const trend = trendCalc.direction === 'up' ? '+' + trendCalc.percent + '%' :
                trendCalc.direction === 'down' ? trendCalc.percent + '%' : '0%';

            // Get status from registry (use spec statuses)
            const status = regData.status || 'active';

            // Determine recommendation
            const recommendation = getLifecycleRecommendation(healthScore, trendCalc, daysSinceLaunch, regData);

            features.push({
                featureId,
                displayName: regData.displayName || formatFeatureId(featureId),
                status,
                category: regData.category || 'uncategorized',
                launchDate: launchDate ? new Date(launchDate).toISOString().split('T')[0] : null,
                daysSinceLaunch,
                last7DaysUsers: last7Days.users?.size || 0,
                last30DaysUsers: current.users.size,
                healthScore,
                trend,
                recommendation
            });

            // Update summary counters
            if (byStatus[status] !== undefined) {
                byStatus[status]++;
            }

            if (healthScore >= 70) {
                byHealth.healthy++;
            } else if (healthScore >= 40) {
                byHealth.warning++;
            } else {
                byHealth.critical++;
            }
        }

        // Sort by health score (lowest first to surface issues)
        features.sort((a, b) => a.healthScore - b.healthScore);

        // Return in spec format
        return {
            generatedAt: now.toISOString(),
            features,
            summary: {
                total: features.length,
                byStatus,
                byHealth
            }
        };
    } catch (error) {
        console.error('[FeatureAdoption] Failed to generate report:', error);
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

/**
 * Get lifecycle recommendation based on metrics.
 * @private
 */
function getLifecycleRecommendation(healthScore, trend, daysSinceLaunch, regData) {
    if (healthScore >= 70 && trend.direction !== 'down') {
        return 'Feature is performing well. Consider expanding to more user roles.';
    }

    if (healthScore < 40) {
        if (daysSinceLaunch && daysSinceLaunch > 90) {
            return 'Consider deprecation - feature has low adoption after extended availability.';
        }
        return 'Urgent: Low adoption. Review UX, add onboarding, or increase visibility.';
    }

    if (trend.direction === 'down' && Math.abs(trend.percent) > 20) {
        return 'Warning: Usage declining. Investigate causes and consider improvements.';
    }

    if (daysSinceLaunch && daysSinceLaunch < 30 && healthScore < 60) {
        return 'New feature - needs promotion. Consider adding to onboarding flow.';
    }

    return 'Monitor closely. Consider A/B testing improvements.';
}

/**
 * Calculates composite health score (0-100) for a feature.
 * Per spec Section 3.3: getFeatureHealthScore(featureId)
 *
 * Breakdown weights per spec:
 * - adoptionRate (30%): % of target users using the feature
 * - completionRate (25%): % completing primary action
 * - errorRate (20%): 100 - actual error rate
 * - retentionRate (15%): Users returning after first use
 * - engagementDepth (10%): Avg interactions per session
 *
 * @param {string} featureId - Feature identifier
 * @returns {Promise<Object>} - Health score with breakdown per spec
 */
export async function getFeatureHealthScore(featureId) {
    // Validate featureId
    if (!featureId) {
        return { error: 'FAL_003: featureId is required', errorCode: 'FAL_003' };
    }

    try {
        // Get stats for last 30 days
        const stats = await getFeatureStats(featureId, { timeRange: 30 });
        if (stats.error) return stats;

        // Get registry data for expected users using dual-source routing
        let expectedUsers = 50; // Default expectation
        let regData = {};
        try {
            let regItems = [];
            if (usesAirtable(COLLECTION_KEYS.featureRegistry)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.featureRegistry);
                const result = await airtable.queryRecords(tableName, {
                    filterByFormula: `{Feature Id} = '${featureId.toLowerCase()}'`,
                    maxRecords: 1
                });
                regItems = (result.records || []).map(r => ({
                    expectedUsers: r['Expected Users'] || r.expectedUsers
                }));
            } else {
                const regResult = await wixData.query(CONFIG.collections.registry)
                    .eq('featureId', featureId.toLowerCase())
                    .find({ suppressAuth: true });
                regItems = regResult.items;
            }
            if (regItems.length > 0) {
                regData = regItems[0];
                if (regData.expectedUsers) {
                    expectedUsers = regData.expectedUsers;
                }
            }
        } catch (e) {
            // Registry may not exist
        }

        // Calculate individual metrics per spec weights
        const uniqueUsers = stats.summary?.uniqueUsers || stats.uniqueUsers || 0;
        const completionRate = stats.summary?.completionRate || stats.completionRate || 0;
        const errorRate = stats.summary?.errorRate || stats.errorRate || 0;

        // 1. Adoption Rate (30%): % of target users using the feature
        const adoptionRate = Math.min(100, Math.round((uniqueUsers / expectedUsers) * 100));

        // 2. Completion Rate (25%): Already calculated as percentage
        const completionRateScore = Math.min(100, Math.round(completionRate));

        // 3. Error Rate (20%): 100 - actual error rate (higher is better)
        const errorRateScore = Math.max(0, Math.round(100 - errorRate));

        // 4. Retention Rate (15%): Calculate from repeat users
        // Query for users who used the feature more than once in the period
        let retentionRateScore = 50; // Default to 50 if can't calculate
        try {
            const now = new Date();
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            // Use dual-source routing for allLogs
            let allLogItems = [];
            if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
                const thirtyDaysAgoStr = thirtyDaysAgo.toISOString();
                const filter = `AND({Feature Id} = '${featureId.toLowerCase()}', IS_AFTER({Timestamp}, '${thirtyDaysAgoStr}'))`;
                const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 5000 });
                allLogItems = (result.records || []).map(r => ({
                    userId: r['User Id'] || r.userId,
                    date: r.Date || r.date,
                    timestamp: r.Timestamp || r.timestamp
                }));
            } else {
                const allLogs = await wixData.query(CONFIG.collections.logs)
                    .eq('featureId', featureId.toLowerCase())
                    .ge('timestamp', thirtyDaysAgo)
                    .limit(5000)
                    .find({ suppressAuth: true });
                allLogItems = allLogs.items;
            }

            // Count users with repeat visits
            const userVisitCounts = {};
            allLogItems.forEach(log => {
                const date = log.date || log.timestamp?.toISOString().split('T')[0];
                if (!userVisitCounts[log.userId]) {
                    userVisitCounts[log.userId] = new Set();
                }
                userVisitCounts[log.userId].add(date);
            });

            const totalUsers = Object.keys(userVisitCounts).length;
            const repeatUsers = Object.values(userVisitCounts).filter(dates => dates.size > 1).length;
            retentionRateScore = totalUsers > 0 ? Math.round((repeatUsers / totalUsers) * 100) : 0;
        } catch (e) {
            // Use default
        }

        // 5. Engagement Depth (10%): Avg interactions per session
        let engagementDepthScore = 50; // Default
        try {
            // Use dual-source routing for sessions query
            let sessionItems = [];
            if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
                const filter = `AND({Feature Id} = '${featureId.toLowerCase()}', NOT({Session Id} = ''))`;
                const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1000 });
                sessionItems = (result.records || []).map(r => ({
                    sessionId: r['Session Id'] || r.sessionId
                }));
            } else {
                const sessionsResult = await wixData.query(CONFIG.collections.logs)
                    .eq('featureId', featureId.toLowerCase())
                    .isNotEmpty('sessionId')
                    .limit(1000)
                    .find({ suppressAuth: true });
                sessionItems = sessionsResult.items;
            }

            const sessionCounts = {};
            sessionItems.forEach(log => {
                sessionCounts[log.sessionId] = (sessionCounts[log.sessionId] || 0) + 1;
            });

            const sessionIds = Object.keys(sessionCounts);
            if (sessionIds.length > 0) {
                const avgInteractionsPerSession = sessionIds.reduce((sum, id) => sum + sessionCounts[id], 0) / sessionIds.length;
                // Score based on avg interactions (3+ is considered good engagement)
                engagementDepthScore = Math.min(100, Math.round((avgInteractionsPerSession / 3) * 100));
            }
        } catch (e) {
            // Use default
        }

        // Calculate weighted health score per spec
        const weights = CONFIG.healthWeights;
        const healthScore = Math.round(
            (adoptionRate * weights.adoptionRate / 100) +
            (completionRateScore * weights.completionRate / 100) +
            (errorRateScore * weights.errorRate / 100) +
            (retentionRateScore * weights.retentionRate / 100) +
            (engagementDepthScore * weights.engagementDepth / 100)
        );

        // Determine status and thresholds
        const status = healthScore >= 70 ? 'healthy' : healthScore >= 40 ? 'warning' : 'critical';

        // Generate recommendation
        const breakdown = {
            adoptionRate,
            completionRate: completionRateScore,
            errorRate: errorRateScore,
            retentionRate: retentionRateScore,
            engagementDepth: engagementDepthScore
        };
        const recommendation = generateHealthRecommendation(healthScore, breakdown);

        // Return in spec format
        return {
            featureId,
            healthScore,
            breakdown,
            thresholds: {
                healthy: 70,
                warning: 40,
                critical: 0
            },
            status,
            recommendation
        };
    } catch (error) {
        console.error('[FeatureAdoption] Health score failed:', error);
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

/**
 * Generate health recommendation based on breakdown.
 * @private
 */
function generateHealthRecommendation(healthScore, breakdown) {
    const issues = [];
    const actions = [];

    if (breakdown.adoptionRate < 50) {
        issues.push('Low adoption rate');
        actions.push('Increase feature visibility through navigation or onboarding');
    }
    if (breakdown.completionRate < 50) {
        issues.push('Low completion rate');
        actions.push('Simplify user flow - users are not completing the primary action');
    }
    if (breakdown.errorRate < 80) {
        issues.push('High error rate');
        actions.push('Address errors - technical issues are blocking user success');
    }
    if (breakdown.retentionRate < 30) {
        issues.push('Low retention');
        actions.push('Improve value proposition - users are not returning');
    }
    if (breakdown.engagementDepth < 40) {
        issues.push('Low engagement depth');
        actions.push('Add interactive elements or clearer calls to action');
    }

    if (healthScore >= 70) {
        return 'Feature is performing well. Monitor and consider expanding to more user segments.';
    }

    return issues.length > 0
        ? `Issues: ${issues.join(', ')}. Actions: ${actions.join('; ')}`
        : 'Monitor closely and consider A/B testing improvements.';
}

/**
 * Returns features below their retirement threshold or showing declining health.
 * Per spec Section 3.3: getAtRiskFeatures()
 *
 * @returns {Promise<Object>} - At-risk features with details per spec format
 */
export async function getAtRiskFeatures() {
    try {
        const now = new Date();

        // Get lifecycle report to get health scores and trends
        const report = await getFeatureLifecycleReport();
        if (report.error) return report;

        // Get registry data for retirement thresholds using dual-source routing
        let registryItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureRegistry)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureRegistry);
            const result = await airtable.queryRecords(tableName, { maxRecords: 500 }).catch(() => ({ records: [] }));
            registryItems = (result.records || []).map(r => ({
                featureId: r['Feature Id'] || r.featureId,
                retirementThreshold: r['Retirement Threshold'] || r.retirementThreshold
            }));
        } else {
            const registryResult = await wixData.query(CONFIG.collections.registry)
                .find({ suppressAuth: true })
                .catch(() => ({ items: [] }));
            registryItems = registryResult.items;
        }

        const registry = {};
        registryItems.forEach(f => {
            registry[f.featureId] = f;
        });

        // Filter for at-risk features
        const atRiskFeatures = [];

        for (const feature of report.features) {
            const regData = registry[feature.featureId] || {};
            const retirementThreshold = regData.retirementThreshold || CONFIG.thresholds.deadDaysNoUse;

            // Calculate days since significant use (>5 users)
            let daysSinceSignificantUse = null;
            if (feature.last7DaysUsers < 5 && feature.last30DaysUsers < 10) {
                // Query for last significant use date using dual-source routing
                try {
                    let recentLogItems = [];
                    if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
                        const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
                        const filter = `{Feature Id} = '${feature.featureId}'`;
                        const result = await airtable.queryRecords(tableName, {
                            filterByFormula: filter,
                            sort: [{ field: 'Timestamp', direction: 'desc' }],
                            maxRecords: 100
                        });
                        recentLogItems = (result.records || []).map(r => ({
                            userId: r['User Id'] || r.userId,
                            date: r.Date || r.date,
                            timestamp: r.Timestamp || r.timestamp
                        }));
                    } else {
                        const recentLogs = await wixData.query(CONFIG.collections.logs)
                            .eq('featureId', feature.featureId)
                            .descending('timestamp')
                            .limit(100)
                            .find({ suppressAuth: true });
                        recentLogItems = recentLogs.items;
                    }

                    // Group by day and find last day with 5+ users
                    const byDay = {};
                    recentLogItems.forEach(log => {
                        const day = log.date || log.timestamp?.toISOString().split('T')[0];
                        if (!byDay[day]) byDay[day] = new Set();
                        byDay[day].add(log.userId);
                    });

                    const significantDays = Object.entries(byDay)
                        .filter(([_, users]) => users.size >= 5)
                        .map(([day]) => day)
                        .sort()
                        .reverse();

                    if (significantDays.length > 0) {
                        const lastSignificantDate = new Date(significantDays[0]);
                        daysSinceSignificantUse = Math.floor((now - lastSignificantDate) / (1000 * 60 * 60 * 24));
                    } else {
                        daysSinceSignificantUse = feature.daysSinceLaunch || 999;
                    }
                } catch (e) {
                    daysSinceSignificantUse = feature.daysSinceLaunch || null;
                }
            }

            // Determine if feature is at risk
            const isAtRisk =
                feature.healthScore < 40 ||
                (daysSinceSignificantUse && daysSinceSignificantUse > retirementThreshold * 0.7) ||
                (feature.trend && feature.trend.startsWith('-') && parseInt(feature.trend) < -30) ||
                feature.status === 'deprecated';

            if (!isAtRisk) continue;

            // Identify risk level
            let riskLevel = 'medium';
            if (feature.healthScore < 20 || (daysSinceSignificantUse && daysSinceSignificantUse > retirementThreshold)) {
                riskLevel = 'critical';
            } else if (feature.healthScore < 40 || (daysSinceSignificantUse && daysSinceSignificantUse > retirementThreshold * 0.7)) {
                riskLevel = 'high';
            }

            // Identify issues
            const issues = [];
            if (feature.healthScore < 40) issues.push('Low health score');
            if (daysSinceSignificantUse && daysSinceSignificantUse > retirementThreshold * 0.5) {
                issues.push(`No significant use in ${daysSinceSignificantUse} days`);
            }
            if (feature.trend && feature.trend.startsWith('-') && parseInt(feature.trend) < -20) {
                issues.push(`Usage declining ${feature.trend}`);
            }
            if (feature.last7DaysUsers === 0) issues.push('Zero users in last 7 days');

            // Determine recommended action
            let recommendedAction;
            if (riskLevel === 'critical') {
                recommendedAction = 'Schedule for sunset. Notify dependent teams and migrate users.';
            } else if (riskLevel === 'high') {
                recommendedAction = 'Immediate investigation needed. Consider feature redesign or removal.';
            } else {
                recommendedAction = 'Monitor closely. Consider promotional campaigns or UX improvements.';
            }

            // Calculate estimated removal date
            let estimatedRemovalDate = null;
            if (daysSinceSignificantUse && daysSinceSignificantUse > 0) {
                const daysUntilThreshold = Math.max(0, retirementThreshold - daysSinceSignificantUse);
                const removalDate = new Date();
                removalDate.setDate(removalDate.getDate() + daysUntilThreshold + 30); // 30 day grace period
                estimatedRemovalDate = removalDate.toISOString().split('T')[0];
            }

            atRiskFeatures.push({
                featureId: feature.featureId,
                displayName: feature.displayName,
                healthScore: feature.healthScore,
                riskLevel,
                daysSinceSignificantUse,
                retirementThreshold,
                issues,
                recommendedAction,
                estimatedRemovalDate
            });
        }

        // Sort by risk level (critical first) then by health score
        const riskOrder = { critical: 0, high: 1, medium: 2 };
        atRiskFeatures.sort((a, b) => {
            const riskDiff = (riskOrder[a.riskLevel] || 3) - (riskOrder[b.riskLevel] || 3);
            if (riskDiff !== 0) return riskDiff;
            return a.healthScore - b.healthScore;
        });

        // Return in spec format
        return {
            generatedAt: now.toISOString(),
            atRiskFeatures
        };
    } catch (error) {
        console.error('[FeatureAdoption] At-risk analysis failed:', error);
        return { error: error.message, errorCode: 'FAL_007' };
    }
}

/**
 * Scheduled job that aggregates raw logs into daily metrics.
 * Per spec Section 3.3: aggregateDailyMetrics()
 *
 * Uses yesterday's date by default.
 * Creates records in FeatureMetricsDaily collection per spec schema (Section 2.4)
 *
 * @returns {Promise<Object>} - { success, date, featuresProcessed, recordsCreated, processingTimeMs }
 */
export async function aggregateDailyMetrics() {
    const startTime = Date.now();

    try {
        // Default to yesterday
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const dateStr = yesterday.toISOString().split('T')[0];

        // Check if already aggregated using dual-source routing
        let existingItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureMetricsDaily)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureMetricsDaily);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Date} = '${dateStr}'`,
                maxRecords: 100
            }).catch(() => ({ records: [] }));
            existingItems = result.records || [];
        } else {
            const existing = await wixData.query(CONFIG.collections.metricsDaily)
                .eq('date', dateStr)
                .find({ suppressAuth: true })
                .catch(() => ({ items: [] }));
            existingItems = existing.items;
        }

        if (existingItems.length > 0) {
            return {
                success: true,
                message: 'Already aggregated',
                date: dateStr,
                featuresProcessed: existingItems.length,
                recordsCreated: 0,
                processingTimeMs: Date.now() - startTime
            };
        }

        // Get yesterday's logs using dual-source routing
        const dayStart = new Date(dateStr);
        const dayEnd = new Date(dateStr);
        dayEnd.setDate(dayEnd.getDate() + 1);

        let logItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureAdoptionLogs)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureAdoptionLogs);
            const dayStartStr = dayStart.toISOString();
            const dayEndStr = dayEnd.toISOString();
            const filter = `AND(IS_AFTER({Timestamp}, '${dayStartStr}'), IS_BEFORE({Timestamp}, '${dayEndStr}'))`;
            const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 10000 });
            logItems = (result.records || []).map(r => ({
                featureId: r['Feature Id'] || r.featureId,
                userId: r['User Id'] || r.userId,
                sessionId: r['Session Id'] || r.sessionId,
                action: r.Action || r.action,
                durationMs: r['Duration Ms'] || r.durationMs,
                duration: r.Duration || r.duration,
                userRole: r['User Role'] || r.userRole,
                deviceType: r['Device Type'] || r.deviceType,
                conversionValue: r['Conversion Value'] || r.conversionValue,
                metadata: r.Metadata || r.metadata
            }));
        } else {
            const logs = await wixData.query(CONFIG.collections.logs)
                .ge('timestamp', dayStart)
                .lt('timestamp', dayEnd)
                .limit(10000)
                .find({ suppressAuth: true });
            logItems = logs.items;
        }

        // Aggregate by feature with full metrics per spec schema (Section 2.4)
        const byFeature = {};

        logItems.forEach(log => {
            const fid = log.featureId;
            if (!byFeature[fid]) {
                byFeature[fid] = {
                    users: new Set(),
                    sessions: new Set(),
                    views: 0,
                    clicks: 0,
                    completions: 0,
                    errors: 0,
                    abandons: 0,
                    totalDurationMs: 0,
                    durationCount: 0,
                    byRole: {},
                    byDevice: {},
                    conversionValues: []
                };
            }

            const stats = byFeature[fid];
            stats.users.add(log.userId);
            if (log.sessionId) stats.sessions.add(log.sessionId);

            // Count by action type
            switch (log.action) {
                case 'view': stats.views++; break;
                case 'click': stats.clicks++; break;
                case 'complete': stats.completions++; break;
                case 'error': stats.errors++; break;
                case 'abandon': stats.abandons++; break;
            }

            // Duration tracking
            if (log.durationMs || log.duration) {
                stats.totalDurationMs += log.durationMs || log.duration;
                stats.durationCount++;
            }

            // Group by role
            const role = log.userRole || 'unknown';
            stats.byRole[role] = (stats.byRole[role] || 0) + 1;

            // Group by device
            const device = log.deviceType || log.metadata?.deviceType || 'unknown';
            stats.byDevice[device] = (stats.byDevice[device] || 0) + 1;

            // Track conversion values
            if (log.conversionValue) {
                stats.conversionValues.push(log.conversionValue);
            }
        });

        // Build records per spec schema (Section 2.4 FeatureMetricsDaily)
        const metricsToInsert = [];

        for (const [featureId, stats] of Object.entries(byFeature)) {
            const uniqueUsers = stats.users.size;
            const uniqueSessions = stats.sessions.size;
            const totalInteractions = stats.views + stats.clicks + stats.completions + stats.errors + stats.abandons;

            // Calculate rates
            const completionRate = stats.views > 0
                ? Math.round((stats.completions / stats.views) * 1000) / 10
                : 0;
            const errorRate = totalInteractions > 0
                ? Math.round((stats.errors / totalInteractions) * 1000) / 10
                : 0;
            const abandonRate = stats.views > 0
                ? Math.round((stats.abandons / stats.views) * 1000) / 10
                : 0;

            // Calculate averages
            const avgSessionDurationMs = stats.durationCount > 0
                ? Math.round(stats.totalDurationMs / stats.durationCount)
                : null;
            const avgConversionValue = stats.conversionValues.length > 0
                ? Math.round(stats.conversionValues.reduce((a, b) => a + b, 0) / stats.conversionValues.length * 100) / 100
                : null;

            // Keys use snake_case to match FIELD_MAPPINGS in airtableClient.jsw
            metricsToInsert.push({
                // Core identifiers
                date: dateStr,
                feature_id: featureId,

                // User metrics
                unique_users: uniqueUsers,
                total_interactions: stats.views + stats.clicks + stats.completions + stats.errors + stats.abandons,

                // Calculated rates
                completion_rate: completionRate,
                error_rate: errorRate,
                abandon_rate: abandonRate,

                // Duration and value metrics
                avg_duration_ms: avgSessionDurationMs,
                conversion_value_total: avgConversionValue,

                // Breakdowns (stored as JSON)
                by_role: stats.byRole ? JSON.stringify(stats.byRole) : null,
                by_device: stats.byDevice ? JSON.stringify(stats.byDevice) : null
            });
        }

        // Batch insert using dual-source routing
        let recordsCreated = 0;
        for (const metric of metricsToInsert) {
            try {
                await insertData(COLLECTION_KEYS.featureMetricsDaily, CONFIG.collections.metricsDaily, metric);
                recordsCreated++;
            } catch (e) {
                console.error(`[FeatureAdoption] Failed to insert metric for ${metric.feature_id}:`, e.message);
            }
        }

        const processingTimeMs = Date.now() - startTime;

        return {
            success: true,
            date: dateStr,
            featuresProcessed: metricsToInsert.length,
            recordsCreated,
            processingTimeMs
        };
    } catch (error) {
        console.error('[FeatureAdoption] Daily aggregation failed:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FAL_007',
            processingTimeMs: Date.now() - startTime
        };
    }
}

// ============================================
// ADMIN FUNCTIONS
// ============================================

/**
 * Register a new feature in the FeatureRegistry.
 * Adds a new feature to the FeatureRegistry collection with lifecycle metadata.
 *
 * @param {Object} featureData - Feature definition object
 * @param {string} featureData.featureId - Unique identifier (required)
 * @param {string} featureData.displayName - Human-readable name (required)
 * @param {string} [featureData.description] - What the feature does
 * @param {string} [featureData.category] - Feature category: 'matching', 'communication', 'analytics', 'onboarding'
 * @param {string} [featureData.status] - Lifecycle status: 'beta', 'active', 'deprecated', 'sunset' (default: 'beta')
 * @param {string} [featureData.expectedUsagePattern] - How often feature should be used: 'daily', 'weekly', 'onboarding-only', 'event-driven'
 * @param {Array<string>} [featureData.targetRoles] - Which user roles should use it (e.g., ['driver', 'recruiter'])
 * @param {string} [featureData.owner] - Team/person responsible
 * @param {string} [featureData.successMetric] - How to measure success (e.g., 'completion_rate > 40%')
 * @param {number} [featureData.retirementThreshold] - Days without use before flagging (default: 30)
 * @param {Array<string>} [featureData.relatedFeatures] - Features often used together
 * @param {string} [featureData.documentationUrl] - Link to feature docs
 * @returns {Promise<Object>} - { success: boolean, featureId?: string, registryId?: string, error?: string, errorCode?: string }
 */
export async function registerFeature(featureData) {
    // Validate required fields
    if (!featureData.featureId) {
        return {
            success: false,
            error: 'Missing required field: featureId',
            errorCode: 'FAL_003'
        };
    }

    if (!featureData.displayName) {
        return {
            success: false,
            error: 'Missing required field: displayName',
            errorCode: 'FAL_003'
        };
    }

    // Validate status if provided
    if (featureData.status && !CONFIG.validStatuses.includes(featureData.status)) {
        return {
            success: false,
            error: `Invalid status: ${featureData.status}. Valid statuses: ${CONFIG.validStatuses.join(', ')}`,
            errorCode: 'FAL_008'
        };
    }

    const normalizedFeatureId = featureData.featureId.toLowerCase().trim();

    // Build the registry record per spec (Section 2.2 FeatureRegistry)
    // Keys use snake_case to match FIELD_MAPPINGS in airtableClient.jsw
    const record = {
        // Core identifiers
        feature_id: normalizedFeatureId,
        display_name: featureData.displayName,
        description: featureData.description || '',
        category: featureData.category || 'uncategorized',

        // Lifecycle
        launch_date: new Date(),
        status: featureData.status || 'beta',

        // Usage expectations
        expected_usage_pattern: featureData.expectedUsagePattern || 'event-driven',
        target_roles: Array.isArray(featureData.targetRoles) ? featureData.targetRoles.join(', ') : '',
        owner: featureData.owner || '',
        success_metric: featureData.successMetric || '',
        retirement_threshold: featureData.retirementThreshold || 30,

        // Relationships
        related_features: Array.isArray(featureData.relatedFeatures) ? featureData.relatedFeatures.join(', ') : '',
        documentation_url: featureData.documentationUrl || ''
    };

    try {
        // Check if feature already exists using dual-source routing
        let existingItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureRegistry)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureRegistry);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Feature Id} = '${normalizedFeatureId}'`,
                maxRecords: 1
            }).catch(() => ({ records: [] }));
            existingItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                featureId: r['Feature Id'] || r.featureId,
                ...r
            }));
        } else {
            const existing = await wixData.query(CONFIG.collections.registry)
                .eq('featureId', normalizedFeatureId)
                .find({ suppressAuth: true })
                .catch(() => ({ items: [] }));
            existingItems = existing.items;
        }

        if (existingItems.length > 0) {
            return {
                success: false,
                error: 'Feature already registered with this featureId',
                errorCode: 'FAL_003',
                existing: existingItems[0]
            };
        }

        // Insert using dual-source routing
        const result = await insertData(COLLECTION_KEYS.featureRegistry, CONFIG.collections.registry, record);

        return {
            success: true,
            featureId: normalizedFeatureId,
            registryId: result._id
        };
    } catch (error) {
        console.error('[FeatureAdoption] Failed to register feature:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FAL_007'
        };
    }
}

/**
 * Update a feature's lifecycle status.
 * Changes a feature's lifecycle status with validation of allowed transitions.
 * Status lifecycle: beta -> active -> deprecated -> sunset (can reactivate deprecated -> active)
 *
 * @param {string} featureId - Feature identifier to update
 * @param {string} status - New status: 'beta', 'active', 'deprecated', 'sunset'
 * @param {string} [reason] - Explanation for status change
 * @returns {Promise<Object>} - { success: boolean, featureId?: string, previousStatus?: string, newStatus?: string, updatedAt?: string, error?: string, errorCode?: string }
 */
export async function updateFeatureStatus(featureId, status, reason = '') {
    // Validate required fields
    if (!featureId) {
        return {
            success: false,
            error: 'Missing required field: featureId',
            errorCode: 'FAL_003'
        };
    }

    if (!status) {
        return {
            success: false,
            error: 'Missing required field: status',
            errorCode: 'FAL_003'
        };
    }

    // Validate status value per spec
    if (!CONFIG.validStatuses.includes(status)) {
        return {
            success: false,
            error: `Invalid status: ${status}. Valid statuses: ${CONFIG.validStatuses.join(', ')}`,
            errorCode: 'FAL_008'
        };
    }

    const normalizedFeatureId = featureId.toLowerCase().trim();

    try {
        // Use dual-source routing for registry lookup
        let featureItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureRegistry)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureRegistry);
            const queryResult = await airtable.queryRecords(tableName, {
                filterByFormula: `{Feature Id} = '${normalizedFeatureId}'`,
                maxRecords: 1
            });
            featureItems = (queryResult.records || []).map(r => ({
                _id: r.id || r._id,
                featureId: r['Feature Id'] || r.featureId,
                status: r.Status || r.status,
                statusHistory: r['Status History'] || r.statusHistory || [],
                ...r
            }));
        } else {
            const result = await wixData.query(CONFIG.collections.registry)
                .eq('featureId', normalizedFeatureId)
                .find({ suppressAuth: true });
            featureItems = result.items;
        }

        if (featureItems.length === 0) {
            return {
                success: false,
                error: 'Feature not found in registry',
                errorCode: 'FAL_001'
            };
        }

        const feature = featureItems[0];
        const previousStatus = feature.status;

        // Validate status transition per spec lifecycle: beta -> active -> deprecated -> sunset
        // Allow reactivation: deprecated -> active (as noted in spec)
        const validTransitions = {
            'beta': ['active', 'deprecated', 'sunset'],
            'active': ['deprecated', 'sunset'],
            'deprecated': ['active', 'sunset'],  // Can reactivate
            'sunset': []  // Terminal state
        };

        // If current status is in our new spec statuses, validate transition
        if (CONFIG.validStatuses.includes(previousStatus)) {
            const allowed = validTransitions[previousStatus] || [];
            if (previousStatus !== status && !allowed.includes(status)) {
                return {
                    success: false,
                    error: `Invalid status transition from '${previousStatus}' to '${status}'. Allowed transitions: ${allowed.join(', ') || 'none'}`,
                    errorCode: 'FAL_008'
                };
            }
        }

        // Update only mapped fields to avoid Airtable UNKNOWN_FIELD_NAME errors
        const featureUpdate = {
            _id: feature._id,
            status
        };

        // Use dual-source routing for update
        const updated = await updateData(COLLECTION_KEYS.featureRegistry, CONFIG.collections.registry, featureUpdate);

        return {
            success: true,
            featureId: normalizedFeatureId,
            previousStatus,
            newStatus: status,
            updatedAt: now.toISOString()
        };
    } catch (error) {
        console.error('[FeatureAdoption] Failed to update status:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FAL_007'
        };
    }
}

/**
 * Define a conversion funnel.
 * Creates or updates a conversion funnel definition in the FeatureFunnels collection.
 *
 * @param {Object} funnelData - Funnel definition object
 * @param {string} funnelData.funnelId - Unique funnel identifier (required)
 * @param {string} funnelData.displayName - Human-readable name (required)
 * @param {string} [funnelData.description] - What this funnel measures
 * @param {Array<Object>} funnelData.steps - Ordered step definitions (required)
 * @param {number} funnelData.steps[].order - Step order (1-based)
 * @param {string} funnelData.steps[].featureId - Feature identifier for this step
 * @param {string} funnelData.steps[].action - Required action: 'view', 'click', 'complete', etc.
 * @param {string} [funnelData.steps[].displayName] - Human-readable step name
 * @param {boolean} [funnelData.steps[].optional] - Whether step is optional (default: false)
 * @param {boolean} [funnelData.isActive] - Whether to track this funnel (default: true)
 * @returns {Promise<Object>} - { success: boolean, funnelId?: string, stepsCount?: number, isNew?: boolean, error?: string, errorCode?: string }
 */
export async function defineFunnel(funnelData) {
    // Validate required fields
    if (!funnelData.funnelId) {
        return {
            success: false,
            error: 'Missing required field: funnelId',
            errorCode: 'FAL_003'
        };
    }

    if (!funnelData.displayName) {
        return {
            success: false,
            error: 'Missing required field: displayName',
            errorCode: 'FAL_003'
        };
    }

    if (!Array.isArray(funnelData.steps) || funnelData.steps.length === 0) {
        return {
            success: false,
            error: 'steps must be a non-empty array',
            errorCode: 'FAL_003'
        };
    }

    // Validate each step
    for (let i = 0; i < funnelData.steps.length; i++) {
        const step = funnelData.steps[i];
        if (!step.featureId) {
            return {
                success: false,
                error: `Step ${i + 1} is missing required field: featureId`,
                errorCode: 'FAL_003'
            };
        }
        if (!step.action) {
            return {
                success: false,
                error: `Step ${i + 1} is missing required field: action`,
                errorCode: 'FAL_003'
            };
        }
        if (!CONFIG.validActions.includes(step.action) && step.action !== '*') {
            return {
                success: false,
                error: `Step ${i + 1} has invalid action: ${step.action}`,
                errorCode: 'FAL_002'
            };
        }
    }

    const normalizedFunnelId = funnelData.funnelId.toLowerCase().trim();

    // Build the funnel record per spec (Section 2.3 FeatureFunnels)
    // Keys use snake_case to match FIELD_MAPPINGS in airtableClient.jsw
    const record = {
        funnel_id: normalizedFunnelId,
        display_name: funnelData.displayName,
        description: funnelData.description || '',
        steps: JSON.stringify(funnelData.steps.map((s, i) => ({
            order: s.order || i + 1,
            featureId: s.featureId.toLowerCase().trim(),
            action: s.action,
            displayName: s.displayName || s.name || formatFeatureId(s.featureId),
            optional: s.optional || false
        }))),
        is_active: funnelData.isActive !== false,
        created_at: new Date(),
        updated_at: new Date()
    };

    try {
        // Check if funnel already exists using dual-source routing
        let existingItems = [];
        if (usesAirtable(COLLECTION_KEYS.featureFunnels)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureFunnels);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Funnel Id} = '${normalizedFunnelId}'`,
                maxRecords: 1
            }).catch(() => ({ records: [] }));
            existingItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                funnelId: r['Funnel Id'] || r.funnelId,
                displayName: r['Display Name'] || r.displayName,
                description: r.Description || r.description,
                steps: r.Steps || r.steps,
                isActive: r['Is Active'] !== undefined ? r['Is Active'] : r.isActive,
                ...r
            }));
        } else {
            const existing = await wixData.query(CONFIG.collections.funnels)
                .eq('funnelId', normalizedFunnelId)
                .find({ suppressAuth: true })
                .catch(() => ({ items: [] }));
            existingItems = existing.items;
        }

        let isNew = true;

        if (existingItems.length > 0) {
            // Update existing funnel using dual-source routing
            isNew = false;
            const updated = {
                ...existingItems[0],
                display_name: record.display_name,
                description: record.description,
                steps: record.steps,
                is_active: record.is_active,
                updated_at: new Date()
            };
            await updateData(COLLECTION_KEYS.featureFunnels, CONFIG.collections.funnels, updated);
        } else {
            // Create new funnel using dual-source routing
            await insertData(COLLECTION_KEYS.featureFunnels, CONFIG.collections.funnels, record);
        }

        return {
            success: true,
            funnelId: normalizedFunnelId,
            stepsCount: record.steps.length,
            isNew
        };
    } catch (error) {
        console.error('[FeatureAdoption] Failed to define funnel:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FAL_007'
        };
    }
}

/**
 * Get all defined funnels
 * @returns {Promise<Array>} - Array of funnel definitions
 */
export async function getFunnels() {
    try {
        // Use dual-source routing for funnels query
        if (usesAirtable(COLLECTION_KEYS.featureFunnels)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureFunnels);
            const result = await airtable.queryRecords(tableName, { maxRecords: 100 });
            return (result.records || []).map(r => ({
                _id: r.id || r._id,
                funnelId: r['Funnel Id'] || r.funnelId,
                displayName: r['Display Name'] || r.displayName,
                description: r.Description || r.description,
                steps: r.Steps || r.steps,
                isActive: r['Is Active'] !== undefined ? r['Is Active'] : r.isActive,
                createdAt: r['Created At'] || r.createdAt,
                updatedAt: r['Updated At'] || r.updatedAt
            }));
        }
        const result = await wixData.query(CONFIG.collections.funnels)
            .find({ suppressAuth: true });
        return result.items;
    } catch (error) {
        console.error('[FeatureAdoption] Failed to get funnels:', error);
        return { error: error.message };
    }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

function aggregateByFeature(items) {
    const stats = {};

    items.forEach(log => {
        const fid = log.featureId;
        if (!stats[fid]) {
            stats[fid] = {
                count: 0,
                users: new Set(),
                errors: 0,
                completions: 0,
                actions: {},
                roles: {},
                totalDuration: 0,
                durCount: 0,
                lastUsed: null
            };
        }

        stats[fid].count++;
        stats[fid].users.add(log.userId);

        if (log.action === 'error') stats[fid].errors++;
        if (log.action === 'complete') stats[fid].completions++;

        stats[fid].actions[log.action] = (stats[fid].actions[log.action] || 0) + 1;
        stats[fid].roles[log.userRole] = (stats[fid].roles[log.userRole] || 0) + 1;

        if (log.duration) {
            stats[fid].totalDuration += log.duration;
            stats[fid].durCount++;
        }

        if (!stats[fid].lastUsed || log.timestamp > stats[fid].lastUsed) {
            stats[fid].lastUsed = log.timestamp;
        }
    });

    return stats;
}

function aggregateAllFeatures(items, groupBy) {
    const stats = aggregateByFeature(items);

    return Object.entries(stats).map(([featureId, data]) => ({
        featureId,
        totalInteractions: data.count,
        uniqueUsers: data.users.size,
        completions: data.completions,
        errors: data.errors,
        completionRate: data.count > 0 ? Math.round((data.completions / data.count) * 100) : 0,
        errorRate: data.count > 0 ? Math.round((data.errors / data.count) * 100) : 0,
        avgDuration: data.durCount > 0 ? Math.round(data.totalDuration / data.durCount) : null,
        lastUsed: data.lastUsed,
        byAction: data.actions,
        byRole: data.roles
    })).sort((a, b) => b.totalInteractions - a.totalInteractions);
}

function aggregateSingleFeature(featureId, items, groupBy) {
    const totalInteractions = items.length;
    const uniqueUsers = new Set(items.map(i => i.userId)).size;

    const actions = {};
    const roles = {};
    let completions = 0;
    let errors = 0;
    let totalDuration = 0;
    let durCount = 0;

    items.forEach(item => {
        actions[item.action] = (actions[item.action] || 0) + 1;
        roles[item.userRole] = (roles[item.userRole] || 0) + 1;

        if (item.action === 'complete') completions++;
        if (item.action === 'error') errors++;

        if (item.duration) {
            totalDuration += item.duration;
            durCount++;
        }
    });

    // Group by selected dimension
    let grouped = {};
    if (groupBy === 'day') {
        items.forEach(item => {
            const day = item.date || item.timestamp?.toISOString().split('T')[0];
            if (!grouped[day]) grouped[day] = 0;
            grouped[day]++;
        });
    } else if (groupBy === 'hour') {
        items.forEach(item => {
            const hour = item.hour || new Date(item.timestamp).getHours();
            if (!grouped[hour]) grouped[hour] = 0;
            grouped[hour]++;
        });
    } else if (groupBy === 'action') {
        grouped = actions;
    } else if (groupBy === 'userRole') {
        grouped = roles;
    }

    return {
        featureId,
        totalInteractions,
        uniqueUsers,
        completions,
        errors,
        completionRate: totalInteractions > 0 ? Math.round((completions / totalInteractions) * 100) : 0,
        errorRate: totalInteractions > 0 ? Math.round((errors / totalInteractions) * 100) : 0,
        avgDuration: durCount > 0 ? Math.round(totalDuration / durCount) : null,
        byAction: actions,
        byRole: roles,
        grouped,
        groupedBy: groupBy
    };
}

/**
 * Generates a comprehensive lifecycle report for all features.
 * Used by Admin Dashboard.
 */
export async function getFeatureLifecycleReport() {
    try {
        await requireAdmin();

        // Get all registry features
        let features = [];
        if (usesAirtable(COLLECTION_KEYS.featureRegistry)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.featureRegistry);
            const result = await airtable.getAllRecords(tableName);
            features = result.map(r => ({
                featureId: r['Feature Id'] || r.featureId,
                displayName: r['Display Name'] || r.displayName,
                createdDate: r['Created Date'] || r.createdDate || r.Created || new Date(),
                status: r['Status'] || r.status || 'active'
            }));
        } else {
            const result = await wixData.query(CONFIG.collections.registry).find({ suppressAuth: true });
            features = result.items;
        }

        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);

        const reportFeatures = [];
        const summary = {
            total: features.length,
            byStatus: { beta: 0, active: 0, deprecated: 0, sunset: 0 },
            byHealth: { healthy: 0, warning: 0, critical: 0 }
        };

        for (const feature of features) {
            // Get stats for last 30 days
            const currentStats = await getFeatureStats(feature.featureId, { start: thirtyDaysAgo, end: now });
            // Get stats for previous 30 days (for trend)
            const prevStats = await getFeatureStats(feature.featureId, { start: sixtyDaysAgo, end: thirtyDaysAgo });

            const interactions30d = currentStats.uniqueUsers || 0;
            const healthScore = calculateHealthScore({
                users: new Set(Array(interactions30d).fill(1)), // Mocking set size since stats returns count
                count: currentStats.totalInteractions || 0,
                completions: currentStats.completions || 0,
                errors: currentStats.errors || 0
            });

            // Calculate metrics
            const completionRate = currentStats.completionRate || 0;
            
            // Determine trend
            const prevInteractions = prevStats.uniqueUsers || 0;
            const trend = interactions30d > prevInteractions * 1.1 ? 'growing' : 
                         interactions30d < prevInteractions * 0.9 ? 'declining' : 'stable';

            const daysSinceLaunch = feature.createdDate 
                ? Math.floor((new Date() - new Date(feature.createdDate)) / (1000 * 60 * 60 * 24)) 
                : 0;

            let recommendation = 'monitor';
            if (healthScore >= 80) recommendation = 'scale';
            else if (healthScore < 40) recommendation = 'investigate';
            if (trend === 'declining' && healthScore < 50) recommendation = 'consider_deprecation';

            reportFeatures.push({
                featureId: feature.featureId,
                displayName: feature.displayName || feature.featureId,
                status: feature.status || 'active',
                category: feature.category,
                launchDate: feature.createdDate,
                daysSinceLaunch,
                healthScore,
                interactions30d,
                last7DaysUsers: Math.floor(interactions30d / 4), // Approximation
                completionRate,
                trend,
                recommendation,
                issues: [] // TODO: Add issue detection logic
            });

            // Update summary
            const statusKey = (feature.status || 'active').toLowerCase();
            if (summary.byStatus[statusKey] !== undefined) summary.byStatus[statusKey]++;
            
            if (healthScore >= 70) summary.byHealth.healthy++;
            else if (healthScore >= 40) summary.byHealth.warning++;
            else summary.byHealth.critical++;
        }

        return {
            features: reportFeatures,
            summary
        };

    } catch (error) {
        console.error('[FeatureAdoption] Lifecycle report failed:', error);
        return { error: error.message };
    }
}

/**
 * Get features identified as 'At Risk'.
 */
export async function getAtRiskFeatures() {
    try {
        const report = await getFeatureLifecycleReport();
        if (report.error) throw new Error(report.error);

        const atRisk = report.features.filter(f => f.healthScore < 40).map(f => ({
            ...f,
            riskLevel: f.healthScore < 20 ? 'critical' : 'warning',
            daysSinceSignificantUse: 0, // Placeholder
            recommendedAction: f.healthScore < 20 ? 'deprecate' : 'investigate'
        }));

        return { atRiskFeatures: atRisk };
    } catch (error) {
         console.error('[FeatureAdoption] At-risk report failed:', error);
        return { error: error.message };
    }
}

/**
 * Calculates a composite health score (0-100) for a feature.
 * @param {string} featureId - Feature identifier
 */
export async function getFeatureHealthScore(featureId) {
    if (!featureId) return { error: 'Missing featureId' };

    try {
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        
        const stats = await getFeatureStats(featureId, { start: thirtyDaysAgo, end: now });
        if (stats.error) throw new Error(stats.error);

        const healthScore = calculateHealthScore({
            users: new Set(Array(stats.uniqueUsers || 0).fill(1)),
            count: stats.totalInteractions || 0,
            completions: stats.completions || 0,
            errors: stats.errors || 0
        });

        // Calculate breakdown for frontend
        // Weights: usage (40%), completion (30%), errorFree (30%)
        // This rebuilds logic from calculateHealthScore to return breakdown
        const expectedUsers = 50;
        const expectedCompletions = 0.3;
        
        const breakdown = {
            usageScore: Math.min(100, (stats.uniqueUsers / expectedUsers) * 100),
            completionScore: Math.min(100, ((stats.completions / stats.totalInteractions) / expectedCompletions) * 100) || 0,
            errorFreeScore: Math.max(0, 100 - ((stats.errors / stats.totalInteractions) * 100)) || 100
        };

        return {
            featureId,
            healthScore,
            breakdown,
            status: healthScore >= 70 ? 'healthy' : healthScore >= 40 ? 'warning' : 'critical'
        };

    } catch (error) {
        console.error('[FeatureAdoption] Health score calculation failed:', error);
        return { error: error.message };
    }
}

function calculateLifecycleStatus(featureId, current, previous, regData) {
    // Check if manually deprecated
    if (regData.status === FeatureCycles.DEPRECATED) {
        return FeatureCycles.DEPRECATED;
    }

    // Check if Dead (no usage in 30 days)
    if (current.count === 0) {
        return FeatureCycles.DEAD;
    }

    // Check if New (created < 30 days ago)
    if (regData.createdDate) {
        const daysSinceCreation = (new Date() - new Date(regData.createdDate)) / (1000 * 60 * 60 * 24);
        if (daysSinceCreation < CONFIG.thresholds.newFeatureDays) {
            return FeatureCycles.NEW;
        }
    }

    // Check if At Risk (usage dropped significantly)
    if (previous.count > 0) {
        const dropPercent = ((previous.count - current.count) / previous.count) * 100;
        if (dropPercent >= CONFIG.thresholds.atRiskDropPercent) {
            return FeatureCycles.AT_RISK;
        }
    }

    // Check if Mature (90+ days old with stable usage)
    if (regData.createdDate) {
        const daysSinceCreation = (new Date() - new Date(regData.createdDate)) / (1000 * 60 * 60 * 24);
        if (daysSinceCreation >= CONFIG.thresholds.matureMinDays &&
            current.users.size >= CONFIG.thresholds.adoptedMinUsers) {
            return FeatureCycles.MATURE;
        }
    }

    // Check if Adopted (meeting thresholds)
    if (current.users.size >= CONFIG.thresholds.adoptedMinUsers &&
        current.count >= CONFIG.thresholds.adoptedMinInteractions) {
        return FeatureCycles.ADOPTED;
    }

    // Default to At Risk if not meeting adoption thresholds
    return current.count < 5 ? FeatureCycles.AT_RISK : FeatureCycles.NEW;
}

function calculateHealthScore(stats) {
    // Expected baseline
    const expectedUsers = 50;
    const expectedCompletions = 0.3; // 30% completion rate is healthy

    // Usage score (40%): How many users vs expected
    const usageScore = Math.min(100, (stats.users.size / expectedUsers) * 100);

    // Completion score (30%): Completion rate
    const completionRate = stats.count > 0 ? stats.completions / stats.count : 0;
    const completionScore = Math.min(100, (completionRate / expectedCompletions) * 100);

    // Error-free score (30%): Inverse of error rate
    const errorRate = stats.count > 0 ? stats.errors / stats.count : 0;
    const errorFreeScore = Math.max(0, 100 - (errorRate * 100));

    // Weighted average
    const weights = CONFIG.healthWeights;
    const score = Math.round(
        (usageScore * weights.usage / 100) +
        (completionScore * weights.completion / 100) +
        (errorFreeScore * weights.errorFree / 100)
    );

    return Math.min(100, Math.max(0, score));
}

function calculateTrend(current, previous) {
    if (previous === 0) {
        return { direction: current > 0 ? 'up' : 'flat', percent: current > 0 ? 100 : 0 };
    }

    const change = ((current - previous) / previous) * 100;
    return {
        direction: change > 5 ? 'up' : change < -5 ? 'down' : 'flat',
        percent: Math.round(change)
    };
}

function findDropOffStep(stepMetrics) {
    let maxDrop = 0;
    let dropStep = null;

    for (let i = 1; i < stepMetrics.length; i++) {
        const drop = 100 - stepMetrics[i].stepRate;
        if (drop > maxDrop) {
            maxDrop = drop;
            dropStep = {
                step: i + 1,
                name: stepMetrics[i].name,
                dropPercent: Math.round(drop)
            };
        }
    }

    return dropStep;
}

function formatFeatureId(featureId) {
    return featureId
        .replace(/_/g, ' ')
        .replace(/\b\w/g, c => c.toUpperCase());
}

function getHealthRecommendation(score, breakdown) {
    const recommendations = [];

    if (breakdown.usageScore < 50) {
        recommendations.push('Increase feature visibility - consider adding to navigation or homepage');
    }
    if (breakdown.completionScore < 50) {
        recommendations.push('Simplify user flow - users are not completing the feature');
    }
    if (breakdown.errorFreeScore < 80) {
        recommendations.push('Address errors - high error rate is blocking users');
    }

    if (score >= 80) {
        return { status: 'healthy', message: 'Feature is performing well', actions: recommendations };
    } else if (score >= 50) {
        return { status: 'needs_attention', message: 'Feature could be improved', actions: recommendations };
    } else {
        return { status: 'critical', message: 'Feature needs immediate attention', actions: recommendations };
    }
}

function identifyRiskFactors(feature) {
    const factors = [];

    if (feature.uniqueUsers30d < 5) {
        factors.push('Very low user count');
    }
    if (feature.errorRate > 10) {
        factors.push('High error rate');
    }
    if (feature.completionRate < 20) {
        factors.push('Low completion rate');
    }
    if (feature.trend?.direction === 'down') {
        factors.push(`Usage declining (${feature.trendPercent}%)`);
    }
    if (feature.status === FeatureCycles.DEAD) {
        factors.push('No usage in 30 days');
    }

    return factors;
}

/**
 * Badge Service
 *
 * Manages recruiter badges including:
 * - Responsiveness badges (Lightning, Fast, Active)
 * - Quality badges (Quality Matcher, Retention King)
 * - Milestone badges (First Hire, Ten Club, Century Club)
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import { getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';
import { createNotification } from 'backend/memberService';
import { logGamificationEvent, awardRecruiterPoints } from 'backend/gamificationService';
import { chunkArray } from 'backend/utils/arrayUtils';

// =============================================================================
// COLLECTION KEYS (Airtable-only)
// =============================================================================

const COLLECTION_KEYS = {
  badgeDefinitions: 'badgeDefinitions',
  recruiterBadges: 'recruiterBadges',
  recruiterProgression: 'recruiterProgression',
  driverCarrierInterests: 'driverCarrierInterests',
  gamificationEvents: 'gamificationEvents'
};

// =============================================================================
// BADGE TIER THRESHOLDS
// =============================================================================

/**
 * Response time badge tiers
 * Based on average response time to driver inquiries
 */
const RESPONSE_TIME_TIERS = {
  lightning: { maxHours: 4, tier: 3, name: 'Lightning Responder', color: '#10b981' },
  fast: { maxHours: 24, tier: 2, name: 'Fast Responder', color: '#3b82f6' },
  active: { maxHours: 48, tier: 1, name: 'Active Recruiter', color: '#6366f1' }
};

/**
 * Quality badge tiers (offer acceptance rate)
 */
const QUALITY_TIERS = {
  elite: { minRate: 0.90, tier: 3, name: 'Elite Matcher', color: '#f59e0b' },
  quality: { minRate: 0.75, tier: 2, name: 'Quality Matcher', color: '#8b5cf6' },
  standard: { minRate: 0.50, tier: 1, name: 'Standard Recruiter', color: '#64748b' }
};

/**
 * Retention badge tiers (90-day retention rate)
 */
const RETENTION_TIERS = {
  king: { minRate: 0.95, tier: 3, name: 'Retention King', color: '#ec4899' },
  master: { minRate: 0.85, tier: 2, name: 'Retention Master', color: '#14b8a6' },
  solid: { minRate: 0.70, tier: 1, name: 'Solid Retention', color: '#6b7280' }
};

/**
 * Hires badge tiers (cumulative successful hires)
 */
const HIRES_TIERS = {
  century: { minHires: 100, tier: 4, name: 'Century Club', color: '#ef4444' },
  fifty: { minHires: 50, tier: 3, name: 'Fifty Club', color: '#f97316' },
  ten: { minHires: 10, tier: 2, name: 'Ten Club', color: '#22c55e' },
  first: { minHires: 1, tier: 1, name: 'First Hire', color: '#3b82f6' }
};

// =============================================================================
// AIRTABLE-ONLY HELPER FUNCTIONS
// =============================================================================

async function queryData(collectionKey, options = {}) {
  const tableName = getAirtableTableName(collectionKey);
  const result = await airtable.queryRecords(tableName, {
    filterByFormula: options.filter || '',
    sort: options.sort,
    maxRecords: options.limit || 100
  });
  return result.records || [];
}

async function insertData(collectionKey, data) {
  const tableName = getAirtableTableName(collectionKey);
  return await airtable.createRecord(tableName, data);
}

async function updateData(collectionKey, recordId, data) {
  const tableName = getAirtableTableName(collectionKey);
  return await airtable.updateRecord(tableName, recordId, data);
}

async function getRecord(collectionKey, recordId) {
  const tableName = getAirtableTableName(collectionKey);
  return await airtable.getRecord(tableName, recordId);
}

// =============================================================================
// GET BADGE DEFINITIONS
// =============================================================================

/**
 * Get all badge definitions
 * @param {string} userType - "recruiter" (drivers use achievements, not badges)
 * @returns {array} Badge definitions
 */
export async function getBadgeDefinitions(userType = 'recruiter') {
  try {
    let filter = '{Is Active} = "Yes"';

    if (userType !== 'all') {
      filter = `AND(${filter}, {User Type} = "${userType}")`;
    }

    const records = await queryData(COLLECTION_KEYS.badgeDefinitions, {
      filter,
      sort: [{ field: 'Display Order', direction: 'asc' }],
      limit: 100
    });

    return records.map(normalizeBadgeDefinition);
  } catch (error) {
    console.error('getBadgeDefinitions error:', error);
    return [];
  }
}

/**
 * Get user's earned badges with tier information
 * @param {string} userId - Recruiter ID
 * @param {string} userType - "recruiter"
 * @returns {array} Earned badges with tier details
 */
export async function getBadges(userId, userType = 'recruiter') {
  try {
    // Get all badge definitions
    const definitions = await getBadgeDefinitions(userType);

    // Get user's earned badges
    const earnedRecords = await queryData(COLLECTION_KEYS.recruiterBadges, {
      filter: `AND({Recruiter ID} = "${userId}")`,
      limit: 100
    });

    const earnedMap = new Map();
    for (const record of earnedRecords) {
      earnedMap.set(record['Badge ID'], {
        _id: record.id,
        tier: record['Current Tier'] || 1,
        tierName: record['Tier Name'],
        earnedAt: record['Earned At'],
        lastUpgraded: record['Last Upgraded'],
        progress: record['Progress'] || 0
      });
    }

    // Combine definitions with earned status
    const badges = definitions.map(def => {
      const earned = earnedMap.get(def.badgeId);
      return {
        ...def,
        earned: !!earned,
        currentTier: earned?.tier || 0,
        tierName: earned?.tierName || null,
        earnedAt: earned?.earnedAt || null,
        lastUpgraded: earned?.lastUpgraded || null,
        progress: earned?.progress || 0
      };
    });

    return badges;
  } catch (error) {
    console.error('getBadges error:', error);
    return [];
  }
}

// =============================================================================
// BADGE TIER CALCULATIONS
// =============================================================================

/**
 * Calculate response time badge tier
 * @param {number} avgResponseHours - Average response time in hours
 * @returns {object} Badge tier info
 */
export function calculateResponseTimeBadge(avgResponseHours) {
  if (avgResponseHours === null || avgResponseHours === undefined) {
    return { tier: 0, name: null, color: null, qualifies: false };
  }

  if (avgResponseHours < RESPONSE_TIME_TIERS.lightning.maxHours) {
    return { ...RESPONSE_TIME_TIERS.lightning, qualifies: true };
  }
  if (avgResponseHours < RESPONSE_TIME_TIERS.fast.maxHours) {
    return { ...RESPONSE_TIME_TIERS.fast, qualifies: true };
  }
  if (avgResponseHours < RESPONSE_TIME_TIERS.active.maxHours) {
    return { ...RESPONSE_TIME_TIERS.active, qualifies: true };
  }

  return { tier: 0, name: null, color: null, qualifies: false };
}

/**
 * Calculate quality badge tier (offer acceptance rate)
 * @param {number} acceptanceRate - Acceptance rate (0-1)
 * @returns {object} Badge tier info
 */
export function calculateQualityBadge(acceptanceRate) {
  if (acceptanceRate === null || acceptanceRate === undefined) {
    return { tier: 0, name: null, color: null, qualifies: false };
  }

  if (acceptanceRate >= QUALITY_TIERS.elite.minRate) {
    return { ...QUALITY_TIERS.elite, qualifies: true };
  }
  if (acceptanceRate >= QUALITY_TIERS.quality.minRate) {
    return { ...QUALITY_TIERS.quality, qualifies: true };
  }
  if (acceptanceRate >= QUALITY_TIERS.standard.minRate) {
    return { ...QUALITY_TIERS.standard, qualifies: true };
  }

  return { tier: 0, name: null, color: null, qualifies: false };
}

/**
 * Calculate retention badge tier (90-day retention)
 * @param {number} retentionRate - 90-day retention rate (0-1)
 * @returns {object} Badge tier info
 */
export function calculateRetentionBadge(retentionRate) {
  if (retentionRate === null || retentionRate === undefined) {
    return { tier: 0, name: null, color: null, qualifies: false };
  }

  if (retentionRate >= RETENTION_TIERS.king.minRate) {
    return { ...RETENTION_TIERS.king, qualifies: true };
  }
  if (retentionRate >= RETENTION_TIERS.master.minRate) {
    return { ...RETENTION_TIERS.master, qualifies: true };
  }
  if (retentionRate >= RETENTION_TIERS.solid.minRate) {
    return { ...RETENTION_TIERS.solid, qualifies: true };
  }

  return { tier: 0, name: null, color: null, qualifies: false };
}

/**
 * Calculate hires badge tier (cumulative hires)
 * @param {number} totalHires - Total successful hires
 * @returns {object} Badge tier info
 */
export function calculateHiresBadge(totalHires) {
  if (totalHires === null || totalHires === undefined || totalHires < 1) {
    return { tier: 0, name: null, color: null, qualifies: false };
  }

  if (totalHires >= HIRES_TIERS.century.minHires) {
    return { ...HIRES_TIERS.century, qualifies: true };
  }
  if (totalHires >= HIRES_TIERS.fifty.minHires) {
    return { ...HIRES_TIERS.fifty, qualifies: true };
  }
  if (totalHires >= HIRES_TIERS.ten.minHires) {
    return { ...HIRES_TIERS.ten, qualifies: true };
  }
  if (totalHires >= HIRES_TIERS.first.minHires) {
    return { ...HIRES_TIERS.first, qualifies: true };
  }

  return { tier: 0, name: null, color: null, qualifies: false };
}

// =============================================================================
// RECALCULATE BADGES
// =============================================================================

/**
 * Recalculate all badges for a recruiter
 * @param {string} recruiterId - Recruiter ID
 * @returns {object} { badges_updated, new_badges, tier_upgrades }
 */
export async function recalculateRecruiterBadges(recruiterId) {
  try {
    const results = {
      badges_updated: 0,
      new_badges: [],
      tier_upgrades: []
    };

    // Get recruiter stats
    const stats = await getRecruiterStats(recruiterId);

    // Calculate each badge type
    const badgeCalculations = [
      {
        badgeId: 'response_time',
        category: 'responsiveness',
        calculation: calculateResponseTimeBadge(stats.avgResponseHours)
      },
      {
        badgeId: 'quality_matcher',
        category: 'quality',
        calculation: calculateQualityBadge(stats.acceptanceRate)
      },
      {
        badgeId: 'retention',
        category: 'retention',
        calculation: calculateRetentionBadge(stats.retention90DayRate)
      },
      {
        badgeId: 'hires_milestone',
        category: 'milestone',
        calculation: calculateHiresBadge(stats.totalHires)
      }
    ];

    // Get existing badges
    const existingBadges = await queryData(COLLECTION_KEYS.recruiterBadges, {
      filter: `{Recruiter ID} = "${recruiterId}"`,
      limit: 50
    });

    const existingMap = new Map();
    for (const badge of existingBadges) {
      existingMap.set(badge['Badge ID'], badge);
    }

    const now = new Date().toISOString();

    // Process each badge
    for (const { badgeId, category, calculation } of badgeCalculations) {
      if (!calculation.qualifies) {
        continue;
      }

      const existing = existingMap.get(badgeId);

      if (existing) {
        // Check for tier upgrade
        const currentTier = existing['Current Tier'] || 0;
        if (calculation.tier > currentTier) {
          // Tier upgrade
          await updateData(COLLECTION_KEYS.recruiterBadges, existing.id, {
            'Current Tier': calculation.tier,
            'Tier Name': calculation.name,
            'Badge Color': calculation.color,
            'Last Upgraded': now,
            'Updated At': now
          });

          results.tier_upgrades.push({
            badgeId,
            previousTier: currentTier,
            newTier: calculation.tier,
            tierName: calculation.name
          });

          // Send tier upgrade notification
          await sendBadgeTierUpgradeNotification(recruiterId, badgeId, calculation);
          results.badges_updated++;
        }
      } else {
        // New badge earned
        await insertData(COLLECTION_KEYS.recruiterBadges, {
          'Recruiter ID': recruiterId,
          'Badge ID': badgeId,
          'Badge Category': category,
          'Current Tier': calculation.tier,
          'Tier Name': calculation.name,
          'Badge Color': calculation.color,
          'Earned At': now,
          'Last Upgraded': now,
          'Progress': 100,
          'Created At': now,
          'Updated At': now
        });

        results.new_badges.push({
          badgeId,
          tier: calculation.tier,
          tierName: calculation.name
        });

        // Send new badge notification
        await sendNewBadgeNotification(recruiterId, badgeId, calculation);
        results.badges_updated++;
      }
    }

    // Log gamification event if any badges changed
    if (results.badges_updated > 0) {
      await logGamificationEvent(recruiterId, 'recruiter', {
        eventType: 'badge_update',
        action: 'badge_recalculation',
        metadata: {
          newBadges: results.new_badges,
          tierUpgrades: results.tier_upgrades
        }
      });
    }

    return results;
  } catch (error) {
    console.error('recalculateRecruiterBadges error:', error);
    return { badges_updated: 0, new_badges: [], tier_upgrades: [], error: error.message };
  }
}

/**
 * Get recruiter stats for badge calculation
 * @param {string} recruiterId
 * @returns {object} Stats object
 */
async function getRecruiterStats(recruiterId) {
  try {
    // Get progression data
    const progressionRecords = await queryData(COLLECTION_KEYS.recruiterProgression, {
      filter: `{Recruiter ID} = "${recruiterId}"`,
      limit: 1
    });

    if (progressionRecords.length === 0) {
      return {
        avgResponseHours: null,
        acceptanceRate: null,
        retention90DayRate: null,
        totalHires: 0
      };
    }

    const progression = progressionRecords[0];

    // Also calculate live response time from interactions
    const liveResponseTime = await calculateLiveResponseTime(recruiterId);

    return {
      avgResponseHours: liveResponseTime || progression['Avg Response Hours'] || null,
      acceptanceRate: progression['Hire Acceptance Rate'] || null,
      retention90DayRate: progression['Retention 90 Day Rate'] || null,
      totalHires: progression['Total Hires'] || 0
    };
  } catch (error) {
    console.error('getRecruiterStats error:', error);
    return {
      avgResponseHours: null,
      acceptanceRate: null,
      retention90DayRate: null,
      totalHires: 0
    };
  }
}

/**
 * Calculate live response time from driver-carrier interactions
 * @param {string} recruiterId
 * @returns {number|null} Average response hours
 */
async function calculateLiveResponseTime(recruiterId) {
  try {
    // Query interactions with recruiter response times
    const interactions = await queryData(COLLECTION_KEYS.driverCarrierInterests, {
      filter: `AND({Recruiter ID} = "${recruiterId}", {Recruiter Response Time} != BLANK())`,
      limit: 100
    });

    if (interactions.length === 0) {
      return null;
    }

    let totalHours = 0;
    let count = 0;

    for (const interaction of interactions) {
      const responseTime = interaction['Recruiter Response Time'] ||
                          interaction.recruiter_response_time;
      if (responseTime && typeof responseTime === 'number') {
        totalHours += responseTime;
        count++;
      }
    }

    return count > 0 ? totalHours / count : null;
  } catch (error) {
    console.error('calculateLiveResponseTime error:', error);
    return null;
  }
}

// =============================================================================
// BADGE PROGRESS
// =============================================================================

/**
 * Check progress toward a specific badge tier
 * @param {string} userId - Recruiter ID
 * @param {string} badgeId - Badge identifier
 * @returns {object} Progress information
 */
export async function checkBadgeTierProgress(userId, badgeId) {
  try {
    const stats = await getRecruiterStats(userId);

    switch (badgeId) {
      case 'response_time':
        return calculateResponseTimeProgress(stats.avgResponseHours);

      case 'quality_matcher':
        return calculateQualityProgress(stats.acceptanceRate);

      case 'retention':
        return calculateRetentionProgress(stats.retention90DayRate);

      case 'hires_milestone':
        return calculateHiresProgress(stats.totalHires);

      default:
        return { error: 'unknown_badge', badgeId };
    }
  } catch (error) {
    console.error('checkBadgeTierProgress error:', error);
    return { error: error.message };
  }
}

/**
 * Calculate response time progress
 */
function calculateResponseTimeProgress(avgHours) {
  if (avgHours === null) {
    return {
      currentTier: 0,
      nextTier: 1,
      nextTierName: RESPONSE_TIME_TIERS.active.name,
      current: null,
      target: RESPONSE_TIME_TIERS.active.maxHours,
      percentage: 0,
      direction: 'lower_is_better'
    };
  }

  const currentBadge = calculateResponseTimeBadge(avgHours);

  // Find next tier
  let nextTier = null;
  if (currentBadge.tier < 3) {
    if (avgHours >= RESPONSE_TIME_TIERS.fast.maxHours) {
      nextTier = { ...RESPONSE_TIME_TIERS.fast, tierNum: 2 };
    } else if (avgHours >= RESPONSE_TIME_TIERS.lightning.maxHours) {
      nextTier = { ...RESPONSE_TIME_TIERS.lightning, tierNum: 3 };
    }
  }

  return {
    currentTier: currentBadge.tier,
    currentTierName: currentBadge.name,
    nextTier: nextTier?.tierNum || null,
    nextTierName: nextTier?.name || 'Max tier reached',
    current: avgHours,
    target: nextTier?.maxHours || RESPONSE_TIME_TIERS.lightning.maxHours,
    percentage: nextTier ? Math.min(100, Math.round(((nextTier.maxHours - avgHours) / nextTier.maxHours) * 100)) : 100,
    direction: 'lower_is_better'
  };
}

/**
 * Calculate quality progress
 */
function calculateQualityProgress(acceptanceRate) {
  if (acceptanceRate === null) {
    return {
      currentTier: 0,
      nextTier: 1,
      nextTierName: QUALITY_TIERS.standard.name,
      current: 0,
      target: QUALITY_TIERS.standard.minRate,
      percentage: 0,
      direction: 'higher_is_better'
    };
  }

  const currentBadge = calculateQualityBadge(acceptanceRate);

  // Find next tier
  let nextTier = null;
  if (currentBadge.tier < 3) {
    if (acceptanceRate < QUALITY_TIERS.standard.minRate) {
      nextTier = { ...QUALITY_TIERS.standard, tierNum: 1 };
    } else if (acceptanceRate < QUALITY_TIERS.quality.minRate) {
      nextTier = { ...QUALITY_TIERS.quality, tierNum: 2 };
    } else if (acceptanceRate < QUALITY_TIERS.elite.minRate) {
      nextTier = { ...QUALITY_TIERS.elite, tierNum: 3 };
    }
  }

  return {
    currentTier: currentBadge.tier,
    currentTierName: currentBadge.name,
    nextTier: nextTier?.tierNum || null,
    nextTierName: nextTier?.name || 'Max tier reached',
    current: acceptanceRate,
    target: nextTier?.minRate || QUALITY_TIERS.elite.minRate,
    percentage: nextTier ? Math.min(100, Math.round((acceptanceRate / nextTier.minRate) * 100)) : 100,
    direction: 'higher_is_better'
  };
}

/**
 * Calculate retention progress
 */
function calculateRetentionProgress(retentionRate) {
  if (retentionRate === null) {
    return {
      currentTier: 0,
      nextTier: 1,
      nextTierName: RETENTION_TIERS.solid.name,
      current: 0,
      target: RETENTION_TIERS.solid.minRate,
      percentage: 0,
      direction: 'higher_is_better'
    };
  }

  const currentBadge = calculateRetentionBadge(retentionRate);

  // Find next tier
  let nextTier = null;
  if (currentBadge.tier < 3) {
    if (retentionRate < RETENTION_TIERS.solid.minRate) {
      nextTier = { ...RETENTION_TIERS.solid, tierNum: 1 };
    } else if (retentionRate < RETENTION_TIERS.master.minRate) {
      nextTier = { ...RETENTION_TIERS.master, tierNum: 2 };
    } else if (retentionRate < RETENTION_TIERS.king.minRate) {
      nextTier = { ...RETENTION_TIERS.king, tierNum: 3 };
    }
  }

  return {
    currentTier: currentBadge.tier,
    currentTierName: currentBadge.name,
    nextTier: nextTier?.tierNum || null,
    nextTierName: nextTier?.name || 'Max tier reached',
    current: retentionRate,
    target: nextTier?.minRate || RETENTION_TIERS.king.minRate,
    percentage: nextTier ? Math.min(100, Math.round((retentionRate / nextTier.minRate) * 100)) : 100,
    direction: 'higher_is_better'
  };
}

/**
 * Calculate hires progress
 */
function calculateHiresProgress(totalHires) {
  const currentBadge = calculateHiresBadge(totalHires);

  // Find next tier
  let nextTier = null;
  if (currentBadge.tier < 4) {
    if (totalHires < HIRES_TIERS.first.minHires) {
      nextTier = { ...HIRES_TIERS.first, tierNum: 1 };
    } else if (totalHires < HIRES_TIERS.ten.minHires) {
      nextTier = { ...HIRES_TIERS.ten, tierNum: 2 };
    } else if (totalHires < HIRES_TIERS.fifty.minHires) {
      nextTier = { ...HIRES_TIERS.fifty, tierNum: 3 };
    } else if (totalHires < HIRES_TIERS.century.minHires) {
      nextTier = { ...HIRES_TIERS.century, tierNum: 4 };
    }
  }

  return {
    currentTier: currentBadge.tier,
    currentTierName: currentBadge.name,
    nextTier: nextTier?.tierNum || null,
    nextTierName: nextTier?.name || 'Max tier reached',
    current: totalHires,
    target: nextTier?.minHires || HIRES_TIERS.century.minHires,
    percentage: nextTier ? Math.min(100, Math.round((totalHires / nextTier.minHires) * 100)) : 100,
    direction: 'higher_is_better'
  };
}

// =============================================================================
// NOTIFICATIONS
// =============================================================================

/**
 * Send notification for new badge earned
 */
async function sendNewBadgeNotification(recruiterId, badgeId, badgeInfo) {
  try {
    await createNotification(
      recruiterId,
      'badge_earned',
      `New Badge: ${badgeInfo.name}!`,
      `Congratulations! You've earned the ${badgeInfo.name} badge. Keep up the great work!`,
      '/recruiter/dashboard'
    );

    // Award points for earning a badge
    await awardRecruiterPoints(recruiterId, 'badge_earned', {
      badgeId,
      tier: badgeInfo.tier,
      badgeName: badgeInfo.name
    });
  } catch (error) {
    console.error('sendNewBadgeNotification error:', error);
  }
}

/**
 * Send notification for badge tier upgrade
 */
async function sendBadgeTierUpgradeNotification(recruiterId, badgeId, badgeInfo) {
  try {
    await createNotification(
      recruiterId,
      'badge_upgrade',
      `Badge Upgraded: ${badgeInfo.name}!`,
      `Your badge has been upgraded to ${badgeInfo.name}! You're now at Tier ${badgeInfo.tier}.`,
      '/recruiter/dashboard'
    );

    // Award bonus points for tier upgrade
    await awardRecruiterPoints(recruiterId, 'badge_tier_upgrade', {
      badgeId,
      tier: badgeInfo.tier,
      badgeName: badgeInfo.name
    });
  } catch (error) {
    console.error('sendBadgeTierUpgradeNotification error:', error);
  }
}

// =============================================================================
// INTEGRATION WITH RECRUITER STATS
// =============================================================================

/**
 * Get response time badge for a carrier (integration with recruiterStats)
 * This provides backward compatibility with the existing recruiterStats.jsw badge logic
 * @param {number} avgResponseHours - Average response hours
 * @returns {object} Badge info in recruiterStats format
 */
export function getResponseTimeBadgeForStats(avgResponseHours) {
  const badge = calculateResponseTimeBadge(avgResponseHours);

  if (!badge.qualifies) {
    return {
      badge: null,
      badge_color: '#64748b' // default gray
    };
  }

  return {
    badge: badge.name,
    badge_color: badge.color
  };
}

/**
 * Get all badge summary for recruiter dashboard
 * @param {string} recruiterId
 * @returns {object} Summary of all badges
 */
export async function getRecruiterBadgeSummary(recruiterId) {
  try {
    const stats = await getRecruiterStats(recruiterId);
    const earnedBadges = await getBadges(recruiterId, 'recruiter');

    return {
      recruiter_id: recruiterId,
      total_badges: earnedBadges.filter(b => b.earned).length,
      badges: {
        response_time: calculateResponseTimeBadge(stats.avgResponseHours),
        quality: calculateQualityBadge(stats.acceptanceRate),
        retention: calculateRetentionBadge(stats.retention90DayRate),
        hires: calculateHiresBadge(stats.totalHires)
      },
      stats: {
        avg_response_hours: stats.avgResponseHours,
        acceptance_rate: stats.acceptanceRate,
        retention_rate: stats.retention90DayRate,
        total_hires: stats.totalHires
      },
      earned_badges: earnedBadges.filter(b => b.earned)
    };
  } catch (error) {
    console.error('getRecruiterBadgeSummary error:', error);
    return { error: error.message };
  }
}

// =============================================================================
// BATCH OPERATIONS
// =============================================================================

/**
 * Recalculate badges for all recruiters (scheduled job)
 * @returns {object} { processed, badges_awarded, tier_upgrades, errors }
 */
export async function batchRecalculateBadges() {
  try {
    const recruiters = await queryData(COLLECTION_KEYS.recruiterProgression, {
      limit: 1000
    });

    console.log(`[batchRecalculateBadges] Starting: ${recruiters.length} recruiters`);

    let processed = 0;
    let totalBadgesAwarded = 0;
    let totalTierUpgrades = 0;
    const errors = [];

    // Filter recruiters with valid IDs
    const validRecruiters = recruiters.filter(r => r['Recruiter ID']);

    // Chunk and process in parallel (10 per chunk - complex recalc internally)
    const chunks = chunkArray(validRecruiters, 10);

    for (const chunk of chunks) {
      const results = await Promise.all(
        chunk.map(async (recruiter) => {
          try {
            const recruiterId = recruiter['Recruiter ID'];
            const result = await recalculateRecruiterBadges(recruiterId);
            return {
              success: true,
              badgesAwarded: result.new_badges.length,
              tierUpgrades: result.tier_upgrades.length
            };
          } catch (error) {
            return { success: false, id: recruiter['Recruiter ID'], error: error.message };
          }
        })
      );

      for (const r of results) {
        processed++;
        if (r.success) {
          totalBadgesAwarded += r.badgesAwarded;
          totalTierUpgrades += r.tierUpgrades;
        } else {
          errors.push(r);
        }
      }

      // Rate limit between chunks (200ms = 5 req/sec)
      await new Promise(r => setTimeout(r, 200));
    }

    console.log(`[batchRecalculateBadges] Complete: ${processed} recruiters, ${totalBadgesAwarded} new badges, ${totalTierUpgrades} tier upgrades, ${errors.length} errors`);

    return {
      processed,
      badges_awarded: totalBadgesAwarded,
      tier_upgrades: totalTierUpgrades,
      errors: errors.length
    };
  } catch (error) {
    console.error('batchRecalculateBadges error:', error);
    return { processed: 0, badges_awarded: 0, tier_upgrades: 0, error: error.message };
  }
}

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Normalize Airtable badge definition record
 */
function normalizeBadgeDefinition(record) {
  return {
    _id: record.id,
    badgeId: record['Badge ID'],
    name: record['Name'],
    description: record['Description'],
    category: record['Category'],
    icon: record['Icon'],
    color: record['Color'],
    userType: record['User Type'],
    maxTier: record['Max Tier'] || 3,
    tierNames: record['Tier Names'] ? JSON.parse(record['Tier Names']) : [],
    tierThresholds: record['Tier Thresholds'] ? JSON.parse(record['Tier Thresholds']) : [],
    isActive: record['Is Active'] === 'Yes',
    displayOrder: record['Display Order'] || 0
  };
}

/**
 * Get badge tier thresholds for reference
 * @returns {object} All tier threshold configurations
 */
export function getBadgeTierThresholds() {
  return {
    responseTime: RESPONSE_TIME_TIERS,
    quality: QUALITY_TIERS,
    retention: RETENTION_TIERS,
    hires: HIRES_TIERS
  };
}

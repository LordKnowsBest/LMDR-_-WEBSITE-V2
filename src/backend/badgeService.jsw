/**
 * Badge Service
 *
 * Manages recruiter badges including:
 * - Responsiveness badges (Lightning, Fast, Active)
 * - Quality badges (Quality Matcher, Retention King)
 * - Milestone badges (First Hire, Ten Club, Century Club)
 *
 * This service uses Airtable-only collections (no Wix fallback).
 * 
 * @module backend/badgeService
 */

import * as dataAccess from 'backend/dataAccess';
import { createNotification } from 'backend/memberService';
import { logGamificationEvent, awardRecruiterPoints } from 'backend/gamificationService';
import { chunkArray } from 'backend/utils/arrayUtils';
import { log } from 'backend/observabilityService';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
  badgeDefinitions: 'badgeDefinitions',
  recruiterBadges: 'recruiterBadges',
  recruiterProgression: 'recruiterProgression',
  driverCarrierInterests: 'driverCarrierInterests',
  gamificationEvents: 'gamificationEvents'
};

// =============================================================================
// BADGE TIER THRESHOLDS
// =============================================================================

/**
 * Response time badge tiers
 * Based on average response time to driver inquiries
 */
const RESPONSE_TIME_TIERS = {
  lightning: { maxHours: 4, tier: 3, name: 'Lightning Responder', color: '#10b981' },
  fast: { maxHours: 24, tier: 2, name: 'Fast Responder', color: '#3b82f6' },
  active: { maxHours: 48, tier: 1, name: 'Active Recruiter', color: '#6366f1' }
};

/**
 * Quality badge tiers (offer acceptance rate)
 */
const QUALITY_TIERS = {
  elite: { minRate: 0.90, tier: 3, name: 'Elite Matcher', color: '#f59e0b' },
  quality: { minRate: 0.75, tier: 2, name: 'Quality Matcher', color: '#8b5cf6' },
  standard: { minRate: 0.50, tier: 1, name: 'Standard Recruiter', color: '#64748b' }
};

/**
 * Retention badge tiers (90-day retention rate)
 */
const RETENTION_TIERS = {
  king: { minRate: 0.95, tier: 3, name: 'Retention King', color: '#ec4899' },
  master: { minRate: 0.85, tier: 2, name: 'Retention Master', color: '#14b8a6' },
  solid: { minRate: 0.70, tier: 1, name: 'Solid Retention', color: '#6b7280' }
};

/**
 * Hires badge tiers (cumulative successful hires)
 */
const HIRES_TIERS = {
  century: { minHires: 100, tier: 4, name: 'Century Club', color: '#ef4444' },
  fifty: { minHires: 50, tier: 3, name: 'Fifty Club', color: '#f97316' },
  ten: { minHires: 10, tier: 2, name: 'Ten Club', color: '#22c55e' },
  first: { minHires: 1, tier: 1, name: 'First Hire', color: '#3b82f6' }
};

// =============================================================================
// GET BADGE DEFINITIONS
// =============================================================================

/**
 * Get all badge definitions
 */
export async function getBadgeDefinitions(userType = 'recruiter') {
  try {
    const filters = { is_active: 'Yes' };
    if (userType !== 'all') filters.user_type = userType;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.badgeDefinitions, {
      filters, 
      sort: [{ field: 'display_order', direction: 'asc' }], 
      limit: 100, 
      suppressAuth: true
    });
    return (result.items || []).map(normalizeBadgeDefinition);
  } catch (error) { 
    return []; 
  }
}

/**
 * Get user's earned badges
 */
export async function getBadges(userId, userType = 'recruiter') {
  try {
    const [defs, earned] = await Promise.all([
      getBadgeDefinitions(userType),
      dataAccess.queryRecords(COLLECTION_KEYS.recruiterBadges, { 
        filters: { recruiter_id: userId }, 
        limit: 100, 
        suppressAuth: true 
      })
    ]);

    const earnedMap = new Map();
    (earned.items || []).forEach(r => {
      earnedMap.set(r.badge_id, { 
        _id: r._id, 
        tier: r.current_tier || 1, 
        tierName: r.tier_name, 
        earnedAt: r.earned_at, 
        lastUpgraded: r.last_upgraded, 
        progress: r.progress || 0 
      });
    });

    return defs.map(def => {
      const e = earnedMap.get(def.badgeId);
      return { 
        ...def, 
        earned: !!e, 
        currentTier: e?.tier || 0, 
        tierName: e?.tierName || null, 
        earnedAt: e?.earnedAt || null, 
        lastUpgraded: e?.lastUpgraded || null, 
        progress: e?.progress || 0 
      };
    });
  } catch (error) { 
    return []; 
  }
}

// =============================================================================
// BADGE TIER CALCULATIONS
// =============================================================================

export function calculateResponseTimeBadge(avg) {
  if (avg === null || avg === undefined) return { tier: 0, qualifies: false };
  if (avg < RESPONSE_TIME_TIERS.lightning.maxHours) return { ...RESPONSE_TIME_TIERS.lightning, qualifies: true };
  if (avg < RESPONSE_TIME_TIERS.fast.maxHours) return { ...RESPONSE_TIME_TIERS.fast, qualifies: true };
  if (avg < RESPONSE_TIME_TIERS.active.maxHours) return { ...RESPONSE_TIME_TIERS.active, qualifies: true };
  return { tier: 0, qualifies: false };
}

export function calculateQualityBadge(rate) {
  if (rate === null || rate === undefined) return { tier: 0, qualifies: false };
  if (rate >= QUALITY_TIERS.elite.minRate) return { ...QUALITY_TIERS.elite, qualifies: true };
  if (rate >= QUALITY_TIERS.quality.minRate) return { ...QUALITY_TIERS.quality, qualifies: true };
  if (rate >= QUALITY_TIERS.standard.minRate) return { ...QUALITY_TIERS.standard, qualifies: true };
  return { tier: 0, qualifies: false };
}

export function calculateRetentionBadge(rate) {
  if (rate === null || rate === undefined) return { tier: 0, qualifies: false };
  if (rate >= RETENTION_TIERS.king.minRate) return { ...RETENTION_TIERS.king, qualifies: true };
  if (rate >= RETENTION_TIERS.master.minRate) return { ...RETENTION_TIERS.master, qualifies: true };
  if (rate >= RETENTION_TIERS.solid.minRate) return { ...RETENTION_TIERS.solid, qualifies: true };
  return { tier: 0, qualifies: false };
}

export function calculateHiresBadge(total) {
  if (!total) return { tier: 0, qualifies: false };
  if (total >= HIRES_TIERS.century.minHires) return { ...HIRES_TIERS.century, qualifies: true };
  if (total >= HIRES_TIERS.fifty.minHires) return { ...HIRES_TIERS.fifty, qualifies: true };
  if (total >= HIRES_TIERS.ten.minHires) return { ...HIRES_TIERS.ten, qualifies: true };
  if (total >= HIRES_TIERS.first.minHires) return { ...HIRES_TIERS.first, qualifies: true };
  return { tier: 0, qualifies: false };
}

// =============================================================================
// RECALCULATE BADGES
// =============================================================================

/**
 * Recalculate badges for a specific recruiter
 */
export async function recalculateRecruiterBadges(recruiterId) {
  try {
    const stats = await getRecruiterStats(recruiterId);
    const badgeCalcs = [
      { id: 'response_time', cat: 'responsiveness', calc: calculateResponseTimeBadge(stats.avgResponseHours) },
      { id: 'quality_matcher', cat: 'quality', calc: calculateQualityBadge(stats.acceptanceRate) },
      { id: 'retention', cat: 'retention', calc: calculateRetentionBadge(stats.retention90DayRate) },
      { id: 'hires_milestone', cat: 'milestone', calc: calculateHiresBadge(stats.totalHires) }
    ];

    const existingRes = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterBadges, { 
      filters: { recruiter_id: recruiterId }, 
      limit: 50, 
      suppressAuth: true 
    });
    const existingMap = new Map();
    (existingRes.items || []).forEach(b => existingMap.set(b.badge_id, b));

    const results = { badges_updated: 0, new_badges: [], tier_upgrades: [] };
    const now = new Date().toISOString();

    for (const { id, cat, calc } of badgeCalcs) {
      if (!calc.qualifies) continue;
      const e = existingMap.get(id);
      
      if (e) {
        if (calc.tier > (e.current_tier || 0)) {
          await dataAccess.updateRecord(COLLECTION_KEYS.recruiterBadges, { 
            ...e, 
            current_tier: calc.tier, 
            tier_name: calc.name, 
            badge_color: calc.color, 
            last_upgraded: now, 
            updated_at: now 
          }, { suppressAuth: true });
          
          results.tier_upgrades.push({ id, previous: e.current_tier, new: calc.tier, name: calc.name });
          await sendBadgeTierUpgradeNotification(recruiterId, id, calc);
          results.badges_updated++;
        }
      } else {
        await dataAccess.insertRecord(COLLECTION_KEYS.recruiterBadges, { 
          recruiter_id: recruiterId, 
          badge_id: id, 
          badge_category: cat, 
          current_tier: calc.tier, 
          tier_name: calc.name, 
          badge_color: calc.color, 
          earned_at: now, 
          last_upgraded: now, 
          progress: 100, 
          created_at: now, 
          updated_at: now 
        }, { suppressAuth: true });
        
        results.new_badges.push({ id, tier: calc.tier, name: calc.name });
        await sendNewBadgeNotification(recruiterId, id, calc);
        results.badges_updated++;
      }
    }

    if (results.badges_updated > 0) {
      await logGamificationEvent(recruiterId, 'recruiter', { 
        eventType: 'badge_update', 
        action: 'badge_recalculation', 
        metadata: { 
          newBadges: results.new_badges, 
          tierUpgrades: results.tier_upgrades 
        } 
      });
    }
    
    return results;
  } catch (error) { 
    return { 
      badges_updated: 0, 
      new_badges: [], 
      tier_upgrades: [], 
      error: error.message 
    }; 
  }
}

/**
 * Get internal recruiter stats for badge calculation
 */
async function getRecruiterStats(recruiterId) {
  try {
    const progRes = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterProgression, { 
      filters: { recruiter_id: recruiterId }, 
      limit: 1, 
      suppressAuth: true 
    });
    
    if (!progRes.items?.length) {
      return { avgResponseHours: null, acceptanceRate: null, retention90DayRate: null, totalHires: 0 };
    }
    
    const p = progRes.items[0];
    const liveResp = await calculateLiveResponseTime(recruiterId);
    
    return { 
      avgResponseHours: liveResp || p.avg_response_hours || null, 
      acceptanceRate: p.hire_acceptance_rate || null, 
      retention90DayRate: p.retention_90_day_rate || null, 
      totalHires: p.total_hires || 0 
    };
  } catch (err) { 
    return { avgResponseHours: null, acceptanceRate: null, retention90DayRate: null, totalHires: 0 }; 
  }
}

/**
 * Calculate live response time from interest records
 */
async function calculateLiveResponseTime(recruiterId) {
  try {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverCarrierInterests, { 
      filters: { 
        recruiter_id: recruiterId, 
        recruiter_response_time: { ne: null } 
      }, 
      limit: 100, 
      suppressAuth: true 
    });
    
    const items = res.items || [];
    if (items.length === 0) return null;
    
    const sum = items.reduce((s, i) => s + (i.recruiter_response_time || 0), 0);
    return sum / items.length;
  } catch (err) { 
    return null; 
  }
}

export async function checkBadgeTierProgress(userId, badgeId) {
  try {
    const stats = await getRecruiterStats(userId);
    switch (badgeId) {
      case 'response_time': return calculateResponseTimeProgress(stats.avgResponseHours);
      case 'quality_matcher': return calculateQualityProgress(stats.acceptanceRate);
      case 'retention': return calculateRetentionProgress(stats.retention90DayRate);
      case 'hires_milestone': return calculateHiresProgress(stats.totalHires);
      default: return { error: 'unknown_badge', badgeId };
    }
  } catch (error) { 
    return { error: error.message }; 
  }
}

function calculateResponseTimeProgress(avg) { 
  return { 
    currentTier: calculateResponseTimeBadge(avg).tier, 
    current: avg, 
    target: 4, 
    direction: 'lower_is_better' 
  }; 
}

function calculateQualityProgress(rate) { 
  return { 
    currentTier: calculateQualityBadge(rate).tier, 
    current: rate, 
    target: 0.9, 
    direction: 'higher_is_better' 
  }; 
}

function calculateRetentionProgress(rate) { 
  return { 
    currentTier: calculateRetentionBadge(rate).tier, 
    current: rate, 
    target: 0.95, 
    direction: 'higher_is_better' 
  }; 
}

function calculateHiresProgress(total) { 
  return { 
    currentTier: calculateHiresBadge(total).tier, 
    current: total, 
    target: 100, 
    direction: 'higher_is_better' 
  }; 
}

async function sendNewBadgeNotification(recruiterId, badgeId, badgeInfo) {
  try {
    await createNotification(
      recruiterId, 
      'badge_earned', 
      `New Badge: ${badgeInfo.name}!`, 
      `Congratulations! You've earned the ${badgeInfo.name} badge.`, 
      '/recruiter/dashboard'
    );
    await awardRecruiterPoints(recruiterId, 'badge_earned', { 
      badgeId, 
      tier: badgeInfo.tier, 
      badgeName: badgeInfo.name 
    });
  } catch (error) { 
    console.error('[badgeService] Failed to send new badge notification:', error.message);
  }
}

async function sendBadgeTierUpgradeNotification(recruiterId, badgeId, badgeInfo) {
  try {
    await createNotification(
      recruiterId, 
      'badge_upgrade', 
      `Badge Upgraded: ${badgeInfo.name}!`, 
      `Your badge has been upgraded to ${badgeInfo.name}!`, 
      '/recruiter/dashboard'
    );
    await awardRecruiterPoints(recruiterId, 'badge_tier_upgrade', { 
      badgeId, 
      tier: badgeInfo.tier, 
      badgeName: badgeInfo.name 
    });
  } catch (error) { 
    console.error('[badgeService] Failed to send badge upgrade notification:', error.message);
  }
}

export function getResponseTimeBadgeForStats(avg) {
  const b = calculateResponseTimeBadge(avg);
  return b.qualifies ? { badge: b.name, badge_color: b.color } : { badge: null, badge_color: '#64748b' };
}

export async function getRecruiterBadgeSummary(recruiterId) {
  try {
    const [stats, earned] = await Promise.all([
      getRecruiterStats(recruiterId), 
      getBadges(recruiterId, 'recruiter')
    ]);
    
    return { 
      recruiter_id: recruiterId, 
      total_badges: earned.filter(b => b.earned).length, 
      badges: { 
        response_time: calculateResponseTimeBadge(stats.avgResponseHours), 
        quality: calculateQualityBadge(stats.acceptanceRate), 
        retention: calculateRetentionBadge(stats.retention90DayRate), 
        hires: calculateHiresBadge(stats.totalHires) 
      }, 
      stats, 
      earned_badges: earned.filter(b => b.earned) 
    };
  } catch (error) { 
    return { error: error.message }; 
  }
}

/**
 * Batch recalculate badges for all recruiters
 * Runs as a scheduled task or administrative action.
 */
export async function batchRecalculateBadges() {
  const traceId = `batch-badges-${Date.now()}`;
  try {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterProgression, { 
      limit: 1000, 
      suppressAuth: true 
    });
    const recruiters = res.items || [];
    
    let processed = 0;
    let updated = 0;
    
    // Process recruiters in chunks
    const chunks = chunkArray(recruiters, 10);
    
    for (const chunk of chunks) {
      const results = await Promise.all(chunk.map(async (r) => {
        if (r.recruiter_id) {
          try {
            const res = await recalculateRecruiterBadges(r.recruiter_id);
            return res.badges_updated > 0;
          } catch (err) {
            console.error(`[badgeService] Failed to recalculate for ${r.recruiter_id}:`, err.message);
            return false;
          }
        }
        return false;
      }));
      
      updated += results.filter(Boolean).length;
      processed += chunk.length;
      
      // Delay to respect rate limits
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    await log({
      level: 'INFO',
      source: 'badge-service',
      message: `Batch badge recalculation complete: ${updated} recruiters updated`,
      traceId,
      details: { processed, updated }
    });
    
    return { processed, updated };
  } catch (error) { 
    await log({
      level: 'ERROR',
      source: 'badge-service',
      message: 'Batch badge recalculation failed',
      traceId,
      details: { error: error.message }
    });
    return { error: error.message }; 
  }
}

/**
 * Normalize badge definition record
 */
function normalizeBadgeDefinition(r) {
  return { 
    _id: r._id, 
    badgeId: r.badge_id, 
    name: r.name, 
    description: r.description, 
    category: r.category, 
    icon: r.icon, 
    color: r.color, 
    userType: r.user_type, 
    maxTier: r.max_tier || 3, 
    isActive: r.is_active === 'Yes', 
    displayOrder: r.display_order || 0 
  };
}

/**
 * Get badge tier thresholds for reference
 */
export function getBadgeTierThresholds() { 
  return { 
    responseTime: RESPONSE_TIME_TIERS, 
    quality: QUALITY_TIERS, 
    retention: RETENTION_TIERS, 
    hires: HIRES_TIERS 
  }; 
}
import { getSecret } from 'wix-secrets-backend';

const DEFAULT_RUNTIME = 'wix';

const WixSecretProvider = {
  async get(secretKey) {
    return getSecret(secretKey);
  }
};

// Stub provider for future migration track.
const GCPSecretProvider = {
  async get(secretKey) {
    console.warn(`[socialSecretService] GCPSecretProvider not implemented for ${secretKey}. Falling back to Wix secrets.`);
    return WixSecretProvider.get(secretKey);
  }
};

function getRuntime() {
  if (typeof process !== 'undefined' && process.env && process.env.SOCIAL_RUNTIME) {
    return String(process.env.SOCIAL_RUNTIME).toLowerCase();
  }
  return DEFAULT_RUNTIME;
}

function getProvider() {
  return getRuntime() === 'gcp' ? GCPSecretProvider : WixSecretProvider;
}

async function getRequiredSecret(secretKey) {
  const value = await getProvider().get(secretKey);
  if (!value) {
    throw new Error(`Missing required secret: ${secretKey}`);
  }
  return value;
}

export async function getFBPageToken(pageId) {
  if (!pageId) throw new Error('pageId is required');
  return getRequiredSecret(`meta_page_token_${pageId}`);
}

export async function getIGUserToken(igUserId) {
  if (!igUserId) throw new Error('igUserId is required');
  return getRequiredSecret(`meta_ig_token_${igUserId}`);
}

export async function getMetaAppId() {
  return getRequiredSecret('meta_app_id');
}

export async function getMetaAppSecret() {
  return getRequiredSecret('meta_app_secret');
}

export async function getMetaUserToken(userId) {
  if (!userId) throw new Error('userId is required');
  return getRequiredSecret(`meta_user_token_${userId}`);
}

export async function getMetaPageIdForIG(igUserId) {
  if (!igUserId) throw new Error('igUserId is required');
  return getRequiredSecret(`meta_ig_page_id_${igUserId}`);
}

export function getSecretProviderName() {
  return getRuntime() === 'gcp' ? 'GCPSecretProvider' : 'WixSecretProvider';
}

/**
 * Save social platform credentials to Airtable `socialCredentials` collection.
 * Wix Secrets cannot be written to programmatically, so credentials are persisted
 * as an Airtable record (one record per platform per carrier).
 *
 * @param {string} platform      - 'facebook' | 'instagram' | 'linkedin'
 * @param {Object} credentials   - key/value pairs specific to the platform:
 *   facebook:  { appId, appSecret, pageId, pageToken, carrierDot }
 *   instagram: { igUserId, carrierDot }
 *   linkedin:  { clientId, clientSecret, accessToken, orgUrn, carrierDot }
 * @returns {{ success: boolean, platform?: string, error?: string }}
 */
export async function saveCredentials(platform, credentials) {
  try {
    const supportedPlatforms = ['facebook', 'instagram', 'linkedin'];
    if (!supportedPlatforms.includes(platform)) {
      return { success: false, error: `Unsupported platform: ${platform}` };
    }

    const dataAccess = await import('backend/dataAccess');

    const record = {
      platform,
      carrier_dot:   credentials.carrierDot   || '',
      app_id:        credentials.appId         || '',
      app_secret:    credentials.appSecret     || '',
      page_id:       credentials.pageId        || '',
      page_token:    credentials.pageToken     || '',
      ig_user_id:    credentials.igUserId      || '',
      client_id:     credentials.clientId      || '',
      client_secret: credentials.clientSecret  || '',
      access_token:  credentials.accessToken   || '',
      org_urn:       credentials.orgUrn        || '',
      updated_at:    new Date().toISOString().slice(0, 10)
    };

    // Upsert: if a record for this platform + carrier already exists, update it;
    // otherwise insert a new one.
    const existing = await dataAccess.queryRecords('socialCredentials', {
      filters: {
        platform,
        carrier_dot: record.carrier_dot
      },
      limit: 1,
      suppressAuth: true
    });

    if (existing && existing.items && existing.items.length > 0) {
      const existingId = existing.items[0]._id || existing.items[0].id;
      await dataAccess.updateRecord('socialCredentials', existingId, record, { suppressAuth: true });
    } else {
      await dataAccess.insertRecord('socialCredentials', record, { suppressAuth: true });
    }

    return { success: true, platform };
  } catch (error) {
    console.error('[socialSecretService] saveCredentials error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get credential configuration status for a platform by querying Airtable.
 * Returns 'connected' when at least one active record exists for the platform,
 * 'unconfigured' otherwise.
 *
 * @param {string} platform    - 'facebook' | 'instagram' | 'linkedin'
 * @param {string} [carrierDot] - optional carrier scope; omit to check any carrier
 * @returns {{ status: 'connected' | 'unconfigured' }}
 */
export async function getCredentialStatus(platform, carrierDot) {
  try {
    const supportedPlatforms = ['facebook', 'instagram', 'linkedin'];
    if (!supportedPlatforms.includes(platform)) {
      return { status: 'unconfigured' };
    }

    const dataAccess = await import('backend/dataAccess');

    const filters = { platform };
    if (carrierDot) {
      filters.carrier_dot = carrierDot;
    }

    const result = await dataAccess.queryRecords('socialCredentials', {
      filters,
      limit: 1,
      suppressAuth: true
    });

    if (result && result.items && result.items.length > 0) {
      return { status: 'connected' };
    }
    return { status: 'unconfigured' };
  } catch (error) {
    console.error('[socialSecretService] getCredentialStatus error:', error);
    return { status: 'unconfigured' };
  }
}

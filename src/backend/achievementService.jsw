/**
 * Achievement Service
 *
 * Manages achievements for both drivers and recruiters including:
 * - Checking and awarding achievements based on user actions
 * - Tracking achievement progress
 * - Retrieving earned and available achievements
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import * as dataAccess from 'backend/dataAccess';
import { createNotification } from 'backend/memberService';
import { awardDriverXP, awardRecruiterPoints, logGamificationEvent } from 'backend/gamificationService';
import { runAchievementChecker, DRIVER_ACHIEVEMENT_CHECKERS, RECRUITER_ACHIEVEMENT_CHECKERS } from 'backend/achievementCheckers';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
  achievementDefinitions: 'achievementDefinitions',
  driverAchievements: 'driverAchievements',
  driverProgression: 'driverProgression',
  recruiterProgression: 'recruiterProgression',
  gamificationEvents: 'gamificationEvents'
};

// =============================================================================
// GET ACHIEVEMENTS
// =============================================================================

/**
 * Get all achievement definitions
 */
export async function getAchievementDefinitions(userType = 'all', category = null) {
  try {
    const filters = { is_active: 'Yes' };
    if (userType !== 'all') filters.user_type = userType;
    if (category) filters.category = category;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.achievementDefinitions, {
      filters, sort: [{ field: 'display_order', direction: 'asc' }], limit: 100, suppressAuth: true
    });
    return (result.items || []).map(normalizeAchievementDefinition);
  } catch (error) { return []; }
}

/**
 * Get user's achievements
 */
export async function getAchievements(userId, userType, options = {}) {
  try {
    const [defs, earned] = await Promise.all([
      getAchievementDefinitions(userType, options.category),
      dataAccess.queryRecords(COLLECTION_KEYS.driverAchievements, { filters: { user_id: userId, user_type: userType }, limit: 100, suppressAuth: true })
    ]);

    const earnedMap = new Map();
    (earned.items || []).forEach(r => earnedMap.set(r.achievement_id, { earnedAt: r.earned_at, progress: r.progress || 100, isComplete: r.is_complete === 'Yes' }));

    const achievements = defs.map(def => {
      const e = earnedMap.get(def.achievementId);
      return { ...def, earned: !!e?.isComplete, earnedAt: e?.earnedAt || null, progress: e?.progress || 0, isComplete: e?.isComplete || false };
    });

    return options.include_locked ? achievements : achievements.filter(a => !a.isHidden || a.earned);
  } catch (error) { return []; }
}

/**
 * Get progress toward a specific achievement
 */
export async function getAchievementProgress(userId, achievementId) {
  try {
    const defs = await dataAccess.queryRecords(COLLECTION_KEYS.achievementDefinitions, { filters: { achievement_id: achievementId }, limit: 1, suppressAuth: true });
    if (!defs.items?.length) return { current: 0, target: 0, percentage: 0, is_complete: false, error: 'not_found' };
    const def = normalizeAchievementDefinition(defs.items[0]);

    const earned = await dataAccess.queryRecords(COLLECTION_KEYS.driverAchievements, { filters: { user_id: userId, achievement_id: achievementId, is_complete: 'Yes' }, limit: 1, suppressAuth: true });
    if (earned.items?.length) return { current: def.requirementValue, target: def.requirementValue, percentage: 100, is_complete: true, earned_at: earned.items[0].earned_at };

    const checkerResult = await runAchievementChecker(def.achievementId, userId, def.userType, {});
    if (!checkerResult.error || checkerResult.error !== 'no_checker') return { current: checkerResult.current, target: checkerResult.target, percentage: Math.min(100, Math.round((checkerResult.current / checkerResult.target) * 100)), is_complete: checkerResult.qualifies };

    const current = await calculateCurrentProgress(userId, def);
    return { current, target: def.requirementValue, percentage: Math.min(100, Math.round((current / def.requirementValue) * 100)), is_complete: current >= def.requirementValue };
  } catch (error) { return { current: 0, target: 0, percentage: 0, is_complete: false, error: error.message }; }
}

// =============================================================================
// CHECK AND AWARD ACHIEVEMENTS
// =============================================================================

export async function checkAndAwardAchievements(userId, userType, context = {}) {
  try {
    const defs = await getAchievementDefinitions(userType);
    const earned = await dataAccess.queryRecords(COLLECTION_KEYS.driverAchievements, { filters: { user_id: userId, user_type: userType, is_complete: 'Yes' }, limit: 200, suppressAuth: true });
    const earnedIds = new Set((earned.items || []).map(r => r.achievement_id));

    const newlyEarned = [];
    for (const def of defs) {
      if (earnedIds.has(def.achievementId)) continue;
      if (await checkAchievementQualification(userId, userType, def, context)) {
        if (await awardAchievement(userId, userType, def)) newlyEarned.push({ ...def, earnedAt: new Date().toISOString() });
      }
    }
    return newlyEarned;
  } catch (error) { return []; }
}

async function checkAchievementQualification(userId, userType, def, context = {}) {
  try {
    const res = await runAchievementChecker(def.achievementId, userId, userType, context);
    if (!res.error || res.error !== 'no_checker') return res.qualifies;
    return (await calculateCurrentProgress(userId, def)) >= def.requirementValue;
  } catch (error) { return false; }
}

async function calculateCurrentProgress(userId, def) {
  try {
    const progKey = def.userType === 'driver' ? COLLECTION_KEYS.driverProgression : COLLECTION_KEYS.recruiterProgression;
    const filter = def.userType === 'driver' ? { driver_id: userId } : { recruiter_id: userId };
    const progRes = await dataAccess.queryRecords(progKey, { filters: filter, limit: 1, suppressAuth: true });
    const progression = progRes.items?.[0] || {};

    if (def.requirementType === 'count') {
      const val = getFieldValue(progression, def.requirementField);
      if (val !== undefined) return val;
      const evts = await dataAccess.queryRecords(COLLECTION_KEYS.gamificationEvents, { filters: { user_id: userId, action: def.requirementField }, limit: 1000, suppressAuth: true });
      return evts.items?.length || 0;
    }
    if (def.requirementType === 'streak') return progression.streak_days || 0;
    const val = getFieldValue(progression, def.requirementField);
    return def.requirementType === 'threshold' ? (val || 0) : (val ? 1 : 0);
  } catch (error) { return 0; }
}

function getFieldValue(record, field) {
  const variations = [field, field.replace(/_/g, ' '), field.charAt(0).toUpperCase() + field.slice(1)];
  for (const v of variations) if (record[v] !== undefined) return record[v];
  return undefined;
}

async function awardAchievement(userId, userType, def) {
  try {
    const now = new Date().toISOString();
    await dataAccess.insertRecord(COLLECTION_KEYS.driverAchievements, { user_id: userId, user_type: userType, achievement_id: def.achievementId, achievement_name: def.name, earned_at: now, progress: 100, is_complete: 'Yes', notified: 'No', display_order: def.displayOrder || 0 }, { suppressAuth: true });

    if (def.xpReward > 0) {
      if (userType === 'driver') await awardDriverXP(userId, 'achievement_earned', { achievementId: def.achievementId, xpOverride: def.xpReward });
      else await awardRecruiterPoints(userId, 'achievement_earned', { achievementId: def.achievementId, pointsOverride: def.xpReward });
    }

    await createNotification(userId, 'achievement_earned', `Unlocked: ${def.name}!`, def.description + (def.xpReward > 0 ? ` +${def.xpReward} XP` : ''), '/dashboard');
    await logGamificationEvent(userId, userType, { eventType: 'achievement_earned', action: 'achievement_earned', xpEarned: def.xpReward || 0, metadata: { achievementId: def.achievementId, achievementName: def.name, category: def.category } });
    return true;
  } catch (error) { return false; }
}

export async function manuallyAwardAchievement(userId, achievementId) {
  try {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.achievementDefinitions, { filters: { achievement_id: achievementId }, limit: 1, suppressAuth: true });
    if (!res.items?.length) return { success: false, reason: 'not_found' };
    const def = normalizeAchievementDefinition(res.items[0]);

    const earned = await dataAccess.queryRecords(COLLECTION_KEYS.driverAchievements, { filters: { user_id: userId, achievement_id: achievementId, is_complete: 'Yes' }, limit: 1, suppressAuth: true });
    if (earned.items?.length) return { success: false, reason: 'already_earned' };

    const awarded = await awardAchievement(userId, def.userType, def);
    return awarded ? { success: true, achievement: { ...def, earnedAt: new Date().toISOString() } } : { success: false, reason: 'award_failed' };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function checkProfileAchievements(driverId, data = {}) {
  return await checkAndAwardAchievements(driverId, 'driver', { action: 'profile_update', profileCompletion: data.profileCompletion || 0, hasPhoto: !!data.photoUrl, hasCDL: !!data.cdlNumber, cdlVerified: !!data.cdlVerified, bioLength: (data.bio || '').length });
}

export async function checkApplicationAchievements(driverId, count) {
  return await checkAndAwardAchievements(driverId, 'driver', { action: 'submit_application', totalApplications: count });
}

export async function checkResponseAchievements(driverId, hours) {
  return await checkAndAwardAchievements(driverId, 'driver', { action: 'message_response', responseTimeHours: hours });
}

export async function checkLevelAchievements(driverId, level) {
  return await checkAndAwardAchievements(driverId, 'driver', { action: 'level_up', level });
}

export async function checkHireAchievements(recruiterId, count) {
  return await checkAndAwardAchievements(recruiterId, 'recruiter', { action: 'successful_hire', totalHires: count });
}

export async function checkStreakAchievements(driverId, days) {
  return await checkAndAwardAchievements(driverId, 'driver', { action: 'streak_update', streakDays: days });
}

export async function batchCheckAchievements(userType) {
  try {
    const key = userType === 'driver' ? COLLECTION_KEYS.driverProgression : COLLECTION_KEYS.recruiterProgression;
    const idField = userType === 'driver' ? 'driver_id' : 'recruiter_id';
    const res = await dataAccess.queryRecords(key, { limit: 1000, suppressAuth: true });
    let awarded = 0;
    for (const u of (res.items || [])) {
      if (u[idField]) { const newly = await checkAndAwardAchievements(u[idField], userType); awarded += newly.length; }
    }
    return { processed: res.items?.length || 0, awarded };
  } catch (error) { return { error: error.message }; }
}

function normalizeAchievementDefinition(r) {
  return { _id: r._id, achievementId: r.achievement_id, name: r.name, description: r.description, category: r.category, icon: r.icon, color: r.color, userType: r.user_type, requirementType: r.requirement_type, requirementField: r.requirement_field, requirementValue: r.requirement_value || 1, xpReward: r.xp_reward || 0, isHidden: r.is_hidden === 'Yes', isActive: r.is_active === 'Yes', displayOrder: r.display_order || 0 };
}

export function hasAchievementChecker(id, type) { return !!(type === 'driver' ? DRIVER_ACHIEVEMENT_CHECKERS : RECRUITER_ACHIEVEMENT_CHECKERS)[id]; }
export function listAchievementCheckers() { return { driver: Object.keys(DRIVER_ACHIEVEMENT_CHECKERS), recruiter: Object.keys(RECRUITER_ACHIEVEMENT_CHECKERS) }; }

export async function getBulkAchievementProgress(userId, userType, ids = []) {
  try {
    const defs = await getAchievementDefinitions(userType);
    const results = {};
    for (const def of defs) {
      if (ids.length && !ids.includes(def.achievementId)) continue;
      const prog = await getAchievementProgress(userId, def.achievementId);
      results[def.achievementId] = { name: def.name, category: def.category, ...prog };
    }
    return results;
  } catch (error) { return {}; }
}

import * as dataAccess from 'backend/dataAccess';
import { getDetailedCSAData } from 'backend/fmcsaService';
import { seedCSAScores } from 'backend/seeds/seedMockData';
import { dispatchSafetyAlertEvent } from 'backend/apiWebhookService';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    csaScoreHistory: 'csaScoreHistory',
    complianceAlerts: 'complianceAlerts',
    carrierSubscriptions: 'carrierSubscriptions'
};

const STATUS = { PENDING: 'pending', UPCOMING: 'upcoming', DUE_SOON: 'due_soon', OVERDUE: 'overdue', COMPLETED: 'completed' };

// ============================================================
// CSA SCORE MONITORING
// ============================================================

/**
 * Get current CSA scores with trend analysis
 */
export async function getCSAScoresWithTrends(carrierDot) {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.csaScoreHistory, {
      filters: { carrier_dot: carrierDot },
      sort: [{ field: 'snapshot_date', direction: 'desc' }],
      limit: 1, suppressAuth: true
  });

  if (!result.items?.length) {
    const seedResult = await seedCSAScores(carrierDot);
    if (seedResult.seeded) {
        const reRes = await dataAccess.queryRecords(COLLECTION_KEYS.csaScoreHistory, {
            filters: { carrier_dot: carrierDot },
            sort: [{ field: 'snapshot_date', direction: 'desc' }],
            limit: 1, suppressAuth: true
        });
        if (reRes.items?.length) return reRes.items[0];
    }
    return await snapshotCSAScores(carrierDot, 'manual');
  }

  return result.items[0];
}

/**
 * Get CSA score history for charting
 */
export async function getCSAScoreHistory(carrierDot, months = 12) {
  const cutoff = new Date(); cutoff.setMonth(cutoff.getMonth() - months);

  const result = await dataAccess.queryRecords(COLLECTION_KEYS.csaScoreHistory, {
      filters: { carrier_dot: carrierDot, snapshot_date: { gte: cutoff } },
      sort: [{ field: 'snapshot_date', direction: 'asc' }], limit: 100, suppressAuth: true
  });

  if (!result.items?.length) {
      const seedResult = await seedCSAScores(carrierDot);
      if (seedResult.seeded) {
          const reRes = await dataAccess.queryRecords(COLLECTION_KEYS.csaScoreHistory, {
              filters: { carrier_dot: carrierDot, snapshot_date: { gte: cutoff } },
              sort: [{ field: 'snapshot_date', direction: 'asc' }], limit: 100, suppressAuth: true
          });
          return reRes.items || [];
      }
  }

  return result.items || [];
}

/**
 * Take a snapshot of current CSA scores
 */
export async function snapshotCSAScores(carrierDot, source = 'manual') {
  const liveData = await getDetailedCSAData(carrierDot);
  if (liveData.error) throw new Error(liveData.userMessage || 'Failed to fetch FMCSA data');

  const prevRes = await dataAccess.queryRecords(COLLECTION_KEYS.csaScoreHistory, {
      filters: { carrier_dot: carrierDot },
      sort: [{ field: 'snapshot_date', direction: 'desc' }],
      limit: 1, suppressAuth: true
  });
  const prev = prevRes.items?.[0];

  const trend = {}, basics = liveData.basics || {};
  const prevBasics = parseJsonObject(prev?.basics);
  Object.keys(basics).forEach(key => {
    const current = basics[key].percentile || 0;
    const previous = prevBasics?.[key]?.percentile ?? current;
    trend[key] = current - previous;
  });

  const snapshot = {
    carrier_dot: carrierDot, snapshot_date: new Date(),
    overall_percentile: 0, basics: JSON.stringify(basics),
    alerts_active: JSON.stringify(liveData.has_basic_alerts ? Object.keys(basics).filter(k => basics[k].alert) : []),
    inspections_30_day: 0, violations_30_day: 0, crashes_30_day: 0,
    trend_vs_prior: JSON.stringify(trend), source, _createdDate: new Date()
  };

  const result = await dataAccess.insertRecord(COLLECTION_KEYS.csaScoreHistory, snapshot, { suppressAuth: true });
  if (source === 'scheduled') await checkAndAlert(carrierDot, result.record, prev);

  return result.record;
}

async function checkAndAlert(carrierDot, current, prev) {
    if (!prev) return;
    const newAlerts = [];
    const currAlerts = JSON.parse(current.alerts_active || '[]');
    const prevAlerts = JSON.parse(prev.alerts_active || '[]');
    
    currAlerts.filter(a => !prevAlerts.includes(a)).forEach(basic => {
        newAlerts.push({ type: 'csa_change', severity: 'critical', message: `New FMCSA Alert in ${basic.replace('_', ' ')}` });
    });
    
    const currBasics = JSON.parse(current.basics || '{}');
    const trend = JSON.parse(current.trend_vs_prior || '{}');
    Object.keys(currBasics).forEach(key => {
        if (trend[key] > 10) newAlerts.push({ type: 'csa_change', severity: 'warning', message: `${key.replace('_', ' ')} score increased by ${trend[key]}%` });
    });
    
    for (const a of newAlerts) {
        const inserted = await dataAccess.insertRecord(COLLECTION_KEYS.complianceAlerts, {
            carrier_dot: carrierDot, alert_type: a.type, severity: a.severity,
            title: 'CSA Score Alert', message: a.message, status: 'active',
            related_entity_type: 'csa_score', related_entity_id: current._id, _createdDate: new Date()
        }, { suppressAuth: true });
        const alertRecord = inserted?.record || inserted || {};
        await dispatchSafetyAlertEvent({
            dot_number: Number(carrierDot),
            alert_type: a.type,
            occurred_at: new Date().toISOString(),
            partner_event_id: alertRecord._id || null,
            details: {
                severity: a.severity,
                message: a.message,
                related_entity_id: current._id || null
            }
        }).catch(() => null);
    }
}

export async function processCSAScoreUpdates() {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierSubscriptions, { filters: { is_active: true }, limit: 1000, suppressAuth: true });
  const subs = result.items || [];
  let processed = 0;
  for (const sub of subs) {
      if (sub.carrier_dot) {
          try { await snapshotCSAScores(sub.carrier_dot, 'scheduled'); processed++; } catch (e) { }
      }
  }
  return { processed };
}

export async function getCSARecommendations(carrierDot) {
    const scores = await getCSAScoresWithTrends(carrierDot);
    const basics = typeof scores.basics === 'string' ? JSON.parse(scores.basics) : (scores.basics || {});
    const recs = [];
    if (basics.unsafe_driving?.percentile > 50) recs.push({ category: 'Unsafe Driving', action: 'Implement defensive driving course', priority: 'high' });
    if (basics.vehicle_maintenance?.percentile > 50) recs.push({ category: 'Vehicle Maintenance', action: 'Review pre-trip inspection logs', priority: 'medium' });
    return recs;
}

function parseJsonObject(value) {
    if (!value) return {};
    if (typeof value === 'object') return value;
    try {
        return JSON.parse(value);
    } catch (_e) {
        return {};
    }
}

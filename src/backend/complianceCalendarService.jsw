import * as dataAccess from 'backend/dataAccess';
import { sendComplianceNotification } from 'backend/emailService';
import { getProfileById } from 'backend/driverProfiles';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    complianceEvents: 'complianceEvents',
    complianceAlerts: 'complianceAlerts',
    carrierDocuments: 'carrierDocuments'
};

// Event Statuses
const STATUS = {
  PENDING: 'pending', UPCOMING: 'upcoming', DUE_SOON: 'due_soon', OVERDUE: 'overdue', COMPLETED: 'completed'
};

// ============================================================
// COMPLIANCE EVENTS - CRUD
// ============================================================

/**
 * Get all compliance events for a carrier
 */
export async function getComplianceEvents(carrierDot, filters = {}) {
  const queryFilters = {};
  if (carrierDot) queryFilters.carrier_dot = carrierDot;
  if (filters.status) queryFilters.status = filters.status;
  if (filters.category) queryFilters.event_category = filters.category;
  if (filters.driverId) queryFilters.driver_id = filters.driverId;
  if (filters.dateRange) {
    if (filters.dateRange.start) queryFilters.due_date = { gte: new Date(filters.dateRange.start) };
    // Handle upper bound if needed
  }

  const result = await dataAccess.queryRecords(COLLECTION_KEYS.complianceEvents, {
    filters: queryFilters, sort: [{ field: 'due_date', direction: 'asc' }], limit: 500, suppressAuth: true
  });
  return result.items || [];
}

/**
 * Create a new compliance event
 */
export async function createComplianceEvent(eventData) {
  if (!eventData.carrier_dot || !eventData.event_type || !eventData.due_date) throw new Error('Missing fields');

  if (!eventData.status) {
    const diffDays = Math.ceil((new Date(eventData.due_date) - new Date()) / (1000 * 60 * 60 * 24));
    if (diffDays < 0) eventData.status = STATUS.OVERDUE;
    else if (diffDays <= 7) eventData.status = STATUS.DUE_SOON;
    else if (diffDays <= 30) eventData.status = STATUS.UPCOMING;
    else eventData.status = STATUS.PENDING;
  }

  Object.assign(eventData, { reminder_30_sent: false, reminder_14_sent: false, reminder_7_sent: false, reminder_due_sent: false });
  const result = await dataAccess.insertRecord(COLLECTION_KEYS.complianceEvents, eventData, { suppressAuth: true });
  if (!result.success) throw new Error(result.error);
  return result.record;
}

/**
 * Update a compliance event
 */
export async function updateComplianceEvent(eventId, updates) {
  delete updates._id; delete updates._owner;
  const existing = await dataAccess.getRecord(COLLECTION_KEYS.complianceEvents, eventId, { suppressAuth: true });
  if (!existing) throw new Error('Event not found');

  const toUpdate = { ...existing, ...updates, _id: eventId };
  if (updates.due_date && toUpdate.status !== STATUS.COMPLETED) {
    const diffDays = Math.ceil((new Date(updates.due_date) - new Date()) / (1000 * 60 * 60 * 24));
    if (diffDays < 0) toUpdate.status = STATUS.OVERDUE;
    else if (diffDays <= 7) toUpdate.status = STATUS.DUE_SOON;
    else if (diffDays <= 30) toUpdate.status = STATUS.UPCOMING;
    else toUpdate.status = STATUS.PENDING;
  }

  const result = await dataAccess.updateRecord(COLLECTION_KEYS.complianceEvents, toUpdate, { suppressAuth: true });
  if (!result.success) throw new Error(result.error);
  return result.record;
}

export async function completeComplianceEvent(eventId, documentId = null) {
  const existing = await dataAccess.getRecord(COLLECTION_KEYS.complianceEvents, eventId, { suppressAuth: true });
  if (!existing) throw new Error('Event not found');

  const updatedEvent = await updateComplianceEvent(eventId, { status: STATUS.COMPLETED, completed_date: new Date(), document_id: documentId });
  if (existing.recurrence && existing.auto_renew) await createNextRecurringEvent(existing);
  return updatedEvent;
}

export async function deleteComplianceEvent(eventId) {
  const result = await dataAccess.removeRecord(COLLECTION_KEYS.complianceEvents, eventId, { suppressAuth: true });
  return result.success;
}

// ============================================================
// CALENDAR VIEWS & DASHBOARD
// ============================================================

export async function getCalendarView(carrierDot, startDate, endDate) {
  const events = await getComplianceEvents(carrierDot, { dateRange: { start: startDate, end: endDate } });
  const overdueResult = await dataAccess.queryRecords(COLLECTION_KEYS.complianceEvents, {
    filters: { carrier_dot: carrierDot, status: STATUS.OVERDUE }, limit: 100, suppressAuth: true
  });
  
  const allEventsMap = new Map();
  (overdueResult.items || []).forEach(e => allEventsMap.set(e._id, e));
  events.forEach(e => allEventsMap.set(e._id, e));
  const allEvents = Array.from(allEventsMap.values());

  return {
    events: allEvents,
    summary: {
      overdue: allEvents.filter(e => e.status === STATUS.OVERDUE).length,
      dueSoon: allEvents.filter(e => e.status === STATUS.DUE_SOON).length,
      upcoming: allEvents.filter(e => e.status === STATUS.UPCOMING).length,
      total: allEvents.length
    }
  };
}

export async function getComplianceDashboard(carrierDot) {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.complianceEvents, {
    filters: { carrier_dot: carrierDot, status: { ne: STATUS.COMPLETED } }, suppressAuth: true
  });
  const activeEvents = result.items || [];
  
  const overdue = activeEvents.filter(e => e.status === STATUS.OVERDUE);
  const dueSoon = activeEvents.filter(e => e.status === STATUS.DUE_SOON);
  const upcoming = activeEvents.filter(e => [STATUS.UPCOMING, STATUS.PENDING].includes(e.status));

  let score = Math.max(0, 100 - (overdue.length * 10) - (dueSoon.length * 2));
  const alertsRes = await dataAccess.queryRecords(COLLECTION_KEYS.complianceAlerts, {
    filters: { carrier_dot: carrierDot, status: 'active' }, limit: 5, suppressAuth: true
  });

  return {
    score, stats: { overdue: overdue.length, dueSoon: dueSoon.length, upcoming: upcoming.length, totalActive: activeEvents.length },
    topPriorityItems: [...overdue, ...dueSoon].sort((a, b) => new Date(a.due_date) - new Date(b.due_date)).slice(0, 5),
    alerts: alertsRes.items || []
  };
}

// ============================================================
// INTERNAL HELPERS & REMINDERS
// ============================================================

async function createNextRecurringEvent(completedEvent) {
  const { recurrence } = completedEvent;
  if (!recurrence || !recurrence.interval_days) return;
  const nextDueDate = new Date(completedEvent.due_date);
  nextDueDate.setDate(nextDueDate.getDate() + recurrence.interval_days);

  await createComplianceEvent({
    carrier_dot: completedEvent.carrier_dot, driver_id: completedEvent.driver_id,
    event_type: completedEvent.event_type, event_category: completedEvent.event_category,
    title: completedEvent.title, due_date: nextDueDate, status: STATUS.PENDING,
    recurrence, auto_renew: true, assigned_to: completedEvent.assigned_to, priority: completedEvent.priority
  });
}

export async function processComplianceReminders() {
  const today = new Date(); today.setHours(0,0,0,0);
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.complianceEvents, {
    filters: { status: { ne: STATUS.COMPLETED } }, limit: 1000, suppressAuth: true
  });
  const activeEvents = result.items || [];

  let updatedCount = 0;
  for (const event of activeEvents) {
    const diffDays = Math.ceil((new Date(event.due_date) - today) / (1000 * 60 * 60 * 24));
    let newStatus = event.status;

    if (diffDays < 0) newStatus = STATUS.OVERDUE;
    else if (diffDays <= 7) newStatus = STATUS.DUE_SOON;
    else if (diffDays <= 30) newStatus = STATUS.UPCOMING;

    if (newStatus !== event.status) {
      await updateComplianceEvent(event._id, { status: newStatus });
      updatedCount++;
    }

    // Reminder Logic
    const reminderCheck = async (days, flag) => {
      if (diffDays === days && !event[flag]) {
        await createComplianceAlert(event, `${days}_day`);
        await updateComplianceEvent(event._id, { [flag]: true });
      }
    };
    if (diffDays === 30) await reminderCheck(30, 'reminder_30_sent');
    else if (diffDays === 14) await reminderCheck(14, 'reminder_14_sent');
    else if (diffDays === 7) await reminderCheck(7, 'reminder_7_sent');
    else if (diffDays === 0) await reminderCheck(0, 'reminder_due_sent');
  }
  return { processed: activeEvents.length, updated: updatedCount };
}

async function createComplianceAlert(event, reminderType) {
  const alert = {
    carrier_dot: event.carrier_dot, alert_type: 'overdue_event',
    severity: ['due_today', 'overdue'].includes(reminderType) ? 'critical' : 'warning',
    title: `Compliance Reminder: ${event.title}`, message: `Item due in ${reminderType.replace('_', ' ')}.`,
    related_entity_type: 'event', related_entity_id: event._id, status: 'active'
  };
  await dataAccess.insertRecord(COLLECTION_KEYS.complianceAlerts, alert, { suppressAuth: true });
  
  let recipientId = null, driverName = '', dashboardUrl = 'https://www.lastmiledr.app/carrier/compliance';
  if (event.driver_id) {
    const profile = await getProfileById(event.driver_id);
    recipientId = profile?.wix_member_id || profile?._owner;
    driverName = profile?.display_name || 'Driver';
    dashboardUrl = 'https://www.lastmiledr.app/driver-dashboard';
  } else if (event.assigned_to) recipientId = event.assigned_to;

  if (recipientId) {
    await sendComplianceNotification(recipientId, { type: reminderType, eventTitle: event.title, dueDate: new Date(event.due_date).toLocaleDateString(), driverName, dashboardUrl });
  }
}

export async function getDriverComplianceItems(driverId) {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.complianceEvents, {
    filters: { driver_id: driverId, status: { ne: STATUS.COMPLETED } },
    sort: [{ field: 'due_date', direction: 'asc' }], suppressAuth: true
  });
  return result.items || [];
}

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { sendMessageNotification } from 'backend/emailService';

// ============================================================================
// Data Source Configuration
// ============================================================================
import { usesAirtable, getWixCollectionName, getAirtableTableName } from 'backend/config';
import * as airtable from 'backend/airtableClient';

// Collection keys (camelCase, matching config.jsw)
const MESSAGES_KEY = 'messages';
const DRIVER_CARRIER_INTERESTS_KEY = 'driverCarrierInterests';
const RECRUITER_CARRIERS_KEY = 'recruiterCarriers';
const DRIVER_PROFILES_KEY = 'driverProfiles';

// Legacy collection names for wixData
const MESSAGES_COLLECTION = 'Messages';
const DRIVER_CARRIER_INTERESTS_COLLECTION = 'DriverCarrierInterests';
const RECRUITER_CARRIERS_COLLECTION = 'recruiterCarriers';
const DRIVER_PROFILES_COLLECTION = 'DriverProfiles';

// ============================================================================
// Data Abstraction Layer Helpers
// ============================================================================

/**
 * Query records from the appropriate data source
 * @param {string} collectionKey - camelCase collection key
 * @param {Function} wixQueryBuilder - Function that builds and executes wixData query
 * @param {Object} airtableOptions - Options for Airtable query
 * @returns {Promise<Object>} Query result with items array
 */
async function queryData(collectionKey, wixQueryBuilder, airtableOptions = {}) {
  if (usesAirtable(collectionKey)) {
    try {
      const tableName = getAirtableTableName(collectionKey);
      const result = await airtable.queryRecords(tableName, airtableOptions);
      return { items: result.records || [], totalCount: (result.records || []).length };
    } catch (error) {
      console.error(`[Messaging] Airtable query error for ${collectionKey}:`, error.message);
      throw error;
    }
  }
  // Use Wix
  return await wixQueryBuilder();
}

/**
 * Get a single record by ID
 * @param {string} collectionKey - camelCase collection key
 * @param {string} recordId - Record ID
 * @returns {Promise<Object|null>} Record or null
 */
async function getRecord(collectionKey, recordId) {
  if (usesAirtable(collectionKey)) {
    try {
      const tableName = getAirtableTableName(collectionKey);
      return await airtable.getRecord(tableName, recordId);
    } catch (error) {
      console.error(`[Messaging] Airtable get error for ${collectionKey}:`, error.message);
      return null;
    }
  }
  // Use Wix
  const wixCollection = getWixCollectionName(collectionKey);
  return await wixData.get(wixCollection, recordId, { suppressAuth: true });
}

/**
 * Insert a record into the appropriate data source
 * @param {string} collectionKey - camelCase collection key
 * @param {Object} record - Record to insert
 * @returns {Promise<Object>} Inserted record
 */
async function insertData(collectionKey, record) {
  if (usesAirtable(collectionKey)) {
    try {
      const tableName = getAirtableTableName(collectionKey);
      return await airtable.createRecord(tableName, record);
    } catch (error) {
      console.error(`[Messaging] Airtable insert error for ${collectionKey}:`, error.message);
      throw error;
    }
  }
  // Use Wix
  const wixCollection = getWixCollectionName(collectionKey);
  return await wixData.insert(wixCollection, record);
}

/**
 * Bulk update records
 * @param {string} collectionKey - camelCase collection key
 * @param {Array} records - Records to update
 * @returns {Promise<Object>} Update result
 */
async function bulkUpdateData(collectionKey, records) {
  if (usesAirtable(collectionKey)) {
    try {
      const tableName = getAirtableTableName(collectionKey);
      return await airtable.bulkUpdate(tableName, records);
    } catch (error) {
      console.error(`[Messaging] Airtable bulk update error for ${collectionKey}:`, error.message);
      throw error;
    }
  }
  // Use Wix
  const wixCollection = getWixCollectionName(collectionKey);
  return await wixData.bulkUpdate(wixCollection, records);
}

// ============================================================================
// SECURITY HELPERS
// ============================================================================

/**
 * Validates that the sender has permission to message in this application context.
 * - Drivers can only message on applications they created
 * - Recruiters can only message on applications for their assigned carriers
 */
async function validateSenderPermission(applicationId, senderId, senderType) {
    try {
        const application = await getRecord(DRIVER_CARRIER_INTERESTS_KEY, applicationId);
        if (!application) {
            console.warn('Warning: Application not found:', applicationId);
            return false;
        }

        if (senderType === 'driver') {
            // Driver must own this application
            const isOwner = application.driver_id === senderId;
            if (!isOwner) {
                console.warn('Warning: Driver permission denied - not application owner');
            }
            return isOwner;
        } else if (senderType === 'recruiter') {
            // Recruiter must have access to this carrier
            let recruiterAccessItems = [];

            if (usesAirtable(RECRUITER_CARRIERS_KEY)) {
                // Airtable query
                const filter = `AND({Recruiter ID} = '${senderId}', {Carrier DOT} = '${application.carrier_dot}', {Is Active} = TRUE())`;
                const result = await airtable.queryRecords(getAirtableTableName(RECRUITER_CARRIERS_KEY), {
                    filterByFormula: filter,
                    maxRecords: 1
                });
                recruiterAccessItems = result.records || [];
            } else {
                // Wix query
                const recruiterAccess = await wixData.query(RECRUITER_CARRIERS_COLLECTION)
                    .eq('recruiter_id', senderId)
                    .eq('carrier_dot', application.carrier_dot)
                    .eq('is_active', true)
                    .find({ suppressAuth: true });
                recruiterAccessItems = recruiterAccess.items;
            }

            const hasAccess = recruiterAccessItems.length > 0;
            if (!hasAccess) {
                console.warn('Warning: Recruiter permission denied - no carrier access');
            }
            return hasAccess;
        }

        return false;
    } catch (error) {
        console.error('Error validating sender permission:', error);
        return false;
    }
}

/**
 * Sanitizes message content to prevent XSS and enforce limits.
 */
function sanitizeContent(content) {
    if (!content || typeof content !== 'string') return '';

    return content
        .replace(/<[^>]*>/g, '')     // Strip HTML tags
        .replace(/&[^;]+;/g, '')     // Strip HTML entities
        .substring(0, 2000)          // Limit to 2000 chars
        .trim();
}

/**
 * Triggers an email notification for a new message.
 * Fetches context from application and sends non-blocking notification.
 */
async function triggerMessageNotification(receiverId, senderId, senderType, applicationId, messageContent) {
    try {
        // Get application details for context
        const application = await getRecord(DRIVER_CARRIER_INTERESTS_KEY, applicationId);
        if (!application) {
            console.warn('Warning: Cannot notify - application not found');
            return;
        }

        // Determine sender/receiver names based on sender type
        let senderName = 'Someone';
        let recipientName = 'User';
        let carrierName = application.carrier_name || '';
        let isDriver = false;

        if (senderType === 'driver') {
            // Driver sent message -> notify recruiter
            let driverProfileItems = [];

            if (usesAirtable(DRIVER_PROFILES_KEY)) {
                // Airtable query
                const filter = `{User ID} = '${senderId}'`;
                const result = await airtable.queryRecords(getAirtableTableName(DRIVER_PROFILES_KEY), {
                    filterByFormula: filter,
                    maxRecords: 1
                });
                driverProfileItems = result.records || [];
            } else {
                // Wix query
                const driverProfile = await wixData.query(DRIVER_PROFILES_COLLECTION)
                    .eq('user_id', senderId)
                    .limit(1)
                    .find({ suppressAuth: true });
                driverProfileItems = driverProfile.items;
            }

            if (driverProfileItems.length > 0) {
                senderName = driverProfileItems[0].first_name || 'A driver';
            }
            isDriver = false; // Receiver is recruiter
        } else {
            // Recruiter sent message -> notify driver
            senderName = carrierName || 'A recruiter';
            isDriver = true; // Receiver is driver

            // Get driver name for personalization
            let driverProfileItems = [];

            if (usesAirtable(DRIVER_PROFILES_KEY)) {
                // Airtable query
                const filter = `{User ID} = '${receiverId}'`;
                const result = await airtable.queryRecords(getAirtableTableName(DRIVER_PROFILES_KEY), {
                    filterByFormula: filter,
                    maxRecords: 1
                });
                driverProfileItems = result.records || [];
            } else {
                // Wix query
                const driverProfile = await wixData.query(DRIVER_PROFILES_COLLECTION)
                    .eq('user_id', receiverId)
                    .limit(1)
                    .find({ suppressAuth: true });
                driverProfileItems = driverProfile.items;
            }

            if (driverProfileItems.length > 0) {
                recipientName = driverProfileItems[0].first_name || 'Driver';
            }
        }

        // Send notification
        await sendMessageNotification(receiverId, {
            recipientName,
            senderName,
            messagePreview: messageContent,
            carrierName,
            isDriver
        });

        console.log(`Email notification sent to ${receiverId}`);
    } catch (error) {
        console.error('triggerMessageNotification error:', error);
        throw error; // Re-throw so caller's .catch() handles it
    }
}

// ============================================================================
// EXPORTED FUNCTIONS
// ============================================================================

/**
 * Sends a message from the current user (driver or recruiter).
 * @param {string} applicationId - The ID of the application/match event.
 * @param {string} content - The message text.
 * @param {string} receiverId - ID of the receiving user.
 * @param {string} senderType - 'driver' or 'recruiter'.
 */
export async function sendMessage(applicationId, content, receiverId, senderType) {
    if (!applicationId || !content || !receiverId || !senderType) {
        return { success: false, error: 'Missing required fields' };
    }

    try {
        const userId = await getCurrentUserId();
        if (!userId) {
            return { success: false, error: 'Not authenticated' };
        }

        // Validate sender has permission
        const hasPermission = await validateSenderPermission(applicationId, userId, senderType);
        if (!hasPermission) {
            return { success: false, error: 'Permission denied' };
        }

        // Sanitize content
        const sanitizedContent = sanitizeContent(content);
        if (!sanitizedContent) {
            return { success: false, error: 'Message content is empty' };
        }

        const newMessage = {
            application_id: applicationId,
            content: sanitizedContent,
            sender_id: userId,
            receiver_id: receiverId,
            sender_type: senderType,
            timestamp: new Date(),
            is_read: false
        };

        const result = await insertData(MESSAGES_KEY, newMessage);

        // Send email notification (non-blocking)
        triggerMessageNotification(receiverId, userId, senderType, applicationId, sanitizedContent)
            .catch(err => console.warn('Warning: Notification failed (non-critical):', err.message));

        return { success: true, message: result };
    } catch (error) {
        console.error('Error sending message:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Retrieves the conversation for a specific application.
 * @param {string} applicationId
 */
export async function getConversation(applicationId) {
    if (!applicationId) return { success: false, error: 'Missing applicationId' };

    try {
        let items = [];

        if (usesAirtable(MESSAGES_KEY)) {
            // Airtable query
            const filter = `{Application ID} = '${applicationId}'`;
            const result = await airtable.queryRecords(getAirtableTableName(MESSAGES_KEY), {
                filterByFormula: filter,
                sort: [{ field: 'Timestamp', direction: 'asc' }]
            });
            items = result.records || [];
        } else {
            // Wix query
            const results = await wixData.query(MESSAGES_COLLECTION)
                .eq('application_id', applicationId)
                .ascending('timestamp')
                .find();
            items = results.items;
        }

        return { success: true, messages: items };
    } catch (error) {
        console.error('Error fetching conversation:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Gets unread message count for the current user.
 */
export async function getUnreadCount() {
    try {
        const userId = await getCurrentUserId();
        if (!userId) return { success: false, error: 'Not authenticated' };

        let count = 0;

        if (usesAirtable(MESSAGES_KEY)) {
            // Airtable query - count matching records
            const filter = `AND({Receiver ID} = '${userId}', {Is Read} = FALSE())`;
            const result = await airtable.queryRecords(getAirtableTableName(MESSAGES_KEY), {
                filterByFormula: filter
            });
            count = (result.records || []).length;
        } else {
            // Wix query
            const results = await wixData.query(MESSAGES_COLLECTION)
                .eq('receiver_id', userId)
                .eq('is_read', false)
                .count();
            count = results;
        }

        return { success: true, count };
    } catch (error) {
        console.error('Error counting unread messages:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Marks all messages in a conversation as read for the receiver.
 * @param {string} applicationId
 */
export async function markAsRead(applicationId) {
    try {
        const userId = await getCurrentUserId();
        if (!userId) return { success: false, error: 'Not authenticated' };

        let unreadItems = [];

        if (usesAirtable(MESSAGES_KEY)) {
            // Airtable query
            const filter = `AND({Application ID} = '${applicationId}', {Receiver ID} = '${userId}', {Is Read} = FALSE())`;
            const result = await airtable.queryRecords(getAirtableTableName(MESSAGES_KEY), {
                filterByFormula: filter
            });
            unreadItems = result.records || [];
        } else {
            // Wix query
            const unreadResults = await wixData.query(MESSAGES_COLLECTION)
                .eq('application_id', applicationId)
                .eq('receiver_id', userId)
                .eq('is_read', false)
                .find();
            unreadItems = unreadResults.items;
        }

        if (unreadItems.length > 0) {
            const updates = unreadItems.map(msg => ({ ...msg, is_read: true }));
            await bulkUpdateData(MESSAGES_KEY, updates);
        }

        return { success: true };
    } catch (error) {
        console.error('Error marking messages as read:', error);
        return { success: false, error: error.message };
    }
}

// Helper to get current user ID
async function getCurrentUserId() {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) {
        return null;
    }
    return currentUser.id;
}

import wixUsersBackend from 'wix-users-backend';
import { sendMessageNotification } from 'backend/emailService';
import * as dataAccess from 'backend/dataAccess';

// Gamification Hooks (Lazy-loaded to avoid circular deps)
let gamificationLoaded = false;
let awardDriverXP = null;
let awardRecruiterPoints = null;
let updateChallengeProgress = null;
let checkResponseAchievements = null;

async function loadGamificationServices() {
    if (gamificationLoaded) return;
    try {
        const gamificationService = await import('backend/gamificationService');
        awardDriverXP = gamificationService.awardDriverXP;
        awardRecruiterPoints = gamificationService.awardRecruiterPoints;

        const challengeService = await import('backend/challengeService');
        updateChallengeProgress = challengeService.updateChallengeProgress;

        const achievementService = await import('backend/achievementService');
        checkResponseAchievements = achievementService.checkResponseAchievements;

        gamificationLoaded = true;
    } catch (err) {
        console.warn('Gamification services not available:', err.message);
    }
}

/**
 * Award XP/points for sending a message (non-blocking)
 */
async function awardMessageGamification(senderId, senderType, applicationId, isFirstResponse = false) {
    try {
        await loadGamificationServices();

        if (senderType === 'driver' && awardDriverXP) {
            await awardDriverXP(senderId, 'send_message', {
                sourceType: 'messaging',
                sourceId: applicationId
            });

            if (updateChallengeProgress) {
                await updateChallengeProgress(senderId, 'driver', 'send_message', { applicationId });
            }
        } else if (senderType === 'recruiter' && awardRecruiterPoints) {
            await awardRecruiterPoints(senderId, 'send_message', {
                sourceType: 'messaging',
                sourceId: applicationId
            });

            if (updateChallengeProgress) {
                await updateChallengeProgress(senderId, 'recruiter', 'send_message', { applicationId });
            }
        }
    } catch (err) {
        console.warn('Failed to award message gamification:', err.message);
    }
}

/**
 * Track response time for fast response bonus and achievements
 */
async function trackResponseTime(userId, userType, responseTimeMinutes, applicationId) {
    try {
        await loadGamificationServices();

        if (responseTimeMinutes < 60) {
            if (userType === 'driver' && awardDriverXP) {
                await awardDriverXP(userId, 'fast_response', {
                    sourceType: 'messaging',
                    sourceId: applicationId,
                    responseTimeMinutes
                });
            } else if (userType === 'recruiter' && awardRecruiterPoints) {
                await awardRecruiterPoints(userId, 'fast_response', {
                    sourceType: 'messaging',
                    sourceId: applicationId,
                    responseTimeMinutes
                });
            }
        }

        if (checkResponseAchievements) {
            await checkResponseAchievements(userId, userType, responseTimeMinutes);
        }
    } catch (err) {
        console.warn('Failed to track response time:', err.message);
    }
}

/**
 * Check if this message is a response and award fast response bonus
 */
async function checkAndAwardResponseBonus(senderId, senderType, applicationId, receiverId) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.messages, {
            filters: {
                application_id: applicationId,
                sender_id: receiverId
            },
            sort: [{ field: 'timestamp', direction: 'desc' }],
            limit: 1,
            suppressAuth: true
        });

        const lastMessageFromOther = result.items?.[0];
        if (!lastMessageFromOther) return;

        const lastMessageTime = new Date(lastMessageFromOther.timestamp);
        const now = new Date();
        const responseTimeMinutes = Math.round((now - lastMessageTime) / (1000 * 60));

        await trackResponseTime(senderId, senderType, responseTimeMinutes, applicationId);
    } catch (err) {
        console.warn('Failed to check response bonus:', err.message);
    }
}

// Collection keys
const COLLECTION_KEYS = {
    messages: 'messages',
    interests: 'driverCarrierInterests',
    recruiterCarriers: 'recruiterCarriers',
    driverProfiles: 'driverProfiles'
};

// ============================================================================
// SECURITY HELPERS
// ============================================================================

async function validateSenderPermission(applicationId, senderId, senderType) {
    try {
        // Try interests first (Standard job application)
        const application = await dataAccess.getRecord(COLLECTION_KEYS.interests, applicationId, { suppressAuth: true });
        
        if (application) {
            if (senderType === 'driver') {
                return application.driver_id === senderId;
            } else if (senderType === 'recruiter') {
                const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
                    filters: {
                        recruiter_id: senderId,
                        carrier_dot: application.carrier_dot,
                        is_active: true
                    },
                    limit: 1,
                    suppressAuth: true
                });
                return result.items && result.items.length > 0;
            }
        }

        // Try mentorship (Mentor-Mentee match)
        const mentorMatch = await dataAccess.getRecord('mentorMatches', applicationId, { suppressAuth: true });
        if (mentorMatch) {
            return mentorMatch.mentorId === senderId || mentorMatch.menteeId === senderId;
        }

        return false;
    } catch (error) {
        console.error('Error validating sender permission:', error);
        return false;
    }
}

function sanitizeContent(content) {
    if (!content || typeof content !== 'string') return '';
    return content.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, '').substring(0, 2000).trim();
}

async function triggerMessageNotification(receiverId, senderId, senderType, applicationId, messageContent) {
    try {
        // Try interests
        const application = await dataAccess.getRecord(COLLECTION_KEYS.interests, applicationId, { suppressAuth: true });
        
        if (application) {
            let senderName = 'Someone';
            let recipientName = 'User';
            let carrierName = application.carrier_name || '';
            let isDriver = false;

            if (senderType === 'driver') {
                const result = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, {
                    filters: { user_id: senderId },
                    limit: 1,
                    suppressAuth: true
                });
                if (result.items?.[0]) senderName = result.items[0].first_name || 'A driver';
                isDriver = false;
            } else {
                senderName = carrierName || 'A recruiter';
                isDriver = true;
                const result = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, {
                    filters: { user_id: receiverId },
                    limit: 1,
                    suppressAuth: true
                });
                if (result.items?.[0]) recipientName = result.items[0].first_name || 'Driver';
            }

            await sendMessageNotification(receiverId, { recipientName, senderName, messagePreview: messageContent, carrierName, isDriver });
            return;
        }

        // Try mentorship
        const mentorMatch = await dataAccess.getRecord('mentorMatches', applicationId, { suppressAuth: true });
        if (mentorMatch) {
            const senderRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, {
                filters: { user_id: senderId },
                limit: 1,
                suppressAuth: true
            });
            const senderName = senderRes.items?.[0]?.first_name || 'Your Mentor/Mentee';
            
            await sendMessageNotification(receiverId, { 
                recipientName: 'User', 
                senderName, 
                messagePreview: messageContent, 
                carrierName: 'LMDR Mentorship', 
                isDriver: true 
            });
        }
    } catch (error) {
        console.error('triggerMessageNotification error:', error);
    }
}

// ============================================================================
// EXPORTED FUNCTIONS
// ============================================================================

export async function sendMessage(applicationId, content, receiverId, senderType) {
    if (!applicationId || !content || !receiverId || !senderType) {
        return { success: false, error: 'Missing required fields' };
    }

    try {
        const userId = await getCurrentUserId();
        if (!userId) return { success: false, error: 'Not authenticated' };

        const hasPermission = await validateSenderPermission(applicationId, userId, senderType);
        if (!hasPermission) return { success: false, error: 'Permission denied' };

        const sanitizedContent = sanitizeContent(content);
        if (!sanitizedContent) return { success: false, error: 'Message content is empty' };

        const newMessage = {
            application_id: applicationId,
            content: sanitizedContent,
            sender_id: userId,
            receiver_id: receiverId,
            sender_type: senderType,
            timestamp: new Date(),
            is_read: false
        };

        const result = await dataAccess.insertRecord(COLLECTION_KEYS.messages, newMessage);
        if (!result.success) throw new Error(result.error);

        triggerMessageNotification(receiverId, userId, senderType, applicationId, sanitizedContent).catch(() => {});
        awardMessageGamification(userId, senderType, applicationId).catch(() => {});
        checkAndAwardResponseBonus(userId, senderType, applicationId, receiverId).catch(() => {});

        if (senderType === 'driver') {
            (async () => {
                try {
                    const automation = await import('backend/pipelineAutomationService');
                    const interest = await dataAccess.getRecord(COLLECTION_KEYS.interests, applicationId, { suppressAuth: true });
                    if (interest?.carrier_dot) {
                        await automation.processEvent(interest.carrier_dot, 'driver_message', { driverId: userId, interestId: applicationId });
                    }
                } catch (err) { /* ignore */ }
            })();
        }

        return { success: true, message: result.record };
    } catch (error) {
        console.error('Error sending message:', error);
        return { success: false, error: error.message };
    }
}

export async function getConversation(applicationId) {
    if (!applicationId) return { success: false, error: 'Missing applicationId' };
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.messages, {
            filters: { application_id: applicationId },
            sort: [{ field: 'timestamp', direction: 'asc' }],
            suppressAuth: true
        });
        return { success: true, messages: result.items || [] };
    } catch (error) {
        console.error('Error fetching conversation:', error);
        return { success: false, error: error.message };
    }
}

export async function getUnreadCount() {
    try {
        const userId = await getCurrentUserId();
        if (!userId) return { success: false, error: 'Not authenticated' };
        const count = await dataAccess.countRecords(COLLECTION_KEYS.messages, {
            receiver_id: userId,
            is_read: false
        });
        return { success: true, count };
    } catch (error) {
        console.error('Error counting unread messages:', error);
        return { success: false, error: error.message };
    }
}

export async function markAsRead(applicationId) {
    try {
        const userId = await getCurrentUserId();
        if (!userId) return { success: false, error: 'Not authenticated' };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.messages, {
            filters: {
                application_id: applicationId,
                receiver_id: userId,
                is_read: false
            },
            suppressAuth: true
        });

        const unreadItems = result.items || [];
        if (unreadItems.length > 0) {
            const updates = unreadItems.map(msg => ({ ...msg, is_read: true }));
            await dataAccess.bulkUpdateRecords(COLLECTION_KEYS.messages, updates, { suppressAuth: true });
        }
        return { success: true };
    } catch (error) {
        console.error('Error marking messages as read:', error);
        return { success: false, error: error.message };
    }
}

async function getCurrentUserId() {
    const currentUser = wixUsersBackend.currentUser;
    return currentUser.loggedIn ? currentUser.id : null;
}
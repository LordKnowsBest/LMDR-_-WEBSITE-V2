// ============================================================================
// SELF-HEALING SERVICE — Anomaly detection, triage, remediation, verification
// Detects issues, proposes fixes (approval-gated), executes, and updates
// the compendium with resolution knowledge.
// ============================================================================

import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  incidents: 'incidentLog',
  plans: 'remediationPlans'
};

function generateId(prefix) {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// ============================================================================
// REMEDIATION STRATEGY MAP
// Maps anomaly types to concrete action sequences
// ============================================================================

const REMEDIATION_STRATEGIES = {
  high_error_rate: {
    actions: [
      { type: 'clear_cache', target: 'observability', description: 'Clear error tracking caches' },
      { type: 'retry_jobs', target: 'scheduler', description: 'Re-trigger recently failed jobs' }
    ],
    estimated_impact: 'Reduces error backlog, restores normal processing',
    risk_assessment: 'low'
  },
  slow_response: {
    actions: [
      { type: 'clear_cache', target: 'observability', description: 'Reset metric caches to clear stale data' },
      { type: 'flag_optimization', target: 'queries', description: 'Flag slow queries for optimization review' }
    ],
    estimated_impact: 'Improves response latency by clearing bottlenecks',
    risk_assessment: 'low'
  },
  api_failure: {
    actions: [
      { type: 'switch_provider', target: 'ai_router', description: 'Failover to backup AI provider' },
      { type: 'enable_circuit_breaker', target: 'api', description: 'Enable circuit breaker for failing endpoint' }
    ],
    estimated_impact: 'Restores API availability via failover',
    risk_assessment: 'medium'
  },
  data_inconsistency: {
    actions: [
      { type: 'validation_scan', target: 'data', description: 'Run data validation scan across affected collections' },
      { type: 'reconciliation', target: 'data', description: 'Trigger reconciliation job for mismatched records' }
    ],
    estimated_impact: 'Identifies and flags inconsistent records for correction',
    risk_assessment: 'low'
  },
  cost_spike: {
    actions: [
      { type: 'throttle_requests', target: 'ai_router', description: 'Reduce AI call rate to control costs' },
      { type: 'switch_provider', target: 'ai_router', description: 'Switch to lower-cost AI model' }
    ],
    estimated_impact: 'Reduces AI spend by throttling and model switching',
    risk_assessment: 'medium'
  }
};

// Anomaly type mapping: observability rule types -> remediation categories
const ANOMALY_TYPE_MAP = {
  error_spike: 'high_error_rate',
  latency_drift: 'slow_response',
  traffic_drop: 'api_failure',
  cost_spike: 'cost_spike',
  job_failure: 'high_error_rate'
};

// ============================================================================
// 1. DETECT AND TRIAGE
// ============================================================================

/**
 * Run anomaly detection and triage each anomaly against known patterns.
 * Creates incident records for each detected anomaly.
 * @returns {Promise<Object>} { incidents, critical_count, warning_count }
 */
export async function detectAndTriage() {
  try {
    // Run anomaly detection
    const { runAnomalyDetection } = await import('backend/observabilityService');
    await runAnomalyDetection();

    // Fetch active (unacknowledged) anomaly alerts
    const alertsResult = await dataAccess.queryRecords('anomalyAlerts', {
      filters: { acknowledged: false },
      limit: 100,
      suppressAuth: true
    });
    const alerts = (alertsResult && alertsResult.items) || [];

    if (alerts.length === 0) {
      return { incidents: [], critical_count: 0, warning_count: 0 };
    }

    // Query compendium for admin playbooks
    const { getCompendiumIndex } = await import('backend/compendiumService');
    const compendium = await getCompendiumIndex('admin');
    const playbooks = (compendium && compendium.entries) || [];

    const incidents = [];
    let critical_count = 0;
    let warning_count = 0;

    for (const alert of alerts) {
      const anomalyType = alert.type || 'unknown';
      const severity = alert.severity || 'warning';

      // Match against compendium playbooks
      const matchedPlaybook = playbooks.find(p =>
        p.topic && p.topic.toLowerCase().includes(anomalyType.replace('_', ' '))
      ) || null;

      // Map anomaly type to remediation category
      const remediationCategory = ANOMALY_TYPE_MAP[anomalyType] || 'high_error_rate';
      const confidence = matchedPlaybook ? Math.min(95, (matchedPlaybook.confidence || 50) + 20) : 40;

      const incidentId = generateId('inc');
      const incidentRecord = {
        incident_id: incidentId,
        anomaly_id: alert._id || alert.id || '',
        anomaly_type: anomalyType,
        severity,
        probable_cause: remediationCategory,
        matched_playbook: matchedPlaybook ? matchedPlaybook.topic : '',
        confidence,
        metric_name: alert.metric || '',
        expected_value: alert.expectedValue || 0,
        actual_value: alert.actualValue || 0,
        deviation: alert.deviation || 0,
        status: 'triaged',
        created_at: new Date().toISOString(),
        resolved_at: ''
      };

      await dataAccess.insertRecord(COLLECTIONS.incidents, incidentRecord, {
        suppressAuth: true
      });

      incidents.push({
        incidentId,
        anomalyId: alert._id || alert.id || '',
        severity,
        probable_cause: remediationCategory,
        matched_playbook: matchedPlaybook ? matchedPlaybook.topic : null,
        confidence
      });

      if (severity === 'critical') critical_count++;
      else if (severity === 'warning') warning_count++;
    }

    return { incidents, critical_count, warning_count };
  } catch (error) {
    console.error('selfHealingService.detectAndTriage error:', error);
    return { incidents: [], critical_count: 0, warning_count: 0, error: error.message };
  }
}

// ============================================================================
// 2. PROPOSE REMEDIATION
// ============================================================================

/**
 * Generate a remediation proposal for an incident. Creates an approval gate.
 * @param {string} incidentId - Incident ID to remediate
 * @returns {Promise<Object>} { planId, gateId, actions, estimated_impact, risk_assessment }
 */
export async function proposeRemediation(incidentId) {
  try {
    if (!incidentId) {
      return { error: 'incidentId is required' };
    }

    // Load incident
    const incidentResult = await dataAccess.queryRecords(COLLECTIONS.incidents, {
      filters: { incident_id: incidentId },
      limit: 1,
      suppressAuth: true
    });
    const incident = (incidentResult && incidentResult.items && incidentResult.items[0]) || null;
    if (!incident) {
      return { error: 'Incident not found' };
    }

    // Look up strategy
    const cause = incident.probable_cause || 'high_error_rate';
    const strategy = REMEDIATION_STRATEGIES[cause] || REMEDIATION_STRATEGIES.high_error_rate;

    const planId = generateId('plan');
    const planRecord = {
      plan_id: planId,
      incident_id: incidentId,
      anomaly_type: incident.anomaly_type || '',
      probable_cause: cause,
      actions: JSON.stringify(strategy.actions),
      estimated_impact: strategy.estimated_impact,
      risk_assessment: strategy.risk_assessment,
      status: 'proposed',
      created_at: new Date().toISOString(),
      executed_at: '',
      verified_at: '',
      approved_by: '',
      gate_id: ''
    };

    await dataAccess.insertRecord(COLLECTIONS.plans, planRecord, {
      suppressAuth: true
    });

    // Create approval gate
    const { createGate } = await import('backend/agentRunLedgerService');
    const gateResult = await createGate(
      '',
      '',
      'execute_fix',
      `Remediation plan ${planId} for incident ${incidentId} (${cause}) — risk: ${strategy.risk_assessment}`,
      strategy.risk_assessment === 'medium' ? 'execute_high' : 'execute_low'
    );
    const gateId = (gateResult && gateResult.gateId) || '';

    // Update plan with gate ID
    const planRecordId = await _findRecordId(COLLECTIONS.plans, 'plan_id', planId);
    if (planRecordId) {
      await dataAccess.updateRecord(COLLECTIONS.plans, planRecordId, {
        gate_id: gateId
      }, { suppressAuth: true });
    }

    // Update incident status
    const incidentRecordId = incident._id || incident.id;
    if (incidentRecordId) {
      await dataAccess.updateRecord(COLLECTIONS.incidents, incidentRecordId, {
        status: 'plan_proposed'
      }, { suppressAuth: true });
    }

    return {
      planId,
      gateId,
      actions: strategy.actions,
      estimated_impact: strategy.estimated_impact,
      risk_assessment: strategy.risk_assessment
    };
  } catch (error) {
    console.error('selfHealingService.proposeRemediation error:', error);
    return { error: error.message };
  }
}

// ============================================================================
// 3. EXECUTE REMEDIATION
// ============================================================================

/**
 * Execute an approved remediation plan. Runs actions in sequence.
 * @param {string} planId - Plan ID to execute
 * @param {string} approvedBy - Admin who approved
 * @returns {Promise<Object>} { planId, actions_completed, actions_failed, status }
 */
export async function executeRemediation(planId, approvedBy) {
  try {
    if (!planId) {
      return { error: 'planId is required' };
    }

    // Load plan
    const planResult = await dataAccess.queryRecords(COLLECTIONS.plans, {
      filters: { plan_id: planId },
      limit: 1,
      suppressAuth: true
    });
    const plan = (planResult && planResult.items && planResult.items[0]) || null;
    if (!plan) {
      return { error: 'Plan not found' };
    }

    if (plan.status !== 'proposed' && plan.status !== 'approved') {
      return { error: `Plan status is '${plan.status}', expected 'proposed' or 'approved'` };
    }

    let actions = [];
    try {
      actions = JSON.parse(plan.actions || '[]');
    } catch (e) {
      actions = [];
    }

    const { logStep } = await import('backend/agentRunLedgerService');
    let actions_completed = 0;
    let actions_failed = 0;
    const executionLog = [];

    for (const action of actions) {
      const startTime = Date.now();
      try {
        await _executeAction(action);
        const latency = Date.now() - startTime;
        await logStep('', action.type, 'execute_high', { target: action.target }, { success: true }, latency, 'executed');
        actions_completed++;
        executionLog.push({ action: action.type, status: 'success', latency_ms: latency });
      } catch (actionError) {
        const latency = Date.now() - startTime;
        await logStep('', action.type, 'execute_high', { target: action.target }, { error: actionError.message }, latency, 'failed');
        actions_failed++;
        executionLog.push({ action: action.type, status: 'failed', error: actionError.message, latency_ms: latency });
      }
    }

    // Update plan status
    const planRecordId = plan._id || plan.id;
    const finalStatus = actions_failed === 0 ? 'executed' : 'partial_failure';
    if (planRecordId) {
      await dataAccess.updateRecord(COLLECTIONS.plans, planRecordId, {
        status: finalStatus,
        approved_by: approvedBy || '',
        executed_at: new Date().toISOString()
      }, { suppressAuth: true });
    }

    // Update incident status
    if (plan.incident_id) {
      const incRecordId = await _findRecordId(COLLECTIONS.incidents, 'incident_id', plan.incident_id);
      if (incRecordId) {
        await dataAccess.updateRecord(COLLECTIONS.incidents, incRecordId, {
          status: finalStatus === 'executed' ? 'remediated' : 'remediation_partial'
        }, { suppressAuth: true });
      }
    }

    return {
      planId,
      actions_completed,
      actions_failed,
      status: finalStatus,
      execution_log: executionLog
    };
  } catch (error) {
    console.error('selfHealingService.executeRemediation error:', error);
    return { error: error.message };
  }
}

// ============================================================================
// 4. VERIFY REMEDIATION
// ============================================================================

/**
 * Check if a remediation resolved the issue. Updates compendium if verified.
 * @param {string} planId - Plan ID to verify
 * @returns {Promise<Object>} { planId, verified, metric_before, metric_after, compendium_updated }
 */
export async function verifyRemediation(planId) {
  try {
    if (!planId) {
      return { error: 'planId is required' };
    }

    // Load plan
    const planResult = await dataAccess.queryRecords(COLLECTIONS.plans, {
      filters: { plan_id: planId },
      limit: 1,
      suppressAuth: true
    });
    const plan = (planResult && planResult.items && planResult.items[0]) || null;
    if (!plan) {
      return { error: 'Plan not found' };
    }

    // Load associated incident for baseline metrics
    let incident = null;
    if (plan.incident_id) {
      const incResult = await dataAccess.queryRecords(COLLECTIONS.incidents, {
        filters: { incident_id: plan.incident_id },
        limit: 1,
        suppressAuth: true
      });
      incident = (incResult && incResult.items && incResult.items[0]) || null;
    }

    const metric_before = incident ? (incident.actual_value || 0) : 0;
    const expected = incident ? (incident.expected_value || 0) : 0;

    // Re-run anomaly detection to check current state
    const { runAnomalyDetection } = await import('backend/observabilityService');
    await runAnomalyDetection();

    // Check if the same anomaly type is still firing
    const recentAlerts = await dataAccess.queryRecords('anomalyAlerts', {
      filters: {
        type: incident ? incident.anomaly_type : '',
        acknowledged: false
      },
      limit: 5,
      suppressAuth: true
    });
    const stillFiring = ((recentAlerts && recentAlerts.items) || []).length;

    // Determine verification result
    const verified = stillFiring === 0;
    const metric_after = stillFiring;

    const planRecordId = plan._id || plan.id;
    let compendium_updated = false;

    if (verified) {
      // Mark plan as verified
      if (planRecordId) {
        await dataAccess.updateRecord(COLLECTIONS.plans, planRecordId, {
          status: 'verified',
          verified_at: new Date().toISOString()
        }, { suppressAuth: true });
      }

      // Update incident to resolved
      if (plan.incident_id) {
        const incRecordId = await _findRecordId(COLLECTIONS.incidents, 'incident_id', plan.incident_id);
        if (incRecordId) {
          await dataAccess.updateRecord(COLLECTIONS.incidents, incRecordId, {
            status: 'resolved',
            resolved_at: new Date().toISOString()
          }, { suppressAuth: true });
        }
      }

      // Update compendium with resolution knowledge
      try {
        const { createCompendiumEntry, updateCompendiumEntry } = await import('backend/compendiumService');
        const cause = plan.probable_cause || 'unknown';
        const topic = `self_healing_${cause}`;
        let actions = [];
        try { actions = JSON.parse(plan.actions || '[]'); } catch (e) { actions = []; }
        const summary = `Auto-resolved ${cause} via: ${actions.map(a => a.type).join(', ')}. Metric went from ${metric_before} to ${metric_after} (expected: ${expected}).`;

        const updated = await updateCompendiumEntry('admin', topic, {
          content_summary: summary,
          confidence: 85,
          evidence: `plan:${planId}, incident:${plan.incident_id}`
        });

        if (!updated || !updated.updated) {
          await createCompendiumEntry('admin', {
            topic,
            type: 'playbook',
            content_summary: summary,
            confidence: 85,
            evidence: `plan:${planId}, incident:${plan.incident_id}`,
            file_path: 'backend/selfHealingService.jsw'
          });
        }
        compendium_updated = true;
      } catch (compError) {
        console.error('selfHealingService.verifyRemediation compendium update error:', compError);
      }
    } else {
      // Mark plan as failed verification
      if (planRecordId) {
        await dataAccess.updateRecord(COLLECTIONS.plans, planRecordId, {
          status: 'verification_failed',
          verified_at: new Date().toISOString()
        }, { suppressAuth: true });
      }

      // Escalate: mark incident as needs_human_review
      if (plan.incident_id) {
        const incRecordId = await _findRecordId(COLLECTIONS.incidents, 'incident_id', plan.incident_id);
        if (incRecordId) {
          await dataAccess.updateRecord(COLLECTIONS.incidents, incRecordId, {
            status: 'needs_human_review',
            severity: 'critical'
          }, { suppressAuth: true });
        }
      }
    }

    return {
      planId,
      verified,
      metric_before,
      metric_after,
      compendium_updated
    };
  } catch (error) {
    console.error('selfHealingService.verifyRemediation error:', error);
    return { error: error.message };
  }
}

// ============================================================================
// 5. GET INCIDENT TIMELINE
// ============================================================================

/**
 * Get the full lifecycle view for an incident.
 * @param {string} incidentId - Incident ID
 * @returns {Promise<Object>} { incident, triage, remediation_plan, execution_log, verification, compendium_entry }
 */
export async function getIncidentTimeline(incidentId) {
  try {
    if (!incidentId) {
      return { error: 'incidentId is required' };
    }

    // Load incident
    const incResult = await dataAccess.queryRecords(COLLECTIONS.incidents, {
      filters: { incident_id: incidentId },
      limit: 1,
      suppressAuth: true
    });
    const incident = (incResult && incResult.items && incResult.items[0]) || null;
    if (!incident) {
      return { error: 'Incident not found' };
    }

    // Load remediation plan (if any)
    const planResult = await dataAccess.queryRecords(COLLECTIONS.plans, {
      filters: { incident_id: incidentId },
      limit: 1,
      suppressAuth: true
    });
    const plan = (planResult && planResult.items && planResult.items[0]) || null;

    // Parse plan actions for execution log
    let actions = [];
    if (plan) {
      try { actions = JSON.parse(plan.actions || '[]'); } catch (e) { actions = []; }
    }

    // Look up compendium entry
    let compendium_entry = null;
    if (incident.probable_cause) {
      try {
        const { getCompendiumEntry } = await import('backend/compendiumService');
        compendium_entry = await getCompendiumEntry('admin', `self_healing_${incident.probable_cause}`);
      } catch (e) {
        // Compendium entry may not exist yet
      }
    }

    return {
      incident: {
        incident_id: incident.incident_id,
        anomaly_type: incident.anomaly_type,
        severity: incident.severity,
        status: incident.status,
        created_at: incident.created_at,
        resolved_at: incident.resolved_at || null
      },
      triage: {
        probable_cause: incident.probable_cause,
        matched_playbook: incident.matched_playbook || null,
        confidence: incident.confidence,
        metric_name: incident.metric_name,
        expected_value: incident.expected_value,
        actual_value: incident.actual_value,
        deviation: incident.deviation
      },
      remediation_plan: plan ? {
        plan_id: plan.plan_id,
        status: plan.status,
        risk_assessment: plan.risk_assessment,
        estimated_impact: plan.estimated_impact,
        actions,
        approved_by: plan.approved_by || null,
        gate_id: plan.gate_id || null,
        created_at: plan.created_at
      } : null,
      execution_log: plan ? {
        executed_at: plan.executed_at || null,
        verified_at: plan.verified_at || null
      } : null,
      verification: plan ? {
        status: plan.status,
        verified_at: plan.verified_at || null
      } : null,
      compendium_entry
    };
  } catch (error) {
    console.error('selfHealingService.getIncidentTimeline error:', error);
    return { error: error.message };
  }
}

// ============================================================================
// 6. GET ACTIVE INCIDENTS
// ============================================================================

/**
 * Get all unresolved incidents grouped by severity.
 * @returns {Promise<Object>} { incidents, by_severity: { critical, warning, info } }
 */
export async function getActiveIncidents() {
  try {
    const result = await dataAccess.queryRecords(COLLECTIONS.incidents, {
      limit: 200,
      suppressAuth: true
    });
    const allItems = (result && result.items) || [];

    // Filter out resolved and false_positive
    const active = allItems.filter(i =>
      i.status !== 'resolved' && i.status !== 'false_positive'
    );

    const by_severity = { critical: 0, warning: 0, info: 0 };
    const incidents = active.map(i => {
      const sev = i.severity || 'info';
      if (by_severity[sev] !== undefined) by_severity[sev]++;
      return {
        incident_id: i.incident_id,
        anomaly_type: i.anomaly_type,
        severity: sev,
        probable_cause: i.probable_cause,
        status: i.status,
        confidence: i.confidence,
        created_at: i.created_at
      };
    });

    return { incidents, by_severity };
  } catch (error) {
    console.error('selfHealingService.getActiveIncidents error:', error);
    return { incidents: [], by_severity: { critical: 0, warning: 0, info: 0 }, error: error.message };
  }
}

// ============================================================================
// INTERNAL HELPERS
// ============================================================================

/**
 * Find a record's internal ID by querying a field value
 */
async function _findRecordId(collection, field, value) {
  const result = await dataAccess.queryRecords(collection, {
    filters: { [field]: value },
    limit: 1,
    suppressAuth: true
  });
  const item = (result && result.items && result.items[0]) || null;
  return item ? (item._id || item.id || null) : null;
}

/**
 * Execute a single remediation action by dispatching to existing services
 */
async function _executeAction(action) {
  const actionType = action.type || '';

  switch (actionType) {
    case 'clear_cache': {
      // Trigger a health metrics refresh to clear stale caches
      const { getHealthMetrics } = await import('backend/observabilityService');
      await getHealthMetrics('hour');
      break;
    }
    case 'retry_jobs': {
      // Re-trigger failed scheduled jobs by invoking the job runner
      const { triggerJob } = await import('backend/admin_jobs_service');
      const jobName = action.params?.jobName || 'runEnrichmentBatch';
      await triggerJob(jobName);
      break;
    }
    case 'switch_provider': {
      // Failover to backup provider via AI Router config update
      const { updateCostOptimizerConfig } = await import('backend/aiRouterService');
      const provider = action.params?.targetProvider || 'openai';
      await updateCostOptimizerConfig({
        preferredFallback: provider,
        lastFailoverAt: new Date().toISOString(),
        failoverReason: action.reason || 'self-healing triggered'
      });
      break;
    }
    case 'throttle_requests': {
      // Record throttle event in observability for rate-limit enforcement
      const { recordMetric } = await import('backend/observabilityService');
      await recordMetric('throttle_activated', {
        endpoint: action.params?.endpoint || 'unknown',
        reducedRate: action.params?.reducedRate || 50,
        activatedAt: new Date().toISOString()
      });
      break;
    }
    case 'enable_circuit_breaker': {
      // Record circuit breaker state in observability
      const obs = await import('backend/observabilityService');
      await obs.recordMetric('circuit_breaker_open', {
        service: action.params?.service || 'unknown',
        openedAt: new Date().toISOString(),
        ttlMs: action.params?.ttlMs || 60000
      });
      break;
    }
    case 'flag_optimization': {
      // Create an anomaly alert for slow query review
      const { createAnomalyRule } = await import('backend/observabilityService');
      await createAnomalyRule({
        name: `Slow query flag: ${action.params?.queryName || 'unknown'}`,
        metric: 'query_latency',
        threshold: action.params?.thresholdMs || 5000,
        severity: 'warning',
        enabled: true
      });
      break;
    }
    case 'validation_scan': {
      // Run data validation via health metrics refresh on affected collections
      const obsService = await import('backend/observabilityService');
      await obsService.getHealthMetrics('day');
      break;
    }
    case 'reconciliation': {
      // Trigger backfill migration to reconcile data inconsistencies
      const { triggerJob: triggerReconcileJob } = await import('backend/admin_jobs_service');
      await triggerReconcileJob('runBackfillMigration');
      break;
    }
    default: {
      console.warn(`selfHealingService: Unknown action type '${actionType}'`);
    }
  }
}

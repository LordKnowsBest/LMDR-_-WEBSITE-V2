import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { mediaManager } from 'wix-media-backend';
import { extractInfoFromDocument } from 'backend/ocrService.jsw';

// Dual-source data access
import { usesAirtable, getWixCollectionName } from 'backend/config';
import * as dataAccess from 'backend/dataAccess';
import * as airtable from 'backend/airtableClient';

// Gamification hooks
import { checkProfileAchievements } from 'backend/achievementService';

// Lazy-loaded gamification services to avoid circular dependencies
async function getGamificationService() {
  return await import('backend/gamificationService');
}

// Non-blocking XP award helper
async function awardXPNonBlocking(driverId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardDriverXP(driverId, action, metadata);
  } catch (err) {
    console.warn(`XP award failed for ${action}:`, err.message);
  }
}

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  profilesCollection: 'DriverProfiles',
  interestsCollection: 'DriverCarrierInterests',
  mediaFolder: '/driver-documents',
  
  // Profile Status Values
  STATUS: {
    ACTIVE: 'active',
    INCOMPLETE: 'incomplete',
    DORMANT: 'dormant'
  },
  
  // Completeness scoring weights (Spec: Base 20%, Exp 30%, Docs 30%, Prefs 20%)
  COMPLETENESS_WEIGHTS: {
    // Base Info (20%)
    display_name: 10,
    email: 5,
    phone: 5,
    
    // Experience (30%)
    years_experience: 10,
    cdl_class: 10,
    endorsements: 4,
    clean_mvr: 2,
    accidents_last_3_years: 2,
    violations_last_3_years: 2,

    // Documents (30%)
    cdl_images: 20,
    med_card_image: 10,

    // Preferences (20%)
    home_zip: 5,
    preferred_operation_type: 5,
    min_cpm: 5,
    fleet_size_preference: 5
  }
};

// ============================================================================
// DOCUMENT UPLOAD HELPERS (Phase 4H)
// ============================================================================

/**
 * Upload base64 encoded file to Wix Media Manager
 * 
 * @param {Object} fileObj { data: base64, name: string, type: string }
 * @param {string} userId
 * @returns {Promise<string>} File URL
 */
async function uploadToMediaManager(fileObj, userId) {
    if (!fileObj || !fileObj.data) return null;

    try {
        // Strip base64 prefix if present
        const base64Content = fileObj.data.split(';base64,').pop();
        const buffer = Buffer.from(base64Content, 'base64');

        // Define path in media manager: /driver-documents/{userId}/{filename}
        const fileName = `${Date.now()}_${fileObj.name.replace(/\s+/g, '_')}`;
        const filePath = `${CONFIG.mediaFolder}/${userId}`;

        // Determine mediaType based on file mime type
        // Wix requires 'image' for images, 'document' for PDFs/docs
        const mimeType = fileObj.type || 'application/octet-stream';
        let mediaType = 'document';
        if (mimeType.startsWith('image/')) {
            mediaType = 'image';
        } else if (mimeType.startsWith('video/')) {
            mediaType = 'video';
        } else if (mimeType.startsWith('audio/')) {
            mediaType = 'audio';
        }

        console.log(`üì§ Uploading ${fileName} as ${mediaType} (${mimeType})`);

        const uploadResult = await mediaManager.upload(
            filePath,
            buffer,
            fileName,
            {
                mediaOptions: {
                    mimeType: mimeType,
                    mediaType: mediaType
                },
                metadataOptions: {
                    isPrivate: false,
                    isVisitorUpload: false
                }
            }
        );

        console.log(`‚úÖ Uploaded: ${uploadResult.fileUrl}`);
        return uploadResult.fileUrl;
    } catch (error) {
        console.error('‚ùå Media upload error:', error);
        throw new Error('Failed to upload document to Media Manager');
    }
}

// ============================================================================
// PROFILE RETRIEVAL
// ============================================================================

/**
 * Get or create a driver profile for the current logged-in user
 * This is the main entry point for driver identity
 * 
 * @returns {Promise<Object>} Driver profile with computed fields
 */
export async function getOrCreateDriverProfile() {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { 
        success: false, 
        error: 'User not logged in',
        profile: null 
      };
    }
    
    const userId = currentUser.id;
    console.log(`üë§ Getting profile for user: ${userId}`);
    
    // Check for existing profile
    const existingProfile = await getProfileByUserId(userId);
    
    if (existingProfile) {
      console.log(`‚úÖ Found existing profile for user ${userId}`);
      return {
        success: true,
        profile: enrichProfile(existingProfile),
        isNew: false
      };
    }
    
    // Create new profile for first-time user
    console.log(`üìù Creating new profile for user ${userId}`);
    const newProfile = await createNewProfile(userId, currentUser);
    
    return {
      success: true,
      profile: enrichProfile(newProfile),
      isNew: true
    };
    
  } catch (error) {
    console.error('‚ùå Error in getOrCreateDriverProfile:', error);
    return {
      success: false,
      error: error.message,
      profile: null
    };
  }
}

/**
 * Get profile by Wix user ID
 * Supports dual data sources via config.jsw
 */
async function getProfileByUserId(userId) {
  try {
    const result = await dataAccess.queryRecords('driverProfiles', {
      filters: { _owner: userId },
      limit: 1,
      suppressAuth: true
    });

    return result.success && result.items.length > 0 ? result.items[0] : null;
  } catch (error) {
    console.error('Profile lookup error:', error);
    return null;
  }
}

/**
 * Get profile by profile ID (for admin/internal use)
 * Supports dual data sources via config.jsw
 */
export async function getProfileById(profileId) {
  try {
    const result = await dataAccess.getRecord('driverProfiles', profileId, { suppressAuth: true });
    return result ? enrichProfile(result) : null;
  } catch (error) {
    console.error('Profile get error:', error);
    return null;
  }
}

// ============================================================================
// PROFILE CREATION
// ============================================================================

/**
 * Create a new driver profile for a user
 */
async function createNewProfile(userId, userObject) {
  let userEmail = '';
  
  try {
    userEmail = await userObject.getEmail();
  } catch (e) {
    console.log('Could not retrieve user email');
  }
  
  const now = new Date();
  
  const profileData = {
    // Identity - linked to Wix user via _owner system field
    display_name: '',
    email: userEmail,
    phone: '',
    
    // Preferences - empty until first search
    home_zip: '',
    max_commute_miles: 50,
    min_cpm: 0.50,
    preferred_operation_type: 'no_preference',
    max_turnover_percent: 90,
    max_truck_age_years: 5,
    fleet_size_preference: 'no_preference',
    
    // Qualifications - for future reverse matching
    years_experience: null,
    cdl_class: '',
    endorsements: [],
    clean_mvr: null,
    accidents_last_3_years: null,
    violations_last_3_years: null,
    
    // Persistent Documents (Phase 4C) - Image fields
    cdl_front_image: null,
    cdl_back_image: null,
    med_card_image: null,
    resume_file: null,
    
    // Engagement tracking
    last_search_date: null,
    total_searches: 0,
    profile_completeness_score: 0,
    
    // Status
    profile_status: CONFIG.STATUS.INCOMPLETE,
    is_discoverable: false, // Opt-in privacy model
    
    // Timestamps
    created_date: now,
    updated_date: now
  };
  
  // Use dual-source data access for insert
  const insertResult = await dataAccess.insertRecord('driverProfiles', profileData, { suppressAuth: true });

  if (!insertResult.success) {
    throw new Error(insertResult.error || 'Failed to create profile');
  }

  const inserted = insertResult.record;
  console.log(`‚úÖ Created new profile with ID: ${inserted._id}`);
  return inserted;
}

// ============================================================================
// PROFILE UPDATES
// ============================================================================

/**
 * Update driver preferences (from search form)
 * Called every time a driver searches
 */
export async function updateDriverPreferences(preferences) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found' };
    }
    
    const now = new Date();
    
    // Update preferences
    const updatedData = {
      ...profile,
      home_zip: preferences.homeZip || profile.home_zip,
      max_commute_miles: preferences.maxDistance || profile.max_commute_miles,
      min_cpm: preferences.minCPM || profile.min_cpm,
      preferred_operation_type: preferences.operationType || profile.preferred_operation_type,
      max_turnover_percent: preferences.maxTurnover || profile.max_turnover_percent,
      max_truck_age_years: preferences.maxTruckAge || profile.max_truck_age_years,
      fleet_size_preference: preferences.fleetSize || profile.fleet_size_preference,
      
      // Update display name if provided
      display_name: preferences.driverName || profile.display_name,
      
      // Engagement metrics
      last_search_date: now,
      total_searches: (profile.total_searches || 0) + 1,
      updated_date: now
    };
    
    // Recalculate completeness
    updatedData.profile_completeness_score = calculateCompleteness(updatedData);
    
    // Update status based on completeness
    if (updatedData.profile_completeness_score >= 80) {
      updatedData.profile_status = CONFIG.STATUS.ACTIVE;
    } else if (updatedData.profile_completeness_score >= 30) {
      updatedData.profile_status = CONFIG.STATUS.INCOMPLETE;
    }
    
    // Use dual-source data access for update
    const updateResult = await dataAccess.updateRecord('driverProfiles', updatedData, { suppressAuth: true });

    if (!updateResult.success) {
      throw new Error(updateResult.error || 'Failed to update preferences');
    }

    const updated = updateResult.record;
    console.log(`‚úÖ Updated preferences for user ${userId}`);

    // Check for profile-related achievements (non-blocking)
    checkProfileAchievements(profile._id, {
      profileCompletion: updatedData.profile_completeness_score,
      hasPhoto: !!updatedData.cdl_front_image,
      hasCDL: !!updatedData.cdl_class,
      cdlVerified: false,
      bioLength: 0
    }).catch(err => console.warn('Achievement check failed:', err.message));

    // Award XP for profile update (non-blocking)
    awardXPNonBlocking(profile._id, 'update_profile', {
      completenessScore: updatedData.profile_completeness_score,
      searchCount: updatedData.total_searches
    });

    return {
      success: true,
      profile: enrichProfile(updated)
    };

  } catch (error) {
    console.error('‚ùå Error updating preferences:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Update driver persistent documents
 * Called after successful upload or application submission
 */
export async function updateDriverDocuments(docData) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found' };
    }
    
    const now = new Date();
    
    const updatedData = {
      ...profile,
      updated_date: now
    };

    // Upload files to Media Manager and store in image fields (Phase 4H)
    if (docData.cdlFront && docData.cdlFront.data) {
      updatedData.cdl_front_image = await uploadToMediaManager(docData.cdlFront, userId);
    } else if (typeof docData.cdlFront === 'string') {
      updatedData.cdl_front_image = docData.cdlFront;
    }

    if (docData.cdlBack && docData.cdlBack.data) {
      updatedData.cdl_back_image = await uploadToMediaManager(docData.cdlBack, userId);
    } else if (typeof docData.cdlBack === 'string') {
      updatedData.cdl_back_image = docData.cdlBack;
    }

    if (docData.medCard && docData.medCard.data) {
      updatedData.med_card_image = await uploadToMediaManager(docData.medCard, userId);
    } else if (typeof docData.medCard === 'string') {
      updatedData.med_card_image = docData.medCard;
    }

    if (docData.resume && docData.resume.data) {
      updatedData.resume_file = await uploadToMediaManager(docData.resume, userId);
    } else if (typeof docData.resume === 'string') {
      updatedData.resume_file = docData.resume;
    }
    
    // Recalculate completeness
    updatedData.profile_completeness_score = calculateCompleteness(updatedData);
    
    // Update status
    if (updatedData.profile_completeness_score >= 80) {
      updatedData.profile_status = CONFIG.STATUS.ACTIVE;
    }
    
    // Use dual-source data access for update
    const updateResult = await dataAccess.updateRecord('driverProfiles', updatedData, { suppressAuth: true });

    if (!updateResult.success) {
      throw new Error(updateResult.error || 'Failed to update documents');
    }

    const updated = updateResult.record;
    console.log(`‚úÖ Updated documents for user ${userId}`);
    
    // OCR Processing (New for Phase 7)
    // We run this AFTER storing the URLs so the user definitely has the docs saved
    // but the extraction helps populate profile fields
    const ocrPromises = [];

    if (docData.cdlFront && docData.cdlFront.data) {
        const base64 = docData.cdlFront.data.split(';base64,').pop();
        ocrPromises.push(extractInfoFromDocument(base64, docData.cdlFront.type, 'CDL_FRONT'));
    }

    if (docData.medCard && docData.medCard.data) {
        const base64 = docData.medCard.data.split(';base64,').pop();
        ocrPromises.push(extractInfoFromDocument(base64, docData.medCard.type, 'MED_CARD'));
    }

    if (ocrPromises.length > 0) {
        console.log(`üß† Triggering OCR for ${ocrPromises.length} documents...`);
        const ocrResults = await Promise.all(ocrPromises);
        
        ocrResults.forEach(res => {
            if (res && !res.error) {
                // CDL Data Mapping
                if (res.licenseNumber) {
                    if (!updatedData.display_name && res.fullName) updatedData.display_name = res.fullName;
                    if (res.cdlClass) updatedData.cdl_class = res.cdlClass;
                    if (res.expirationDate) updatedData.cdl_expiration_date = res.expirationDate;
                    if (res.endorsements) updatedData.endorsements = res.endorsements;
                }
                // Med Card Data Mapping
                if (res.certificateExpirationDate) {
                    updatedData.med_card_expiration_date = res.certificateExpirationDate;
                }
            }
        });

        // Final save with OCR data using dual-source data access
        updatedData.profile_completeness_score = calculateCompleteness(updatedData);
        if (updatedData.profile_completeness_score >= 80) updatedData.profile_status = CONFIG.STATUS.ACTIVE;

        await dataAccess.updateRecord('driverProfiles', updatedData, { suppressAuth: true });
        console.log('‚úÖ Profile enriched via OCR extraction');
    }

    // Check for profile-related achievements (non-blocking)
    checkProfileAchievements(profile._id, {
      profileCompletion: updatedData.profile_completeness_score,
      hasPhoto: !!(updatedData.cdl_front_image || updatedData.med_card_image),
      hasCDL: !!updatedData.cdl_class,
      cdlVerified: false,
      bioLength: 0
    }).catch(err => console.warn('Achievement check failed:', err.message));

    // Award XP for document upload (non-blocking)
    awardXPNonBlocking(profile._id, 'upload_document', {
      documentCount: [
        updatedData.cdl_front_image,
        updatedData.cdl_back_image,
        updatedData.med_card_image,
        updatedData.resume_file
      ].filter(Boolean).length
    });

    return {
      success: true,
      profile: enrichProfile(updatedData)
    };

  } catch (error) {
    console.error('‚ùå Error updating documents:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Update driver qualifications (from profile page)
 * Used for reverse matching
 */
export async function updateDriverQualifications(qualifications) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found' };
    }
    
    const now = new Date();
    
    const updatedData = {
      ...profile,
      years_experience: qualifications.yearsExperience ?? profile.years_experience,
      cdl_class: qualifications.cdlClass || profile.cdl_class,
      endorsements: qualifications.endorsements || profile.endorsements,
      clean_mvr: qualifications.cleanMVR ?? profile.clean_mvr,
      accidents_last_3_years: qualifications.accidentsLast3Years ?? profile.accidents_last_3_years,
      violations_last_3_years: qualifications.violationsLast3Years ?? profile.violations_last_3_years,
      updated_date: now
    };
    
    // Recalculate completeness
    updatedData.profile_completeness_score = calculateCompleteness(updatedData);
    
    // Update status
    if (updatedData.profile_completeness_score >= 80) {
      updatedData.profile_status = CONFIG.STATUS.ACTIVE;
    }
    
    // Use dual-source data access for update
    const updateResult = await dataAccess.updateRecord('driverProfiles', updatedData, { suppressAuth: true });

    if (!updateResult.success) {
      throw new Error(updateResult.error || 'Failed to update qualifications');
    }

    const updated = updateResult.record;
    console.log(`‚úÖ Updated qualifications for user ${userId}`);

    // Award XP for qualification update (non-blocking)
    awardXPNonBlocking(profile._id, 'update_profile', {
      completenessScore: updatedData.profile_completeness_score,
      hasQualifications: !!(updatedData.years_experience && updatedData.cdl_class)
    });

    return {
      success: true,
      profile: enrichProfile(updated)
    };

  } catch (error) {
    console.error('‚ùå Error updating qualifications:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Toggle driver discoverability (opt-in for recruiters)
 */
export async function setDiscoverability(isDiscoverable) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found' };
    }
    
    const updatedData = {
      ...profile,
      is_discoverable: Boolean(isDiscoverable),
      updated_date: new Date()
    };

    // Use dual-source data access for update
    const updateResult = await dataAccess.updateRecord('driverProfiles', updatedData, { suppressAuth: true });

    if (!updateResult.success) {
      throw new Error(updateResult.error || 'Failed to update discoverability');
    }

    const updated = updateResult.record;
    console.log(`‚úÖ Set discoverability to ${isDiscoverable} for user ${userId}`);

    return {
      success: true,
      profile: enrichProfile(updated)
    };

  } catch (error) {
    console.error('‚ùå Error setting discoverability:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CARRIER INTEREST MANAGEMENT
// ============================================================================

/**
 * Log when a driver expresses interest in a carrier
 * Replaces the anonymous MatchEvents logging
 */
export async function logCarrierInterest(carrierData) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      // Fallback to anonymous logging for non-logged-in users
      return { success: false, error: 'User not logged in', isAnonymous: true };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found' };
    }
    
    // Format date as YYYY-MM-DD for Airtable date fields (not datetime)
    const now = new Date();
    const formattedDate = now.toISOString().split('T')[0];

    // Check for existing interest record using dual-source data access
    const existingResult = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(carrierData.carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      // Update existing record with new timestamp
      const existing = existingResult.items[0];
      const updateResult = await dataAccess.updateRecord('driverCarrierInterests', {
        ...existing,
        match_score: carrierData.matchScore || existing.match_score,
        action: carrierData.action || 'interested',
        action_timestamp: formattedDate
      }, { suppressAuth: true });

      console.log(`üìù Updated existing interest for DOT ${carrierData.carrierDOT}`);
      return { success: true, interest: updateResult.record, isUpdate: true };
    }
    
    // Create new interest record
    const interestData = {
      driver_id: profile._id,
      carrier_dot: String(carrierData.carrierDOT),
      carrier_name: carrierData.carrierName || '',
      match_score: carrierData.matchScore || 0,
      action: carrierData.action || 'interested',
      action_timestamp: formattedDate,
      driver_zip_at_match: profile.home_zip || '',
      outcome: null,
      outcome_date: null,
      notes: null
    };
    
    // Use dual-source data access for insert
    const insertResult = await dataAccess.insertRecord('driverCarrierInterests', interestData, { suppressAuth: true });

    if (!insertResult.success) {
      throw new Error(insertResult.error || 'Failed to log interest');
    }

    console.log(`‚úÖ Logged interest: Driver ${profile._id} ‚Üí Carrier DOT ${carrierData.carrierDOT}`);

    return {
      success: true,
      interest: insertResult.record,
      isNew: true
    };

  } catch (error) {
    console.error('‚ùå Error logging carrier interest:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get all carriers a driver has expressed interest in
 */
export async function getDriverInterests() {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in', interests: [] };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found', interests: [] };
    }
    
    const result = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: { driver_id: profile._id },
      sort: [{ field: 'action_timestamp', direction: 'desc' }],
      limit: 100,
      suppressAuth: true
    });

    if (!result.success) {
      return { success: false, error: result.error, interests: [] };
    }

    console.log(`üìã Found ${result.items.length} interests for driver ${profile._id}`);

    return {
      success: true,
      interests: result.items,
      totalCount: result.totalCount || result.items.length
    };
    
  } catch (error) {
    console.error('‚ùå Error getting driver interests:', error);
    return { success: false, error: error.message, interests: [] };
  }
}

/**
 * Remove interest in a carrier
 */
export async function removeCarrierInterest(carrierDOT) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }
    
    const userId = currentUser.id;
    const profile = await getProfileByUserId(userId);
    
    if (!profile) {
      return { success: false, error: 'Profile not found' };
    }
    
    const existingResult = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: {
        driver_id: profile._id,
        carrier_dot: String(carrierDOT)
      },
      limit: 1,
      suppressAuth: true
    });

    if (!existingResult.success || existingResult.items.length === 0) {
      return { success: false, error: 'Interest not found' };
    }

    const deleteResult = await dataAccess.deleteRecord('driverCarrierInterests', existingResult.items[0]._id, { suppressAuth: true });

    if (!deleteResult.success) {
      throw new Error(deleteResult.error || 'Failed to remove interest');
    }

    console.log(`üóëÔ∏è Removed interest for DOT ${carrierDOT}`);
    return { success: true };
    
  } catch (error) {
    console.error('‚ùå Error removing interest:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ADMIN/ANALYTICS FUNCTIONS
// ============================================================================

/**
 * Get interest signals for a specific carrier (for carrier dashboard)
 * Only returns aggregate data, not individual driver info (privacy)
 */
export async function getCarrierInterestStats(carrierDOT) {
  try {
    const dotString = String(carrierDOT);

    const result = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: { carrier_dot: dotString },
      suppressAuth: true
    });

    if (!result.success) {
      return { success: false, error: result.error };
    }

    const interests = result.items;
    
    // Aggregate stats (no PII)
    const stats = {
      carrier_dot: dotString,
      total_interests: interests.length,
      interests_last_30_days: 0,
      interests_last_7_days: 0,
      avg_match_score: 0,
      top_driver_zips: {}
    };
    
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    let totalScore = 0;
    
    for (const interest of interests) {
      const actionDate = new Date(interest.action_timestamp);
      
      if (actionDate >= thirtyDaysAgo) stats.interests_last_30_days++;
      if (actionDate >= sevenDaysAgo) stats.interests_last_7_days++;
      
      totalScore += interest.match_score || 0;
      
      // Aggregate ZIPs (first 3 digits only for privacy)
      const zipPrefix = (interest.driver_zip_at_match || '').substring(0, 3);
      if (zipPrefix) {
        stats.top_driver_zips[zipPrefix] = (stats.top_driver_zips[zipPrefix] || 0) + 1;
      }
    }
    
    stats.avg_match_score = interests.length > 0 
      ? Math.round(totalScore / interests.length) 
      : 0;
    
    // Convert ZIP counts to sorted array
    stats.top_driver_zips = Object.entries(stats.top_driver_zips)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([zip, count]) => ({ zip_prefix: zip, count }));
    
    return { success: true, stats };
    
  } catch (error) {
    console.error('‚ùå Error getting carrier stats:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get platform-wide driver activity stats (for admin dashboard)
 */
export async function getDriverActivityStats() {
  try {
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    // Get all profiles using dual-source data access
    const profileResult = await dataAccess.getAllRecords('driverProfiles', { suppressAuth: true });

    const profiles = profileResult || [];
    
    // Calculate stats
    const stats = {
      total_profiles: profiles.length,
      active_last_30_days: 0,
      active_last_7_days: 0,
      discoverable_profiles: 0,
      complete_profiles: 0,
      avg_completeness: 0,
      avg_searches_per_driver: 0,
      profile_status_breakdown: {
        active: 0,
        incomplete: 0,
        dormant: 0
      }
    };
    
    let totalCompleteness = 0;
    let totalSearches = 0;
    
    for (const profile of profiles) {
      const lastSearch = profile.last_search_date ? new Date(profile.last_search_date) : null;
      
      if (lastSearch && lastSearch >= thirtyDaysAgo) stats.active_last_30_days++;
      if (lastSearch && lastSearch >= sevenDaysAgo) stats.active_last_7_days++;
      
      if (profile.is_discoverable) stats.discoverable_profiles++;
      if (profile.profile_completeness_score >= 80) stats.complete_profiles++;
      
      totalCompleteness += profile.profile_completeness_score || 0;
      totalSearches += profile.total_searches || 0;
      
      const status = profile.profile_status || 'incomplete';
      stats.profile_status_breakdown[status] = (stats.profile_status_breakdown[status] || 0) + 1;
    }
    
    stats.avg_completeness = profiles.length > 0 
      ? Math.round(totalCompleteness / profiles.length) 
      : 0;
    
    stats.avg_searches_per_driver = profiles.length > 0 
      ? Math.round((totalSearches / profiles.length) * 10) / 10 
      : 0;
    
    // Get interest stats using dual-source data access
    const interestResult = await dataAccess.queryRecords('driverCarrierInterests', {
      filters: {
        action_timestamp: { gte: thirtyDaysAgo }
      },
      suppressAuth: true
    });

    stats.total_interests_30_days = interestResult.success ? (interestResult.totalCount || interestResult.items.length) : 0;
    
    return { success: true, stats };
    
  } catch (error) {
    console.error('‚ùå Error getting activity stats:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Calculate profile completeness score (0-100)
 */
/**
 * Calculate profile completeness score (0-100)
 */
function calculateCompleteness(profile) {
  let score = 0;
  const weights = CONFIG.COMPLETENESS_WEIGHTS;
  
  // Base Info (20%)
  if (profile.display_name && profile.display_name.trim().length > 0) score += weights.display_name;
  if (profile.email && profile.email.includes('@')) score += weights.email;
  if (profile.phone && profile.phone.length >= 10) score += weights.phone;
  
  // Experience (30%)
  if (profile.years_experience !== null && profile.years_experience >= 0) score += weights.years_experience;
  if (profile.cdl_class && profile.cdl_class.length > 0) score += weights.cdl_class;
  if (profile.endorsements && profile.endorsements.length > 0) score += weights.endorsements;
  if (profile.clean_mvr !== null) score += weights.clean_mvr;
  if (profile.accidents_last_3_years !== null) score += weights.accidents_last_3_years;
  if (profile.violations_last_3_years !== null) score += weights.violations_last_3_years;

  // Documents (30%)
  if (profile.cdl_front_image && profile.cdl_back_image) score += weights.cdl_images;
  if (profile.med_card_image) score += weights.med_card_image;
  
  // Preferences (20%)
  if (profile.home_zip && profile.home_zip.length >= 5) score += weights.home_zip;
  if (profile.preferred_operation_type && profile.preferred_operation_type !== 'no_preference') score += weights.preferred_operation_type;
  if (profile.min_cpm && profile.min_cpm > 0) score += weights.min_cpm;
  if (profile.fleet_size_preference && profile.fleet_size_preference !== 'no_preference') score += weights.fleet_size_preference;

  return Math.min(100, score);
}

/**
 * Enrich profile with computed fields for frontend
 */
/**
 * Enrich profile with computed fields for frontend
 */
function enrichProfile(profile) {
  if (!profile) return null;
  
  const completeness = calculateCompleteness(profile);
  const weights = CONFIG.COMPLETENESS_WEIGHTS;
  
  // Create detailed suggestions list with point values
  const suggestions = [];
  
  // Base Info
  if (!profile.display_name) suggestions.push({ label: 'Add your name', points: weights.display_name, action: 'edit_profile' });
  if (!profile.phone) suggestions.push({ label: 'Add phone number', points: weights.phone, action: 'edit_profile' });
  
  // Experience
  if (profile.years_experience === null) suggestions.push({ label: 'Set years of experience', points: weights.years_experience, action: 'edit_experience' });
  if (!profile.cdl_class) suggestions.push({ label: 'Set CDL Class', points: weights.cdl_class, action: 'edit_experience' });
  
  // Documents
  if (!profile.cdl_front_image || !profile.cdl_back_image) {
    suggestions.push({ label: 'Upload CDL Photos', points: weights.cdl_images, action: 'upload_documents' });
  }
  if (!profile.med_card_image) {
    suggestions.push({ label: 'Upload Medical Card', points: weights.med_card_image, action: 'upload_documents' });
  }
  
  // Preferences
  if (!profile.home_zip) suggestions.push({ label: 'Set Home ZIP', points: weights.home_zip, action: 'edit_preferences' });
  if (!profile.min_cpm) suggestions.push({ label: 'Set Pay Expectations', points: weights.min_cpm, action: 'edit_preferences' });
  
  // Backward compatibility for existing frontend code that uses missing_fields array of strings
  const missingFields = suggestions.map(s => s.label);
  
  return {
    ...profile,
    profile_completeness_score: completeness,
    missing_fields: missingFields,
    suggestions: suggestions,
    is_complete: completeness >= 80,
    can_be_discovered: profile.is_discoverable && completeness >= 50
  };
}

// ============================================================================
// PROFILE INSIGHTS
// ============================================================================

/**
 * Get list of carriers who viewed the driver's profile
 * Used for "Who's Viewed You" dashboard widget
 */
export async function getDriverProfileViews(limit = 10) {
  try {
    const currentUser = await wixUsersBackend.currentUser;
    
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in', views: [] };
    }
    
    // Get driver profile first
    const driverProfile = await getProfileByUserId(currentUser.id);
    if (!driverProfile) {
      return { success: false, error: 'Driver profile not found', views: [] };
    }
    
    console.log(`üëÄ Getting profile views for driver ${driverProfile._id}`);

    // Query views
    const viewsResult = await dataAccess.queryRecords('carrierDriverViews', {
      filters: {
        driver_id: driverProfile._id
      },
      sort: [{ field: '_createdDate', direction: 'desc' }], // Wix field
      limit: limit,
      suppressAuth: true
    });

    if (!viewsResult.success || viewsResult.items.length === 0) {
      return { success: true, views: [], totalCount: 0 };
    }
    
    const views = viewsResult.items;
    
    // Extract unique carrier DOTs to fetch company details
    const uniqueDots = [...new Set(views.map(v => v.carrier_dot))];
    
    // Fetch carrier details
    // Note: We can't do a simple "IN" query easily with dataAccess if it doesn't support it strictly
    // So we'll fetch them individually or use a filter query if the list is small
    
    let carriers = [];
    if (uniqueDots.length > 0) {
       // Only fetch what we need (Company Name, Location)
       // Using a promise.all for specific DOTs or a larger query if possible
       // For now, let's assume we can query by DOT
       // If uniqueDots is large, we might want to optimize this. For limit=10, it's fine.
       
       const carrierPromises = uniqueDots.map(dot => 
         dataAccess.queryRecords('carriers', {
           filters: { dot_number: parseInt(dot) }, // Ensure number type for DOT if required
           limit: 1,
           suppressAuth: true
         })
       );
       
       const carrierResults = await Promise.all(carrierPromises);
       carriers = carrierResults
         .filter(r => r.success && r.items.length > 0)
         .map(r => r.items[0]);
    }
    
    // Map details back to views
    const enrichedViews = views.map(view => {
      const carrier = carriers.find(c => String(c.dot_number) === String(view.carrier_dot));
      return {
        view_id: view._id,
        carrier_dot: view.carrier_dot,
        carrier_name: carrier ? carrier.company_name : 'Unknown Carrier',
        carrier_city: carrier ? carrier.city : '',
        carrier_state: carrier ? carrier.state : '',
        viewed_at: view._createdDate || view['Created Time'], // Handle both Wix/Airtable
        view_type: view.view_type || 'full_profile'
      };
    });

    return {
      success: true,
      views: enrichedViews,
      totalCount: viewsResult.totalCount || enrichedViews.length
    };

  } catch (error) {
    console.error('‚ùå Error getting profile views:', error);
    return { success: false, error: error.message, views: [] };
  }
}

// ============================================================================
// TESTING
// ============================================================================

/**
 * Test the driver profile system
 */
export async function testDriverProfileSystem() {
  console.log('=== DRIVER PROFILE SYSTEM TEST ===');
  
  try {
    // Test getOrCreate
    const result = await getOrCreateDriverProfile();
    console.log('getOrCreateDriverProfile:', result.success ? 'PASS' : 'FAIL');
    
    if (result.success) {
      console.log('Profile ID:', result.profile._id);
      console.log('Is New:', result.isNew);
      console.log('Completeness:', result.profile.profile_completeness_score);
    }
    
    return result;
    
  } catch (error) {
    console.error('Test failed:', error);
    return { success: false, error: error.message };
  }
}

import wixUsersBackend from 'wix-users-backend';
import { mediaManager } from 'wix-media-backend';
import { extractInfoFromDocument } from 'backend/ocrService.jsw';
import * as dataAccess from 'backend/dataAccess';

// Gamification hooks
import { checkProfileAchievements } from 'backend/achievementService';

// Analytics hooks
import { convertSessionToDriver } from 'backend/recruiterAnalyticsService';

// Lazy-loaded gamification services to avoid circular dependencies
async function getGamificationService() {
  return await import('backend/gamificationService');
}

// Non-blocking XP award helper
async function awardXPNonBlocking(driverId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardDriverXP(driverId, action, metadata);
  } catch (err) {
    console.warn(`XP award failed for ${action}:`, err.message);
  }
}

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  mediaFolder: '/driver-documents',

  // Profile Status Values
  STATUS: {
    ACTIVE: 'active',
    INCOMPLETE: 'incomplete',
    DORMANT: 'dormant'
  },

  // Completeness scoring weights (Spec: Base 20%, Exp 30%, Docs 30%, Prefs 20%)
  COMPLETENESS_WEIGHTS: {
    // Base Info (20%)
    display_name: 10,
    email: 5,
    phone: 5,

    // Experience (30%)
    years_experience: 10,
    cdl_class: 10,
    endorsements: 4,
    clean_mvr: 2,
    accidents_last_3_years: 2,
    violations_last_3_years: 2,

    // Documents (30%)
    cdl_images: 20,
    med_card_image: 10,

    // Preferences (20%)
    home_zip: 5,
    preferred_operation_type: 5,
    min_cpm: 5,
    fleet_size_preference: 5
  }
};

const COLLECTION_KEYS = {
  profiles: 'driverProfiles',
  interests: 'driverCarrierInterests',
  views: 'carrierDriverViews',
  carriers: 'carriers'
};

// ============================================================================
// DOCUMENT UPLOAD HELPERS
// ============================================================================

async function uploadToMediaManager(fileObj, userId) {
  if (!fileObj || !fileObj.data) return null;

  try {
    const base64Content = fileObj.data.split(';base64,').pop();
    const buffer = Buffer.from(base64Content, 'base64');
    const fileName = `${Date.now()}_${fileObj.name.replace(/\s+/g, '_')}`;
    const filePath = `${CONFIG.mediaFolder}/${userId}`;
    const mimeType = fileObj.type || 'application/octet-stream';
    
    let mediaType = 'document';
    if (mimeType.startsWith('image/')) mediaType = 'image';
    else if (mimeType.startsWith('video/')) mediaType = 'video';
    else if (mimeType.startsWith('audio/')) mediaType = 'audio';

    console.log(`üì§ Uploading ${fileName} as ${mediaType} (${mimeType})`);

    const uploadResult = await mediaManager.upload(
      filePath,
      buffer,
      fileName,
      {
        mediaOptions: { mimeType, mediaType },
        metadataOptions: { isPrivate: false, isVisitorUpload: false }
      }
    );

    console.log(`‚úÖ Uploaded: ${uploadResult.fileUrl}`);
    return uploadResult.fileUrl;
  } catch (error) {
    console.error('‚ùå Media upload error:', error);
    throw new Error('Failed to upload document to Media Manager');
  }
}

// ============================================================================
// PROFILE RETRIEVAL
// ============================================================================

export async function getOrCreateDriverProfile(sessionId) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in', profile: null };

    const userId = currentUser.id;
    const existingProfile = await getProfileByUserId(userId);

    if (existingProfile) {
      return { success: true, profile: enrichProfile(existingProfile), isNew: false };
    }

    const newProfile = await createNewProfile(userId, currentUser);
    if (sessionId) {
      convertSessionToDriver(sessionId, newProfile._id).catch(() => {});
    }

    return { success: true, profile: enrichProfile(newProfile), isNew: true };
  } catch (error) {
    console.error('‚ùå Error in getOrCreateDriverProfile:', error);
    return { success: false, error: error.message, profile: null };
  }
}

async function getProfileByUserId(userId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.profiles, {
      filters: { _owner: userId },
      limit: 1,
      suppressAuth: true
    });
    return result.success && result.items.length > 0 ? result.items[0] : null;
  } catch (error) {
    console.error('Profile lookup error:', error);
    return null;
  }
}

export async function getProfileById(profileId) {
  try {
    const result = await dataAccess.getRecord(COLLECTION_KEYS.profiles, profileId, { suppressAuth: true });
    return result ? enrichProfile(result) : null;
  } catch (error) {
    console.error('Profile get error:', error);
    return null;
  }
}

// ============================================================================
// PROFILE CREATION
// ============================================================================

async function createNewProfile(userId, userObject) {
  let userEmail = '';
  try { userEmail = await userObject.getEmail(); } catch (e) { /* ignore */ }

  const now = new Date();
  const profileData = {
    wix_member_id: userId,
    display_name: '',
    email: userEmail,
    phone: '',
    home_zip: '',
    max_commute_miles: 50,
    min_cpm: 0.50,
    preferred_operation_type: 'no_preference',
    max_turnover_percent: 90,
    max_truck_age_years: 5,
    fleet_size_preference: 'no_preference',
    years_experience: null,
    cdl_class: '',
    endorsements: '',
    clean_mvr: null,
    accidents_last_3_years: null,
    violations_last_3_years: null,
    cdl_front_image: null,
    cdl_back_image: null,
    med_card_image: null,
    resume_file: null,
    last_search_date: null,
    total_searches: 0,
    profile_completeness_score: 0,
    profile_status: CONFIG.STATUS.INCOMPLETE,
    is_discoverable: false,
    created_date: now.toISOString().split('T')[0],
    updated_date: now.toISOString().split('T')[0]
  };

  const result = await dataAccess.insertRecord(COLLECTION_KEYS.profiles, profileData, { suppressAuth: true });
  if (!result.success) throw new Error(result.error || 'Failed to create profile');
  return result.record;
}

// ============================================================================
// PROFILE UPDATES
// ============================================================================

export async function updateDriverPreferences(preferences) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found' };

    const now = new Date();
    const updatedData = {
      ...profile,
      home_zip: preferences.homeZip || profile.home_zip,
      max_commute_miles: preferences.maxDistance || profile.max_commute_miles,
      min_cpm: preferences.minCPM || profile.min_cpm,
      preferred_operation_type: preferences.operationType || profile.preferred_operation_type,
      max_turnover_percent: preferences.maxTurnover || profile.max_turnover_percent,
      max_truck_age_years: preferences.maxTruckAge || profile.max_truck_age_years,
      fleet_size_preference: preferences.fleetSize || profile.fleet_size_preference,
      display_name: preferences.driverName || profile.display_name,
      last_search_date: now,
      total_searches: (profile.total_searches || 0) + 1,
      updated_date: now
    };

    updatedData.profile_completeness_score = calculateCompleteness(updatedData);
    if (updatedData.profile_completeness_score >= 80) updatedData.profile_status = CONFIG.STATUS.ACTIVE;
    else if (updatedData.profile_completeness_score >= 30) updatedData.profile_status = CONFIG.STATUS.INCOMPLETE;

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.profiles, updatedData, { suppressAuth: true });
    if (!result.success) throw new Error(result.error || 'Failed to update preferences');

    checkProfileAchievements(profile._id, {
      profileCompletion: updatedData.profile_completeness_score,
      hasPhoto: !!updatedData.cdl_front_image,
      hasCDL: !!updatedData.cdl_class,
      cdlVerified: false, bioLength: 0
    }).catch(() => {});

    awardXPNonBlocking(profile._id, 'update_profile', {
      completenessScore: updatedData.profile_completeness_score,
      searchCount: updatedData.total_searches
    });

    return { success: true, profile: enrichProfile(result.record) };
  } catch (error) {
    console.error('‚ùå Error updating preferences:', error);
    return { success: false, error: error.message };
  }
}

export async function updateDriverDocuments(docData) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found' };

    const updatedData = { ...profile, updated_date: new Date() };

    if (docData.cdlFront?.data) updatedData.cdl_front_image = await uploadToMediaManager(docData.cdlFront, currentUser.id);
    else if (typeof docData.cdlFront === 'string') updatedData.cdl_front_image = docData.cdlFront;

    if (docData.cdlBack?.data) updatedData.cdl_back_image = await uploadToMediaManager(docData.cdlBack, currentUser.id);
    else if (typeof docData.cdlBack === 'string') updatedData.cdl_back_image = docData.cdlBack;

    if (docData.medCard?.data) updatedData.med_card_image = await uploadToMediaManager(docData.medCard, currentUser.id);
    else if (typeof docData.medCard === 'string') updatedData.med_card_image = docData.medCard;

    if (docData.resume?.data) updatedData.resume_file = await uploadToMediaManager(docData.resume, currentUser.id);
    else if (typeof docData.resume === 'string') updatedData.resume_file = docData.resume;

    updatedData.profile_completeness_score = calculateCompleteness(updatedData);
    if (updatedData.profile_completeness_score >= 80) updatedData.profile_status = CONFIG.STATUS.ACTIVE;

    // OCR Processing
    const ocrPromises = [];
    if (docData.cdlFront?.data) {
      ocrPromises.push(extractInfoFromDocument(docData.cdlFront.data.split(';base64,').pop(), docData.cdlFront.type, 'CDL_FRONT'));
    }
    if (docData.medCard?.data) {
      ocrPromises.push(extractInfoFromDocument(docData.medCard.data.split(';base64,').pop(), docData.medCard.type, 'MED_CARD'));
    }

    if (ocrPromises.length > 0) {
      const ocrResults = await Promise.all(ocrPromises);
      ocrResults.forEach(res => {
        if (res && !res.error) {
          if (res.licenseNumber) {
            if (!updatedData.display_name && res.fullName) updatedData.display_name = res.fullName;
            if (res.cdlClass) updatedData.cdl_class = res.cdlClass;
            if (res.expirationDate) updatedData.cdl_expiration_date = res.expirationDate;
            if (res.endorsements) updatedData.endorsements = Array.isArray(res.endorsements) ? res.endorsements.join(', ') : res.endorsements;
          }
          if (res.certificateExpirationDate) updatedData.med_card_expiration_date = res.certificateExpirationDate;
        }
      });
      updatedData.profile_completeness_score = calculateCompleteness(updatedData);
      if (updatedData.profile_completeness_score >= 80) updatedData.profile_status = CONFIG.STATUS.ACTIVE;
    }

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.profiles, updatedData, { suppressAuth: true });
    if (!result.success) throw new Error(result.error || 'Failed to update documents');

    checkProfileAchievements(profile._id, {
      profileCompletion: updatedData.profile_completeness_score,
      hasPhoto: !!(updatedData.cdl_front_image || updatedData.med_card_image),
      hasCDL: !!updatedData.cdl_class,
      cdlVerified: false, bioLength: 0
    }).catch(() => {});

    awardXPNonBlocking(profile._id, 'upload_document', {
      documentCount: [updatedData.cdl_front_image, updatedData.cdl_back_image, updatedData.med_card_image, updatedData.resume_file].filter(Boolean).length
    });

    return { success: true, profile: enrichProfile(result.record) };
  } catch (error) {
    console.error('‚ùå Error updating documents:', error);
    return { success: false, error: error.message };
  }
}

export async function updateDriverQualifications(qualifications) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found' };

    const updatedData = {
      ...profile,
      years_experience: qualifications.yearsExperience ?? profile.years_experience,
      cdl_class: qualifications.cdlClass || profile.cdl_class,
      endorsements: Array.isArray(qualifications.endorsements) ? qualifications.endorsements.join(', ') : (qualifications.endorsements || profile.endorsements),
      clean_mvr: qualifications.cleanMVR ?? profile.clean_mvr,
      accidents_last_3_years: qualifications.accidentsLast3Years ?? profile.accidents_last_3_years,
      violations_last_3_years: qualifications.violationsLast3Years ?? profile.violations_last_3_years,
      updated_date: new Date().toISOString().split('T')[0]
    };

    updatedData.profile_completeness_score = calculateCompleteness(updatedData);
    if (updatedData.profile_completeness_score >= 80) updatedData.profile_status = CONFIG.STATUS.ACTIVE;

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.profiles, updatedData, { suppressAuth: true });
    if (!result.success) throw new Error(result.error || 'Failed to update qualifications');

    awardXPNonBlocking(profile._id, 'update_profile', {
      completenessScore: updatedData.profile_completeness_score,
      hasQualifications: !!(updatedData.years_experience && updatedData.cdl_class)
    });

    return { success: true, profile: enrichProfile(result.record) };
  } catch (error) {
    console.error('‚ùå Error updating qualifications:', error);
    return { success: false, error: error.message };
  }
}

export async function setDiscoverability(isDiscoverable) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found' };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.profiles, {
      ...profile,
      is_discoverable: Boolean(isDiscoverable),
      updated_date: new Date()
    }, { suppressAuth: true });

    if (!result.success) throw new Error(result.error || 'Failed to update discoverability');
    return { success: true, profile: enrichProfile(result.record) };
  } catch (error) {
    console.error('‚ùå Error setting discoverability:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CARRIER INTEREST MANAGEMENT
// ============================================================================

export async function logCarrierInterest(carrierData) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in', isAnonymous: true };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found' };

    const formattedDate = new Date().toISOString().split('T')[0];
    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: profile._id, carrier_dot: String(carrierData.carrierDOT) },
      limit: 1,
      suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      const existing = existingResult.items[0];
      const result = await dataAccess.updateRecord(COLLECTION_KEYS.interests, {
        ...existing,
        match_score: carrierData.matchScore || existing.match_score,
        action: carrierData.action || 'interested',
        action_timestamp: formattedDate
      }, { suppressAuth: true });
      return { success: true, interest: result.record, isUpdate: true };
    }

    const interestData = {
      driver_id: profile._id,
      carrier_dot: String(carrierData.carrierDOT),
      carrier_name: carrierData.carrierName || '',
      match_score: carrierData.matchScore || 0,
      action: carrierData.action || 'interested',
      action_timestamp: formattedDate,
      driver_zip_at_match: profile.home_zip || '',
      outcome: null, outcome_date: null, notes: null
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.interests, interestData, { suppressAuth: true });
    if (!result.success) throw new Error(result.error || 'Failed to log interest');

    return { success: true, interest: result.record, isNew: true };
  } catch (error) {
    console.error('‚ùå Error logging carrier interest:', error);
    return { success: false, error: error.message };
  }
}

export async function getDriverInterests() {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in', interests: [] };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found', interests: [] };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: profile._id },
      sort: [{ field: 'action_timestamp', direction: 'desc' }],
      limit: 100,
      suppressAuth: true
    });

    if (!result.success) return { success: false, error: result.error, interests: [] };
    return { success: true, interests: result.items, totalCount: result.totalCount || result.items.length };
  } catch (error) {
    console.error('‚ùå Error getting driver interests:', error);
    return { success: false, error: error.message, interests: [] };
  }
}

export async function removeCarrierInterest(carrierDOT) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Profile not found' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: profile._id, carrier_dot: String(carrierDOT) },
      limit: 1, suppressAuth: true
    });

    if (!result.success || result.items.length === 0) return { success: false, error: 'Interest not found' };

    const delResult = await dataAccess.removeRecord(COLLECTION_KEYS.interests, result.items[0]._id, { suppressAuth: true });
    if (!delResult.success) throw new Error(delResult.error || 'Failed to remove interest');

    return { success: true };
  } catch (error) {
    console.error('‚ùå Error removing interest:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ADMIN/ANALYTICS FUNCTIONS
// ============================================================================

export async function getCarrierInterestStats(carrierDOT) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { carrier_dot: String(carrierDOT) },
      suppressAuth: true
    });

    if (!result.success) return { success: false, error: result.error };
    const interests = result.items || [];

    const stats = {
      carrier_dot: String(carrierDOT),
      total_interests: interests.length,
      interests_last_30_days: 0,
      interests_last_7_days: 0,
      avg_match_score: 0,
      top_driver_zips: {}
    };

    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    let totalScore = 0;
    interests.forEach(interest => {
      const actionDate = new Date(interest.action_timestamp);
      if (actionDate >= thirtyDaysAgo) stats.interests_last_30_days++;
      if (actionDate >= sevenDaysAgo) stats.interests_last_7_days++;
      totalScore += interest.match_score || 0;
      const zipPrefix = (interest.driver_zip_at_match || '').substring(0, 3);
      if (zipPrefix) stats.top_driver_zips[zipPrefix] = (stats.top_driver_zips[zipPrefix] || 0) + 1;
    });

    stats.avg_match_score = interests.length > 0 ? Math.round(totalScore / interests.length) : 0;
    stats.top_driver_zips = Object.entries(stats.top_driver_zips)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([zip, count]) => ({ zip_prefix: zip, count }));

    return { success: true, stats };
  } catch (error) {
    console.error('‚ùå Error getting carrier stats:', error);
    return { success: false, error: error.message };
  }
}

export async function getDriverActivityStats() {
  try {
    const profiles = await dataAccess.getAllRecords(COLLECTION_KEYS.profiles, { suppressAuth: true });
    
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const stats = {
      total_profiles: profiles.length, active_last_30_days: 0, active_last_7_days: 0,
      discoverable_profiles: 0, complete_profiles: 0, avg_completeness: 0, avg_searches_per_driver: 0,
      profile_status_breakdown: { active: 0, incomplete: 0, dormant: 0 }
    };

    let totalCompleteness = 0, totalSearches = 0;
    profiles.forEach(profile => {
      const lastSearch = profile.last_search_date ? new Date(profile.last_search_date) : null;
      if (lastSearch && lastSearch >= thirtyDaysAgo) stats.active_last_30_days++;
      if (lastSearch && lastSearch >= sevenDaysAgo) stats.active_last_7_days++;
      if (profile.is_discoverable) stats.discoverable_profiles++;
      if (profile.profile_completeness_score >= 80) stats.complete_profiles++;
      totalCompleteness += profile.profile_completeness_score || 0;
      totalSearches += profile.total_searches || 0;
      const status = profile.profile_status || 'incomplete';
      stats.profile_status_breakdown[status] = (stats.profile_status_breakdown[status] || 0) + 1;
    });

    stats.avg_completeness = profiles.length > 0 ? Math.round(totalCompleteness / profiles.length) : 0;
    stats.avg_searches_per_driver = profiles.length > 0 ? Math.round((totalSearches / profiles.length) * 10) / 10 : 0;

    const interestResult = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { action_timestamp: { gte: thirtyDaysAgo.toISOString().split('T')[0] } },
      suppressAuth: true
    });
    stats.total_interests_30_days = interestResult.success ? (interestResult.totalCount || interestResult.items.length) : 0;

    return { success: true, stats };
  } catch (error) {
    console.error('‚ùå Error getting activity stats:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// HELPERS
// ============================================================================

function calculateCompleteness(profile) {
  let score = 0;
  const weights = CONFIG.COMPLETENESS_WEIGHTS;
  if (profile.display_name?.trim().length > 0) score += weights.display_name;
  if (profile.email?.includes('@')) score += weights.email;
  if (profile.phone?.length >= 10) score += weights.phone;
  if (profile.years_experience !== null && profile.years_experience >= 0) score += weights.years_experience;
  if (profile.cdl_class) score += weights.cdl_class;
  if (profile.endorsements?.length > 0) score += weights.endorsements;
  if (profile.clean_mvr !== null) score += weights.clean_mvr;
  if (profile.accidents_last_3_years !== null) score += weights.accidents_last_3_years;
  if (profile.violations_last_3_years !== null) score += weights.violations_last_3_years;
  if (profile.cdl_front_image && profile.cdl_back_image) score += weights.cdl_images;
  if (profile.med_card_image) score += weights.med_card_image;
  if (profile.home_zip?.length >= 5) score += weights.home_zip;
  if (profile.preferred_operation_type && profile.preferred_operation_type !== 'no_preference') score += weights.preferred_operation_type;
  if (profile.min_cpm > 0) score += weights.min_cpm;
  if (profile.fleet_size_preference && profile.fleet_size_preference !== 'no_preference') score += weights.fleet_size_preference;
  return Math.min(100, score);
}

function enrichProfile(profile) {
  if (!profile) return null;
  const completeness = calculateCompleteness(profile);
  const weights = CONFIG.COMPLETENESS_WEIGHTS;
  const suggestions = [];
  if (!profile.display_name) suggestions.push({ label: 'Add your name', points: weights.display_name, action: 'edit_profile' });
  if (!profile.phone) suggestions.push({ label: 'Add phone number', points: weights.phone, action: 'edit_profile' });
  if (profile.years_experience === null) suggestions.push({ label: 'Set years of experience', points: weights.years_experience, action: 'edit_experience' });
  if (!profile.cdl_class) suggestions.push({ label: 'Set CDL Class', points: weights.cdl_class, action: 'edit_experience' });
  if (!profile.cdl_front_image || !profile.cdl_back_image) suggestions.push({ label: 'Upload CDL Photos', points: weights.cdl_images, action: 'upload_documents' });
  if (!profile.med_card_image) suggestions.push({ label: 'Upload Medical Card', points: weights.med_card_image, action: 'upload_documents' });
  if (!profile.home_zip) suggestions.push({ label: 'Set Home ZIP', points: weights.home_zip, action: 'edit_preferences' });
  if (!profile.min_cpm) suggestions.push({ label: 'Set Pay Expectations', points: weights.min_cpm, action: 'edit_preferences' });

  return {
    ...profile, profile_completeness_score: completeness, missing_fields: suggestions.map(s => s.label),
    suggestions, is_complete: completeness >= 80, can_be_discovered: profile.is_discoverable && completeness >= 50
  };
}

export async function getDriverProfileViews(limit = 10) {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in', views: [] };

    const profile = await getProfileByUserId(currentUser.id);
    if (!profile) return { success: false, error: 'Driver profile not found', views: [] };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.views, {
      filters: { driver_id: profile._id },
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit, suppressAuth: true
    });

    if (!result.success || !result.items?.length) return { success: true, views: [], totalCount: 0 };
    const views = result.items;
    const uniqueDots = [...new Set(views.map(v => v.carrier_dot))];

    const carrierPromises = uniqueDots.map(dot => dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { dot_number: parseInt(dot) }, limit: 1, suppressAuth: true
    }));

    const carrierResults = await Promise.all(carrierPromises);
    const carriers = carrierResults.filter(r => r.success && r.items?.length).map(r => r.items[0]);

    const enrichedViews = views.map(view => {
      const carrier = carriers.find(c => String(c.dot_number) === String(view.carrier_dot));
      return {
        view_id: view._id, carrier_dot: view.carrier_dot, carrier_name: carrier ? (carrier.legal_name || carrier.company_name) : 'Unknown Carrier',
        carrier_city: carrier?.city || '', carrier_state: carrier?.state || '', viewed_at: view._createdDate, view_type: view.view_type || 'full_profile'
      };
    });

    return { success: true, views: enrichedViews, totalCount: result.totalCount || enrichedViews.length };
  } catch (error) {
    console.error('‚ùå Error getting profile views:', error);
    return { success: false, error: error.message, views: [] };
  }
}

export async function testDriverProfileSystem() {
  try {
    const result = await getOrCreateDriverProfile();
    return result;
  } catch (error) {
    return { success: false, error: error.message };
  }
}

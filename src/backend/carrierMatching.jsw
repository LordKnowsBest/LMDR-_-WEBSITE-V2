import { updateDriverPreferences, logCarrierInterest } from 'backend/driverProfiles';
import { log, logDatabase, startTrace, endTrace } from 'backend/observabilityService';
import * as dataAccess from 'backend/dataAccess';
import { searchCarriersSemantic } from 'backend/semanticSearchService';
import { blendSemanticScore } from 'backend/driverScoring';
import { FEATURE_FLAGS } from 'backend/configData';

// ============================================================================
// SHARED SCORING MODULE
// ============================================================================
const { calculateMatchScore, CONFIG: SCORING_CONFIG } = require('backend/scoring');
import { getCarrierMatchingWeights } from 'backend/admin_config_service';

const CONFIG = {
  // MATCH LIMITS - Free vs Premium
  freeUserMaxResults: 2,
  premiumUserMaxResults: 10,

  defaultMaxDistance: 100
};

// ============================================================================
// IN-MEMORY CARRIER CACHE (avoids Airtable query on repeat searches)
// ============================================================================
let __carrierCache = null;
let __carrierCacheTime = 0;
const CARRIER_CACHE_TTL = 1800000; // 30 minutes (carrier data rarely changes)

async function getCachedCarriers() {
  const now = Date.now();
  if (__carrierCache && (now - __carrierCacheTime < CARRIER_CACHE_TTL)) {
    console.log(`üì¶ Using cached carriers (${__carrierCache.length} items, ${Math.round((now - __carrierCacheTime) / 1000)}s old)`);
    return { success: true, items: __carrierCache, fromCache: true };
  }

  const result = await dataAccess.queryRecords('carriers', {
    limit: 1000,
    sort: [{ field: 'combined_score', direction: 'desc' }]
  });
  if (result.success && result.items?.length > 0) {
    __carrierCache = result.items;
    __carrierCacheTime = now;
    console.log(`üì¶ Carrier cache refreshed: ${result.items.length} items`);
  }
  return { ...result, fromCache: false };
}

// ============================================================================
// CACHE LOOKUP
// ============================================================================

/**
 * Get existing enrichments from cache
 */
async function getExistingEnrichments(dotNumbers) {
  if (!dotNumbers || dotNumbers.length === 0) return {};

  try {
    const dotStrings = dotNumbers.map(d => String(d));
    
    const result = await dataAccess.queryRecords('carrierEnrichments', {
      filters: { dot_number: { hasSome: dotStrings } }
    });

    const items = result.items || [];
    const enrichmentMap = {};
    for (const item of items) {
      const enrichedDate = item.enriched_date;
      const daysSince = enrichedDate
        ? (Date.now() - new Date(enrichedDate).getTime()) / (1000 * 60 * 60 * 24)
        : 999;

      if (daysSince <= 14) {
        enrichmentMap[item.dot_number] = {
          ...item,
          fromCache: true,
          cacheAge: Math.round(daysSince)
        };
      }
    }

    console.log(`üì¶ Found ${Object.keys(enrichmentMap).length} cached enrichments`);
    return enrichmentMap;

  } catch (error) {
    console.error('Cache lookup error:', error.message);
    return {};
  }
}

// ============================================================================
// MAIN EXPORTED FUNCTION - findMatchingCarriers
// ============================================================================

export async function findMatchingCarriers(driverPrefs, isPremiumUser = false) {
  const startTime = Date.now();
  const TOTAL_BUDGET_MS = 12000; // Must return before Wix ~14s gateway timeout

  console.log('üöÄ ===== BACKEND: findMatchingCarriers =====');
  console.log('üìã Prefs received:', JSON.stringify(driverPrefs));
  console.log('üë§ Premium user:', isPremiumUser);

  const maxResults = isPremiumUser
    ? CONFIG.premiumUserMaxResults
    : CONFIG.freeUserMaxResults;

  // Fire off profile update (non-blocking, returns immediately for non-logged-in users)
  // Use a ref object so the async mutation is visible inside the pipeline
  const profileRef = { value: null };
  updateDriverPreferences(driverPrefs)
    .then(r => { profileRef.value = r.success ? r.profile : null; })
    .catch(() => {});

  // Hard timeout: return graceful error instead of letting Wix 504 us
  let timeoutId;
  const timeoutFallback = new Promise(resolve => {
    timeoutId = setTimeout(() => {
      console.warn(`[carrierMatching] Total budget exceeded (${TOTAL_BUDGET_MS}ms) ‚Äî returning timeout error`);
      resolve({
        success: false,
        matches: [],
        totalScored: 0,
        error: 'Search timed out. Please try again ‚Äî repeat searches are faster.',
        userTier: isPremiumUser ? 'premium' : 'free'
      });
    }, TOTAL_BUDGET_MS);
  });

  const result = await Promise.race([
    _findMatchingCarriersPipeline(driverPrefs, isPremiumUser, maxResults, startTime, profileRef),
    timeoutFallback
  ]);
  clearTimeout(timeoutId);
  return result;
}

async function _findMatchingCarriersPipeline(driverPrefs, isPremiumUser, maxResults, startTime, profileRef) {
  // Generate traceId locally ‚Äî defer ALL observability writes until after response is built
  const traceId = 'tr_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);

  try {
    // STEP 1: Fetch carriers (cached) + weights in parallel ‚Äî this is the critical path
    console.log('üìå Step 1: Fetching carriers + weights...');
    const queryStartTime = Date.now();

    const [result, fetchedWeights] = await Promise.all([
      getCachedCarriers(),
      getCarrierMatchingWeights().catch(() => SCORING_CONFIG.weights)
    ]);

    if (!result.success) throw new Error(result.error);
    const carrierItems = result.items || [];
    const queryLatency = Date.now() - queryStartTime;

    console.log(`üìä Step 2: Got ${carrierItems.length} carriers in ${queryLatency}ms (cache: ${result.fromCache})`);

    if (carrierItems.length === 0) {
      return {
        success: true, matches: [], totalScored: 0,
        message: 'No carriers in database',
        userTier: isPremiumUser ? 'premium' : 'free', driverProfile: null
      };
    }

    // Semantic blend: pre-fetch carrier scores from Pinecone before scoring loop.
    // On timeout or failure, semanticScoreMap stays empty and scoring is unaffected.
    const semanticScoreMap = new Map();
    if (FEATURE_FLAGS.semanticSearchBlendEnabled) {
      try {
        const cdl  = driverPrefs.cdl_class || driverPrefs.cdlClass || '';
        const ops  = Array.isArray(driverPrefs.operation_types)
          ? driverPrefs.operation_types.join(', ')
          : (driverPrefs.operationType || driverPrefs.operation_type || '');
        const state = driverPrefs.home_state || driverPrefs.homeState || '';
        const pay   = (driverPrefs.pay_range_min || driverPrefs.minPay)
          ? `min $${driverPrefs.pay_range_min || driverPrefs.minPay}/mi` : '';
        const semanticQuery = [
          cdl   && `CDL-${cdl} driver looking for`,
          ops   && `${ops} freight`,
          state && `in or near ${state}`,
          pay,
        ].filter(Boolean).join(' ') || 'CDL truck driver job';

        const semanticResult = await searchCarriersSemantic(
          semanticQuery,
          {},
          Math.min(carrierItems.length, 200)
        );
        if (semanticResult?.results) {
          for (const r of semanticResult.results) {
            semanticScoreMap.set(r.carrierId, r.score);
          }
          console.log(`[carrierMatching] Semantic pre-fetch: ${semanticScoreMap.size} scores loaded`);
        }
      } catch (err) {
        console.warn('[carrierMatching] Semantic pre-fetch failed (non-blocking):', err.message);
      }
    }

    // STEP 2: Score all carriers (synchronous, ~10ms)
    const customWeights = driverPrefs.customWeights || fetchedWeights;
    const scoredCarriers = carrierItems.map(rawCarrier => {
      const scored = calculateMatchScore(driverPrefs, rawCarrier, customWeights);
      if (FEATURE_FLAGS.semanticSearchBlendEnabled && semanticScoreMap.has(rawCarrier._id)) {
        scored.overallScore = blendSemanticScore(scored.overallScore, semanticScoreMap.get(rawCarrier._id));
      }
      return scored;
    });

    // STEP 3: Group divisions of the same carrier
    const groupedCarriers = {};
    for (const scored of scoredCarriers) {
      const legalName = scored.carrier.LEGAL_NAME;
      if (!groupedCarriers[legalName] || scored.overallScore > groupedCarriers[legalName].overallScore) {
        groupedCarriers[legalName] = scored;
      }
    }
    const distinctCarriers = Object.values(groupedCarriers);

    // STEP 4: Filter and sort
    const validCarriers = distinctCarriers.filter(c => c.overallScore >= 10);
    validCarriers.sort((a, b) => b.overallScore - a.overallScore);
    const topMatches = validCarriers.slice(0, maxResults);

    // STEP 5: Build response
    const matchesWithStatus = topMatches.map(m => ({
      ...m,
      enrichment: null,
      needsEnrichment: true,
      fromCache: false,
      recruiterStats: null
    }));

    const elapsed = Date.now() - startTime;
    console.log(`‚úÖ Match complete: ${matchesWithStatus.length} results in ${elapsed}ms`);

    // Fire-and-forget: ALL observability AFTER building the response
    Promise.all([
      startTrace('findMatchingCarriers', { isPremiumUser, tags: ['carrier-matching'], traceId }),
      log({ level: 'INFO', source: 'carrier-matching', message: `Match complete: ${matchesWithStatus.length} results`, traceId, duration: elapsed, details: { totalScored: scoredCarriers.length, totalMatches: validCarriers.length, returned: matchesWithStatus.length } }),
      logDatabase({ operation: 'query', collection: 'Carriers', affectedRows: carrierItems.length, latencyMs: queryLatency, traceId }),
      endTrace(traceId, 'completed', { totalMatches: matchesWithStatus.length, totalScored: scoredCarriers.length, elapsed })
    ]).catch(() => {});

    const driverProfile = profileRef.value;

    return {
      success: true,
      matches: matchesWithStatus,
      totalScored: scoredCarriers.length,
      totalMatches: validCarriers.length,
      userTier: isPremiumUser ? 'premium' : 'free',
      maxAllowed: maxResults,
      cachedCount: 0,
      needsEnrichmentCount: matchesWithStatus.length,
      driverProfile: driverProfile ? {
        id: driverProfile._id,
        displayName: driverProfile.display_name,
        completeness: driverProfile.profile_completeness_score,
        totalSearches: driverProfile.total_searches,
        isComplete: driverProfile.is_complete,
        missingFields: driverProfile.missing_fields
      } : null,
      upsellMessage: !isPremiumUser && validCarriers.length > maxResults
        ? `${validCarriers.length - maxResults} more matches available! Sign up to see all your matches.`
        : null
    };

  } catch (error) {
    console.error(`[carrierMatching] Pipeline error:`, error.message);
    Promise.all([
      log({ level: 'ERROR', source: 'carrier-matching', message: `Match failed: ${error.message}`, traceId, details: { error: error.message } }),
      endTrace(traceId, 'error', { error: error.message })
    ]).catch(() => {});

    return {
      success: false,
      matches: [],
      totalScored: 0,
      error: error.message,
      userTier: isPremiumUser ? 'premium' : 'free'
    };
  }
}

// ============================================================================
// EXPORTED FUNCTION - logMatchEvent
// ============================================================================

export async function logMatchEvent(matchEvent) {
  // Try to use the new driver-linked system first
  try {
    const interestResult = await logCarrierInterest({
      carrierDOT: matchEvent.carrierDOT,
      carrierName: matchEvent.carrierName,
      matchScore: matchEvent.matchScore,
      action: matchEvent.action || 'interested'
    });
    
    if (interestResult.success) {
      return { success: true, method: 'driver_linked', isNew: interestResult.isNew };
    }
  } catch (interestError) {
    console.log('‚ö†Ô∏è Driver interest system unavailable:', interestError.message);
  }
  
  // FALLBACK: MatchEvents collection for anonymous users
  try {
    const score = parseInt(matchEvent.matchScore);
    const dotNumber = parseInt(matchEvent.carrierDOT, 10);
    const zipNumber = parseInt(matchEvent.driverZip, 10);
    const formattedDate = new Date().toISOString().split('T')[0];

    const matchEventData = {
      driver_zip: isNaN(zipNumber) ? 0 : zipNumber,
      driver_name: matchEvent.driverName || 'Anonymous',
      carrier_dot: isNaN(dotNumber) ? 0 : dotNumber,
      carrier_name: matchEvent.carrierName,
      match_score: isNaN(score) ? 0 : score,
      action: matchEvent.action,
      timestamp: formattedDate
    };

    const insertResult = await dataAccess.insertRecord('matchEvents', matchEventData, { suppressAuth: true });
    if (!insertResult.success) throw new Error(insertResult.error);

    return { success: true, method: 'legacy' };
  } catch (error) {
    console.error('‚ùå Error logging match:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// NEW EXPORTED FUNCTION - Get driver's saved carriers
// ============================================================================

export async function getDriverSavedCarriers() {
  try {
    const { getDriverInterests } = await import('backend/driverProfiles');
    const result = await getDriverInterests();
    
    if (!result.success) return { success: false, carriers: [], error: result.error };
    
    const dotNumbers = result.interests.map(i => i.carrier_dot);
    if (dotNumbers.length === 0) return { success: true, carriers: [], totalCount: 0 };
    
    const carrierResult = await dataAccess.queryRecords('carriers', {
      filters: { dot_number: { hasSome: dotNumbers } }
    });

    const carrierMap = {};
    (carrierResult.items || []).forEach(carrier => {
      carrierMap[carrier.dot_number] = normalizeCarrier(carrier);
    });
    
    const enrichedCarriers = result.interests.map(interest => ({
      ...interest,
      carrier: carrierMap[interest.carrier_dot] || null
    }));
    
    return {
      success: true,
      carriers: enrichedCarriers,
      totalCount: result.totalCount
    };
    
  } catch (error) {
    console.error('‚ùå Error getting saved carriers:', error);
    return { success: false, carriers: [], error: error.message };
  }
}

/**
 * Normalize carrier data structure
 */
function normalizeCarrier(carrier) {
  return {
    dot_number: carrier.dot_number,
    legal_name: carrier.legal_name || carrier.title || 'Unknown Carrier',
    phy_city: carrier.phy_city,
    phy_state: carrier.phy_state,
    nbr_power_unit: carrier.nbr_power_unit,
    driver_total: carrier.driver_total,
    ...carrier
  };
}
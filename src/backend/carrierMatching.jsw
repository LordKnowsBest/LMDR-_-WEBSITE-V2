import wixData from 'wix-data';
import { getOrCreateDriverProfile, updateDriverPreferences, logCarrierInterest } from 'backend/driverProfiles';
import { log, logDatabase, startTrace, endTrace } from 'backend/observabilityService';

// Dual-source data access
import { usesAirtable, getWixCollectionName } from 'backend/config';
import * as dataAccess from 'backend/dataAccess';
import * as airtable from 'backend/airtableClient';

// ============================================================================
// SHARED SCORING MODULE
// ============================================================================
const { calculateMatchScore, CONFIG: SCORING_CONFIG } = require('backend/scoring');

const CONFIG = {
  collectionsName: 'Carriers',
  enrichmentsCollection: 'CarrierEnrichments',
  
  // MATCH LIMITS - Free vs Premium
  freeUserMaxResults: 2,
  premiumUserMaxResults: 10,
  
  defaultMaxDistance: 100
};

// ============================================================================
// CACHE LOOKUP
// ============================================================================

/**
 * Get existing enrichments from cache
 * Supports dual data sources via config.jsw
 */
async function getExistingEnrichments(dotNumbers) {
  if (!dotNumbers || dotNumbers.length === 0) return {};

  try {
    const dotStrings = dotNumbers.map(d => String(d));
    let items = [];

    // Check which data source to use for CarrierEnrichments
    if (usesAirtable('carrierEnrichments')) {
      // Airtable query - build OR formula for multiple DOT numbers
      const dotConditions = dotStrings.map(d => `{DOT Number} = '${d}'`).join(', ');
      const filterFormula = `OR(${dotConditions})`;

      const result = await airtable.queryRecords('CarrierEnrichments', {
        filterByFormula: filterFormula
      });

      items = result.records || [];
    } else {
      // Wix Data query (existing logic)
      const result = await wixData.query(CONFIG.enrichmentsCollection)
        .hasSome('dot_number', dotStrings)
        .find();
      items = result.items;
    }

    const enrichmentMap = {};
    for (const item of items) {
      const enrichedDate = item.enriched_date;
      const daysSince = enrichedDate
        ? (Date.now() - new Date(enrichedDate).getTime()) / (1000 * 60 * 60 * 24)
        : 999;

      if (daysSince <= 14) {
        enrichmentMap[item.dot_number] = {
          ...item,
          fromCache: true,
          cacheAge: Math.round(daysSince)
        };
      }
    }

    console.log(`üì¶ Found ${Object.keys(enrichmentMap).length} cached enrichments`);
    return enrichmentMap;

  } catch (error) {
    console.error('Cache lookup error:', error.message);
    return {};
  }
}

// ============================================================================
// MAIN EXPORTED FUNCTION - findMatchingCarriers
// Now integrates with Driver Profile system
// ============================================================================

export async function findMatchingCarriers(driverPrefs, isPremiumUser = false) {
  const startTime = Date.now();

  // Start distributed trace for this matching operation
  const trace = await startTrace('findMatchingCarriers', {
    isPremiumUser,
    operationType: driverPrefs.operationType,
    tags: ['carrier-matching', 'search']
  });
  const traceId = trace.traceId;

  console.log('üöÄ ===== BACKEND: findMatchingCarriers =====');
  console.log('üìã Prefs received:', JSON.stringify(driverPrefs));
  console.log('üë§ Premium user:', isPremiumUser);
  await log({ level: 'INFO', source: 'carrier-matching', message: 'Starting carrier match', traceId, details: { isPremiumUser, operationType: driverPrefs.operationType } });

  const maxResults = isPremiumUser
    ? CONFIG.premiumUserMaxResults
    : CONFIG.freeUserMaxResults;

  console.log(`üìä Max results to return: ${maxResults}`);
  
  // =========================================================================
  // NEW: Update driver profile with search preferences
  // =========================================================================
  let driverProfile = null;
  try {
    const profileResult = await updateDriverPreferences(driverPrefs);
    if (profileResult.success) {
      driverProfile = profileResult.profile;
      console.log(`üë§ Updated driver profile: ${driverProfile._id}`);
      console.log(`   Completeness: ${driverProfile.profile_completeness_score}%`);
      console.log(`   Total searches: ${driverProfile.total_searches}`);
    } else {
      console.log(`‚ö†Ô∏è Profile update skipped: ${profileResult.error}`);
    }
  } catch (profileError) {
    console.log('‚ö†Ô∏è Profile system unavailable:', profileError.message);
    // Continue without profile - anonymous user
  }
  
  try {
    // STEP 1: Query the database (supports dual data sources)
    console.log('üìå Step 1: Querying Carriers collection...');
    const queryStartTime = Date.now();
    let carrierItems = [];

    // Check which data source to use for Carriers
    if (usesAirtable('carriers')) {
      // Airtable query path
      const airtableResult = await airtable.queryRecords('Carriers', {
        maxRecords: 500
      });
      carrierItems = airtableResult.records || [];
    } else {
      // Wix Data query path (existing logic)
      const query = wixData.query(CONFIG.collectionsName).limit(500);
      const results = await query.find();
      carrierItems = results.items;
    }

    const queryLatency = Date.now() - queryStartTime;

    await logDatabase({ operation: 'query', collection: CONFIG.collectionsName, affectedRows: carrierItems.length, latencyMs: queryLatency, traceId });

    console.log(`üìä Step 2: Query complete. Found ${carrierItems.length} carriers`);

    // Create a results object for compatibility with existing code
    const results = { items: carrierItems };
    
    if (results.items.length === 0) {
      console.warn('‚ö†Ô∏è No carriers found in database');
      await log({ level: 'WARN', source: 'carrier-matching', message: 'No carriers in database', traceId });
      await endTrace(traceId, 'completed', { totalMatches: 0, elapsed: Date.now() - startTime });
      return {
        success: true,
        matches: [],
        totalScored: 0,
        message: 'No carriers in database',
        userTier: isPremiumUser ? 'premium' : 'free',
        driverProfile: driverProfile ? { id: driverProfile._id, completeness: driverProfile.profile_completeness_score } : null
      };
    }
    
    // STEP 2: Log first raw carrier for debugging
    console.log('üîç Step 3: Sample raw carrier data:');
    const sampleCarrier = results.items[0];
    console.log('   Raw fields:', Object.keys(sampleCarrier).join(', '));
    console.log('   dot_number:', sampleCarrier.dot_number);
    console.log('   legal_name:', sampleCarrier.legal_name);
    console.log('   phy_city:', sampleCarrier.phy_city);
    console.log('   phy_state:', sampleCarrier.phy_state);
    console.log('   phy_zip:', sampleCarrier.phy_zip);
    
    // STEP 3: Score all carriers
    console.log('üßÆ Step 4: Scoring carriers...');
    const customWeights = driverPrefs.customWeights || SCORING_CONFIG.weights;
    const scoredCarriers = results.items.map(rawCarrier => 
      calculateMatchScore(driverPrefs, rawCarrier, customWeights)
    );
    
    // STEP 4: Composite Scoring - Group divisions of the same carrier
    console.log('üîÑ Step 5: Performing composite grouping...');
    const groupedCarriers = {};
    for (const scored of scoredCarriers) {
      const legalName = scored.carrier.LEGAL_NAME;
      // Keep the best division match for each legal entity
      if (!groupedCarriers[legalName] || scored.overallScore > groupedCarriers[legalName].overallScore) {
        groupedCarriers[legalName] = scored;
      }
    }
    const distinctCarriers = Object.values(groupedCarriers);

    // STEP 5: Filter and sort
    console.log('üîÑ Step 6: Filtering and sorting...');
    const validCarriers = distinctCarriers.filter(c => c.overallScore >= 10);
    validCarriers.sort((a, b) => b.overallScore - a.overallScore);
    
    console.log(`   Total scored: ${scoredCarriers.length}`);
    console.log(`   Distinct carriers: ${distinctCarriers.length}`);
    console.log(`   Valid (score >= 10): ${validCarriers.length}`);
    
    const topMatches = validCarriers.slice(0, maxResults);
    console.log(`   Returning top: ${topMatches.length}`);
    
    // STEP 6: Check enrichment cache & responsiveness
    console.log('üì¶ Step 7: Checking enrichment cache & responsiveness...');
    const dotNumbers = topMatches.map(m => m.carrier.DOT_NUMBER);
    const { getRecruiterStats } = await import('backend/recruiterStats');
    
    let cachedEnrichments = {};
    const responsivenessStats = {};
    
    try {
      cachedEnrichments = await getExistingEnrichments(dotNumbers);
      
      // Get responsiveness for top matches
      await Promise.all(dotNumbers.map(async (dot) => {
        try {
          const stats = await getRecruiterStats(dot);
          responsivenessStats[dot] = stats;
        } catch (e) {
          console.warn(`Could not get stats for ${dot}:`, e.message);
        }
      }));
    } catch (cacheErr) {
      console.warn('‚ö†Ô∏è Cache/Stats lookup failed:', cacheErr.message);
    }
    
    // STEP 7: Build final response
    console.log('üèóÔ∏è Step 8: Building response...');
    const matchesWithStatus = topMatches.map(m => {
      const dotNum = String(m.carrier.DOT_NUMBER);
      const cached = cachedEnrichments[dotNum];
      
      return {
        ...m,
        enrichment: cached || null,
        needsEnrichment: !cached,
        fromCache: !!cached,
        recruiterStats: responsivenessStats[dotNum] || null
      };
    });

    const needsFreshCount = matchesWithStatus.filter(m => m.needsEnrichment).length;
    
    // Log what we're returning
    console.log('‚úÖ Step 9: Response ready');
    console.log(`   Matches: ${matchesWithStatus.length}`);
    console.log(`   Cached: ${matchesWithStatus.length - needsFreshCount}`);
    console.log(`   Need enrichment: ${needsFreshCount}`);
    
    if (matchesWithStatus.length > 0) {
      console.log('üèÜ Top match:');
      const top = matchesWithStatus[0];
      console.log(`   ${top.carrier.LEGAL_NAME} (DOT: ${top.carrier.DOT_NUMBER})`);
      console.log(`   ${top.carrier.PHY_CITY}, ${top.carrier.PHY_STATE}`);
      console.log(`   Score: ${top.overallScore}%`);
    }

    const elapsed = Date.now() - startTime;
    await log({
      level: 'INFO',
      source: 'carrier-matching',
      message: `Match complete: ${matchesWithStatus.length} results`,
      traceId,
      duration: elapsed,
      details: { totalScored: scoredCarriers.length, totalMatches: validCarriers.length, returned: matchesWithStatus.length }
    });
    await endTrace(traceId, 'completed', { totalMatches: matchesWithStatus.length, totalScored: scoredCarriers.length, elapsed });

    return {
      success: true,
      matches: matchesWithStatus,
      totalScored: scoredCarriers.length,
      totalMatches: validCarriers.length,
      userTier: isPremiumUser ? 'premium' : 'free',
      maxAllowed: maxResults,
      cachedCount: matchesWithStatus.length - needsFreshCount,
      needsEnrichmentCount: needsFreshCount,

      // NEW: Include driver profile info for frontend personalization
      driverProfile: driverProfile ? {
        id: driverProfile._id,
        displayName: driverProfile.display_name,
        completeness: driverProfile.profile_completeness_score,
        totalSearches: driverProfile.total_searches,
        isComplete: driverProfile.is_complete,
        missingFields: driverProfile.missing_fields
      } : null,

      upsellMessage: !isPremiumUser && validCarriers.length > maxResults
        ? `${validCarriers.length - maxResults} more matches available! Sign up to see all your matches.`
        : null
    };

  } catch (error) {
    console.error('‚ùå BACKEND ERROR:', error);
    console.error('   Message:', error.message);
    console.error('   Stack:', error.stack);
    await log({ level: 'ERROR', source: 'carrier-matching', message: `Match failed: ${error.message}`, traceId, details: { error: error.message } });
    await endTrace(traceId, 'error', { error: error.message });

    return {
      success: false,
      matches: [],
      totalScored: 0,
      error: error.message,
      userTier: isPremiumUser ? 'premium' : 'free'
    };
  }
}

// ============================================================================
// EXPORTED FUNCTION - logMatchEvent
// Now uses the new DriverCarrierInterests system for logged-in users
// Falls back to anonymous MatchEvents for non-logged-in users
// ============================================================================

export async function logMatchEvent(matchEvent) {
  console.log('üìù Logging match event:', matchEvent.carrierName);
  
  // Try to use the new driver-linked system first
  try {
    const interestResult = await logCarrierInterest({
      carrierDOT: matchEvent.carrierDOT,
      carrierName: matchEvent.carrierName,
      matchScore: matchEvent.matchScore,
      action: matchEvent.action || 'interested'
    });
    
    if (interestResult.success) {
      console.log('‚úÖ Interest logged to DriverCarrierInterests');
      return { 
        success: true, 
        method: 'driver_linked',
        isNew: interestResult.isNew
      };
    }
    
    // If user is anonymous, fall back to old system
    if (interestResult.isAnonymous) {
      console.log('üë§ Anonymous user - falling back to MatchEvents');
    }
    
  } catch (interestError) {
    console.log('‚ö†Ô∏è Driver interest system unavailable:', interestError.message);
  }
  
  // FALLBACK: Use the legacy MatchEvents collection for anonymous users
  // Supports dual data sources via config.jsw
  try {
    const score = parseInt(matchEvent.matchScore);

    // Airtable expects numeric fields for DOT and ZIP
    const dotNumber = parseInt(matchEvent.carrierDOT, 10);
    const zipNumber = parseInt(matchEvent.driverZip, 10);

    // Format timestamp as YYYY-MM-DD for Airtable date field (not datetime)
    const now = new Date();
    const formattedDate = now.toISOString().split('T')[0];

    const matchEventData = {
      driver_zip: isNaN(zipNumber) ? 0 : zipNumber,
      driver_name: matchEvent.driverName || 'Anonymous',
      carrier_dot: isNaN(dotNumber) ? 0 : dotNumber,
      carrier_name: matchEvent.carrierName,
      match_score: isNaN(score) ? 0 : score,
      action: matchEvent.action,
      timestamp: formattedDate
    };

    const insertResult = await dataAccess.insertRecord('matchEvents', matchEventData, { suppressAuth: true });

    if (!insertResult.success) {
      throw new Error(insertResult.error);
    }

    console.log('‚úÖ Match event logged to MatchEvents (legacy)');
    return { success: true, method: 'legacy' };

  } catch (error) {
    console.error('‚ùå Error logging match:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// NEW EXPORTED FUNCTION - Get driver's saved carriers
// ============================================================================

export async function getDriverSavedCarriers() {
  try {
    // Import at runtime to avoid circular dependency
    const { getDriverInterests } = await import('backend/driverProfiles');
    
    const result = await getDriverInterests();
    
    if (!result.success) {
      return { success: false, carriers: [], error: result.error };
    }
    
    // Enrich with carrier data
    const dotNumbers = result.interests.map(i => i.carrier_dot);
    
    if (dotNumbers.length === 0) {
      return { success: true, carriers: [], totalCount: 0 };
    }
    
    // Get carrier details using dual-source data access
    let carrierItems = [];

    if (usesAirtable('carriers')) {
      // Airtable query - build OR formula for multiple DOT numbers
      const dotConditions = dotNumbers.map(d => `{DOT Number} = '${d}'`).join(', ');
      const filterFormula = `OR(${dotConditions})`;

      const airtableResult = await airtable.queryRecords('Carriers', {
        filterByFormula: filterFormula
      });
      carrierItems = airtableResult.records || [];
    } else {
      const carrierResult = await wixData.query(CONFIG.collectionsName)
        .hasSome('dot_number', dotNumbers)
        .find();
      carrierItems = carrierResult.items;
    }

    const carrierMap = {};
    for (const carrier of carrierItems) {
      carrierMap[carrier.dot_number] = normalizeCarrier(carrier);
    }
    
    // Combine interests with carrier data
    const enrichedCarriers = result.interests.map(interest => ({
      ...interest,
      carrier: carrierMap[interest.carrier_dot] || null
    }));
    
    return {
      success: true,
      carriers: enrichedCarriers,
      totalCount: result.totalCount
    };
    
  } catch (error) {
    console.error('‚ùå Error getting saved carriers:', error);
    return { success: false, carriers: [], error: error.message };
  }
}

/**
 * Normalize carrier data structure
 */
function normalizeCarrier(carrier) {
  return {
    dot_number: carrier.dot_number,
    legal_name: carrier.legal_name || carrier.title || 'Unknown Carrier',
    phy_city: carrier.phy_city,
    phy_state: carrier.phy_state,
    nbr_power_unit: carrier.nbr_power_unit,
    driver_total: carrier.driver_total,
    ...carrier
  };
}

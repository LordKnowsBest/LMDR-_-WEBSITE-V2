import { updateDriverPreferences, logCarrierInterest } from 'backend/driverProfiles';
import { log, logDatabase, startTrace, endTrace } from 'backend/observabilityService';
import * as dataAccess from 'backend/dataAccess';
import { seedCarriers } from 'backend/seeds/seedMockData';

// ============================================================================
// SHARED SCORING MODULE
// ============================================================================
const { calculateMatchScore, CONFIG: SCORING_CONFIG } = require('backend/scoring');
import { getCarrierMatchingWeights } from 'backend/admin_config_service';

const CONFIG = {
  // MATCH LIMITS - Free vs Premium
  freeUserMaxResults: 2,
  premiumUserMaxResults: 10,
  
  defaultMaxDistance: 100
};

// ============================================================================
// CACHE LOOKUP
// ============================================================================

/**
 * Get existing enrichments from cache
 */
async function getExistingEnrichments(dotNumbers) {
  if (!dotNumbers || dotNumbers.length === 0) return {};

  try {
    const dotStrings = dotNumbers.map(d => String(d));
    
    const result = await dataAccess.queryRecords('carrierEnrichments', {
      filters: { dot_number: { hasSome: dotStrings } }
    });

    const items = result.items || [];
    const enrichmentMap = {};
    for (const item of items) {
      const enrichedDate = item.enriched_date;
      const daysSince = enrichedDate
        ? (Date.now() - new Date(enrichedDate).getTime()) / (1000 * 60 * 60 * 24)
        : 999;

      if (daysSince <= 14) {
        enrichmentMap[item.dot_number] = {
          ...item,
          fromCache: true,
          cacheAge: Math.round(daysSince)
        };
      }
    }

    console.log(`üì¶ Found ${Object.keys(enrichmentMap).length} cached enrichments`);
    return enrichmentMap;

  } catch (error) {
    console.error('Cache lookup error:', error.message);
    return {};
  }
}

// ============================================================================
// MAIN EXPORTED FUNCTION - findMatchingCarriers
// ============================================================================

export async function findMatchingCarriers(driverPrefs, isPremiumUser = false) {
  const startTime = Date.now();

  // Start distributed trace for this matching operation
  const trace = await startTrace('findMatchingCarriers', {
    isPremiumUser,
    operationType: driverPrefs.operationType,
    tags: ['carrier-matching', 'search']
  });
  const traceId = trace.traceId;

  console.log('üöÄ ===== BACKEND: findMatchingCarriers =====');
  console.log('üìã Prefs received:', JSON.stringify(driverPrefs));
  console.log('üë§ Premium user:', isPremiumUser);
  await log({ level: 'INFO', source: 'carrier-matching', message: 'Starting carrier match', traceId, details: { isPremiumUser, operationType: driverPrefs.operationType } });

  const maxResults = isPremiumUser
    ? CONFIG.premiumUserMaxResults
    : CONFIG.freeUserMaxResults;

  console.log(`üìä Max results to return: ${maxResults}`);
  
  // NEW: Update driver profile with search preferences
  let driverProfile = null;
  try {
    const profileResult = await updateDriverPreferences(driverPrefs);
    if (profileResult.success) {
      driverProfile = profileResult.profile;
      console.log(`üë§ Updated driver profile: ${driverProfile._id}`);
    }
  } catch (profileError) {
    console.log('‚ö†Ô∏è Profile system unavailable:', profileError.message);
  }
  
  try {
    // STEP 1: Query the database
    console.log('üìå Step 1: Querying Carriers collection...');
    const queryStartTime = Date.now();
    
    const result = await dataAccess.queryRecords('carriers', {
      limit: 500
    });

    if (!result.success) throw new Error(result.error);
    let carrierItems = result.items || [];

    const queryLatency = Date.now() - queryStartTime;
    await logDatabase({ operation: 'query', collection: 'Carriers', affectedRows: carrierItems.length, latencyMs: queryLatency, traceId });

    // SEEDING LOGIC
    if (carrierItems.length === 0) {
      console.warn('‚ö†Ô∏è No carriers found in database. Seeding mock carriers...');
      await log({ level: 'WARN', source: 'carrier-matching', message: 'No carriers in database, attempting seed', traceId });

      const seedResult = await seedCarriers();
      if (seedResult.seeded) {
          const reQueryResult = await dataAccess.queryRecords('carriers', { limit: 500 });
          carrierItems = reQueryResult.items || [];
      }
    }

    console.log(`üìä Step 2: Query complete. Found ${carrierItems.length} carriers`);

    if (carrierItems.length === 0) {
      await endTrace(traceId, 'completed', { totalMatches: 0, elapsed: Date.now() - startTime });
      return {
        success: true,
        matches: [],
        totalScored: 0,
        message: 'No carriers in database',
        userTier: isPremiumUser ? 'premium' : 'free',
        driverProfile: driverProfile ? { id: driverProfile._id, completeness: driverProfile.profile_completeness_score } : null
      };
    }
    
    // STEP 2: Score all carriers
    console.log('üßÆ Step 3: Scoring carriers...');
    
    // Fetch global weights from config service
    let globalWeights = SCORING_CONFIG.weights;
    try {
        globalWeights = await getCarrierMatchingWeights();
    } catch (e) {
        console.warn('‚ö†Ô∏è Failed to fetch global weights, using defaults');
    }

    const customWeights = driverPrefs.customWeights || globalWeights;
    const scoredCarriers = carrierItems.map(rawCarrier => 
      calculateMatchScore(driverPrefs, rawCarrier, customWeights)
    );
    
    // STEP 3: Composite Scoring - Group divisions of the same carrier
    console.log('üîÑ Step 4: Performing composite grouping...');
    const groupedCarriers = {};
    for (const scored of scoredCarriers) {
      const legalName = scored.carrier.LEGAL_NAME;
      if (!groupedCarriers[legalName] || scored.overallScore > groupedCarriers[legalName].overallScore) {
        groupedCarriers[legalName] = scored;
      }
    }
    const distinctCarriers = Object.values(groupedCarriers);

    // STEP 4: Filter and sort
    console.log('üîÑ Step 5: Filtering and sorting...');
    const validCarriers = distinctCarriers.filter(c => c.overallScore >= 10);
    validCarriers.sort((a, b) => b.overallScore - a.overallScore);
    
    const topMatches = validCarriers.slice(0, maxResults);
    
    // STEP 5: Check enrichment cache & responsiveness
    console.log('üì¶ Step 6: Checking enrichment cache & responsiveness...');
    const dotNumbers = topMatches.map(m => m.carrier.DOT_NUMBER);
    const { getRecruiterStats } = await import('backend/recruiterStats');
    
    let cachedEnrichments = {};
    const responsivenessStats = {};
    
    try {
      cachedEnrichments = await getExistingEnrichments(dotNumbers);
      
      await Promise.all(dotNumbers.map(async (dot) => {
        try {
          const stats = await getRecruiterStats(dot);
          responsivenessStats[dot] = stats;
        } catch (e) { /* ignore */ }
      }));
    } catch (cacheErr) {
      console.warn('‚ö†Ô∏è Cache/Stats lookup failed:', cacheErr.message);
    }
    
    // STEP 6: Build final response
    const matchesWithStatus = topMatches.map(m => {
      const dotNum = String(m.carrier.DOT_NUMBER);
      const cached = cachedEnrichments[dotNum];
      
      return {
        ...m,
        enrichment: cached || null,
        needsEnrichment: !cached,
        fromCache: !!cached,
        recruiterStats: responsivenessStats[dotNum] || null
      };
    });

    const needsFreshCount = matchesWithStatus.filter(m => m.needsEnrichment).length;
    const elapsed = Date.now() - startTime;

    await log({
      level: 'INFO',
      source: 'carrier-matching',
      message: `Match complete: ${matchesWithStatus.length} results`,
      traceId,
      duration: elapsed,
      details: { totalScored: scoredCarriers.length, totalMatches: validCarriers.length, returned: matchesWithStatus.length }
    });
    await endTrace(traceId, 'completed', { totalMatches: matchesWithStatus.length, totalScored: scoredCarriers.length, elapsed });

    return {
      success: true,
      matches: matchesWithStatus,
      totalScored: scoredCarriers.length,
      totalMatches: validCarriers.length,
      userTier: isPremiumUser ? 'premium' : 'free',
      maxAllowed: maxResults,
      cachedCount: matchesWithStatus.length - needsFreshCount,
      needsEnrichmentCount: needsFreshCount,
      driverProfile: driverProfile ? {
        id: driverProfile._id,
        displayName: driverProfile.display_name,
        completeness: driverProfile.profile_completeness_score,
        totalSearches: driverProfile.total_searches,
        isComplete: driverProfile.is_complete,
        missingFields: driverProfile.missing_fields
      } : null,
      upsellMessage: !isPremiumUser && validCarriers.length > maxResults
        ? `${validCarriers.length - maxResults} more matches available! Sign up to see all your matches.`
        : null
    };

  } catch (error) {
    await log({ level: 'ERROR', source: 'carrier-matching', message: `Match failed: ${error.message}`, traceId, details: { error: error.message } });
    await endTrace(traceId, 'error', { error: error.message });

    return {
      success: false,
      matches: [],
      totalScored: 0,
      error: error.message,
      userTier: isPremiumUser ? 'premium' : 'free'
    };
  }
}

// ============================================================================
// EXPORTED FUNCTION - logMatchEvent
// ============================================================================

export async function logMatchEvent(matchEvent) {
  // Try to use the new driver-linked system first
  try {
    const interestResult = await logCarrierInterest({
      carrierDOT: matchEvent.carrierDOT,
      carrierName: matchEvent.carrierName,
      matchScore: matchEvent.matchScore,
      action: matchEvent.action || 'interested'
    });
    
    if (interestResult.success) {
      return { success: true, method: 'driver_linked', isNew: interestResult.isNew };
    }
  } catch (interestError) {
    console.log('‚ö†Ô∏è Driver interest system unavailable:', interestError.message);
  }
  
  // FALLBACK: MatchEvents collection for anonymous users
  try {
    const score = parseInt(matchEvent.matchScore);
    const dotNumber = parseInt(matchEvent.carrierDOT, 10);
    const zipNumber = parseInt(matchEvent.driverZip, 10);
    const formattedDate = new Date().toISOString().split('T')[0];

    const matchEventData = {
      driver_zip: isNaN(zipNumber) ? 0 : zipNumber,
      driver_name: matchEvent.driverName || 'Anonymous',
      carrier_dot: isNaN(dotNumber) ? 0 : dotNumber,
      carrier_name: matchEvent.carrierName,
      match_score: isNaN(score) ? 0 : score,
      action: matchEvent.action,
      timestamp: formattedDate
    };

    const insertResult = await dataAccess.insertRecord('matchEvents', matchEventData, { suppressAuth: true });
    if (!insertResult.success) throw new Error(insertResult.error);

    return { success: true, method: 'legacy' };
  } catch (error) {
    console.error('‚ùå Error logging match:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// NEW EXPORTED FUNCTION - Get driver's saved carriers
// ============================================================================

export async function getDriverSavedCarriers() {
  try {
    const { getDriverInterests } = await import('backend/driverProfiles');
    const result = await getDriverInterests();
    
    if (!result.success) return { success: false, carriers: [], error: result.error };
    
    const dotNumbers = result.interests.map(i => i.carrier_dot);
    if (dotNumbers.length === 0) return { success: true, carriers: [], totalCount: 0 };
    
    const carrierResult = await dataAccess.queryRecords('carriers', {
      filters: { dot_number: { hasSome: dotNumbers } }
    });

    const carrierMap = {};
    (carrierResult.items || []).forEach(carrier => {
      carrierMap[carrier.dot_number] = normalizeCarrier(carrier);
    });
    
    const enrichedCarriers = result.interests.map(interest => ({
      ...interest,
      carrier: carrierMap[interest.carrier_dot] || null
    }));
    
    return {
      success: true,
      carriers: enrichedCarriers,
      totalCount: result.totalCount
    };
    
  } catch (error) {
    console.error('‚ùå Error getting saved carriers:', error);
    return { success: false, carriers: [], error: error.message };
  }
}

/**
 * Normalize carrier data structure
 */
function normalizeCarrier(carrier) {
  return {
    dot_number: carrier.dot_number,
    legal_name: carrier.legal_name || carrier.title || 'Unknown Carrier',
    phy_city: carrier.phy_city,
    phy_state: carrier.phy_state,
    nbr_power_unit: carrier.nbr_power_unit,
    driver_total: carrier.driver_total,
    ...carrier
  };
}
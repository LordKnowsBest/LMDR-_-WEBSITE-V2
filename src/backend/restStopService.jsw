import wixUsers from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    restStopReviews: 'restStopReviews',
    restStopConditionReports: 'restStopConditionReports',
    parkingLocations: 'parkingLocations'
};

// ============================================
// SERVICE FUNCTIONS
// ============================================

export async function getLocationReviews(locationId, options = {}) {
    if (!locationId) return { success: false, error: 'Location ID required' };
    try {
        const sort = options.sort || 'recent';
        const queryOptions = { filters: { location_id: locationId }, limit: options.limit || 20, suppressAuth: true };
        
        if (sort === 'helpful') queryOptions.sort = [{ field: 'helpful_votes', direction: 'desc' }];
        else if (sort === 'rating') queryOptions.sort = [{ field: 'overall_rating', direction: 'desc' }];
        else queryOptions.sort = [{ field: '_createdDate', direction: 'desc' }];

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.restStopReviews, queryOptions);
        const stats = await calculateLocationStats(locationId);
        return { success: true, reviews: result.items || [], stats };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

export async function submitReview(locationId, reviewData) {
    const user = wixUsers.currentUser;
    if (!user.loggedIn) return { success: false, error: 'Must be logged in' };
    
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const recentRes = await dataAccess.queryRecords(COLLECTION_KEYS.restStopReviews, {
        filters: { location_id: locationId, driver_id: user.id, _createdDate: { gt: thirtyDaysAgo } },
        limit: 1, suppressAuth: true
    });

    if (recentRes.items?.length) return { success: false, error: 'Already reviewed recently' };

    const record = {
        location_id: locationId, driver_id: user.id, overall_rating: reviewData.overall_rating,
        ratings: JSON.stringify(reviewData.ratings || {}), review_text: reviewData.text,
        photos: JSON.stringify(reviewData.photos || []), helpful_votes: 0, is_verified: false,
        _createdDate: new Date()
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.restStopReviews, record, { suppressAuth: true });
    return { success: result.success, review: result.record };
}

export async function submitConditionReport(locationId, reportData) {
    const user = wixUsers.currentUser;
    if (!user.loggedIn) return { success: false, error: 'Must be logged in' };

    const record = {
        location_id: locationId, report_type: reportData.type, details: reportData.details,
        reporter_id: user.id, confirmations: 0,
        expires_at: new Date(Date.now() + 24 * 3600000).toISOString(), _createdDate: new Date()
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.restStopConditionReports, record, { suppressAuth: true });
    return { success: result.success, report: result.record };
}

export async function voteReview(reviewId, isHelpful) {
    const user = wixUsers.currentUser;
    if (!user.loggedIn) return { success: false, error: 'Must be logged in' };

    try {
        const review = await dataAccess.getRecord(COLLECTION_KEYS.restStopReviews, reviewId, { suppressAuth: true });
        if (!review) return { success: false, error: 'Not found' };

        const update = { ...review, _id: reviewId, helpful_votes: (review.helpful_votes || 0) + (isHelpful ? 1 : -1) };
        await dataAccess.updateRecord(COLLECTION_KEYS.restStopReviews, update, { suppressAuth: true });
        return { success: true, helpful_votes: update.helpful_votes };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

export async function getTopRatedStops(lat, lng, radius, filters = {}) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.parkingLocations, {
            filters: { avg_rating: { gt: 4 } }, limit: 50, suppressAuth: true
        });
        const locations = result.items || [];
            
        const R = 3958.8;
        const items = locations.filter(loc => {
            if (!loc.location) return false;
            const dLat = (loc.location.lat - lat) * Math.PI / 180;
            const dLon = (loc.location.lng - lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat * Math.PI / 180) * Math.cos(loc.location.lat * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return (R * c) <= radius;
        });

        items.sort((a,b) => (b.avg_rating || 0) - (a.avg_rating || 0));
        return { success: true, items };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async function calculateLocationStats(locationId) {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.restStopReviews, { filters: { location_id: locationId }, limit: 500, suppressAuth: true });
    const items = result.items || [];
    if (!items.length) return { avg_rating: 0, count: 0 };
    
    const sum = items.reduce((acc, curr) => acc + (curr.overall_rating || 0), 0);
    return { avg_rating: (sum / items.length).toFixed(1), count: items.length };
}

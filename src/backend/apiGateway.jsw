import * as dataAccess from 'backend/dataAccess';
import { getSecret } from 'wix-secrets-backend';
import { validateApiKey } from 'backend/apiAuthService';
import { checkAndTrackUsage } from 'backend/rateLimitService';
import {
  getExternalCarrierSafety,
  batchExternalCarrierSafety
} from 'backend/externalFmcsaApi';
import { getExternalCurrentCSA, getExternalCSAHistory } from 'backend/externalCsaApi';
import {
  getExternalCarrierIntelligence,
  getExternalSentiment,
  getExternalMarketIntelligence,
  searchExternalCarriers
} from 'backend/externalIntelligenceApi';
import {
  searchExternalParking,
  getExternalParkingLocation
} from 'backend/externalParkingApi';
import {
  searchExternalFuelPrices,
  planExternalRouteFuel,
  getExternalFuelStation
} from 'backend/externalFuelApi';
import {
  searchExternalDrivers,
  getExternalDriverProfile,
  matchExternalCarriers,
  checkExternalQualification
} from 'backend/externalMatchingApi';
import {
  extractExternalCDL,
  extractExternalMedCert,
  verifyExternalDocument,
  processExternalDocumentBatch,
  getExternalBatchStatus
} from 'backend/externalDocumentApi';
import {
  getExternalUserProgress,
  awardExternalXP,
  checkExternalAchievements,
  getExternalLeaderboard,
  subscribeExternalEngagementWebhook
} from 'backend/externalEngagementApi';
import { authorizeProductAccess } from 'backend/apiProductAccessService';
import { generateWebhookSecret } from 'backend/apiWebhookService';

const COLLECTIONS = {
  requestLog: 'apiRequestLog',
  alertSubscriptions: 'apiAlertSubscriptions'
};

const JSON_HEADERS = {
  'Content-Type': 'application/json; charset=utf-8',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Authorization, Content-Type',
  'Access-Control-Allow-Methods': 'GET,POST,DELETE,OPTIONS'
};

/**
 * Main gateway request handler.
 * @param {Object} request
 * @returns {Promise<Object>}
 */
export async function handleGatewayRequest(request) {
  const startedAt = Date.now();
  const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  const method = String(request?.method || 'GET').toUpperCase();
  const routePath = getRoutePath(request);
  const ipAddress = getIpAddress(request);
  const userAgent = getHeader(request, 'user-agent') || null;

  if (!routePath.startsWith('/v1/')) {
    return errorResponse(404, requestId, 'resource_not_found', 'Endpoint not found');
  }

  let authContext = null;
  let statusCode = 200;
  let payload = null;
  let responseHeaders = {};

  try {
    if (method === 'OPTIONS') {
      return {
        status: 200,
        headers: JSON_HEADERS,
        body: { ok: true }
      };
    }

    authContext = await validateApiKey({
      authorizationHeader: getHeader(request, 'authorization'),
      ipAddress
    });

    if (!authContext.success) {
      statusCode = authErrorStatus(authContext.errorCode);
      return errorResponse(statusCode, requestId, authContext.errorCode, authContext.message);
    }

    const usageCheck = await checkAndTrackUsage({
      partnerId: authContext.partner?.partner_id,
      tier: authContext.tier,
      subscription: authContext.subscription,
      endpoint: routePath,
      bypassRateLimit: await shouldBypassRateLimit(request),
      statusCode: 200,
      latencyMs: 0
    });

    if (!usageCheck.allowed) {
      statusCode = 429;
      return errorResponse(
        429,
        requestId,
        usageCheck.errorCode,
        usageCheck.errorCode === 'quota_exceeded' ?
          'Monthly API quota exceeded' :
          'Rate limit exceeded',
        { retry_after: usageCheck.retryAfter },
        usageCheck.headers
      );
    }

    responseHeaders = usageCheck.headers || {};
    const routed = await routeRequest({
      request,
      method,
      routePath,
      authContext
    });

    statusCode = routed.status || 200;
    payload = routed.payload || {};
    responseHeaders = { ...responseHeaders, ...(routed.headers || {}) };
  } catch (error) {
    statusCode = statusForErrorCode(error?.code || 'internal_error');
    payload = {
      error: {
        code: error?.code || 'internal_error',
        message: error.message || 'Unexpected API error'
      },
      request_id: requestId
    };
  } finally {
    await logRequest({
      requestId,
      routePath,
      method,
      statusCode,
      startedAt,
      partnerId: authContext?.partner?.partner_id || null,
      apiKeyId: authContext?.apiKey?.key_id || null,
      ipAddress,
      userAgent
    });
  }

  if (statusCode >= 400) {
    if (payload?.error?.code) {
      return errorResponse(
        statusCode,
        requestId,
        payload.error.code,
        payload.error.message || 'Request failed',
        payload.error
      );
    }
    return {
      status: statusCode,
      headers: { ...JSON_HEADERS, ...responseHeaders },
      body: payload
    };
  }

  return successResponse(statusCode, requestId, payload, responseHeaders);
}

async function routeRequest({ request, method, routePath, authContext }) {
  const tier = String(authContext?.tier || 'starter').toLowerCase();
  const productId = getProductIdForRoute(method, routePath);
  if (productId) {
    const access = await authorizeProductAccess(authContext, {
      productId,
      endpoint: routePath,
      method
    });
    if (!access.allowed) {
      const err = new Error('API product access denied');
      err.code = 'forbidden_product';
      throw err;
    }
  }

  if (method === 'GET' && /^\/v1\/safety\/carrier\/\d+$/.test(routePath)) {
    const dotNumber = routePath.split('/').pop();
    const result = await getExternalCarrierSafety(dotNumber);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/safety/carriers/batch') {
    const body = await parseBody(request);
    const result = await batchExternalCarrierSafety(body?.dot_numbers || []);
    return mapServiceResult(result);
  }

  if (method === 'GET' && /^\/v1\/safety\/csa\/\d+$/.test(routePath)) {
    const dotNumber = routePath.split('/').pop();
    const result = await getExternalCurrentCSA(dotNumber);
    return mapServiceResult(result);
  }

  if (method === 'GET' && /^\/v1\/safety\/csa\/\d+\/history$/.test(routePath)) {
    const parts = routePath.split('/');
    const dotNumber = parts[4];
    const months = Number(request?.query?.months || 6);
    const result = await getExternalCSAHistory(dotNumber, months);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/safety/alerts/subscribe') {
    const body = await parseBody(request);
    const subscription = await createAlertSubscription(authContext.partner?.partner_id, body);
    if (!subscription.success) {
      return {
        status: 400,
        payload: { error: { code: 'invalid_request', message: subscription.message } }
      };
    }
    return { status: 201, payload: subscription.data };
  }

  if (method === 'GET' && routePath === '/v1/safety/alerts/subscriptions') {
    const subscriptions = await listAlertSubscriptions(authContext.partner?.partner_id);
    return { status: 200, payload: { items: subscriptions } };
  }

  if (method === 'DELETE' && /^\/v1\/safety\/alerts\/[^/]+$/.test(routePath)) {
    const subscriptionId = routePath.split('/').pop();
    const deleted = await deleteAlertSubscription(authContext.partner?.partner_id, subscriptionId);
    if (!deleted) {
      return {
        status: 404,
        payload: { error: { code: 'resource_not_found', message: 'Subscription not found' } }
      };
    }
    return { status: 200, payload: { success: true } };
  }

  if (method === 'GET' && /^\/v1\/intelligence\/carrier\/\d+$/.test(routePath)) {
    const dotNumber = routePath.split('/').pop();
    const accessLevel = tier === 'starter' ? 'basic' : 'full';
    const result = await getExternalCarrierIntelligence(dotNumber, { accessLevel });
    return mapServiceResult(result);
  }

  if (method === 'GET' && /^\/v1\/intelligence\/sentiment\/\d+$/.test(routePath)) {
    assertTier(tier, 'growth');
    const dotNumber = routePath.split('/').pop();
    const result = await getExternalSentiment(dotNumber);
    return mapServiceResult(result);
  }

  if (method === 'GET' && routePath === '/v1/intelligence/market') {
    const result = await getExternalMarketIntelligence({
      region: request?.query?.region,
      freight_type: request?.query?.freight_type,
      operation_type: request?.query?.operation_type
    });
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/intelligence/carriers/search') {
    const body = await parseBody(request);
    const result = await searchExternalCarriers(body?.filters || {}, {
      limit: body?.limit,
      offset: body?.offset
    });
    return mapServiceResult(result);
  }

  if (method === 'GET' && routePath === '/v1/parking/search') {
    const result = await searchExternalParking(request?.query || {});
    return mapServiceResult(result);
  }

  if (method === 'GET' && /^\/v1\/parking\/location\/[^/]+$/.test(routePath)) {
    const locationId = routePath.split('/').pop();
    const result = await getExternalParkingLocation(locationId);
    return mapServiceResult(result);
  }

  if (method === 'GET' && routePath === '/v1/fuel/prices') {
    assertTier(tier, 'growth');
    const result = await searchExternalFuelPrices(request?.query || {});
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/fuel/plan') {
    assertTier(tier, 'growth');
    const body = await parseBody(request);
    const result = await planExternalRouteFuel(body);
    return mapServiceResult(result);
  }

  if (method === 'GET' && /^\/v1\/fuel\/station\/[^/]+$/.test(routePath)) {
    assertTier(tier, 'growth');
    const stationId = routePath.split('/').pop();
    const result = await getExternalFuelStation(stationId);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/matching/drivers/search') {
    assertTier(tier, 'enterprise');
    const body = await parseBody(request);
    const result = await searchExternalDrivers(body, authContext);
    const mapped = mapServiceResult(result, 200);
    await trackQuotaUsage(authContext.partner?.partner_id, result?.usageMetric, 1);
    return mapped;
  }

  if (method === 'GET' && /^\/v1\/matching\/driver\/[^/]+$/.test(routePath)) {
    assertTier(tier, 'enterprise');
    const driverId = routePath.split('/').pop();
    const result = await getExternalDriverProfile(driverId, request?.query || {}, authContext);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/matching/carriers') {
    const body = await parseBody(request);
    const result = await matchExternalCarriers(body);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/matching/qualify') {
    const body = await parseBody(request);
    const result = await checkExternalQualification(body);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/documents/cdl/extract') {
    assertTier(tier, 'growth');
    const body = await parseBody(request);
    const result = await extractExternalCDL(body);
    const mapped = mapServiceResult(result, 200);
    await trackQuotaUsage(authContext.partner?.partner_id, result?.usageMetric, 1);
    return mapped;
  }

  if (method === 'POST' && routePath === '/v1/documents/medcert/extract') {
    assertTier(tier, 'growth');
    const body = await parseBody(request);
    const result = await extractExternalMedCert(body);
    const mapped = mapServiceResult(result, 200);
    await trackQuotaUsage(authContext.partner?.partner_id, result?.usageMetric, 1);
    return mapped;
  }

  if (method === 'POST' && routePath === '/v1/documents/verify') {
    assertTier(tier, 'growth');
    const body = await parseBody(request);
    const result = await verifyExternalDocument(body);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/documents/batch') {
    assertTier(tier, 'growth');
    const body = await parseBody(request);
    const result = await processExternalDocumentBatch(body, {
      partnerId: authContext.partner?.partner_id || null
    });
    return mapServiceResult(result, 202);
  }

  if (method === 'GET' && /^\/v1\/documents\/batch\/[^/]+$/.test(routePath)) {
    assertTier(tier, 'growth');
    const jobId = routePath.split('/').pop();
    const result = await getExternalBatchStatus(jobId);
    return mapServiceResult(result);
  }

  if (method === 'GET' && /^\/v1\/engagement\/user\/[^/]+\/progress$/.test(routePath)) {
    assertTier(tier, 'enterprise');
    const parts = routePath.split('/');
    const userId = parts[4];
    const result = await getExternalUserProgress(userId, request?.query || {}, authContext);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/engagement/xp/award') {
    assertTier(tier, 'enterprise');
    const body = await parseBody(request);
    body.partner_id = authContext.partner?.partner_id || body.partner_id;
    const result = await awardExternalXP(body);
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/engagement/achievements/check') {
    assertTier(tier, 'enterprise');
    const body = await parseBody(request);
    body.partner_id = authContext.partner?.partner_id || body.partner_id;
    const result = await checkExternalAchievements(body);
    return mapServiceResult(result);
  }

  if (method === 'GET' && routePath === '/v1/engagement/leaderboard') {
    assertTier(tier, 'enterprise');
    const result = await getExternalLeaderboard(request?.query || {});
    return mapServiceResult(result);
  }

  if (method === 'POST' && routePath === '/v1/engagement/webhooks/subscribe') {
    assertTier(tier, 'enterprise');
    const body = await parseBody(request);
    const result = await subscribeExternalEngagementWebhook(authContext.partner?.partner_id, body);
    return mapServiceResult(result, 201);
  }

  return {
    status: 404,
    payload: { error: { code: 'resource_not_found', message: 'Endpoint not found' } }
  };
}

function mapServiceResult(result, successStatus = 200) {
  if (!result?.success) {
    const code = result?.errorCode || 'invalid_request';
    return {
      status: statusForErrorCode(code),
      payload: {
        error: {
          code,
          message: result?.message || 'Request failed'
        }
      }
    };
  }

  return {
    status: successStatus,
    payload: result.data || {}
  };
}

function statusForErrorCode(code) {
  if (code === 'invalid_api_key') return 401;
  if (code === 'subscription_inactive') return 403;
  if (code === 'forbidden_ip') return 403;
  if (code === 'resource_not_found') return 404;
  if (code === 'rate_limit_exceeded') return 429;
  if (code === 'quota_exceeded') return 429;
  if (code === 'forbidden_tier') return 403;
  if (code === 'forbidden_product') return 403;
  if (code === 'internal_error') return 500;
  return 400;
}

function assertTier(actualTier, requiredTier) {
  const order = { starter: 1, growth: 2, enterprise: 3, custom: 4 };
  const actual = order[String(actualTier || 'starter').toLowerCase()] || 1;
  const required = order[String(requiredTier || 'starter').toLowerCase()] || 1;
  if (actual < required) {
    const err = new Error(`Tier ${requiredTier} required`);
    err.code = 'forbidden_tier';
    throw err;
  }
}

function successResponse(status, requestId, data, extraHeaders = {}) {
  return {
    status,
    headers: { ...JSON_HEADERS, ...extraHeaders },
    body: {
      data,
      request_id: requestId
    }
  };
}

function errorResponse(status, requestId, code, message, extras = {}, extraHeaders = {}) {
  return {
    status,
    headers: { ...JSON_HEADERS, ...extraHeaders },
    body: {
      error: {
        code,
        message,
        ...extras
      },
      request_id: requestId
    }
  };
}

function authErrorStatus(code) {
  if (code === 'invalid_api_key') return 401;
  if (code === 'subscription_inactive' || code === 'forbidden_ip') return 403;
  return 401;
}

function getRoutePath(request) {
  const explicit = request?.path || '';
  const queryPath = request?.query?.path || '';
  const source = explicit || queryPath || safePathFromUrl(request?.url);
  const normalized = String(source || '');
  const index = normalized.indexOf('/v1/');
  if (index >= 0) return normalized.slice(index);
  return normalized.startsWith('/') ? normalized : `/${normalized}`;
}

function safePathFromUrl(url) {
  if (!url) return '';
  try {
    return new URL(url).pathname || '';
  } catch (_e) {
    return '';
  }
}

function getHeader(request, name) {
  const headers = request?.headers || {};
  const lower = String(name || '').toLowerCase();
  if (typeof headers.get === 'function') {
    return headers.get(name) || headers.get(lower) || null;
  }
  return headers[name] || headers[lower] || null;
}

function getIpAddress(request) {
  return (
    getHeader(request, 'x-forwarded-for') ||
    getHeader(request, 'x-real-ip') ||
    null
  );
}

async function shouldBypassRateLimit(request) {
  const headerValue = getHeader(request, 'x-lmdr-admin-bypass');
  if (!headerValue) return false;

  try {
    const secret = await getSecret('RATE_LIMIT_BYPASS_SECRET');
    if (!secret) return false;
    return headerValue === secret;
  } catch (_e) {
    return false;
  }
}

async function parseBody(request) {
  if (!request?.body) return {};
  if (typeof request.body.json === 'function') {
    try {
      return await request.body.json();
    } catch (_e) { }
  }

  if (typeof request.body.text === 'function') {
    const bodyText = await request.body.text();
    if (!bodyText) return {};
    try {
      return JSON.parse(bodyText);
    } catch (_e) {
      return {};
    }
  }

  return {};
}

function getProductIdForRoute(method, routePath) {
  const m = String(method || 'GET').toUpperCase();
  const path = String(routePath || '');

  if (path.startsWith('/v1/safety/')) return 'safety_suite';
  if (path.startsWith('/v1/intelligence/')) return 'intelligence_suite';
  if (path.startsWith('/v1/parking/') || path.startsWith('/v1/fuel/')) return 'operations_suite';
  if (path.startsWith('/v1/matching/')) return 'matching_suite';
  if (path.startsWith('/v1/documents/')) return 'document_suite';
  if (path.startsWith('/v1/engagement/')) return 'engagement_suite';

  // Explicitly return null for unmatched routes to preserve 404 handling.
  if (!m || !path) return null;
  return null;
}

async function trackQuotaUsage(partnerId, metricKey, amount = 1) {
  if (!partnerId || !metricKey) return;

  try {
    const periodKey = new Date().toISOString().slice(0, 7);
    const result = await dataAccess.queryRecords('apiUsage', {
      filters: {
        partner_id: partnerId,
        period_key: periodKey
      },
      limit: 1,
      suppressAuth: true
    });

    const record = result?.items?.[0];
    if (!record?._id) return;

    const quotas = { ...(record.quotas_used || {}) };
    quotas[metricKey] = Number(quotas[metricKey] || 0) + amount;

    await dataAccess.updateRecord('apiUsage', {
      _id: record._id,
      quotas_used: quotas,
      updated_at: new Date()
    }, { suppressAuth: true });
  } catch (_e) { }
}

async function logRequest({
  requestId,
  partnerId,
  apiKeyId,
  routePath,
  method,
  statusCode,
  startedAt,
  ipAddress,
  userAgent
}) {
  try {
    await dataAccess.insertRecord(COLLECTIONS.requestLog, {
      request_id: requestId,
      partner_id: partnerId,
      api_key_id: apiKeyId,
      endpoint: routePath,
      method,
      request_params: {},
      response_status: statusCode,
      response_time_ms: Date.now() - startedAt,
      cache_hit: false,
      error_message: statusCode >= 400 ? `HTTP ${statusCode}` : null,
      ip_address: ipAddress,
      user_agent: userAgent,
      created_at: new Date()
    }, { suppressAuth: true });
  } catch (_e) { }
}

async function createAlertSubscription(partnerId, body) {
  const dotNumbers = Array.isArray(body?.dot_numbers) ? body.dot_numbers : [];
  const alertTypes = Array.isArray(body?.alert_types) ? body.alert_types : [];
  const webhookUrl = String(body?.webhook_url || '').trim();
  const webhookSecret = String(body?.webhook_secret || '').trim() || generateWebhookSecret();

  if (!dotNumbers.length || !webhookUrl) {
    return {
      success: false,
      message: 'dot_numbers and webhook_url are required'
    };
  }

  const record = await dataAccess.insertRecord(COLLECTIONS.alertSubscriptions, {
    partner_id: partnerId,
    dot_numbers: dotNumbers.map((dot) => Number(dot)),
    alert_types: alertTypes,
    webhook_url: webhookUrl,
    webhook_secret: webhookSecret,
    is_active: true,
    created_at: new Date(),
    updated_at: new Date()
  }, { suppressAuth: true });

  const created = record?.record || null;
  if (!created?._id) {
    return { success: false, message: 'Failed to create subscription' };
  }

  return {
    success: true,
    data: {
      subscription_id: created._id,
      dot_numbers: created.dot_numbers || [],
      alert_types: created.alert_types || [],
      webhook_url: created.webhook_url,
      webhook_secret: created.webhook_secret || webhookSecret
    }
  };
}

async function listAlertSubscriptions(partnerId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.alertSubscriptions, {
    filters: { partner_id: partnerId, is_active: true },
    limit: 100,
    suppressAuth: true
  });

  return (result?.items || []).map((item) => ({
    subscription_id: item._id,
    dot_numbers: item.dot_numbers || [],
    alert_types: item.alert_types || [],
    webhook_url: item.webhook_url,
    created_at: item.created_at || null
  }));
}

async function deleteAlertSubscription(partnerId, subscriptionId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.alertSubscriptions, {
    filters: { _id: subscriptionId, partner_id: partnerId },
    limit: 1,
    suppressAuth: true
  });
  const record = result?.items?.[0];
  if (!record?._id) return false;

  const updated = await dataAccess.updateRecord(COLLECTIONS.alertSubscriptions, {
    _id: record._id,
    is_active: false,
    updated_at: new Date()
  }, { suppressAuth: true });

  return Boolean(updated?.success);
}

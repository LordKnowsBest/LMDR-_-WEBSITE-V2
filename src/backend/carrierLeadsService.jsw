import wixUsersBackend from 'wix-users-backend';
import * as wixData from 'wix-data';
import * as dataAccess from 'backend/dataAccess';
import { usesAirtable, getAirtableTableName, getWixCollectionName } from 'backend/config';
import * as airtableClient from 'backend/airtableClient';

const CONFIG = {
  STATUS: {
    NEW: 'new', CONTACTED: 'contacted', QUALIFIED: 'qualified',
    IN_PROGRESS: 'in_progress', CLOSED_WON: 'closed_won', CLOSED_LOST: 'closed_lost'
  },
  STAFFING_TYPE: { EMERGENCY: 'emergency', STRATEGIC: 'strategic' }
};

const COLLECTION_KEYS = {
  leads: 'carrierStaffingRequests',
  carriers: 'carriers',
  carrierAccounts: 'carriers',
  hiringPreferences: 'carrierHiringPreferences'
};

function parseDriverCount(rangeStr) {
  if (!rangeStr) return null;
  if (rangeStr.includes('+')) {
    const match = rangeStr.match(/(\d+)\+/);
    return match ? parseInt(match[1], 10) : null;
  }
  const rangeMatch = rangeStr.match(/(\d+)\s*-\s*(\d+)/);
  if (rangeMatch) return parseInt(rangeMatch[2], 10);
  const plainMatch = rangeStr.match(/(\d+)/);
  return plainMatch ? parseInt(plainMatch[1], 10) : null;
}

function parseDot(dotRaw) {
  const cleaned = String(dotRaw || '').trim();
  if (!cleaned) return null;
  if (!/^\d+$/.test(cleaned)) return null;
  const dot = parseInt(cleaned, 10);
  if (Number.isNaN(dot) || dot <= 0 || dot > 99999999) return null;
  return dot;
}

async function findCarrierByDot(dot) {
  if (!dot) return null;

  if (usesAirtable(COLLECTION_KEYS.carriers)) {
    const table = getAirtableTableName(COLLECTION_KEYS.carriers);
    const result = await airtableClient.queryRecords(table, {
      filterByFormula: `{DOT_NUMBER} = ${dot}`,
      maxRecords: 1
    });
    const records = result?.records || [];
    return records[0] || null;
  }

  const wixCollection = getWixCollectionName(COLLECTION_KEYS.carriers);
  const wixRuntime = await import('wix-data');
  const queryFn = wixRuntime.query || wixRuntime.default?.query || wixData.query || wixData.default?.query;
  if (typeof queryFn !== 'function') return null;
  const result = await queryFn(wixCollection)
    .eq('dot_number', dot)
    .limit(1)
    .find();
  return result?.items?.[0] || null;
}

async function createLeadRecord(leadRecord) {
  if (usesAirtable(COLLECTION_KEYS.leads)) {
    const table = getAirtableTableName(COLLECTION_KEYS.leads);
    const created = await airtableClient.createRecord(table, leadRecord);
    return { success: true, id: created?._id || created?.id || '' };
  }

  const result = await dataAccess.insertRecord(COLLECTION_KEYS.leads, leadRecord, { suppressAuth: true });
  if (!result.success) {
    return { success: false, error: result.error || 'Insert failed' };
  }
  return { success: true, id: result.record?._id || result.record?.id || '' };
}

export async function submitCarrierStaffingRequest(leadData) {
  try {
    if (!leadData.companyName || !leadData.contactName || !leadData.email || !leadData.phone || !leadData.staffingType) {
      return { success: false, error: 'Missing required fields' };
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(leadData.email)) return { success: false, error: 'Invalid email' };

    const dot = parseDot(leadData.dotNumber);
    let linkedCarrierId = null;

    if (leadData.dotNumber && !dot) {
      linkedCarrierId = null;
    } else if (dot) {
      const carrier = await findCarrierByDot(dot);
      linkedCarrierId = carrier?._id || carrier?.id || null;
    }

    const now = new Date();
    const driversNeededNum = parseDriverCount(leadData.driversNeeded);
    const formatDate = (date) => new Date(date).toISOString().split('T')[0];

    const leadRecord = {
      company_name: leadData.companyName.trim(),
      contact_name: leadData.contactName.trim(),
      email: leadData.email.trim().toLowerCase(),
      phone: leadData.phone.trim(),
      dot_number: dot ? String(dot) : null,
      staffing_type: leadData.staffingType ? leadData.staffingType.toLowerCase() : '',
      drivers_needed: driversNeededNum,
      driver_types: leadData.driverTypes || [],
      additional_notes: leadData.driversNeeded
        ? `Drivers needed: ${leadData.driversNeeded}. ${leadData.additionalNotes || ''}`.trim()
        : (leadData.additionalNotes || ''),
      linked_carrier_id: linkedCarrierId,
      status: CONFIG.STATUS.NEW,
      submitted_date: formatDate(now),
      last_updated: formatDate(now),
      source: 'landing_page',
      source_url: leadData.sourceUrl || '/last-mile-staffing'
    };

    const created = await createLeadRecord(leadRecord);
    if (!created.success) {
      return { success: false, error: created.error || 'Failed to submit request.' };
    }

    return {
      success: true,
      leadId: created.id,
      checkoutToken: created.id,
      message: 'Staffing request submitted.'
    };
  } catch (error) {
    return { success: false, error: error.message || 'Failed to submit request.' };
  }
}

export async function getLeadStatus(leadId) {
  try {
    const lead = await dataAccess.getRecord(COLLECTION_KEYS.leads, leadId, { suppressAuth: true });
    if (!lead) return { success: false, error: 'Lead not found' };

    return { success: true, lead: { id: lead._id, companyName: lead.company_name, status: lead.status, submittedDate: lead.submitted_date, lastUpdated: lead.last_updated } };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getCarrierLeads(options = {}) {
  try {
    const filters = {};
    if (options.status) filters.status = options.status;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.leads, {
      filters, sort: [{ field: 'submitted_date', direction: 'desc' }],
      limit: options.limit || 50, skip: options.skip || 0, suppressAuth: true
    });

    return { success: true, leads: result.items || [], totalCount: result.totalCount || (result.items || []).length };
  } catch (error) {
    return { success: false, error: error.message, leads: [] };
  }
}

export async function submitCarrierIntakePreferences(prefData) {
  try {
    if (!prefData.required_cdl_types?.length) return { success: false, error: 'CDL type required' };

    const preferenceRecord = {
      carrier_dot: prefData.carrier_dot || null, recruiter_id: 'public_intake_form',
      required_cdl_types: prefData.required_cdl_types, required_endorsements: prefData.required_endorsements || [],
      target_radius_miles: prefData.target_radius_miles || 100, target_states: prefData.target_states || [],
      target_zip_codes: [], route_types: prefData.route_types || [],
      equipment_types: prefData.equipment_types || [], offered_pay_min: prefData.offered_pay_min ?? null,
      offered_pay_max: prefData.offered_pay_max ?? null, min_experience_years: prefData.min_experience_years ?? null,
      max_experience_years: null, positions_open: prefData.positions_open ?? null,
      urgency: prefData.urgency || null, is_active: true, source: 'carrier_intake_form'
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.hiringPreferences, preferenceRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    return { success: true, preferenceId: result.record._id, message: 'Preferences saved.' };
  } catch (error) {
    return { success: false, error: 'Failed to save preferences.' };
  }
}

export async function updateLeadStatus(leadId, newStatus, notes = '') {
  try {
    const lead = await dataAccess.getRecord(COLLECTION_KEYS.leads, leadId, { suppressAuth: true });
    if (!lead) return { success: false, error: 'Lead not found' };

    let statusHistory = [];
    try { statusHistory = typeof lead.status_history === 'string' ? JSON.parse(lead.status_history) : (lead.status_history || []); } catch (e) {}
    statusHistory.push({ from: lead.status, to: newStatus, timestamp: new Date().toISOString(), notes });

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.leads, { ...lead, _id: leadId, status: newStatus, last_updated: new Date(), status_history: JSON.stringify(statusHistory) }, { suppressAuth: true });
    return { success: result.success, lead: result.record, error: result.error };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function ensureCarrierRecord(leadId = null, fallbackEmail = null) {
  try {
    const user = wixUsersBackend.currentUser;
    if (!user.loggedIn) return { success: false, error: 'User not logged in' };

    const userId = user.id;
    const userEmail = await user.getEmail();

    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.carrierAccounts, {
      filters: { _owner: userId }, limit: 1, suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      return { success: true, carrier: { id: existingResult.items[0]._id, dotNumber: existingResult.items[0].dot_number, email: userEmail }, created: false };
    }

    let lead = null;
    if (leadId) lead = await dataAccess.getRecord(COLLECTION_KEYS.leads, leadId, { suppressAuth: true });
    if (!lead && (fallbackEmail || userEmail)) {
      const emailRes = await dataAccess.queryRecords(COLLECTION_KEYS.leads, { filters: { email: (fallbackEmail || userEmail).toLowerCase() }, sort: [{ field: 'submitted_date', direction: 'desc' }], limit: 1, suppressAuth: true });
      lead = emailRes.items?.[0];
    }

    if (!lead) return { success: false, error: 'No lead found' };

    let fmcsaData = null;
    if (lead.linked_carrier_id) {
      fmcsaData = await dataAccess.getRecord(COLLECTION_KEYS.carriers, lead.linked_carrier_id, { suppressAuth: true });
    }

    const dotNum = fmcsaData?.dot_number || (lead.dot_number ? parseInt(lead.dot_number, 10) : null);
    const newCarrier = {
      _owner: userId, legal_name: fmcsaData?.legal_name || lead.company_name || '', dot_number: dotNum,
      email_address: lead.email || userEmail, telephone: fmcsaData?.telephone || lead.phone || '',
      city: fmcsaData?.phy_city || '', state: fmcsaData?.phy_state || '',
      carrier_operation: fmcsaData?.carrier_operation || '', driver_total: fmcsaData?.driver_total || null,
      power_units: fmcsaData?.nbr_power_unit || null
    };

    const createdResult = await dataAccess.insertRecord(COLLECTION_KEYS.carrierAccounts, newCarrier, { suppressAuth: true });
    if (!createdResult.success) throw new Error(createdResult.error);

    return { success: true, carrier: { id: createdResult.record._id, dotNumber: dotNum ? String(dotNum) : 'PENDING', email: newCarrier.email_address }, created: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getMatchPreview(criteria = {}) {
  try {
    const filters = {
      is_searchable: true,
      visibility_level: { ne: 'hidden' }
    };

    if (criteria.cdlTypes && Array.isArray(criteria.cdlTypes) && criteria.cdlTypes.length > 0) {
      filters.cdl_class = { hasSome: criteria.cdlTypes };
    }

    if (criteria.endorsements && Array.isArray(criteria.endorsements) && criteria.endorsements.length > 0) {
      filters.endorsements = { hasAll: criteria.endorsements };
    }

    if (criteria.minExperience !== undefined && criteria.minExperience !== null) {
      const exp = parseInt(criteria.minExperience, 10);
      if (!isNaN(exp)) filters.years_experience = { gte: exp };
    }

    const result = await airtableClient.queryRecords(getAirtableTableName('driverProfiles'), {
      filters,
      limit: 1000
    });

    const drivers = result.items || result.records || [];
    const totalCount = result.totalCount || drivers.length;

    const breakdown = {
      byClass: {},
      withEndorsements: 0,
      avgExperience: 0
    };

    let totalExperience = 0;
    for (const driver of drivers) {
      const cdlClass = driver.cdl_class || 'Unknown';
      breakdown.byClass[cdlClass] = (breakdown.byClass[cdlClass] || 0) + 1;
      if (Array.isArray(driver.endorsements) && driver.endorsements.length > 0) {
        breakdown.withEndorsements++;
      }
      totalExperience += (driver.years_experience || 0);
    }

    breakdown.avgExperience = drivers.length > 0
      ? Math.round((totalExperience / drivers.length) * 10) / 10
      : 0;

    let message;
    if (totalCount === 0) {
      message = "We don't have exact matches yet, but our network is growing daily.";
    } else if (totalCount < 5) {
      message = `We have ${totalCount} drivers that match your criteria.`;
    } else if (totalCount < 20) {
      message = `Great news! ${totalCount} qualified drivers match your needs.`;
    } else {
      message = `Excellent! ${totalCount}+ drivers are ready to connect with you.`;
    }

    return {
      success: true,
      preview: {
        count: totalCount,
        breakdown,
        message,
        hasMatches: totalCount > 0,
        exceedsNeed: criteria.driversNeeded
          ? totalCount >= parseInt(criteria.driversNeeded, 10)
          : null
      }
    };

  } catch (error) {
    return {
      success: false,
      error: 'Unable to generate preview',
      preview: {
        count: 0,
        message: "Submit your request and we'll match you with qualified drivers.",
        hasMatches: false
      }
    };
  }
}

export async function getLeadDetails(leadId) {
  try {
    const lead = await dataAccess.getRecord(COLLECTION_KEYS.leads, leadId, { suppressAuth: true });
    if (!lead) return null;
    return { _id: lead._id, companyName: lead.company_name, contactName: lead.contact_name, email: lead.email, phone: lead.phone, driversNeeded: lead.drivers_needed, staffingType: lead.staffing_type };
  } catch (error) {
    throw error;
  }
}

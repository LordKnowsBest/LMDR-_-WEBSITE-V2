/**
 * Social Posting Service
 *
 * Manages social media post creation, scheduling, and publishing
 * for recruiters on Facebook and LinkedIn.
 *
 * Collections: socialPosts, socialAccounts
 */

import { getSecret } from 'wix-secrets-backend';
import * as dataAccess from 'backend/dataAccess';
import * as configData from 'backend/configData';
import * as socialSecretService from 'backend/socialSecretService';
import * as socialRateLimitService from 'backend/socialRateLimitService';
import * as socialQueueService from 'backend/socialQueueService';
import { log } from 'backend/observabilityService';
import { sendSocialAlert } from 'backend/emailService';

// =============================================================================
// CONSTANTS
// =============================================================================

const SUPPORTED_PLATFORMS = ['facebook', 'linkedin'];

const POST_STATUS = {
    DRAFT: 'draft',
    SCHEDULED: 'scheduled',
    PUBLISHED: 'published',
    FAILED: 'failed',
    CANCELLED: 'cancelled'
};

const CHAR_LIMITS = {
    facebook: 63206,
    linkedin: 3000
};

// =============================================================================
// POST CRUD
// =============================================================================

/**
 * Create a new social post
 * @param {string} carrierDot
 * @param {Object} postData
 */
export async function createSocialPost(carrierDot, postData) {
    try {
        if (!carrierDot) return { success: false, error: 'carrierDot required' };
        if (!postData.content) return { success: false, error: 'content required' };
        if (!postData.platforms || postData.platforms.length === 0) {
            return { success: false, error: 'At least one platform required' };
        }

        const invalidPlatforms = postData.platforms.filter(p => !SUPPORTED_PLATFORMS.includes(p));
        if (invalidPlatforms.length > 0) {
            return { success: false, error: `Unsupported platforms: ${invalidPlatforms.join(', ')}` };
        }

        // Validate character limits per platform
        for (const platform of postData.platforms) {
            const limit = CHAR_LIMITS[platform];
            if (postData.content.length > limit) {
                return { success: false, error: `Content too long for ${platform}: ${postData.content.length}/${limit} chars` };
            }
        }

        const record = {
            carrier_dot: carrierDot,
            content: postData.content,
            platforms: JSON.stringify(postData.platforms),
            media_urls: JSON.stringify(postData.mediaUrls || []),
            link_url: postData.linkUrl || '',
            link_title: postData.linkTitle || '',
            link_description: postData.linkDescription || '',
            job_id: postData.jobId || '',
            status: POST_STATUS.DRAFT,
            schedule_type: postData.scheduleType || 'immediate',
            scheduled_time: postData.scheduledTime || null,
            platform_results: JSON.stringify({}),
            engagement: JSON.stringify({ likes: 0, comments: 0, shares: 0, clicks: 0 }),
            created_at: new Date().toISOString()
        };

        const result = await dataAccess.insertRecord('socialPosts', record);
        return { success: true, postId: result._id };
    } catch (error) {
        console.error('[socialPostingService] createSocialPost error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get social posts for a carrier
 * @param {string} carrierDot
 * @param {Object} filters
 */
export async function getSocialPosts(carrierDot, filters = {}) {
    try {
        const query = {
            filter: { carrier_dot: carrierDot },
            sort: [{ fieldName: 'created_at', order: 'desc' }],
            limit: 50
        };
        if (filters.status) query.filter.status = filters.status;
        if (filters.platform) {
            // Filter by platform in results since JSON field
        }

        const records = await dataAccess.queryRecords('socialPosts', query);
        const posts = (records.items || []).map(p => ({
            ...p,
            platforms: _safeJsonParse(p.platforms, []),
            mediaUrls: _safeJsonParse(p.media_urls, []),
            platformResults: _safeJsonParse(p.platform_results, {}),
            engagement: _safeJsonParse(p.engagement, {})
        })).filter(p => !filters.platform || p.platforms.includes(filters.platform));

        return { success: true, posts };
    } catch (error) {
        console.error('[socialPostingService] getSocialPosts error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Publish a social post immediately
 * @param {string} postId
 */
export async function publishSocialPost(postId) {
    try {
        const post = await dataAccess.getRecord('socialPosts', postId);
        if (!post) return { success: false, error: 'Post not found' };
        if (post.status === POST_STATUS.PUBLISHED) {
            return { success: false, error: 'Post already published' };
        }

        const platforms = _safeJsonParse(post.platforms, []);
        const platformResults = {};
        let anySuccess = false;

        for (const platform of platforms) {
            try {
                const account = await _getConnectedAccount(post.carrier_dot, platform);
                if (!account) {
                    platformResults[platform] = { success: false, error: 'No connected account' };
                    continue;
                }

                const result = await _publishToPlatform(platform, post, account);
                platformResults[platform] = result;
                if (result.success) anySuccess = true;
            } catch (err) {
                platformResults[platform] = { success: false, error: err.message };
            }
        }

        await dataAccess.updateRecord('socialPosts', postId, {
            status: anySuccess ? POST_STATUS.PUBLISHED : POST_STATUS.FAILED,
            platform_results: JSON.stringify(platformResults),
            published_at: anySuccess ? new Date().toISOString() : null
        });

        return { success: anySuccess, platformResults };
    } catch (error) {
        console.error('[socialPostingService] publishSocialPost error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Schedule a post for future publishing
 * @param {string} postId
 * @param {string} scheduledTime - ISO string
 */
export async function scheduleSocialPost(postId, scheduledTime) {
    try {
        if (!scheduledTime) return { success: false, error: 'scheduledTime required' };
        if (new Date(scheduledTime) <= new Date()) {
            return { success: false, error: 'scheduledTime must be in the future' };
        }

        await dataAccess.updateRecord('socialPosts', postId, {
            status: POST_STATUS.SCHEDULED,
            scheduled_time: scheduledTime,
            schedule_type: 'scheduled',
            updated_at: new Date().toISOString()
        });

        return { success: true };
    } catch (error) {
        console.error('[socialPostingService] scheduleSocialPost error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Cancel a scheduled post
 * @param {string} postId
 */
export async function cancelSocialPost(postId) {
    try {
        const post = await dataAccess.getRecord('socialPosts', postId);
        if (!post) return { success: false, error: 'Post not found' };
        if (post.status === POST_STATUS.PUBLISHED) {
            return { success: false, error: 'Cannot cancel a published post' };
        }

        await dataAccess.updateRecord('socialPosts', postId, {
            status: POST_STATUS.CANCELLED,
            updated_at: new Date().toISOString()
        });

        return { success: true };
    } catch (error) {
        console.error('[socialPostingService] cancelSocialPost error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get engagement analytics for a post
 * @param {string} postId
 */
export async function getSocialPostAnalytics(postId) {
    try {
        const post = await dataAccess.getRecord('socialPosts', postId);
        if (!post) return { success: false, error: 'Post not found' };

        const platforms = _safeJsonParse(post.platforms, []);
        const platformResults = _safeJsonParse(post.platform_results, {});
        const freshEngagement = {};

        for (const platform of platforms) {
            const result = platformResults[platform];
            if (!result?.success || !result?.postId) continue;

            try {
                const account = await _getConnectedAccount(post.carrier_dot, platform);
                if (!account) continue;
                freshEngagement[platform] = await _fetchEngagement(platform, result.postId, account);
            } catch (err) {
                freshEngagement[platform] = { error: err.message };
            }
        }

        // Update stored engagement
        const merged = { ..._safeJsonParse(post.engagement, {}), ...freshEngagement };
        await dataAccess.updateRecord('socialPosts', postId, {
            engagement: JSON.stringify(merged),
            engagement_updated_at: new Date().toISOString()
        });

        return { success: true, analytics: { platformResults, engagement: merged } };
    } catch (error) {
        console.error('[socialPostingService] getSocialPostAnalytics error:', error);
        return { success: false, error: error.message };
    }
}

// =============================================================================
// ACCOUNT MANAGEMENT (OAUTH)
// =============================================================================

/**
 * Connect a social account via OAuth token exchange
 * @param {string} carrierDot
 * @param {string} platform
 * @param {string} authCode - OAuth authorization code
 */
export async function connectSocialAccount(carrierDot, platform, authCode) {
    try {
        if (!SUPPORTED_PLATFORMS.includes(platform)) {
            return { success: false, error: `Unsupported platform: ${platform}` };
        }

        const tokenResult = await _exchangeOAuthCode(platform, authCode);
        if (!tokenResult.success) {
            return { success: false, error: `OAuth failed: ${tokenResult.error}` };
        }

        // Upsert account record
        const existing = await dataAccess.queryRecords('socialAccounts', {
            filter: { carrier_dot: carrierDot, platform },
            limit: 1
        });

        const record = {
            carrier_dot: carrierDot,
            platform,
            account_id: tokenResult.accountId,
            account_name: tokenResult.accountName || '',
            access_token: tokenResult.accessToken,
            refresh_token: tokenResult.refreshToken || '',
            token_expires_at: tokenResult.expiresAt || null,
            page_id: tokenResult.pageId || '',
            page_name: tokenResult.pageName || '',
            is_active: true,
            connected_at: new Date().toISOString()
        };

        if (existing.items?.length > 0) {
            await dataAccess.updateRecord('socialAccounts', existing.items[0]._id, record);
        } else {
            await dataAccess.insertRecord('socialAccounts', record);
        }

        return { success: true, accountName: tokenResult.accountName };
    } catch (error) {
        console.error('[socialPostingService] connectSocialAccount error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Disconnect a social account
 * @param {string} accountId
 */
export async function disconnectSocialAccount(accountId) {
    try {
        const account = await dataAccess.getRecord('socialAccounts', accountId);
        if (!account) return { success: false, error: 'Account not found' };

        // Revoke token with platform
        await _revokeToken(account.platform, account.access_token).catch(() => { });

        await dataAccess.updateRecord('socialAccounts', accountId, {
            is_active: false,
            access_token: '',
            refresh_token: '',
            disconnected_at: new Date().toISOString()
        });

        return { success: true };
    } catch (error) {
        console.error('[socialPostingService] disconnectSocialAccount error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get connected social accounts for a carrier
 * @param {string} carrierDot
 */
export async function getConnectedAccounts(carrierDot) {
    try {
        const records = await dataAccess.queryRecords('socialAccounts', {
            filter: { carrier_dot: carrierDot, is_active: true },
            limit: 20
        });

        // Strip sensitive tokens from response
        const accounts = (records.items || []).map(a => ({
            _id: a._id,
            platform: a.platform,
            accountId: a.account_id,
            accountName: a.account_name,
            pageName: a.page_name,
            isActive: a.is_active,
            connectedAt: a.connected_at,
            tokenExpiresAt: a.token_expires_at
        }));

        return { success: true, accounts };
    } catch (error) {
        console.error('[socialPostingService] getConnectedAccounts error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Refresh an expiring access token
 * @param {string} accountId
 */
export async function refreshSocialToken(accountId) {
    try {
        const account = await dataAccess.getRecord('socialAccounts', accountId);
        if (!account || !account.refresh_token) {
            return { success: false, error: 'Account not found or no refresh token' };
        }

        const result = await _refreshToken(account.platform, account.refresh_token);
        if (!result.success) return { success: false, error: result.error };

        await dataAccess.updateRecord('socialAccounts', accountId, {
            access_token: result.accessToken,
            refresh_token: result.refreshToken || account.refresh_token,
            token_expires_at: result.expiresAt,
            token_refreshed_at: new Date().toISOString()
        });

        return { success: true };
    } catch (error) {
        console.error('[socialPostingService] refreshSocialToken error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Generate AI-optimized post content for a job
 * @param {string} jobId
 * @param {string} platform
 */
export async function generateJobPostContent(jobId, platform) {
    try {
        const job = await dataAccess.getRecord('jobPostings', jobId);
        if (!job) return { success: false, error: 'Job not found' };

        const limit = CHAR_LIMITS[platform] || 500;
        const platformTips = {
            facebook: 'conversational, use emojis, include call-to-action',
            linkedin: 'professional, highlight career growth, no excessive emojis'
        };

        // Template-based generation (no AI call to keep it fast and free)
        const templates = {
            facebook: `ðŸš› NOW HIRING: ${job.title}!\n\nðŸ“ ${job.location}\nðŸ’° ${job.pay_rate || 'Competitive Pay'}\nðŸ  ${job.home_time || 'Great Home Time'}\n\nWe're looking for qualified CDL-A drivers to join our team. Apply today!\n\n#CDLDriver #TruckingJobs #NowHiring`,
            linkedin: `We are actively recruiting for a ${job.title} position based in ${job.location}.\n\n**What We Offer:**\nâ€¢ ${job.pay_rate || 'Competitive compensation'}\nâ€¢ ${job.home_time || 'Flexible home time'}\nâ€¢ Full benefits package\n\n**Requirements:**\nâ€¢ CDL Class ${job.cdl_class_required || 'A'}\nâ€¢ ${job.experience_years || 0}+ years experience\n\nInterested candidates, please apply through our platform.\n\n#CDLDriver #TruckDriver #Recruiting`
        };

        const content = templates[platform] || templates.facebook;
        const truncated = content.length > limit ? content.substring(0, limit - 3) + '...' : content;

        return { success: true, content: truncated, platform, characterCount: truncated.length, limit };
    } catch (error) {
        console.error('[socialPostingService] generateJobPostContent error:', error);
        return { success: false, error: error.message };
    }
}

// =============================================================================
// SCHEDULER JOBS
// =============================================================================

/**
 * Scheduler: Publish due scheduled posts (every 15 min)
 */
export async function processScheduledPosts() {
    try {
        const now = new Date().toISOString();

        const duePosts = await dataAccess.queryRecords('socialPosts', {
            filter: { status: POST_STATUS.SCHEDULED },
            limit: 20
        });

        let published = 0;
        let failed = 0;

        for (const post of (duePosts.items || [])) {
            if (!post.scheduled_time || post.scheduled_time > now) continue;

            const result = await publishSocialPost(post._id);
            if (result.success) published++;
            else failed++;
        }

        console.log(`[socialPostingService] processScheduledPosts: ${published} published, ${failed} failed`);
        return { success: true, published, failed };
    } catch (error) {
        console.error('[socialPostingService] processScheduledPosts error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Scheduler: Refresh expiring social tokens (daily 3am)
 */
export async function refreshSocialTokensJob() {
    try {
        const soon = new Date();
        soon.setDate(soon.getDate() + 7); // Refresh tokens expiring within 7 days

        const accounts = await dataAccess.queryRecords('socialAccounts', {
            filter: { is_active: true },
            limit: 100
        });

        let refreshed = 0;
        let errors = 0;

        for (const account of (accounts.items || [])) {
            if (!account.token_expires_at) continue;
            if (account.token_expires_at > soon.toISOString()) continue;

            const result = await refreshSocialToken(account._id);
            if (result.success) refreshed++;
            else errors++;
        }

        console.log(`[socialPostingService] refreshSocialTokensJob: ${refreshed} refreshed, ${errors} errors`);
        return { success: true, refreshed, errors };
    } catch (error) {
        console.error('[socialPostingService] refreshSocialTokensJob error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Scheduler: Fetch fresh engagement metrics (every 6 hours)
 */
export async function fetchSocialEngagementJob() {
    try {
        const recentCutoff = new Date();
        recentCutoff.setDate(recentCutoff.getDate() - 30); // Only fetch for posts in last 30 days

        const publishedPosts = await dataAccess.queryRecords('socialPosts', {
            filter: { status: POST_STATUS.PUBLISHED },
            limit: 50
        });

        let updated = 0;
        for (const post of (publishedPosts.items || [])) {
            if (post.published_at && post.published_at < recentCutoff.toISOString()) continue;
            await getSocialPostAnalytics(post._id).catch(() => { });
            updated++;
        }

        console.log(`[socialPostingService] fetchSocialEngagementJob: ${updated} posts updated`);
        return { success: true, updated };
    } catch (error) {
        console.error('[socialPostingService] fetchSocialEngagementJob error:', error);
        return { success: false, error: error.message };
    }
}

// =============================================================================
// PRIVATE HELPERS
// =============================================================================

async function _getConnectedAccount(carrierDot, platform) {
    try {
        const records = await dataAccess.queryRecords('socialAccounts', {
            filter: { carrier_dot: carrierDot, platform, is_active: true },
            limit: 1
        });
        return records.items?.[0] || null;
    } catch {
        return null;
    }
}

async function _publishToPlatform(platform, post, account) {
    switch (platform) {
        case 'facebook':
            return await _publishToFacebook(post, account);
        case 'linkedin':
            return await _publishToLinkedIn(post, account);
        default:
            return { success: false, error: 'Unknown platform' };
    }
}

async function _publishToFacebook(post, account) {
    try {
        const pageId = account.page_id || account.account_id;
        const mediaUrls = _safeJsonParse(post.media_urls, []);

        const params = new URLSearchParams({
            message: post.content,
            access_token: account.access_token
        });
        if (post.link_url) params.append('link', post.link_url);

        const endpoint = mediaUrls.length > 0
            ? `https://graph.facebook.com/v18.0/${pageId}/photos`
            : `https://graph.facebook.com/v18.0/${pageId}/feed`;

        if (mediaUrls.length > 0) params.append('url', mediaUrls[0]);

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: params.toString()
        });

        const data = await response.json();
        if (!response.ok || data.error) {
            return { success: false, error: data.error?.message || `Facebook error ${response.status}` };
        }

        return { success: true, postId: data.id };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async function _publishToLinkedIn(post, account) {
    try {
        const mediaUrls = _safeJsonParse(post.media_urls, []);

        const payload = {
            author: `urn:li:person:${account.account_id}`,
            lifecycleState: 'PUBLISHED',
            specificContent: {
                'com.linkedin.ugc.ShareContent': {
                    shareCommentary: { text: post.content },
                    shareMediaCategory: mediaUrls.length > 0 ? 'IMAGE' : 'NONE',
                    ...(post.link_url ? {
                        media: [{
                            status: 'READY',
                            originalUrl: post.link_url,
                            title: { text: post.link_title || '' },
                            description: { text: post.link_description || '' }
                        }]
                    } : {})
                }
            },
            visibility: { 'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC' }
        };

        const response = await fetch('https://api.linkedin.com/v2/ugcPosts', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${account.access_token}`,
                'Content-Type': 'application/json',
                'X-Restli-Protocol-Version': '2.0.0'
            },
            body: JSON.stringify(payload)
        });

        const data = await response.json();
        if (!response.ok) {
            return { success: false, error: data.message || `LinkedIn error ${response.status}` };
        }

        return { success: true, postId: data.id };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async function _fetchEngagement(platform, externalPostId, account) {
    try {
        switch (platform) {
            case 'facebook': {
                const response = await fetch(
                    `https://graph.facebook.com/v18.0/${externalPostId}?fields=likes.summary(true),comments.summary(true),shares&access_token=${account.access_token}`
                );
                const data = await response.json();
                return {
                    likes: data.likes?.summary?.total_count || 0,
                    comments: data.comments?.summary?.total_count || 0,
                    shares: data.shares?.count || 0
                };
            }
            case 'linkedin': {
                const response = await fetch(
                    `https://api.linkedin.com/v2/socialActions/${encodeURIComponent(externalPostId)}`,
                    { headers: { 'Authorization': `Bearer ${account.access_token}` } }
                );
                const data = await response.json();
                return {
                    likes: data.likesSummary?.totalLikes || 0,
                    comments: data.commentsSummary?.totalFirstLevelComments || 0
                };
            }
            default:
                return {};
        }
    } catch {
        return {};
    }
}

async function _exchangeOAuthCode(platform, authCode) {
    try {
        switch (platform) {
            case 'facebook': {
                const appId = await getSecret('FACEBOOK_APP_ID');
                const appSecret = await getSecret('FACEBOOK_APP_SECRET');
                if (!appId || !appSecret) return { success: false, error: 'Facebook credentials not configured' };

                const redirectUri = 'https://www.lastmiledr.app/_functions/oauth_facebook_callback';
                const response = await fetch(
                    `https://graph.facebook.com/v18.0/oauth/access_token?client_id=${appId}&redirect_uri=${encodeURIComponent(redirectUri)}&client_secret=${appSecret}&code=${authCode}`
                );
                const data = await response.json();
                if (data.error) return { success: false, error: data.error.message };

                // Get user info
                const userResp = await fetch(`https://graph.facebook.com/me?access_token=${data.access_token}&fields=id,name`);
                const user = await userResp.json();

                return {
                    success: true,
                    accessToken: data.access_token,
                    accountId: user.id,
                    accountName: user.name,
                    expiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1000).toISOString() : null
                };
            }
            case 'linkedin': {
                const clientId = await getSecret('LINKEDIN_CLIENT_ID');
                const clientSecret = await getSecret('LINKEDIN_CLIENT_SECRET');
                if (!clientId || !clientSecret) return { success: false, error: 'LinkedIn credentials not configured' };

                const redirectUri = 'https://www.lastmiledr.app/_functions/oauth_linkedin_callback';
                const params = new URLSearchParams({
                    grant_type: 'authorization_code',
                    code: authCode,
                    redirect_uri: redirectUri,
                    client_id: clientId,
                    client_secret: clientSecret
                });

                const response = await fetch('https://www.linkedin.com/oauth/v2/accessToken', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: params.toString()
                });
                const data = await response.json();
                if (data.error) return { success: false, error: data.error_description };

                // Get profile info
                const profileResp = await fetch('https://api.linkedin.com/v2/me', {
                    headers: { 'Authorization': `Bearer ${data.access_token}` }
                });
                const profile = await profileResp.json();

                return {
                    success: true,
                    accessToken: data.access_token,
                    refreshToken: data.refresh_token || '',
                    accountId: profile.id,
                    accountName: `${profile.localizedFirstName || ''} ${profile.localizedLastName || ''}`.trim(),
                    expiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1000).toISOString() : null
                };
            }
            default:
                return { success: false, error: 'Unknown platform' };
        }
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async function _refreshToken(platform, refreshToken) {
    try {
        if (platform === 'linkedin') {
            const clientId = await getSecret('LINKEDIN_CLIENT_ID');
            const clientSecret = await getSecret('LINKEDIN_CLIENT_SECRET');

            const params = new URLSearchParams({
                grant_type: 'refresh_token',
                refresh_token: refreshToken,
                client_id: clientId,
                client_secret: clientSecret
            });

            const response = await fetch('https://www.linkedin.com/oauth/v2/accessToken', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: params.toString()
            });
            const data = await response.json();
            if (data.error) return { success: false, error: data.error_description };

            return {
                success: true,
                accessToken: data.access_token,
                refreshToken: data.refresh_token || refreshToken,
                expiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1000).toISOString() : null
            };
        }

        // Facebook long-lived tokens don't use refresh_token flow
        return { success: false, error: `Token refresh not supported for ${platform}` };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async function _revokeToken(platform, accessToken) {
    if (platform === 'facebook') {
        await fetch(`https://graph.facebook.com/me/permissions?access_token=${accessToken}`, { method: 'DELETE' });
    }
    // LinkedIn token revocation requires a separate API call
}

function _safeJsonParse(str, fallback) {
    try {
        return typeof str === 'string' ? JSON.parse(str) : (str || fallback);
    } catch {
        return fallback;
    }
}

// =============================================================================
// GRAPH API ORGANIC POSTING (FACEBOOK PAGE + INSTAGRAM)
// =============================================================================

const META_GRAPH_BASE = 'https://graph.facebook.com/v25.0';
const RETRY_POLL_MAX = 10;
const RETRY_POLL_MS = 5000;

function nowMs() {
    return Date.now();
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function getSocialPostingEnabledFlag() {
    const fromConfig = Boolean(configData && configData.SOCIAL_POSTING_SETTINGS && configData.SOCIAL_POSTING_SETTINGS.SOCIAL_POSTING_ENABLED);
    if (typeof process !== 'undefined' && process.env && typeof process.env.SOCIAL_POSTING_ENABLED !== 'undefined') {
        return String(process.env.SOCIAL_POSTING_ENABLED).toLowerCase() === 'true';
    }
    return fromConfig;
}

function toBody(params = {}) {
    return new URLSearchParams(
        Object.entries(params).reduce((acc, [key, value]) => {
            if (value !== undefined && value !== null && value !== '') {
                acc[key] = String(value);
            }
            return acc;
        }, {})
    ).toString();
}

function isValidUrl(url = '') {
    try {
        const parsed = new URL(url);
        return parsed.protocol === 'http:' || parsed.protocol === 'https:';
    } catch (error) {
        return false;
    }
}

function toUnixSeconds(isoValue) {
    const ms = new Date(isoValue).getTime();
    if (!Number.isFinite(ms)) return 0;
    return Math.floor(ms / 1000);
}

function normalizeErrorType(error = {}) {
    const code = Number(error.code || 0);
    const subcode = Number(error.error_subcode || 0);
    const message = String(error.message || '').toLowerCase();
    if (code === 190) return 'TOKEN_EXPIRED';
    if (code === 200 || code === 203) return 'PERMISSION_MISSING';
    if (code === 341) return 'RATE_LIMITED_FB';
    if (message.includes('image') && message.includes('public')) return 'MEDIA_NOT_PUBLIC';
    if (message.includes('link') && message.includes('not') && message.includes('visible')) return 'LINK_INVISIBLE';
    return 'GRAPH_API_ERROR';
}

async function logPostingAttempt(fields = {}) {
    await log({
        level: fields.success ? 'INFO' : 'ERROR',
        source: 'social-graph-posting',
        message: fields.success ? 'Social post published' : 'Social post failed',
        duration: fields.duration_ms || 0,
        details: fields
    });
}

async function createQueueBeforeDispatch(payload = {}) {
    const dedupe = payload.dedupe_key || generateDedupeKey(payload);
    const existing = await socialQueueService.getByDedupeKey(dedupe);
    if (!existing.success) {
        return { success: false, error_type: 'QUEUE_ERROR', error_message: existing.error || 'Failed dedupe lookup' };
    }
    if (existing.record && socialQueueService.isPublishedRecord(existing.record)) {
        return {
            success: false,
            duplicate: true,
            error_type: 'DUPLICATE_POST',
            error_message: 'Duplicate post detected',
            queue_record: existing.record
        };
    }

    const queueCreate = await socialQueueService.createQueueRecord({
        dedupe_key: dedupe,
        platform: payload.platform || '',
        post_type: payload.post_type || 'text',
        scheduled_for: payload.scheduled_for || null,
        payload_snapshot: payload,
        status: 'queued'
    });
    if (!queueCreate.success) {
        return { success: false, error_type: 'QUEUE_ERROR', error_message: queueCreate.error || 'Failed to create queue record' };
    }
    const queueRecord = queueCreate.record || {};
    await socialQueueService.appendAuditLog('post_dispatched', {
        platform: payload.platform || '',
        queue_record_id: queueRecord._id || queueRecord.id || '',
        details: { dedupe_key: dedupe, post_type: payload.post_type || 'text' }
    });
    return { success: true, queue_record: queueRecord, dedupe_key: dedupe };
}

async function finalizeQueue(queueRecord, updates = {}, eventType = '') {
    const queueId = queueRecord && (queueRecord._id || queueRecord.id) ? (queueRecord._id || queueRecord.id) : '';
    if (!queueId) return;
    await socialQueueService.updateQueueRecord(queueId, updates);
    if (eventType) {
        await socialQueueService.appendAuditLog(eventType, {
            platform: updates.platform || queueRecord.platform || '',
            queue_record_id: queueId,
            details: updates
        });
    }
}

async function graphFetch(url, token, body, method = 'POST') {
    const response = await fetch(url, {
        method,
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: body || ''
    });
    let payload = {};
    try {
        payload = await response.json();
    } catch (error) {
        payload = {};
    }
    return { response, payload };
}

async function postFacebookByType(pageId, token, payload = {}) {
    const postType = payload.post_type || 'text';
    if (postType === 'photo') {
        if (!isValidUrl(payload.url || payload.image_url || '')) {
            return { success: false, error_type: 'MEDIA_NOT_PUBLIC', error_message: 'Invalid or non-public photo URL' };
        }
        const body = toBody({
            url: payload.url || payload.image_url,
            caption: payload.caption || payload.message || ''
        });
        const { response, payload: graph } = await graphFetch(`${META_GRAPH_BASE}/${pageId}/photos`, token, body);
        if (!response.ok || graph.error) {
            return { success: false, error_type: normalizeErrorType(graph.error || {}), error_message: graph.error ? graph.error.message : `HTTP ${response.status}` };
        }
        return { success: true, post_id: graph.id || '', usage_header: response.headers.get('x-app-usage') || '' };
    }

    if (postType === 'video') {
        if (!isValidUrl(payload.file_url || payload.video_url || '')) {
            return { success: false, error_type: 'MEDIA_NOT_PUBLIC', error_message: 'Invalid video URL' };
        }
        const body = toBody({
            file_url: payload.file_url || payload.video_url,
            description: payload.description || payload.message || ''
        });
        const { response, payload: graph } = await graphFetch(`${META_GRAPH_BASE}/${pageId}/videos`, token, body);
        if (!response.ok || graph.error) {
            return { success: false, error_type: normalizeErrorType(graph.error || {}), error_message: graph.error ? graph.error.message : `HTTP ${response.status}` };
        }
        return { success: true, post_id: graph.id || '', usage_header: response.headers.get('x-app-usage') || '' };
    }

    if (postType === 'link' && payload.link && !isValidUrl(payload.link)) {
        return { success: false, error_type: 'LINK_INVISIBLE', error_message: 'Invalid link URL' };
    }

    const requestBody = {
        message: payload.message || '',
        link: payload.link || ''
    };
    if (payload.scheduled_publish_time) {
        const whenUnix = typeof payload.scheduled_publish_time === 'number' ?
            payload.scheduled_publish_time : toUnixSeconds(payload.scheduled_publish_time);
        const minUnix = Math.floor((Date.now() + 10 * 60 * 1000) / 1000);
        const maxUnix = Math.floor((Date.now() + 75 * 24 * 60 * 60 * 1000) / 1000);
        if (whenUnix < minUnix || whenUnix > maxUnix) {
            return { success: false, error_type: 'GRAPH_API_ERROR', error_message: 'scheduled_publish_time must be 10 minutes to 75 days in the future' };
        }
        requestBody.published = false;
        requestBody.scheduled_publish_time = whenUnix;
    }
    if (!requestBody.message && !requestBody.link) {
        return { success: false, error_type: 'GRAPH_API_ERROR', error_message: 'message or link is required' };
    }
    const { response, payload: graph } = await graphFetch(`${META_GRAPH_BASE}/${pageId}/feed`, token, toBody(requestBody));
    if (!response.ok || graph.error) {
        return { success: false, error_type: normalizeErrorType(graph.error || {}), error_message: graph.error ? graph.error.message : `HTTP ${response.status}` };
    }
    return { success: true, post_id: graph.id || '', usage_header: response.headers.get('x-app-usage') || '' };
}

async function pollContainerStatus(containerId, token) {
    for (let i = 0; i < RETRY_POLL_MAX; i++) {
        const response = await fetch(`${META_GRAPH_BASE}/${containerId}?fields=status_code,media_product_type&access_token=${encodeURIComponent(token)}`);
        const payload = await response.json();
        const statusCode = payload.status_code || '';
        if (statusCode === 'FINISHED' || statusCode === 'PUBLISHED') {
            return { success: true, status_code: statusCode, media_product_type: payload.media_product_type || '' };
        }
        if (statusCode === 'ERROR') {
            return { success: false, error_type: 'MEDIA_PROCESSING_FAILED', error_message: 'Container processing failed' };
        }
        if (statusCode === 'EXPIRED') {
            return { success: false, error_type: 'CONTAINER_EXPIRED', error_message: 'Container expired before publish' };
        }
        await sleep(RETRY_POLL_MS);
    }
    return { success: false, error_type: 'MEDIA_PROCESSING_FAILED', error_message: 'Timed out waiting for media processing' };
}

export function generateDedupeKey(payload = {}) {
    const normalized = {
        platform: payload.platform || '',
        post_type: payload.post_type || 'text',
        text: payload.caption || payload.message || '',
        media: payload.image_url || payload.link || payload.video_url || payload.file_url || '',
        account_id: payload.pageId || payload.igUserId || payload.account_id || ''
    };
    const raw = JSON.stringify(normalized);
    let hash = 0;
    for (let i = 0; i < raw.length; i++) {
        hash = ((hash << 5) - hash) + raw.charCodeAt(i);
        hash |= 0;
    }
    return `ddk_${Math.abs(hash)}_${raw.length}`;
}

export async function postToFacebook(payload = {}) {
    const started = nowMs();
    if (!getSocialPostingEnabledFlag()) {
        return { success: false, error_type: 'POSTING_DISABLED', error_message: 'Social posting is disabled' };
    }

    const pageId = payload.pageId || payload.page_id || '';
    if (!pageId) return { success: false, error_type: 'GRAPH_API_ERROR', error_message: 'pageId is required' };

    const queuePrep = await createQueueBeforeDispatch({ ...payload, platform: 'facebook' });
    if (!queuePrep.success) {
        return {
            success: false,
            error_type: queuePrep.error_type || 'QUEUE_ERROR',
            error_message: queuePrep.error_message || 'Queue error'
        };
    }
    if (queuePrep.duplicate) {
        return { success: false, error_type: 'DUPLICATE_POST', error_message: queuePrep.error_message || 'Duplicate post' };
    }
    const queueRecord = queuePrep.queue_record;

    try {
        const token = await socialSecretService.getFBPageToken(pageId);
        const result = await postFacebookByType(pageId, token, payload);
        if (!result.success) {
            await finalizeQueue(queueRecord, {
                status: 'failed',
                platform: 'facebook',
                error_type: result.error_type,
                error_message: result.error_message
            }, 'post_failed');
            await sendSocialAlert(result.error_type === 'TOKEN_EXPIRED' ? 'TOKEN_EXPIRED' : 'POST_DEAD_LETTERED', {
                pageId,
                errorType: result.error_type,
                message: result.error_message
            });
            await logPostingAttempt({
                platform: 'facebook',
                success: false,
                error_type: result.error_type,
                duration_ms: nowMs() - started
            });
            return result;
        }

        const fbUsage = socialRateLimitService.checkFBUsage(pageId, result.usage_header);
        await finalizeQueue(queueRecord, {
            status: 'published',
            platform: 'facebook',
            fb_post_id: result.post_id,
            published_at: new Date().toISOString()
        }, 'post_published');
        await logPostingAttempt({
            platform: 'facebook',
            success: true,
            post_id: result.post_id,
            duration_ms: nowMs() - started,
            fb_usage: fbUsage
        });
        return { success: true, post_id: result.post_id, fb_usage: fbUsage };
    } catch (error) {
        await finalizeQueue(queueRecord, {
            status: 'failed',
            platform: 'facebook',
            error_type: 'NETWORK_TIMEOUT',
            error_message: error.message
        }, 'post_failed');
        await logPostingAttempt({
            platform: 'facebook',
            success: false,
            error_type: 'NETWORK_TIMEOUT',
            duration_ms: nowMs() - started
        });
        return { success: false, error_type: 'NETWORK_TIMEOUT', error_message: error.message };
    }
}

async function createIGMediaContainer(igUserId, token, payload = {}) {
    const postType = payload.post_type || 'image';
    if (postType === 'carousel') {
        const children = Array.isArray(payload.children) ? payload.children : [];
        if (!children.length) {
            return { success: false, error_type: 'GRAPH_API_ERROR', error_message: 'children required for carousel' };
        }

        const childIds = [];
        for (const item of children) {
            const childBody = toBody({
                image_url: item.image_url || '',
                video_url: item.video_url || '',
                media_type: item.video_url ? 'VIDEO' : '',
                is_carousel_item: true,
                access_token: token
            });
            const childResponse = await fetch(`${META_GRAPH_BASE}/${igUserId}/media`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: childBody
            });
            const childPayload = await childResponse.json();
            if (!childResponse.ok || childPayload.error) {
                return { success: false, error_type: normalizeErrorType(childPayload.error || {}), error_message: childPayload.error ? childPayload.error.message : `HTTP ${childResponse.status}` };
            }
            childIds.push(childPayload.id);
        }

        const carouselBody = toBody({
            media_type: 'CAROUSEL',
            children: childIds.join(','),
            caption: payload.caption || '',
            access_token: token
        });
        const response = await fetch(`${META_GRAPH_BASE}/${igUserId}/media`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: carouselBody
        });
        const container = await response.json();
        if (!response.ok || container.error) {
            return { success: false, error_type: normalizeErrorType(container.error || {}), error_message: container.error ? container.error.message : `HTTP ${response.status}` };
        }
        return { success: true, container_id: container.id };
    }

    const body = {
        caption: payload.caption || ''
    };
    if (postType === 'video') {
        body.video_url = payload.video_url || payload.file_url || '';
        body.media_type = 'VIDEO';
    } else if (postType === 'reels') {
        body.video_url = payload.video_url || payload.file_url || '';
        body.media_type = 'REELS';
    } else {
        body.image_url = payload.image_url || payload.url || '';
    }
    if ((body.image_url && !isValidUrl(body.image_url)) || (body.video_url && !isValidUrl(body.video_url))) {
        return { success: false, error_type: 'MEDIA_NOT_PUBLIC', error_message: 'Media URL must be public and valid' };
    }

    const response = await fetch(`${META_GRAPH_BASE}/${igUserId}/media`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: toBody({ ...body, access_token: token })
    });
    const container = await response.json();
    if (!response.ok || container.error) {
        return { success: false, error_type: normalizeErrorType(container.error || {}), error_message: container.error ? container.error.message : `HTTP ${response.status}` };
    }
    return { success: true, container_id: container.id, post_type: postType };
}

export async function postToInstagram(payload = {}) {
    const started = nowMs();
    if (!getSocialPostingEnabledFlag()) {
        return { success: false, error_type: 'POSTING_DISABLED', error_message: 'Social posting is disabled' };
    }

    const igUserId = payload.igUserId || payload.ig_user_id || '';
    if (!igUserId) return { success: false, error_type: 'GRAPH_API_ERROR', error_message: 'igUserId is required' };

    const queuePrep = await createQueueBeforeDispatch({ ...payload, platform: 'instagram' });
    if (!queuePrep.success) {
        return {
            success: false,
            error_type: queuePrep.error_type || 'QUEUE_ERROR',
            error_message: queuePrep.error_message || 'Queue error'
        };
    }
    if (queuePrep.duplicate) {
        return { success: false, error_type: 'DUPLICATE_POST', error_message: queuePrep.error_message || 'Duplicate post' };
    }
    const queueRecord = queuePrep.queue_record;

    try {
        const token = await socialSecretService.getIGUserToken(igUserId);
        const quota = await socialRateLimitService.checkIGQuota(igUserId);
        if (!quota.success || !quota.can_post || Number(quota.quota_used || 0) >= 50) {
            await finalizeQueue(queueRecord, {
                status: 'failed',
                platform: 'instagram',
                error_type: 'RATE_LIMITED_IG',
                error_message: quota.error || 'Instagram quota exhausted'
            }, 'post_failed');
            return { success: false, error_type: 'RATE_LIMITED_IG', error_message: quota.error || 'IG posting quota exceeded', quota };
        }
        if (Number(quota.quota_used || 0) >= 40) {
            await sendSocialAlert('IG_QUOTA_NEAR_LIMIT', {
                igUserId,
                quotaUsed: quota.quota_used,
                quotaTotal: quota.quota_total
            });
        }

        const container = await createIGMediaContainer(igUserId, token, payload);
        if (!container.success) {
            await finalizeQueue(queueRecord, {
                status: 'failed',
                platform: 'instagram',
                error_type: container.error_type,
                error_message: container.error_message
            }, 'post_failed');
            return { success: false, error_type: container.error_type, error_message: container.error_message };
        }

        const postType = payload.post_type || 'image';
        if (postType === 'video' || postType === 'reels') {
            const poll = await pollContainerStatus(container.container_id, token);
            if (!poll.success) {
                await finalizeQueue(queueRecord, {
                    status: 'failed',
                    platform: 'instagram',
                    ig_container_id: container.container_id,
                    error_type: poll.error_type,
                    error_message: poll.error_message
                }, 'post_failed');
                return { success: false, error_type: poll.error_type, error_message: poll.error_message };
            }
        }

        const publishResponse = await fetch(`${META_GRAPH_BASE}/${igUserId}/media_publish`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: toBody({
                creation_id: container.container_id,
                access_token: token
            })
        });
        const publishPayload = await publishResponse.json();
        if (!publishResponse.ok || publishPayload.error) {
            const errorType = normalizeErrorType(publishPayload.error || {});
            await finalizeQueue(queueRecord, {
                status: 'failed',
                platform: 'instagram',
                ig_container_id: container.container_id,
                error_type: errorType,
                error_message: publishPayload.error ? publishPayload.error.message : `HTTP ${publishResponse.status}`
            }, 'post_failed');
            await sendSocialAlert(errorType === 'TOKEN_EXPIRED' ? 'TOKEN_EXPIRED' : 'POST_DEAD_LETTERED', {
                igUserId,
                errorType,
                message: publishPayload.error ? publishPayload.error.message : `HTTP ${publishResponse.status}`
            });
            return {
                success: false,
                error_type: errorType,
                error_message: publishPayload.error ? publishPayload.error.message : `HTTP ${publishResponse.status}`
            };
        }

        await finalizeQueue(queueRecord, {
            status: 'published',
            platform: 'instagram',
            ig_container_id: container.container_id,
            ig_media_id: publishPayload.id || '',
            published_at: new Date().toISOString()
        }, 'post_published');

        await logPostingAttempt({
            platform: 'instagram',
            success: true,
            media_id: publishPayload.id || '',
            container_id: container.container_id,
            duration_ms: nowMs() - started,
            quota
        });
        return { success: true, media_id: publishPayload.id || '', container_id: container.container_id, quota };
    } catch (error) {
        await finalizeQueue(queueRecord, {
            status: 'failed',
            platform: 'instagram',
            error_type: 'NETWORK_TIMEOUT',
            error_message: error.message
        }, 'post_failed');
        return { success: false, error_type: 'NETWORK_TIMEOUT', error_message: error.message };
    }
}

export async function postToBoth(payload = {}) {
    const facebookPayload = {
        ...payload,
        platform: 'facebook',
        post_type: payload.fb_post_type || payload.post_type || 'text',
        pageId: payload.pageId || payload.page_id || ''
    };
    const instagramPayload = {
        ...payload,
        platform: 'instagram',
        post_type: payload.ig_post_type || payload.post_type || 'image',
        igUserId: payload.igUserId || payload.ig_user_id || ''
    };

    const [facebookResult, instagramResult] = await Promise.allSettled([
        postToFacebook(facebookPayload),
        postToInstagram(instagramPayload)
    ]);

    const fb = facebookResult.status === 'fulfilled' ? facebookResult.value : {
        success: false,
        error_type: 'NETWORK_TIMEOUT',
        error_message: facebookResult.reason ? String(facebookResult.reason.message || facebookResult.reason) : 'Unknown Facebook failure'
    };
    const ig = instagramResult.status === 'fulfilled' ? instagramResult.value : {
        success: false,
        error_type: 'NETWORK_TIMEOUT',
        error_message: instagramResult.reason ? String(instagramResult.reason.message || instagramResult.reason) : 'Unknown Instagram failure'
    };

    const overall_status = fb.success && ig.success ? 'published' :
        ((fb.success || ig.success) ? 'partial' : 'failed');

    return {
        success: overall_status !== 'failed',
        overall_status,
        facebook: fb,
        instagram: ig
    };
}

export const post = {
    facebook: postToFacebook,
    instagram: postToInstagram,
    both: postToBoth
};

/**
 * Admin Observability Agent Service
 *
 * Wraps observability, run ledger, and outcome services for
 * agent-accessible tracing, performance, and replay tools.
 */
import * as dataAccess from 'backend/dataAccess';

function toTimestamp(value) {
  const ts = value ? new Date(value).getTime() : NaN;
  return Number.isFinite(ts) ? ts : 0;
}

function formatDuration(ms) {
  if (!ms || ms <= 0) return '-';
  if (ms < 60000) return `${Math.round(ms / 1000)}s`;
  return `${Math.round(ms / 60000)}m`;
}

export async function getTracingDashboard(userId, params = {}) {
  try {
    const period = params.period || '24h';
    const svc = await import('backend/observabilityService');

    const [health, agentBehavior] = await Promise.all([
      svc.getHealthMetrics(period),
      svc.getAgentBehavior({ period })
    ]);

    return { health, agentBehavior, period };
  } catch (error) {
    return { error: error.message };
  }
}

export async function getToolPerformance(userId, params = {}) {
  try {
    const { toolName, period } = params;
    const limit = params.limit || 100;
    const svc = await import('backend/agentRunLedgerService');

    const runs = await svc.getRecentRuns({ limit });
    const allSteps = [];

    // Gather steps from each run
    const runItems = runs?.items || runs || [];
    for (const run of runItems) {
      try {
        const steps = await svc.getSteps(run.run_id);
        const stepItems = steps?.items || steps || [];
        allSteps.push(...stepItems);
      } catch (_) {
        // Skip runs with missing steps
      }
    }

    // Group by tool_name and compute metrics
    const toolMap = {};
    for (const step of allSteps) {
      const name = step.tool_name || step.toolName || 'unknown';
      if (!toolMap[name]) {
        toolMap[name] = { totalLatency: 0, successCount: 0, errorCount: 0, callCount: 0 };
      }
      toolMap[name].callCount++;
      toolMap[name].totalLatency += Number(step.latency_ms || step.latencyMs || 0);
      if (step.status === 'success' || step.status === 'completed') {
        toolMap[name].successCount++;
      } else if (step.status === 'error' || step.status === 'failed') {
        toolMap[name].errorCount++;
      }
    }

    let tools = Object.entries(toolMap).map(([name, data]) => ({
      name,
      avgLatency: data.callCount > 0 ? Math.round(data.totalLatency / data.callCount) : 0,
      successRate: data.callCount > 0 ? Math.round((data.successCount / data.callCount) * 100) : 0,
      callCount: data.callCount,
      errorRate: data.callCount > 0 ? Math.round((data.errorCount / data.callCount) * 100) : 0
    }));

    if (toolName) {
      tools = tools.filter(t => t.name === toolName);
    }

    tools.sort((a, b) => b.callCount - a.callCount);

    return { tools, period: period || 'all' };
  } catch (error) {
    return { error: error.message };
  }
}

export async function getScoringAccuracy(userId, params = {}) {
  try {
    const role = params.role || 'all';
    const days = params.days || 30;
    const svc = await import('backend/agentOutcomeService');

    const [stats, trends] = await Promise.all([
      svc.getOutcomeStats(role, days),
      svc.getOutcomeTrends(days)
    ]);

    return { stats, trends, period: days };
  } catch (error) {
    return { error: error.message };
  }
}

export async function recalibrateScoring(userId, params = {}) {
  try {
    const { weights } = params;
    if (!weights || typeof weights !== 'object') {
      return { error: 'weights object is required' };
    }

    const evalSvc = await import('backend/agentEvaluationService');
    const role = params.role || 'all';

    const previousBaseline = await evalSvc.computeWeeklyScorecard(role, 30);

    await dataAccess.insertRecord('agentEvaluations', {
      type: 'calibration',
      role,
      weights: JSON.stringify(weights),
      previous_baseline: JSON.stringify(previousBaseline),
      calibrated_by: userId,
      calibrated_at: new Date().toISOString()
    }, { suppressAuth: true });

    return {
      success: true,
      previousBaseline,
      newWeights: weights,
      calibratedAt: new Date().toISOString()
    };
  } catch (error) {
    return { error: error.message };
  }
}

export async function getAgentReplay(userId, params = {}) {
  try {
    const { runId } = params;
    if (!runId) return { error: 'runId is required' };

    const svc = await import('backend/agentRunLedgerService');
    const trace = await svc.getRunExecutionTrace(runId);
    if (!trace) return { error: 'Run not found' };

    return {
      ...trace,
      totalSteps: trace.steps.length,
      totalDuration: trace.steps.reduce((sum, step) => sum + Number(step.latency_ms || step.latencyMs || 0), 0)
    };
  } catch (error) {
    return { error: error.message };
  }
}

export async function getAgentKpis(userId, params = {}) {
  try {
    const days = params.days || 7;
    const cutoffTime = Date.now() - (days * 86400000);
    const [outcomeSvc, ledgerSvc] = await Promise.all([
      import('backend/agentOutcomeService'),
      import('backend/agentRunLedgerService')
    ]);

    const baseStats = await outcomeSvc.getOutcomeStats('all', days);
    const recentRuns = await ledgerSvc.getRecentRunsWithExecution({ limit: 100 });
    const runs = (recentRuns.items || []).filter(run => toTimestamp(run.started_at) >= cutoffTime);
    const gates = await ledgerSvc.getApprovalGatesByDateRange(days);

    const parallelRuns = runs.filter(run => Number(run.parallel_nodes || 0) > 0 || run.execution_model === 'planned_sequential');
    const degradedRuns = runs.filter(run => Number(run.degraded_steps || 0) > 0);
    const verifierDegradedRuns = runs.filter(run => run.verifier_status === 'degraded_but_acceptable');
    const verifierBlockedRuns = runs.filter(run => run.verifier_status === 'blocked');
    const totalBranches = runs.reduce((sum, run) => sum + Number(run.branch_count || 0), 0);
    const totalCriticalPathMs = runs.reduce((sum, run) => sum + Number(run.critical_path_ms || 0), 0);
    const executionModelMix = runs.reduce((acc, run) => {
      const key = run.execution_model || 'sequential';
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {});

    let totalDecisionMs = 0;
    let decidedCount = 0;
    for (const gate of gates) {
      const presentedAt = toTimestamp(gate.presented_at);
      const decidedAt = toTimestamp(gate.decided_at);
      if (presentedAt > 0 && decidedAt > presentedAt) {
        totalDecisionMs += (decidedAt - presentedAt);
        decidedCount += 1;
      }
    }

    return {
      ...baseStats,
      parallel_runs: parallelRuns.length,
      parallel_run_rate: runs.length > 0 ? Math.round((parallelRuns.length / runs.length) * 100) : 0,
      avg_branch_count: runs.length > 0 ? Math.round((totalBranches / runs.length) * 10) / 10 : 0,
      degraded_run_rate: runs.length > 0 ? Math.round((degradedRuns.length / runs.length) * 100) : 0,
      verifier_degraded_rate: runs.length > 0 ? Math.round((verifierDegradedRuns.length / runs.length) * 100) : 0,
      verifier_blocked_count: verifierBlockedRuns.length,
      avg_critical_path_ms: runs.length > 0 ? Math.round(totalCriticalPathMs / runs.length) : 0,
      avg_approval_wait: formatDuration(decidedCount > 0 ? Math.round(totalDecisionMs / decidedCount) : 0),
      execution_model_mix: executionModelMix
    };
  } catch (error) {
    return {
      total_runs: 0,
      success_rate: 0,
      avg_quality_score: 0,
      partial_rate: 0,
      failure_rate: 0,
      period_days: params.days || 7,
      role: 'all',
      parallel_runs: 0,
      parallel_run_rate: 0,
      avg_branch_count: 0,
      degraded_run_rate: 0,
      verifier_degraded_rate: 0,
      verifier_blocked_count: 0,
      avg_critical_path_ms: 0,
      avg_approval_wait: '-',
      execution_model_mix: {},
      error: error.message
    };
  }
}

export async function getRunMonitorRuns(userId, params = {}) {
  try {
    const svc = await import('backend/agentRunLedgerService');
    return await svc.getRecentRunsWithExecution({
      status: params.status || undefined,
      limit: params.limit || 20,
      offset: params.offset || 0
    });
  } catch (error) {
    return { error: error.message };
  }
}

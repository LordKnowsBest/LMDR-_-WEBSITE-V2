import * as dataAccess from 'backend/dataAccess';
import { log } from 'backend/observabilityService';

const COLLECTION_KEY = 'emailTemplates';
const LOG_COLLECTION_KEY = 'emailSendLogs';

/**
 * Get all email templates
 */
export async function getAllTemplates(category = null) {
  const filters = category ? { category } : {};
  const result = await dataAccess.queryRecords(COLLECTION_KEY, {
    filters,
    sort: [{ field: 'name', direction: 'asc' }],
    suppressAuth: true
  });
  return result.items || [];
}

/**
 * Get a single template by key
 */
export async function getTemplate(templateKey) {
  return await dataAccess.findByField(COLLECTION_KEY, 'templateKey', templateKey, { suppressAuth: true });
}

/**
 * Create a new email template
 */
export async function createTemplate(templateData) {
  // Validate unique key
  const existing = await getTemplate(templateData.templateKey);
  if (existing) {
    throw new Error(`Template with key '${templateData.templateKey}' already exists`);
  }

  const sanitized = sanitizeTemplateInput(templateData);
  return await dataAccess.insertRecord(COLLECTION_KEY, {
    ...sanitized,
    version: 1,
    isActive: templateData.isActive ?? false,
    createdAt: new Date(),
    updatedAt: new Date()
  }, { suppressAuth: true });
}

/**
 * Update an existing template and handle versioning
 */
export async function updateTemplate(templateKey, updates) {
  const existing = await getTemplate(templateKey);
  if (!existing) {
    throw new Error(`Template '${templateKey}' not found`);
  }

  const sanitizedUpdates = sanitizeTemplateInput(updates);

  // Handle versioning if content changed
  let newVersion = existing.version || 1;
  const previousVersions = existing.previousVersions || [];
  
  const hasContentChange = sanitizedUpdates.htmlContent !== existing.htmlContent || 
                           sanitizedUpdates.subject !== existing.subject;

  if (hasContentChange) {
    newVersion++;
    // Archive current version
    previousVersions.push({
      version: existing.version,
      htmlContent: existing.htmlContent,
      subject: existing.subject,
      updatedAt: existing.updatedAt,
      updatedBy: existing.updatedBy
    });
    
    // Keep only last 5 versions
    if (previousVersions.length > 5) {
      previousVersions.shift();
    }
  }

  return await dataAccess.updateRecord(COLLECTION_KEY, {
    ...existing,
    ...sanitizedUpdates,
    version: newVersion,
    previousVersions,
    updatedAt: new Date()
  }, { suppressAuth: true });
}

/**
 * Activate a template
 */
export async function activateTemplate(templateKey) {
  return await updateTemplate(templateKey, { isActive: true });
}

/**
 * Get version history.
 */
export async function getTemplateVersions(templateKey) {
  const template = await getTemplate(templateKey);
  if (!template) {
    throw new Error(`Template '${templateKey}' not found`);
  }
  const history = Array.isArray(template.previousVersions) ? template.previousVersions : [];
  return [
    {
      version: template.version || 1,
      subject: template.subject || '',
      updatedAt: template.updatedAt || template.createdAt || null,
      isActive: !!template.isActive
    },
    ...history.slice().reverse().map((version) => ({
      ...version,
      isActive: false
    }))
  ];
}

/**
 * Revert to a previous version
 */
export async function revertToVersion(templateKey, version) {
  const template = await getTemplate(templateKey);
  if (!template) throw new Error(`Template '${templateKey}' not found`);

  const prev = (template.previousVersions || []).find(v => v.version === version);
  if (!prev) throw new Error(`Version ${version} not found for template '${templateKey}'`);

  return await updateTemplate(templateKey, {
    htmlContent: prev.htmlContent,
    subject: prev.subject,
    isActive: true
  });
}

/**
 * Render a template with variables
 */
export async function renderEmail(templateKey, variables) {
  const template = await getTemplate(templateKey);
  if (!template) throw new Error(`Template '${templateKey}' not found`);

  const safeTemplate = sanitizeTemplateInput(template);
  let html = safeTemplate.htmlContent || '';
  let subject = safeTemplate.subject || '';
  let preheader = safeTemplate.preheader || '';

  // Standard substitutions.
  const allVars = {
    ...variables,
    'platform.url': 'https://www.lastmiledr.app',
    'date.today': new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
  };

  validateRequiredVariables(safeTemplate, allVars);

  const replaceToken = (input) => replaceTemplateVariables(input, allVars);
  html = replaceToken(html);
  subject = replaceToken(subject);
  preheader = replaceToken(preheader);

  return {
    subject,
    preheader,
    htmlContent: html,
    plainText: stripHtml(html)
  };
}

/**
 * Send a test email to an admin
 */
export async function sendTestEmail(templateKey, recipientEmail, sampleData = {}) {
  const rendered = await renderEmail(templateKey, sampleData);
  
  // LOG the attempt.
  await log({
    level: 'INFO',
    source: 'email-template-service',
    message: `Sending test email: ${templateKey} to ${recipientEmail}`,
    details: { templateKey, recipientEmail }
  });

  await dataAccess.insertRecord(LOG_COLLECTION_KEY, {
    templateKey,
    recipientId: recipientEmail,
    recipientEmail,
    sentAt: new Date(),
    opened: false,
    clicked: false,
    bounced: false,
    isTest: true
  }, { suppressAuth: true });

  // Placeholder for email provider dispatch.
  return { 
    success: true, 
    message: 'Test email rendered and simulated (Integration pending)',
    rendered 
  };
}

/**
 * Basic HTML stripping for plain text fallback
 */
function stripHtml(html) {
  if (!html) return '';
  return html
    .replace(/<style([\s\S]*?)<\/style>/gi, '')
    .replace(/<script([\s\S]*?)<\/script>/gi, '')
    .replace(/<\/(p|div|h1|h2|h3|li|br)>/gi, '\n')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function sanitizeTemplateInput(templateData = {}) {
  const sanitized = { ...templateData };
  if (Object.prototype.hasOwnProperty.call(sanitized, 'htmlContent')) {
    sanitized.htmlContent = sanitizeHtml(sanitized.htmlContent || '');
  }
  if (Object.prototype.hasOwnProperty.call(sanitized, 'subject')) {
    sanitized.subject = String(sanitized.subject || '').trim();
  }
  if (Object.prototype.hasOwnProperty.call(sanitized, 'preheader')) {
    sanitized.preheader = String(sanitized.preheader || '').trim();
  }
  return sanitized;
}

function sanitizeHtml(html) {
  return String(html || '')
    .replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '')
    .replace(/\son\w+="[^"]*"/gi, '')
    .replace(/\son\w+='[^']*'/gi, '')
    .replace(/javascript:/gi, '');
}

function replaceTemplateVariables(input, variables = {}) {
  return String(input || '').replace(/{{\s*([\w.]+)\s*}}/g, (_, keyPath) => {
    const value = getPathValue(variables, keyPath);
    return value === undefined || value === null ? '' : String(value);
  });
}

function getPathValue(source, keyPath) {
  if (!source || !keyPath) return undefined;
  if (Object.prototype.hasOwnProperty.call(source, keyPath)) {
    return source[keyPath];
  }
  return String(keyPath).split('.').reduce((acc, key) => {
    if (!acc || typeof acc !== 'object') {
      return undefined;
    }
    return acc[key];
  }, source);
}

function validateRequiredVariables(template, variables) {
  const configuredVars = Array.isArray(template.variables) ? template.variables : [];
  const missing = configuredVars
    .filter((item) => item && item.required)
    .map((item) => item.key || item.name)
    .filter((key) => key && getPathValue(variables, key) === undefined);
  if (missing.length > 0) {
    throw new Error(`Missing required variables: ${missing.join(', ')}`);
  }
}

/**
 * Streak Notifications Service
 *
 * Handles all streak-related notifications including:
 * - Streak at risk warnings
 * - Streak broken notifications
 * - Streak milestone celebrations
 */

import { createNotification } from 'backend/memberService';
import { getStreakStatus, getStreaksAtRisk } from 'backend/streakService';

// =============================================================================
// NOTIFICATION TYPES
// =============================================================================

export const STREAK_NOTIFICATION_TYPES = {
  STREAK_AT_RISK: 'streak_at_risk',
  STREAK_BROKEN: 'streak_broken',
  STREAK_MILESTONE: 'streak_milestone',
  STREAK_FREEZE_USED: 'streak_freeze_used',
  STREAK_FREEZE_GRANTED: 'streak_freeze_granted'
};

// =============================================================================
// NOTIFICATION CONTENT
// =============================================================================

const MILESTONE_MESSAGES = {
  7: {
    title: '1 Week Streak!',
    message: "You've logged in 7 days in a row! You're now earning 1.1x XP on all actions. Keep it up!"
  },
  30: {
    title: '30 Day Streak!',
    message: "Incredible! A full month of consistency! You're now earning 1.25x XP. You're on fire!"
  },
  60: {
    title: '60 Day Streak!',
    message: "Two months strong! You're in the top tier of dedicated drivers. Enjoy 1.35x XP on everything!"
  },
  90: {
    title: 'LEGENDARY 90 Day Streak!',
    message: "You've achieved legendary status! Maximum 1.5x XP multiplier unlocked. You're unstoppable!"
  }
};

// =============================================================================
// NOTIFICATION FUNCTIONS
// =============================================================================

/**
 * Send streak at risk notification
 * Called in the evening if user hasn't logged in today
 * @param {string} driverId
 * @param {number} currentStreak
 * @param {number} freezesAvailable
 * @returns {object} { success }
 */
export async function sendStreakAtRiskNotification(driverId, currentStreak, freezesAvailable) {
  try {
    const title = 'Your Streak is at Risk!';
    let message = `Don't lose your ${currentStreak}-day streak! Log in before midnight to keep it going.`;

    if (freezesAvailable > 0) {
      message += ` You have ${freezesAvailable} streak freeze${freezesAvailable > 1 ? 's' : ''} available if you miss a day.`;
    } else {
      message += ' You have no streak freezes left - log in today to protect your progress!';
    }

    return await createNotification(
      driverId,
      STREAK_NOTIFICATION_TYPES.STREAK_AT_RISK,
      title,
      message,
      '/dashboard' // Link to dashboard
    );
  } catch (error) {
    console.error('sendStreakAtRiskNotification error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Send streak broken notification with encouragement
 * @param {string} driverId
 * @param {number} previousStreak
 * @returns {object} { success }
 */
export async function sendStreakBrokenNotification(driverId, previousStreak) {
  try {
    const title = 'Streak Reset';
    let message = '';

    if (previousStreak >= 30) {
      message = `Your ${previousStreak}-day streak has ended, but what an achievement! You proved you can do it once - now let's build an even longer one. Log in today to start fresh!`;
    } else if (previousStreak >= 7) {
      message = `Your ${previousStreak}-day streak has reset. Don't be discouraged - every day is a chance to start again. Your next streak starts today!`;
    } else {
      message = `Your streak has reset. No worries! Log in today to start building a new streak. Consistency is key!`;
    }

    return await createNotification(
      driverId,
      STREAK_NOTIFICATION_TYPES.STREAK_BROKEN,
      title,
      message,
      '/dashboard'
    );
  } catch (error) {
    console.error('sendStreakBrokenNotification error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Send streak milestone celebration notification
 * @param {string} driverId
 * @param {number} milestone - 7, 30, 60, or 90 days
 * @param {number} bonusXP - XP earned for milestone
 * @returns {object} { success }
 */
export async function sendStreakMilestoneNotification(driverId, milestone, bonusXP = 0) {
  try {
    const content = MILESTONE_MESSAGES[milestone];

    if (!content) {
      console.warn(`No milestone message for ${milestone} days`);
      return { success: false, reason: 'invalid_milestone' };
    }

    let message = content.message;
    if (bonusXP > 0) {
      message += ` +${bonusXP} bonus XP earned!`;
    }

    return await createNotification(
      driverId,
      STREAK_NOTIFICATION_TYPES.STREAK_MILESTONE,
      content.title,
      message,
      '/dashboard'
    );
  } catch (error) {
    console.error('sendStreakMilestoneNotification error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Send notification when streak freeze is auto-used
 * @param {string} driverId
 * @param {number} streakPreserved
 * @param {number} freezesRemaining
 * @returns {object} { success }
 */
export async function sendStreakFreezeUsedNotification(driverId, streakPreserved, freezesRemaining) {
  try {
    const title = 'Streak Freeze Used';
    let message = `We used one of your streak freezes to protect your ${streakPreserved}-day streak! `;

    if (freezesRemaining > 0) {
      message += `You have ${freezesRemaining} freeze${freezesRemaining > 1 ? 's' : ''} remaining.`;
    } else {
      message += `This was your last freeze - make sure to log in tomorrow!`;
    }

    return await createNotification(
      driverId,
      STREAK_NOTIFICATION_TYPES.STREAK_FREEZE_USED,
      title,
      message,
      '/dashboard'
    );
  } catch (error) {
    console.error('sendStreakFreezeUsedNotification error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Send notification when monthly streak freeze is granted
 * @param {string} driverId
 * @param {number} newTotal
 * @returns {object} { success }
 */
export async function sendStreakFreezeGrantedNotification(driverId, newTotal) {
  try {
    const title = 'Monthly Streak Freeze Granted!';
    const message = `You've received your monthly streak freeze! You now have ${newTotal} freeze${newTotal > 1 ? 's' : ''} available to protect your streak if you miss a day.`;

    return await createNotification(
      driverId,
      STREAK_NOTIFICATION_TYPES.STREAK_FREEZE_GRANTED,
      title,
      message,
      '/dashboard'
    );
  } catch (error) {
    console.error('sendStreakFreezeGrantedNotification error:', error);
    return { success: false, error: error.message };
  }
}

// =============================================================================
// BATCH NOTIFICATION FUNCTIONS (for scheduled jobs)
// =============================================================================

/**
 * Send streak at risk notifications to all drivers who haven't logged in today
 * Called by scheduled job around 8pm
 * @returns {object} { sent, failed }
 */
export async function sendBatchStreakAtRiskNotifications() {
  try {
    const atRiskDrivers = await getStreaksAtRisk();

    let sent = 0;
    let failed = 0;

    for (const driver of atRiskDrivers) {
      try {
        const result = await sendStreakAtRiskNotification(
          driver.driverId,
          driver.streakDays,
          driver.freezesAvailable
        );

        if (result.success) {
          sent++;
        } else {
          failed++;
        }
      } catch (err) {
        failed++;
      }
    }

    return { sent, failed, total: atRiskDrivers.length };
  } catch (error) {
    console.error('sendBatchStreakAtRiskNotifications error:', error);
    return { sent: 0, failed: 0, error: error.message };
  }
}

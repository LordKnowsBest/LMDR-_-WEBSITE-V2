// ============================================================================
// AGENT SERVICE - Central AI Orchestration Layer
// Takes user messages, builds role-scoped tools, calls AI with tool definitions,
// executes tool_use responses against real backend services, loops until text response
// ============================================================================

import { routeAIRequest } from 'backend/aiRouterService';
import { createConversation, addTurn, getRecentContext } from 'backend/agentConversationService';
import * as dataAccess from 'backend/dataAccess';
import { startRun, logStep, createGate, completeRun } from 'backend/agentRunLedgerService';

// ── Cost Control Configuration ──
const COST_CONTROLS = {
  maxTokensPerRun: {
    driver: 10000,
    recruiter: 15000,
    admin: 20000,
    carrier: 10000
  },
  maxRunTimeMs: 30000,
  maxDailyRunsPerUser: 100,
  costAlertThreshold: 0.50
};

const _dailyRunCounts = new Map();

// Tool definitions mapped to existing backend services
const TOOL_DEFINITIONS = {
  // Driver tools
  find_matches: {
    name: 'find_matches',
    description: 'Find carriers matching driver preferences (zip, distance, pay, run type)',
    input_schema: {
      type: 'object',
      properties: {
        zip: { type: 'string', description: 'Driver home zip code' },
        maxDistance: { type: 'number', description: 'Maximum commute distance in miles' },
        minCPM: { type: 'number', description: 'Minimum cents per mile' },
        operationType: { type: 'string', enum: ['OTR', 'Regional', 'Local', 'any'] }
      },
      required: ['zip']
    },
    serviceModule: 'backend/carrierMatching',
    serviceFunction: 'findMatchingCarriers',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'matches_returned > 0',
      rollback_strategy: null,
      audit_fields: ['zip', 'maxDistance']
    }
  },
  get_carrier_details: {
    name: 'get_carrier_details',
    description: 'Get detailed AI-enriched information about a specific carrier by DOT number',
    input_schema: {
      type: 'object',
      properties: {
        dotNumber: { type: 'string', description: 'USDOT number of the carrier' }
      },
      required: ['dotNumber']
    },
    serviceModule: 'backend/aiEnrichment',
    serviceFunction: 'enrichCarrier',
    roles: ['driver', 'recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'carrier_data_returned',
      rollback_strategy: null,
      audit_fields: ['dotNumber']
    }
  },
  explain_match: {
    name: 'explain_match',
    description: 'Explain why a driver matched with a specific carrier',
    input_schema: {
      type: 'object',
      properties: {
        driverId: { type: 'string' },
        carrierDot: { type: 'string' }
      },
      required: ['driverId', 'carrierDot']
    },
    serviceModule: 'backend/matchExplanationService',
    serviceFunction: 'getMatchExplanationForDriver',
    roles: ['driver'],
    policy: {
      risk_level: 'suggest',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'explanation_generated',
      rollback_strategy: null,
      audit_fields: ['driverId', 'carrierDot']
    }
  },
  get_fmcsa_data: {
    name: 'get_fmcsa_data',
    description: 'Get FMCSA safety data for a carrier',
    input_schema: {
      type: 'object',
      properties: {
        dotNumber: { type: 'string', description: 'USDOT number' }
      },
      required: ['dotNumber']
    },
    serviceModule: 'backend/externalFmcsaApi',
    serviceFunction: 'getCarrierSafety',
    roles: ['driver', 'recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'safety_data_returned',
      rollback_strategy: null,
      audit_fields: ['dotNumber']
    }
  },
  road_conditions: {
    name: 'road_conditions',
    description: 'Get current road conditions for a location',
    input_schema: {
      type: 'object',
      properties: {
        lat: { type: 'number' },
        lon: { type: 'number' },
        zip: { type: 'string' }
      }
    },
    serviceModule: 'backend/roadConditionService',
    serviceFunction: 'getRoadConditions',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'conditions_returned',
      rollback_strategy: null,
      audit_fields: ['zip']
    }
  },
  find_parking: {
    name: 'find_parking',
    description: 'Search for truck parking near a location',
    input_schema: {
      type: 'object',
      properties: {
        lat: { type: 'number' },
        lon: { type: 'number' },
        radius: { type: 'number', description: 'Search radius in miles' }
      }
    },
    serviceModule: 'backend/parkingService',
    serviceFunction: 'searchParking',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'parking_results_returned',
      rollback_strategy: null,
      audit_fields: ['lat', 'lon']
    }
  },
  // Recruiter tools
  search_drivers: {
    name: 'search_drivers',
    description: 'Search for CDL drivers matching criteria',
    input_schema: {
      type: 'object',
      properties: {
        zip: { type: 'string' },
        maxDistance: { type: 'number' },
        endorsements: { type: 'string', description: 'Comma-separated endorsements (Hazmat, Tanker, Doubles)' },
        minExperience: { type: 'number', description: 'Minimum years of experience' }
      }
    },
    serviceModule: 'backend/driverMatching',
    serviceFunction: 'findMatchingDrivers',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'drivers_returned > 0',
      rollback_strategy: null,
      audit_fields: ['zip', 'endorsements']
    }
  },
  get_pipeline: {
    name: 'get_pipeline',
    description: 'Get pipeline candidates for a carrier',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        status: { type: 'string', enum: ['new', 'contacted', 'screening', 'interview', 'offer', 'hired'] }
      },
      required: ['carrierDot']
    },
    serviceModule: 'backend/recruiter_service',
    serviceFunction: 'getPipelineCandidates',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'pipeline_data_returned',
      rollback_strategy: null,
      audit_fields: ['carrierDot']
    }
  },
  update_candidate_status: {
    name: 'update_candidate_status',
    description: 'Update a candidate status in the pipeline',
    input_schema: {
      type: 'object',
      properties: {
        interestId: { type: 'string' },
        newStatus: { type: 'string', enum: ['new', 'contacted', 'screening', 'interview', 'offer', 'hired', 'rejected'] }
      },
      required: ['interestId', 'newStatus']
    },
    serviceModule: 'backend/recruiter_service',
    serviceFunction: 'updateCandidateStatus',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'status_changed',
      rollback_strategy: 'revert_to_previous_status',
      audit_fields: ['interestId', 'newStatus']
    }
  },
  send_message: {
    name: 'send_message',
    description: 'Send a message to a driver or recruiter',
    input_schema: {
      type: 'object',
      properties: {
        applicationId: { type: 'string' },
        content: { type: 'string' },
        receiverId: { type: 'string' }
      },
      required: ['applicationId', 'content', 'receiverId']
    },
    serviceModule: 'backend/messaging',
    serviceFunction: 'sendMessage',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'message_delivered',
      rollback_strategy: null,
      audit_fields: ['receiverId', 'content']
    }
  },
  schedule_interview: {
    name: 'schedule_interview',
    description: 'Request interview availability from a candidate',
    input_schema: {
      type: 'object',
      properties: {
        applicationId: { type: 'string' }
      },
      required: ['applicationId']
    },
    serviceModule: 'backend/interviewScheduler',
    serviceFunction: 'requestAvailability',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'availability_requested',
      rollback_strategy: 'cancel_request',
      audit_fields: ['applicationId']
    }
  },
  log_call: {
    name: 'log_call',
    description: 'Log a call outcome with a driver',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        driverId: { type: 'string' },
        outcome: { type: 'string', enum: ['interested', 'callback', 'not_now', 'wrong_fit', 'no_answer', 'voicemail'] },
        notes: { type: 'string' }
      },
      required: ['carrierDot', 'outcome']
    },
    serviceModule: 'backend/callOutcomeService',
    serviceFunction: 'logCallOutcome',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'call_logged',
      rollback_strategy: 'delete_call_record',
      audit_fields: ['carrierDot', 'outcome']
    }
  },
  get_recruiter_analytics: {
    name: 'get_recruiter_analytics',
    description: 'Get funnel and recruiting analytics metrics',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        period: { type: 'string', enum: ['week', 'month', 'quarter'] }
      }
    },
    serviceModule: 'backend/recruiterAnalyticsService',
    serviceFunction: 'getFunnelMetrics',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'analytics_returned',
      rollback_strategy: null,
      audit_fields: ['carrierDot', 'period']
    }
  },
  // Admin tools
  get_system_health: {
    name: 'get_system_health',
    description: 'Get system health and observability metrics',
    input_schema: { type: 'object', properties: {} },
    serviceModule: 'backend/observabilityService',
    serviceFunction: 'getMetrics',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'health_metrics_returned',
      rollback_strategy: null,
      audit_fields: []
    }
  },
  get_driver_stats: {
    name: 'get_driver_stats',
    description: 'Get driver statistics and listings for admin',
    input_schema: {
      type: 'object',
      properties: {
        page: { type: 'number' },
        pageSize: { type: 'number' },
        status: { type: 'string' }
      }
    },
    serviceModule: 'backend/admin_service',
    serviceFunction: 'getDrivers',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'driver_stats_returned',
      rollback_strategy: null,
      audit_fields: ['status']
    }
  },
  manage_prompts: {
    name: 'manage_prompts',
    description: 'Manage AI prompt templates (list, create, update)',
    input_schema: {
      type: 'object',
      properties: {
        operation: { type: 'string', enum: ['list', 'get', 'create', 'update'] },
        promptId: { type: 'string' },
        data: { type: 'object' }
      },
      required: ['operation']
    },
    serviceModule: 'backend/promptLibraryService',
    serviceFunction: null,
    roles: ['admin'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'prompt_operation_completed',
      rollback_strategy: 'revert_prompt_version',
      audit_fields: ['operation', 'promptId']
    }
  },
  // Carrier/B2B tools
  get_account: {
    name: 'get_account',
    description: 'Get B2B account details',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' }
      },
      required: ['accountId']
    },
    serviceModule: 'backend/b2bAccountService',
    serviceFunction: 'getAccount',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'account_data_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    }
  },
  get_signals: {
    name: 'get_signals',
    description: 'Get match signals for a B2B account',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' }
      },
      required: ['accountId']
    },
    serviceModule: 'backend/b2bMatchSignalService',
    serviceFunction: 'getSignals',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'signals_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    }
  },
  get_opportunities: {
    name: 'get_opportunities',
    description: 'Get pipeline opportunities for B2B',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' },
        stage: { type: 'string' }
      }
    },
    serviceModule: 'backend/b2bPipelineService',
    serviceFunction: 'getOpportunities',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'opportunities_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    }
  },
  get_agent_kpis: {
    name: 'get_agent_kpis',
    description: 'Get agent orchestration KPIs — success rates, quality scores, costs, approval stats',
    input_schema: {
      type: 'object',
      properties: {
        role: { type: 'string', enum: ['driver', 'recruiter', 'admin', 'carrier', 'all'], description: 'Filter by role or all' },
        days: { type: 'number', description: 'Number of days to analyze (default 7)' }
      }
    },
    serviceModule: 'backend/agentOutcomeService',
    serviceFunction: 'getOutcomeStats',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'stats_returned',
      rollback_strategy: null,
      audit_fields: ['role', 'days']
    }
  },
  // Cross-role intelligence tools (Phase 2)
  get_market_intel: {
    name: 'get_market_intel',
    description: 'Get aggregated market intelligence — carrier demand signals, top regions/equipment, and pay ranges',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region filter (e.g. Southeast, Midwest)' },
        job_type: { type: 'string', description: 'Job type filter (OTR, Regional, Local, Dedicated)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getMarketIntel',
    roles: ['recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'intel_returned_with_data',
      rollback_strategy: null,
      audit_fields: ['region', 'job_type']
    }
  },
  get_lane_demand: {
    name: 'get_lane_demand',
    description: 'Get lane-level demand analysis — demand scores, driver supply gaps, and forecast trends by region',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region filter (optional)' },
        period_days: { type: 'number', description: 'Analysis period in days (default 30)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getLaneDemand',
    roles: ['recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 15,
      success_metric: 'lanes_returned > 0',
      rollback_strategy: null,
      audit_fields: ['region']
    }
  },
  get_compensation_benchmarks: {
    name: 'get_compensation_benchmarks',
    description: 'Get compensation benchmarks — CPM percentiles, weekly max pay, sign-on bonuses by region and job type',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region to benchmark' },
        job_type: { type: 'string', description: 'Job type (OTR, Regional, Local, Dedicated)' },
        equipment_type: { type: 'string', description: 'Equipment type (Dry Van, Reefer, Flatbed, Tanker)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getCompensationBenchmarks',
    roles: ['recruiter', 'driver', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'benchmarks_returned_with_sample',
      rollback_strategy: null,
      audit_fields: ['region', 'job_type']
    }
  },
  get_hiring_benchmarks: {
    name: 'get_hiring_benchmarks',
    description: 'Get hiring benchmarks for a carrier — conversion rates by stage, time to fill, drop reasons, best channels',
    input_schema: {
      type: 'object',
      properties: {
        carrier_dot: { type: 'string', description: 'Carrier USDOT number' }
      },
      required: ['carrier_dot']
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getHiringBenchmarks',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 15,
      success_metric: 'benchmarks_returned',
      rollback_strategy: null,
      audit_fields: ['carrier_dot']
    }
  },
  get_conversion_insights: {
    name: 'get_conversion_insights',
    description: 'Get platform-wide conversion insights — overall rates, by source/equipment, touchpoints to hire, best contact windows',
    input_schema: {
      type: 'object',
      properties: {
        period_days: { type: 'number', description: 'Analysis period in days (default 30)' },
        equipment_type: { type: 'string', description: 'Equipment type filter (optional)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getConversionInsights',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'insights_returned',
      rollback_strategy: null,
      audit_fields: ['period_days']
    }
  },
  // Knowledge Compendium curation tool
  run_curator: {
    name: 'run_curator',
    description: 'Run the Knowledge Curator to analyze recent agent outcomes and update the Compendium',
    input_schema: {
      type: 'object',
      properties: {
        department: { type: 'string', description: 'Department to curate (recruiter/carrier/driver/admin/dev or "all")' },
        days: { type: 'number', description: 'Analysis period in days (default 7)' }
      }
    },
    serviceModule: 'backend/compendiumService',
    serviceFunction: 'runCurator',
    roles: ['admin'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 5,
      success_metric: 'patterns_updated > 0',
      rollback_strategy: null,
      audit_fields: ['department', 'days']
    }
  }
};

/**
 * Get policy metadata for a tool
 */
export function getToolPolicy(toolName) {
  const tool = TOOL_DEFINITIONS[toolName];
  return tool ? tool.policy : null;
}

/**
 * Validate tool execution against rate limits
 * Uses in-memory tracking (resets on server restart)
 */
const _rateLimitMap = new Map(); // key: `${userId}:${toolName}`, value: { count, resetAt }

export function validateToolExecution(toolName, userId) {
  const policy = getToolPolicy(toolName);
  if (!policy) return { allowed: false, reason: 'Unknown tool' };

  const key = `${userId}:${toolName}`;
  const now = Date.now();
  const entry = _rateLimitMap.get(key);

  if (!entry || now > entry.resetAt) {
    _rateLimitMap.set(key, { count: 1, resetAt: now + 60000 });
    return { allowed: true };
  }

  if (entry.count >= policy.rate_limit) {
    return { allowed: false, reason: `Rate limit exceeded: ${policy.rate_limit}/min for ${toolName}` };
  }

  entry.count++;
  return { allowed: true };
}

// Role system prompts
const ROLE_SYSTEM_PROMPTS = {
  driver: 'You are LMDR\'s AI assistant for CDL truck drivers. Help drivers find carrier matches, understand safety data, check road conditions, and navigate their job search. Be friendly, practical, and driver-focused. When you have tools available, use them to provide real data rather than generic answers. You can check compensation benchmarks to understand fair pay rates for your experience and region.',
  recruiter: 'You are VelocityMatch\'s AI recruiting assistant. Help recruiters find qualified drivers, manage their pipeline, schedule interviews, track analytics, and optimize their recruiting workflow. Be efficient and data-driven. You have access to market intelligence including carrier demand signals, lane-level demand analysis, and compensation benchmarks from across the platform.',
  admin: 'You are the VelocityMatch platform admin assistant. Help administrators monitor system health, manage AI configurations, review driver and carrier data, and handle platform operations. You can trigger the Knowledge Curator to analyze recent agent runs and update department compendiums.',
  carrier: 'You are VelocityMatch\'s B2B assistant for carrier accounts. Help carriers understand their hiring pipeline, review match signals, and manage their account. You can access hiring benchmarks and conversion insights to understand how your recruiting pipeline compares to platform averages.'
};

// Get tools for a role
function getToolsForRole(role) {
  return Object.values(TOOL_DEFINITIONS)
    .filter(t => t.roles.includes(role))
    .map(t => ({
      name: t.name,
      description: t.description,
      input_schema: t.input_schema
    }));
}

// Execute a tool call against the real backend service
async function executeTool(toolName, toolInput, runContext = {}) {
  const toolDef = TOOL_DEFINITIONS[toolName];
  if (!toolDef) {
    return { error: `Unknown tool: ${toolName}` };
  }

  const { runId, userId } = runContext;

  // Rate limit check
  if (userId) {
    const rateCheck = validateToolExecution(toolName, userId);
    if (!rateCheck.allowed) {
      return { error: rateCheck.reason, type: 'rate_limited' };
    }
  }

  // Approval gate check
  if (toolDef.policy && toolDef.policy.requires_approval && !runContext.approvedGateId) {
    const stepId = runId ? (await logStep(runId, toolName, toolDef.policy.risk_level, toolInput, null, 0, 'pending_approval')).stepId : '';
    const gate = runId ? await createGate(runId, stepId, toolName, `Tool "${toolName}" requires approval (risk: ${toolDef.policy.risk_level})`, toolDef.policy.risk_level) : { gateId: '' };
    return {
      type: 'approval_required',
      gateId: gate.gateId,
      stepId,
      toolName,
      toolDescription: toolDef.description,
      args: toolInput,
      riskLevel: toolDef.policy.risk_level,
      auditFields: toolDef.policy.audit_fields
    };
  }

  const startTime = Date.now();
  try {
    const serviceModule = await import(toolDef.serviceModule);

    let result;
    if (toolName === 'manage_prompts') {
      const { operation, promptId, data } = toolInput;
      switch (operation) {
        case 'list': result = await serviceModule.getPrompts(data || {}); break;
        case 'get': result = await serviceModule.getActivePrompt(promptId); break;
        case 'create': result = await serviceModule.createPrompt(data); break;
        case 'update': result = await serviceModule.updatePrompt(promptId, data); break;
        default: result = { error: `Unknown prompt operation: ${operation}` };
      }
    } else {
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) {
        return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      }
      const args = Object.values(toolInput);
      result = await fn(...args);
    }

    const latencyMs = Date.now() - startTime;
    if (runId) {
      logStep(runId, toolName, toolDef.policy?.risk_level || 'unknown', toolInput, result, latencyMs, 'executed')
        .catch(err => console.error('Step logging failed:', err));
    }

    return result;
  } catch (error) {
    const latencyMs = Date.now() - startTime;
    if (runId) {
      logStep(runId, toolName, toolDef.policy?.risk_level || 'unknown', toolInput, { error: error.message }, latencyMs, 'error')
        .catch(err => console.error('Step logging failed:', err));
    }
    console.error(`Tool execution error [${toolName}]:`, error);
    return { error: error.message };
  }
}

/**
 * Main entry point - handles one agent turn
 * Loops tool_use responses until a text response is returned
 */
export async function handleAgentTurn(role, userId, message, context = {}) {
  if (!ROLE_SYSTEM_PROMPTS[role]) {
    throw new Error(`Unknown role: ${role}`);
  }

  // Get or create conversation
  let conversationId = context.conversationId;
  if (!conversationId) {
    const conv = await createConversation(role, userId);
    conversationId = conv.conversationId;
  }

  // Start run ledger
  let runId = null;
  try {
    const run = await startRun(conversationId, role, userId, message.substring(0, 200));
    runId = run.runId;
  } catch (err) {
    console.error('Run ledger start failed (non-blocking):', err);
  }

  // Daily run limit check
  const dateKey = `${userId}:${new Date().toISOString().split('T')[0]}`;
  const dailyCount = (_dailyRunCounts.get(dateKey) || 0) + 1;
  _dailyRunCounts.set(dateKey, dailyCount);
  if (dailyCount > COST_CONTROLS.maxDailyRunsPerUser) {
    if (runId) completeRun(runId, 'rate_limited', 0, 0).catch(() => {});
    return {
      conversationId,
      runId,
      response: 'You\'ve reached your daily limit for AI assistant requests. Please try again tomorrow.',
      toolsUsed: false,
      role
    };
  }

  // Get recent context
  const recentTurns = await getRecentContext(conversationId, 20);

  // Build messages array
  const messages = [];
  for (const turn of recentTurns) {
    messages.push({ role: turn.role, content: turn.content });
  }
  messages.push({ role: 'user', content: message });

  // Save user turn
  await addTurn(conversationId, 'user', message);

  // Get role-scoped tools
  const tools = getToolsForRole(role);

  // Agent loop - keep calling AI until we get a text response (not tool_use)
  let currentMessages = [...messages];
  const maxIterations = 5;
  let totalTokens = 0;
  const runStartTime = Date.now();

  for (let i = 0; i < maxIterations; i++) {
    // Token cap check
    const roleTokenCap = COST_CONTROLS.maxTokensPerRun[role] || 10000;
    if (totalTokens >= roleTokenCap) {
      const capText = 'I\'ve reached the processing limit for this request. Here\'s what I have so far.';
      await addTurn(conversationId, 'assistant', capText);
      if (runId) {
        completeRun(runId, 'token_cap', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }
      return { conversationId, runId, response: capText, toolsUsed: true, role };
    }

    // Time cap check
    if (Date.now() - runStartTime > COST_CONTROLS.maxRunTimeMs) {
      const timeText = 'This request is taking longer than expected. Here\'s what I have so far.';
      await addTurn(conversationId, 'assistant', timeText);
      if (runId) {
        completeRun(runId, 'time_cap', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }
      return { conversationId, runId, response: timeText, toolsUsed: true, role };
    }
    const aiResponse = await routeAIRequest('agent_orchestration', {
      system: ROLE_SYSTEM_PROMPTS[role],
      messages: currentMessages,
      tools,
      maxTokens: 2048
    });

    totalTokens += aiResponse.tokensUsed || 0;

    // Check if response contains tool_use blocks
    const toolUseBlocks = (aiResponse.contentBlocks || []).filter(b => b.type === 'tool_use');
    const textBlocks = (aiResponse.contentBlocks || []).filter(b => b.type === 'text');

    if (aiResponse.stopReason === 'tool_use' && toolUseBlocks.length > 0) {
      // Add assistant message with tool_use blocks
      currentMessages.push({ role: 'assistant', content: aiResponse.contentBlocks });

      // Execute each tool call
      const toolResults = [];
      for (const toolBlock of toolUseBlocks) {
        const result = await executeTool(toolBlock.name, toolBlock.input, { runId, userId });

        // Check if approval is required
        if (result && result.type === 'approval_required') {
          // Save what we have so far
          await addTurn(conversationId, 'assistant', JSON.stringify(toolUseBlocks), toolUseBlocks);

          // Complete run as paused
          if (runId) {
            completeRun(runId, 'awaiting_approval', totalTokens, 0)
              .catch(err => console.error('Run completion failed:', err));
          }

          return {
            type: 'approval_required',
            conversationId,
            runId,
            gateId: result.gateId,
            stepId: result.stepId,
            toolName: result.toolName,
            toolDescription: result.toolDescription,
            args: result.args,
            riskLevel: result.riskLevel,
            auditFields: result.auditFields,
            pendingToolBlock: toolBlock,
            pendingMessages: currentMessages,
            role
          };
        }

        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolBlock.id,
          content: JSON.stringify(result)
        });
      }

      // Add tool results as user message
      currentMessages.push({ role: 'user', content: toolResults });

      // Save tool execution turn
      await addTurn(conversationId, 'assistant', JSON.stringify(toolUseBlocks), toolUseBlocks);
    } else {
      // Text response - we're done
      const responseText = aiResponse.content || textBlocks.map(b => b.text).join('\n');
      await addTurn(conversationId, 'assistant', responseText);

      // Complete run and evaluate outcome
      if (runId) {
        completeRun(runId, 'completed', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }

      return {
        conversationId,
        runId,
        response: responseText,
        toolsUsed: currentMessages.length > messages.length + 1,
        role
      };
    }
  }

  // Safety: if we hit max iterations, return what we have
  const finalText = 'I\'ve been working on your request but need to summarize. Let me know if you need more details.';
  await addTurn(conversationId, 'assistant', finalText);
  if (runId) {
    completeRun(runId, 'max_iterations', totalTokens, 0)
      .then(() => _evaluateCompletedRun(runId))
      .catch(err => console.error('Run completion failed:', err));
  }
  return { conversationId, runId, response: finalText, toolsUsed: true, role };
}

/**
 * Get available tools for a role (for UI display)
 */
export async function getAvailableTools(role) {
  return getToolsForRole(role);
}

/**
 * Get cost control configuration (for tests and admin display)
 */
export function getCostControls() {
  return { ...COST_CONTROLS };
}

/**
 * Resume agent loop after an approval gate decision
 */
export async function resumeAfterApproval(approvalContext, decision, decidedBy) {
  const { conversationId, runId, gateId, pendingToolBlock, pendingMessages, role } = approvalContext;

  // Resolve the gate
  const { resolveGate } = await import('backend/agentRunLedgerService');
  await resolveGate(gateId, decision, decidedBy);

  if (decision === 'rejected') {
    const toolResults = [{
      type: 'tool_result',
      tool_use_id: pendingToolBlock.id,
      content: JSON.stringify({ error: 'User rejected this action', decision: 'rejected' })
    }];
    const currentMessages = [...pendingMessages, { role: 'user', content: toolResults }];

    const aiResponse = await routeAIRequest('agent_orchestration', {
      system: ROLE_SYSTEM_PROMPTS[role],
      messages: currentMessages,
      tools: getToolsForRole(role),
      maxTokens: 2048
    });

    const responseText = aiResponse.content || (aiResponse.contentBlocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n') || 'Understood, I won\'t proceed with that action.';
    await addTurn(conversationId, 'assistant', responseText);

    if (runId) {
      const { completeRun: cr } = await import('backend/agentRunLedgerService');
      cr(runId, 'completed_with_rejection', aiResponse.tokensUsed || 0, 0).catch(() => {});
    }

    return { conversationId, runId, response: responseText, role };
  }

  // Approved — execute the tool and continue the loop
  const result = await executeTool(pendingToolBlock.name, pendingToolBlock.input, { runId, userId: decidedBy, approvedGateId: gateId });

  const toolResults = [{
    type: 'tool_result',
    tool_use_id: pendingToolBlock.id,
    content: JSON.stringify(result)
  }];
  const currentMessages = [...pendingMessages, { role: 'user', content: toolResults }];

  const aiResponse = await routeAIRequest('agent_orchestration', {
    system: ROLE_SYSTEM_PROMPTS[role],
    messages: currentMessages,
    tools: getToolsForRole(role),
    maxTokens: 2048
  });

  const responseText = aiResponse.content || (aiResponse.contentBlocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n') || 'Action completed.';
  await addTurn(conversationId, 'assistant', responseText);

  if (runId) {
    const { completeRun: cr } = await import('backend/agentRunLedgerService');
    cr(runId, 'completed', aiResponse.tokensUsed || 0, 0).catch(() => {});
  }

  return { conversationId, runId, response: responseText, role };
}

// ── Outcome Evaluation Hook ──
// Import is dynamic to avoid circular dependency issues
// Called after completeRun() in handleAgentTurn completion paths
export async function _evaluateCompletedRun(runId) {
  try {
    const { evaluateRun } = await import('backend/agentOutcomeService');
    return await evaluateRun(runId);
  } catch (err) {
    console.error('Outcome evaluation failed (non-blocking):', err);
    return null;
  }
}

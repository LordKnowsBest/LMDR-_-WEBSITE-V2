// ============================================================================
// AGENT SERVICE - Central AI Orchestration Layer
// Takes user messages, builds role-scoped tools, calls AI with tool definitions,
// executes tool_use responses against real backend services, loops until text response
// ============================================================================

import { routeAIRequest } from 'backend/aiRouterService';
import { createConversation, addTurn, getRecentContext } from 'backend/agentConversationService';
import * as dataAccess from 'backend/dataAccess';
import { startRun, logStep, createGate, completeRun, updateRunPlanningMetadata } from 'backend/agentRunLedgerService';
import { isRuntimeAvailable, callRuntimeStep } from 'backend/agentRuntimeService';
import { classifyUserIntent, buildRagConfig } from 'backend/intentService';
import { ingestTurnMemory } from 'backend/ragIngestionService';
import { FEATURE_FLAGS } from 'backend/configData';
import { buildExecutionPlan } from 'backend/agentPlanService';
import { executePlannedReadNodes, isPlanExecutorEligible } from 'backend/agentDagExecutorService';

// ── Cost Control Configuration ──
const COST_CONTROLS = {
  maxTokensPerRun: {
    driver: 10000,
    recruiter: 15000,
    admin: 20000,
    carrier: 10000
  },
  maxRunTimeMs: 30000,
  maxDailyRunsPerUser: 100,
  costAlertThreshold: 0.50
};

const _dailyRunCounts = new Map();

// Tool definitions mapped to existing backend services
const TOOL_DEFINITIONS = {
  // Driver tools
  find_matches: {
    name: 'find_matches',
    description: 'Find carriers matching driver preferences (zip, distance, pay, run type)',
    input_schema: {
      type: 'object',
      properties: {
        zip: { type: 'string', description: 'Driver home zip code' },
        maxDistance: { type: 'number', description: 'Maximum commute distance in miles' },
        minCPM: { type: 'number', description: 'Minimum cents per mile' },
        operationType: { type: 'string', enum: ['OTR', 'Regional', 'Local', 'any'] }
      },
      required: ['zip']
    },
    serviceModule: 'backend/carrierMatching',
    serviceFunction: 'findMatchingCarriers',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'matches_returned > 0',
      rollback_strategy: null,
      audit_fields: ['zip', 'maxDistance']
    }
  },
  get_carrier_details: {
    name: 'get_carrier_details',
    description: 'Get detailed AI-enriched information about a specific carrier by DOT number',
    input_schema: {
      type: 'object',
      properties: {
        dotNumber: { type: 'string', description: 'USDOT number of the carrier' }
      },
      required: ['dotNumber']
    },
    serviceModule: 'backend/aiEnrichment',
    serviceFunction: 'enrichCarrier',
    roles: ['driver', 'recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'carrier_data_returned',
      rollback_strategy: null,
      audit_fields: ['dotNumber']
    },
    argMapping: ['dotNumber']
  },
  explain_match: {
    name: 'explain_match',
    description: 'Explain why a driver matched with a specific carrier',
    input_schema: {
      type: 'object',
      properties: {
        driverId: { type: 'string' },
        carrierDot: { type: 'string' }
      },
      required: ['driverId', 'carrierDot']
    },
    serviceModule: 'backend/matchExplanationService',
    serviceFunction: 'getMatchExplanationForDriver',
    roles: ['driver'],
    policy: {
      risk_level: 'suggest',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'explanation_generated',
      rollback_strategy: null,
      audit_fields: ['driverId', 'carrierDot']
    },
    argMapping: ['driverId', 'carrierDot']
  },
  get_fmcsa_data: {
    name: 'get_fmcsa_data',
    description: 'Get FMCSA safety data for a carrier',
    input_schema: {
      type: 'object',
      properties: {
        dotNumber: { type: 'string', description: 'USDOT number' }
      },
      required: ['dotNumber']
    },
    serviceModule: 'backend/externalFmcsaApi',
    serviceFunction: 'getExternalCarrierSafety',
    roles: ['driver', 'recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'safety_data_returned',
      rollback_strategy: null,
      audit_fields: ['dotNumber']
    },
    argMapping: ['dotNumber']
  },
  road_conditions: {
    name: 'road_conditions',
    description: 'Get current road conditions for a location',
    input_schema: {
      type: 'object',
      properties: {
        lat: { type: 'number' },
        lon: { type: 'number' },
        zip: { type: 'string' }
      }
    },
    serviceModule: 'backend/roadConditionService',
    serviceFunction: 'getRouteConditions',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'conditions_returned',
      rollback_strategy: null,
      audit_fields: ['zip']
    }
  },
  find_parking: {
    name: 'find_parking',
    description: 'Search for truck parking near a location',
    input_schema: {
      type: 'object',
      properties: {
        lat: { type: 'number' },
        lon: { type: 'number' },
        radius: { type: 'number', description: 'Search radius in miles' }
      }
    },
    serviceModule: 'backend/parkingService',
    serviceFunction: 'searchParking',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'parking_results_returned',
      rollback_strategy: null,
      audit_fields: ['lat', 'lon']
    },
    argMapping: ['lat', 'lon', 'radius']
  },
  // Recruiter tools
  search_drivers: {
    name: 'search_drivers',
    description: 'Search for CDL drivers matching criteria',
    input_schema: {
      type: 'object',
      properties: {
        zip: { type: 'string' },
        maxDistance: { type: 'number' },
        endorsements: { type: 'string', description: 'Comma-separated endorsements (Hazmat, Tanker, Doubles)' },
        minExperience: { type: 'number', description: 'Minimum years of experience' }
      }
    },
    serviceModule: 'backend/driverMatching',
    serviceFunction: 'findMatchingDrivers',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'drivers_returned > 0',
      rollback_strategy: null,
      audit_fields: ['zip', 'endorsements']
    }
  },
  get_pipeline: {
    name: 'get_pipeline',
    description: 'Get pipeline candidates for a carrier',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        status: { type: 'string', enum: ['new', 'contacted', 'screening', 'interview', 'offer', 'hired'] }
      },
      required: ['carrierDot']
    },
    serviceModule: 'backend/recruiter_service',
    serviceFunction: 'getPipelineCandidates',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'pipeline_data_returned',
      rollback_strategy: null,
      audit_fields: ['carrierDot']
    },
    argMapping: ['carrierDot']
  },
  update_candidate_status: {
    name: 'update_candidate_status',
    description: 'Update a candidate status in the pipeline',
    input_schema: {
      type: 'object',
      properties: {
        interestId: { type: 'string' },
        newStatus: { type: 'string', enum: ['new', 'contacted', 'screening', 'interview', 'offer', 'hired', 'rejected'] }
      },
      required: ['interestId', 'newStatus']
    },
    serviceModule: 'backend/recruiter_service',
    serviceFunction: 'updateCandidateStatus',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'status_changed',
      rollback_strategy: 'revert_to_previous_status',
      audit_fields: ['interestId', 'newStatus']
    },
    argMapping: ['interestId', 'newStatus']
  },
  send_message: {
    name: 'send_message',
    description: 'Send a message to a driver or recruiter',
    input_schema: {
      type: 'object',
      properties: {
        applicationId: { type: 'string' },
        content: { type: 'string' },
        receiverId: { type: 'string' }
      },
      required: ['applicationId', 'content', 'receiverId']
    },
    serviceModule: 'backend/messaging',
    serviceFunction: 'sendMessage',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'message_delivered',
      rollback_strategy: null,
      audit_fields: ['receiverId', 'content']
    },
    argMapping: ['applicationId', 'content', 'receiverId']
  },
  schedule_interview: {
    name: 'schedule_interview',
    description: 'Request interview availability from a candidate',
    input_schema: {
      type: 'object',
      properties: {
        applicationId: { type: 'string' }
      },
      required: ['applicationId']
    },
    serviceModule: 'backend/interviewScheduler',
    serviceFunction: 'requestAvailability',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'availability_requested',
      rollback_strategy: 'cancel_request',
      audit_fields: ['applicationId']
    },
    argMapping: ['applicationId']
  },
  log_call: {
    name: 'log_call',
    description: 'Log a call outcome with a driver',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        driverId: { type: 'string' },
        outcome: { type: 'string', enum: ['interested', 'callback', 'not_now', 'wrong_fit', 'no_answer', 'voicemail'] },
        notes: { type: 'string' }
      },
      required: ['carrierDot', 'outcome']
    },
    serviceModule: 'backend/callOutcomeService',
    serviceFunction: 'logCallOutcome',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'call_logged',
      rollback_strategy: 'delete_call_record',
      audit_fields: ['carrierDot', 'outcome']
    }
  },
  get_recruiter_analytics: {
    name: 'get_recruiter_analytics',
    description: 'Get funnel and recruiting analytics metrics',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        period: { type: 'string', enum: ['week', 'month', 'quarter'] }
      }
    },
    serviceModule: 'backend/recruiterAnalyticsService',
    serviceFunction: 'getFunnelMetrics',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'analytics_returned',
      rollback_strategy: null,
      audit_fields: ['carrierDot', 'period']
    },
    argMapping: ['carrierDot', 'period']
  },
  // Admin tools
  get_system_health: {
    name: 'get_system_health',
    description: 'Get system health and observability metrics',
    input_schema: { type: 'object', properties: {} },
    serviceModule: 'backend/observabilityService',
    serviceFunction: 'getMetrics',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'health_metrics_returned',
      rollback_strategy: null,
      audit_fields: []
    }
  },
  get_driver_stats: {
    name: 'get_driver_stats',
    description: 'Get driver statistics and listings for admin',
    input_schema: {
      type: 'object',
      properties: {
        page: { type: 'number' },
        pageSize: { type: 'number' },
        status: { type: 'string' }
      }
    },
    serviceModule: 'backend/admin_service',
    serviceFunction: 'getDriversList',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'driver_stats_returned',
      rollback_strategy: null,
      audit_fields: ['status']
    }
  },
  manage_prompts: {
    name: 'manage_prompts',
    description: 'Manage AI prompt templates (list, create, update)',
    input_schema: {
      type: 'object',
      properties: {
        operation: { type: 'string', enum: ['list', 'get', 'create', 'update'] },
        promptId: { type: 'string' },
        data: { type: 'object' }
      },
      required: ['operation']
    },
    serviceModule: 'backend/promptLibraryService',
    serviceFunction: null,
    roles: ['admin'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'prompt_operation_completed',
      rollback_strategy: 'revert_prompt_version',
      audit_fields: ['operation', 'promptId']
    }
  },
  // Carrier/B2B tools
  get_account: {
    name: 'get_account',
    description: 'Get B2B account details',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' }
      },
      required: ['accountId']
    },
    serviceModule: 'backend/b2bAccountService',
    serviceFunction: 'getAccount',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'account_data_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    },
    argMapping: ['accountId']
  },
  get_signals: {
    name: 'get_signals',
    description: 'Get match signals for a B2B account',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' }
      },
      required: ['accountId']
    },
    serviceModule: 'backend/b2bMatchSignalService',
    serviceFunction: 'getSignals',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'signals_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    },
    argMapping: ['accountId']
  },
  get_opportunities: {
    name: 'get_opportunities',
    description: 'Get pipeline opportunities for B2B',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' },
        stage: { type: 'string' }
      }
    },
    serviceModule: 'backend/b2bPipelineService',
    serviceFunction: 'getOpportunities',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'opportunities_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    },
    argMapping: ['accountId', 'stage']
  },
  get_agent_kpis: {
    name: 'get_agent_kpis',
    description: 'Get agent orchestration KPIs — success rates, quality scores, costs, approval stats',
    input_schema: {
      type: 'object',
      properties: {
        role: { type: 'string', enum: ['driver', 'recruiter', 'admin', 'carrier', 'all'], description: 'Filter by role or all' },
        days: { type: 'number', description: 'Number of days to analyze (default 7)' }
      }
    },
    serviceModule: 'backend/agentOutcomeService',
    serviceFunction: 'getOutcomeStats',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'stats_returned',
      rollback_strategy: null,
      audit_fields: ['role', 'days']
    },
    argMapping: ['role', 'days']
  },
  // Cross-role intelligence tools (Phase 2)
  get_market_intel: {
    name: 'get_market_intel',
    description: 'Get aggregated market intelligence — carrier demand signals, top regions/equipment, and pay ranges',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region filter (e.g. Southeast, Midwest)' },
        job_type: { type: 'string', description: 'Job type filter (OTR, Regional, Local, Dedicated)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getMarketIntel',
    roles: ['recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'intel_returned_with_data',
      rollback_strategy: null,
      audit_fields: ['region', 'job_type']
    },
    argMapping: ['region', 'job_type']
  },
  get_lane_demand: {
    name: 'get_lane_demand',
    description: 'Get lane-level demand analysis — demand scores, driver supply gaps, and forecast trends by region',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region filter (optional)' },
        period_days: { type: 'number', description: 'Analysis period in days (default 30)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getLaneDemand',
    roles: ['recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 15,
      success_metric: 'lanes_returned > 0',
      rollback_strategy: null,
      audit_fields: ['region']
    }
  },
  get_compensation_benchmarks: {
    name: 'get_compensation_benchmarks',
    description: 'Get compensation benchmarks — CPM percentiles, weekly max pay, sign-on bonuses by region and job type',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region to benchmark' },
        job_type: { type: 'string', description: 'Job type (OTR, Regional, Local, Dedicated)' },
        equipment_type: { type: 'string', description: 'Equipment type (Dry Van, Reefer, Flatbed, Tanker)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getCompensationBenchmarks',
    roles: ['recruiter', 'driver', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'benchmarks_returned_with_sample',
      rollback_strategy: null,
      audit_fields: ['region', 'job_type']
    },
    argMapping: ['region', 'job_type', 'equipment_type']
  },
  get_hiring_benchmarks: {
    name: 'get_hiring_benchmarks',
    description: 'Get hiring benchmarks for a carrier — conversion rates by stage, time to fill, drop reasons, best channels',
    input_schema: {
      type: 'object',
      properties: {
        carrier_dot: { type: 'string', description: 'Carrier USDOT number' }
      },
      required: ['carrier_dot']
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getHiringBenchmarks',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 15,
      success_metric: 'benchmarks_returned',
      rollback_strategy: null,
      audit_fields: ['carrier_dot']
    },
    argMapping: ['carrier_dot']
  },
  get_conversion_insights: {
    name: 'get_conversion_insights',
    description: 'Get platform-wide conversion insights — overall rates, by source/equipment, touchpoints to hire, best contact windows',
    input_schema: {
      type: 'object',
      properties: {
        period_days: { type: 'number', description: 'Analysis period in days (default 30)' },
        equipment_type: { type: 'string', description: 'Equipment type filter (optional)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getConversionInsights',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'insights_returned',
      rollback_strategy: null,
      audit_fields: ['period_days']
    }
  },
  // Knowledge Compendium curation tool
  run_curator: {
    name: 'run_curator',
    description: 'Run the Knowledge Curator to analyze recent agent outcomes and update the Compendium',
    input_schema: {
      type: 'object',
      properties: {
        department: { type: 'string', description: 'Department to curate (recruiter/carrier/driver/admin/dev or "all")' },
        days: { type: 'number', description: 'Analysis period in days (default 7)' }
      }
    },
    serviceModule: 'backend/compendiumService',
    serviceFunction: 'runCurator',
    roles: ['admin'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 5,
      success_metric: 'patterns_updated > 0',
      rollback_strategy: null,
      audit_fields: ['department', 'days']
    },
    argMapping: ['department', 'days']
  },

  // Autonomous operations tools (Phase 4)
  start_autopilot: {
    name: 'start_autopilot',
    description: 'Start a recruiter autopilot campaign — automated outreach with approval gates for each send',
    input_schema: {
      type: 'object',
      properties: {
        carrier_dot: { type: 'string', description: 'Target carrier DOT number' },
        objective: { type: 'string', description: 'Campaign objective: outreach, pipeline_advancement, or re_engagement' },
        max_contacts: { type: 'number', description: 'Maximum contacts to reach (default 20)' },
        cadence: { type: 'string', description: 'Outreach cadence: aggressive, standard, or gentle' }
      },
      required: ['carrier_dot', 'objective']
    },
    roles: ['recruiter'],
    serviceModule: 'backend/autopilotService',
    serviceFunction: 'createAutopilotCampaign',
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'campaign_created_with_contacts',
      rollback_strategy: 'pause_campaign',
      audit_fields: ['carrier_dot', 'objective', 'max_contacts']
    }
  },
  get_autopilot_status: {
    name: 'get_autopilot_status',
    description: 'Get status of a running autopilot campaign — progress, metrics, pending approvals',
    input_schema: {
      type: 'object',
      properties: {
        campaign_id: { type: 'string', description: 'Campaign ID to check' }
      },
      required: ['campaign_id']
    },
    roles: ['recruiter', 'admin'],
    serviceModule: 'backend/autopilotService',
    serviceFunction: 'getAutopilotStatus',
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'status_returned',
      rollback_strategy: null,
      audit_fields: ['campaign_id']
    },
    argMapping: ['campaign_id']
  },
  // Self-healing tools (Phase 4)
  detect_anomalies: {
    name: 'detect_anomalies',
    description: 'Run anomaly detection and triage — identify issues, match to known patterns, assess severity',
    input_schema: { type: 'object', properties: {} },
    roles: ['admin'],
    serviceModule: 'backend/selfHealingService',
    serviceFunction: 'detectAndTriage',
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'detection_completed',
      rollback_strategy: null,
      audit_fields: []
    }
  },
  propose_fix: {
    name: 'propose_fix',
    description: 'Generate a remediation proposal for an incident — includes actions, risk assessment, and approval gate',
    input_schema: {
      type: 'object',
      properties: {
        incident_id: { type: 'string', description: 'Incident ID to remediate' }
      },
      required: ['incident_id']
    },
    roles: ['admin'],
    serviceModule: 'backend/selfHealingService',
    serviceFunction: 'proposeRemediation',
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'plan_created',
      rollback_strategy: null,
      audit_fields: ['incident_id']
    },
    argMapping: ['incident_id']
  },
  execute_fix: {
    name: 'execute_fix',
    description: 'Execute an approved remediation plan — runs fix actions and verifies resolution',
    input_schema: {
      type: 'object',
      properties: {
        plan_id: { type: 'string', description: 'Remediation plan ID to execute' },
        approved_by: { type: 'string', description: 'Admin who approved the fix' }
      },
      required: ['plan_id']
    },
    roles: ['admin'],
    serviceModule: 'backend/selfHealingService',
    serviceFunction: 'executeRemediation',
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'remediation_verified',
      rollback_strategy: 'revert_config_changes',
      audit_fields: ['plan_id', 'approved_by']
    },
    argMapping: ['plan_id', 'approved_by']
  },

  // Pipeline Execution Agent tools
  initiate_voice_screen: {
    name: 'initiate_voice_screen',
    description: 'Create a VAPI voice assistant from a template and initiate an outbound screening call to a candidate',
    input_schema: {
      type: 'object',
      properties: {
        template_id: { type: 'string', description: 'Voice agent template ID (e.g. vat_qualification, vat_cold_outreach)' },
        candidate_id: { type: 'string', description: 'Candidate/driver record ID' },
        candidate_name: { type: 'string', description: 'Candidate display name' },
        candidate_phone: { type: 'string', description: 'Candidate phone number' },
        carrier_dot: { type: 'string', description: 'Carrier DOT number' },
        carrier_name: { type: 'string', description: 'Carrier display name' }
      },
      required: ['template_id', 'candidate_id', 'candidate_phone', 'carrier_dot']
    },
    roles: ['recruiter'],
    serviceModule: 'backend/voiceAgentTemplates',
    serviceFunction: 'createAssistantFromTemplate',
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'assistant_created_and_call_initiated',
      rollback_strategy: null,
      audit_fields: ['template_id', 'candidate_id', 'carrier_dot']
    }
  },
  get_pipeline_health: {
    name: 'get_pipeline_health',
    description: 'Get pipeline health metrics — SLA compliance rate, conversion rates, average time to contact',
    input_schema: {
      type: 'object',
      properties: {
        recruiter_id: { type: 'string', description: 'Recruiter user ID' },
        days: { type: 'number', description: 'Look-back period in days (default 7)' }
      },
      required: ['recruiter_id']
    },
    roles: ['recruiter', 'admin'],
    serviceModule: 'backend/pipelineExecutionAgent',
    serviceFunction: 'getPipelineHealth',
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'health_metrics_returned',
      rollback_strategy: null,
      audit_fields: ['recruiter_id', 'days']
    },
    argMapping: ['recruiter_id', 'days']
  },
  emit_pipeline_event: {
    name: 'emit_pipeline_event',
    description: 'Fire a pipeline event to the event bus for processing by the pipeline execution agent',
    input_schema: {
      type: 'object',
      properties: {
        event_type: { type: 'string', description: 'Event type: stage_change, no_response, call_completed, document_received, application_submitted' },
        candidate_id: { type: 'string', description: 'Candidate/driver record ID' },
        carrier_dot: { type: 'string', description: 'Carrier DOT number' },
        stage_from: { type: 'string', description: 'Previous pipeline stage' },
        stage_to: { type: 'string', description: 'New pipeline stage' }
      },
      required: ['event_type', 'candidate_id']
    },
    roles: ['recruiter'],
    serviceModule: 'backend/pipelineEventBus',
    serviceFunction: 'emitEvent',
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'event_emitted',
      rollback_strategy: null,
      audit_fields: ['event_type', 'candidate_id']
    }
  }
};

// ============================================================================
// DOMAIN ROUTER ARCHITECTURE — Phase 1+ (Driver: 83 actions → 7 routers)
// Collapses flat tool definitions into domain routers for AI prompt efficiency.
// Existing TOOL_DEFINITIONS above remain untouched for backward compatibility.
// ============================================================================

const ACTION_REGISTRY = {
  // ── driver_cockpit: 23 actions ──
  driver_cockpit: {
    search_jobs:              { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'searchJobs',              argMapping: ['driverId', 'filters', 'pagination'],                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_job_details:          { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getJobDetails',           argMapping: ['jobId', 'driverId'],                                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    quick_apply:              { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'submitApplication',       argMapping: ['driverId', 'jobId', 'payload'],                       policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    save_job:                 { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'saveJob',                 argMapping: ['driverId', 'jobId'],                                  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_saved_jobs:           { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getSavedJobs',            argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    withdraw_application:     { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'withdrawApplication',     argMapping: ['driverId', 'applicationId', 'reason'],                policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    check_application_status: { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getApplicationStatus',    argMapping: ['driverId', 'applicationId'],                          policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_application_history:  { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getApplicationHistory',   argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    send_message:             { serviceModule: 'backend/messagingService',      serviceFunction: 'sendDriverMessage',       argMapping: ['driverId', 'conversationId', 'payload'],              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_messages:             { serviceModule: 'backend/messagingService',      serviceFunction: 'getConversationMessages', argMapping: ['conversationId', 'driverId', 'pagination'],            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_conversation:         { serviceModule: 'backend/messagingService',      serviceFunction: 'getConversation',         argMapping: ['conversationId', 'driverId'],                         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    mark_read:                { serviceModule: 'backend/messagingService',      serviceFunction: 'markConversationRead',    argMapping: ['conversationId', 'driverId'],                         policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_unread_count:         { serviceModule: 'backend/messagingService',      serviceFunction: 'getDriverUnreadCount',    argMapping: ['driverId'],                                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    update_profile:           { serviceModule: 'backend/driverProfileService',  serviceFunction: 'updateDriverProfile',     argMapping: ['driverId', 'fields'],                                 policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_profile_strength:     { serviceModule: 'backend/driverProfileService',  serviceFunction: 'getProfileStrength',      argMapping: ['driverId'],                                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_profile_suggestions:  { serviceModule: 'backend/driverProfileService',  serviceFunction: 'getProfileSuggestions',   argMapping: ['driverId'],                                           policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 20 } },
    upload_document:          { serviceModule: 'backend/documentService',       serviceFunction: 'recordDriverDocumentUpload', argMapping: ['driverId', 'payload'],                             policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    get_matches:              { serviceModule: 'backend/matchingService',       serviceFunction: 'getDriverMatches',        argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_match_details:        { serviceModule: 'backend/matchingService',       serviceFunction: 'getMatchDetails',         argMapping: ['matchId', 'driverId'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    express_interest:         { serviceModule: 'backend/matchingService',       serviceFunction: 'expressDriverInterest',   argMapping: ['driverId', 'matchId', 'message'],                     policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    dismiss_match:            { serviceModule: 'backend/matchingService',       serviceFunction: 'dismissMatch',            argMapping: ['driverId', 'matchId', 'reason'],                      policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_dashboard_summary:    { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getDashboardSummary',     argMapping: ['driverId'],                                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_notifications:        { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getDriverNotifications',  argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_road: 15 actions ──
  driver_road: {
    find_parking:                 { serviceModule: 'backend/parkingService',        serviceFunction: 'findTruckParking',          argMapping: ['filters'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_parking_details:          { serviceModule: 'backend/parkingService',        serviceFunction: 'getParkingDetails',         argMapping: ['locationId'],                                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    report_parking_availability:  { serviceModule: 'backend/parkingService',        serviceFunction: 'reportParkingAvailability', argMapping: ['driverId', 'locationId', 'report'],              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    save_favorite_parking:        { serviceModule: 'backend/parkingService',        serviceFunction: 'saveFavoriteParking',       argMapping: ['driverId', 'locationId'],                        policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    find_fuel_prices:             { serviceModule: 'backend/fuelService',           serviceFunction: 'findDieselPrices',          argMapping: ['location', 'filters'],                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_fuel_price_trends:        { serviceModule: 'backend/fuelService',           serviceFunction: 'getFuelPriceTrends',        argMapping: ['state', 'weeks', 'granularity'],                 policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    calculate_fuel_cost:          { serviceModule: 'backend/fuelService',           serviceFunction: 'calculateTripFuelCost',     argMapping: ['origin', 'destination', 'truckConfig'],          policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 20 } },
    get_weigh_station_status:     { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'getWeighStationStatus',     argMapping: ['stationId'],                                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_weigh_stations_on_route:  { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'getWeighStationsOnRoute',   argMapping: ['origin', 'destination', 'filters'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    find_rest_stops:              { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'findRestStops',             argMapping: ['filters'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    rate_rest_stop:               { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'rateRestStop',              argMapping: ['driverId', 'stopId', 'rating'],                  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_weather_forecast:         { serviceModule: 'backend/weatherService',        serviceFunction: 'getWeatherForecast',        argMapping: ['location', 'days', 'units'],                     policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_weather_alerts:           { serviceModule: 'backend/weatherService',        serviceFunction: 'getWeatherAlerts',          argMapping: ['location'],                                      policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_road_conditions:          { serviceModule: 'backend/weatherService',        serviceFunction: 'getRoadConditions',         argMapping: ['state', 'route', 'conditionType'],               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    report_road_hazard:           { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'reportRoadHazard',          argMapping: ['driverId', 'report'],                            policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_community: 14 actions ──
  driver_community: {
    get_forum_posts:                { serviceModule: 'backend/communityService',     serviceFunction: 'getForumPosts',          argMapping: ['filters', 'pagination'],               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_forum_post:              { serviceModule: 'backend/communityService',     serviceFunction: 'createForumPost',        argMapping: ['driverId', 'payload'],                 policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    reply_to_post:                  { serviceModule: 'backend/communityService',     serviceFunction: 'replyToPost',            argMapping: ['driverId', 'postId', 'body', 'quoteReplyId'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
    like_post:                      { serviceModule: 'backend/communityService',     serviceFunction: 'toggleLike',             argMapping: ['driverId', 'itemId', 'itemType'],      policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    report_post:                    { serviceModule: 'backend/communityService',     serviceFunction: 'reportContent',          argMapping: ['driverId', 'itemId', 'itemType', 'reason', 'details'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
    search_forums:                  { serviceModule: 'backend/communityService',     serviceFunction: 'searchForums',           argMapping: ['query', 'filters'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    find_mentors:                   { serviceModule: 'backend/mentorshipService',    serviceFunction: 'findMentors',            argMapping: ['filters'],                             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    request_mentorship:             { serviceModule: 'backend/mentorshipService',    serviceFunction: 'requestMentorship',      argMapping: ['driverId', 'mentorId', 'payload'],     policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_mentorship_status:          { serviceModule: 'backend/mentorshipService',    serviceFunction: 'getDriverMentorshipStatus', argMapping: ['driverId'],                         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    rate_mentor:                    { serviceModule: 'backend/mentorshipService',    serviceFunction: 'rateMentor',             argMapping: ['driverId', 'mentorshipId', 'rating'],  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    search_pet_friendly_locations:  { serviceModule: 'backend/petFriendlyService',   serviceFunction: 'searchLocations',        argMapping: ['filters'],                             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    submit_pet_friendly_location:   { serviceModule: 'backend/petFriendlyService',   serviceFunction: 'submitLocation',         argMapping: ['driverId', 'data'],                    policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_health_resources:           { serviceModule: 'backend/healthService',        serviceFunction: 'getResourcesByCategory', argMapping: ['category', 'resourceType'],             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    submit_health_tip:              { serviceModule: 'backend/healthService',        serviceFunction: 'submitTip',              argMapping: ['driverId', 'data'],                    policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
  },

  // ── driver_compliance: 12 actions ──
  driver_compliance: {
    upload_compliance_doc:  { serviceModule: 'backend/documentService',    serviceFunction: 'uploadComplianceDoc',     argMapping: ['driverId', 'payload'],                            policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    get_compliance_docs:    { serviceModule: 'backend/documentService',    serviceFunction: 'getDriverComplianceDocs', argMapping: ['driverId', 'filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    check_doc_expiry:       { serviceModule: 'backend/documentService',    serviceFunction: 'checkDocumentExpiry',     argMapping: ['documentId', 'driverId'],                         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_expiring_docs:      { serviceModule: 'backend/documentService',    serviceFunction: 'getExpiringDocuments',    argMapping: ['driverId', 'daysWindow', 'includeExpired'],        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_hos_summary:        { serviceModule: 'backend/hosService',         serviceFunction: 'getHOSSummary',           argMapping: ['driverId'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    log_hos_entry:          { serviceModule: 'backend/hosService',         serviceFunction: 'logHOSEntry',             argMapping: ['driverId', 'entry'],                              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_hos_violations:     { serviceModule: 'backend/hosService',         serviceFunction: 'getHOSViolations',        argMapping: ['driverId', 'dateRange', 'severity'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    sync_eld_data:          { serviceModule: 'backend/eldService',         serviceFunction: 'syncELDData',             argMapping: ['driverId', 'provider', 'windowHours'],            policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_training_courses:   { serviceModule: 'backend/trainingService',    serviceFunction: 'getAvailableCourses',     argMapping: ['driverId', 'filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    start_training:         { serviceModule: 'backend/trainingService',    serviceFunction: 'enrollInCourse',          argMapping: ['driverId', 'courseId', 'acceptCost'],              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_training_progress:  { serviceModule: 'backend/trainingService',    serviceFunction: 'getTrainingProgress',     argMapping: ['driverId', 'statusFilter'],                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_certifications:     { serviceModule: 'backend/trainingService',    serviceFunction: 'getDriverCertifications', argMapping: ['driverId', 'filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_financial: 10 actions ──
  driver_financial: {
    log_expense:             { serviceModule: 'backend/driverFinancialService', serviceFunction: 'logExpense',             argMapping: ['driverId', 'expense'],                              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_expenses:            { serviceModule: 'backend/driverFinancialService', serviceFunction: 'getExpenses',            argMapping: ['driverId', 'filters', 'pagination'],                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_expense_summary:     { serviceModule: 'backend/driverFinancialService', serviceFunction: 'getExpenseSummary',      argMapping: ['driverId', 'period', 'dateRange'],                   policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    export_expenses:         { serviceModule: 'backend/driverFinancialService', serviceFunction: 'exportExpenses',         argMapping: ['driverId', 'dateRange', 'format', 'categories'],     policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_settlement_history:  { serviceModule: 'backend/settlementService',      serviceFunction: 'getSettlementHistory',   argMapping: ['driverId', 'filters'],                              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    dispute_settlement:      { serviceModule: 'backend/settlementService',      serviceFunction: 'disputeSettlement',      argMapping: ['driverId', 'settlementId', 'dispute'],               policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    calculate_trip_cost:     { serviceModule: 'backend/driverFinancialService', serviceFunction: 'calculateTripCost',      argMapping: ['driverId', 'tripParams'],                            policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 20 } },
    get_tax_summary:         { serviceModule: 'backend/taxService',             serviceFunction: 'getDriverTaxSummary',    argMapping: ['driverId', 'taxYear', 'filingStatus'],               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_deduction_suggestions: { serviceModule: 'backend/taxService',           serviceFunction: 'getDeductionSuggestions', argMapping: ['driverId', 'taxYear'],                              policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 10 } },
    get_per_diem_rates:      { serviceModule: 'backend/taxService',             serviceFunction: 'getPerDiemRates',        argMapping: ['taxYear', 'state'],                                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_lifecycle: 5 actions ──
  driver_lifecycle: {
    get_driver_timeline:     { serviceModule: 'backend/driverLifecycleService', serviceFunction: 'getDriverTimeline',       argMapping: ['driverId', 'filters'],                              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    update_disposition:      { serviceModule: 'backend/driverLifecycleService', serviceFunction: 'updateDisposition',       argMapping: ['driverId', 'disposition', 'availableDate', 'notes'], policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_pending_surveys:     { serviceModule: 'backend/surveyService',          serviceFunction: 'getPendingSurveys',       argMapping: ['driverId', 'surveyType'],                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    submit_survey_response:  { serviceModule: 'backend/surveyService',          serviceFunction: 'submitSurveyResponse',    argMapping: ['driverId', 'surveyRequestId', 'responses'],         policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    submit_match_feedback:   { serviceModule: 'backend/driverLifecycleService', serviceFunction: 'submitMatchFeedback',     argMapping: ['driverId', 'matchId', 'feedback'],                  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
  },

  // ── driver_utility: 4 actions ──
  driver_utility: {
    get_profile_strength_score: { serviceModule: 'backend/driverProfileService',  serviceFunction: 'getProfileStrengthScore', argMapping: ['driverId'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    send_quick_response:        { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'sendQuickResponse',      argMapping: ['driverId', 'conversationId', 'templateKey', 'addendum'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 20 } },
    set_reverse_alert:          { serviceModule: 'backend/alertService',          serviceFunction: 'createReverseAlert',     argMapping: ['driverId', 'alertConfig'],                         policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_market_insights:        { serviceModule: 'backend/marketIntelService',    serviceFunction: 'getDriverMarketInsights', argMapping: ['driverId', 'insightType', 'laneFocus'],            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // —— admin_meta_ads_governance: 13 actions ——
  admin_meta_ads_governance: {
    list_meta_integrations:      { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'listMetaIntegrations',    argMapping: ['filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_token_health:            { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'getTokenHealth',          argMapping: ['integrationId'],                      policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_meta_api_error_digest:   { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'getMetaApiErrorDigest',   argMapping: ['integrationId', 'hours', 'limit'],    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_rate_limit_posture:      { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'getRateLimitPosture',     argMapping: ['integrationId', 'windowHours'],       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_audit_events:            { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'getAuditEvents',          argMapping: ['filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    refresh_system_user_token:   { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'refreshSystemUserToken',  argMapping: ['integrationId', 'payload'],           policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    set_campaign_guardrails:     { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'setCampaignGuardrails',   argMapping: ['payload', 'userId'],                  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    set_daily_budget_caps:       { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'setDailyBudgetCaps',      argMapping: ['payload', 'userId'],                  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    set_approval_thresholds:     { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'setApprovalThresholds',   argMapping: ['payload', 'userId'],                  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    quarantine_integration:      { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'quarantineIntegration',   argMapping: ['integrationId', 'payload', 'userId'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    rotate_credentials:          { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'rotateCredentials',       argMapping: ['integrationId', 'payload', 'userId'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    rebind_ad_account:           { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'rebindAdAccount',         argMapping: ['integrationId', 'payload', 'userId'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    disable_integration:         { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'disableIntegration',      argMapping: ['integrationId', 'payload', 'userId'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
  },

  // —— recruiter_paid_media: 24 actions ——
  recruiter_paid_media: {
    create_campaign_draft:      { serviceModule: 'backend/metaCampaignService', serviceFunction: 'createCampaignDraft',      argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    create_campaign:            { serviceModule: 'backend/metaCampaignService', serviceFunction: 'createCampaign',           argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    update_campaign:            { serviceModule: 'backend/metaCampaignService', serviceFunction: 'updateCampaign',           argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    pause_campaign:             { serviceModule: 'backend/metaCampaignService', serviceFunction: 'pauseCampaign',            argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    resume_campaign:            { serviceModule: 'backend/metaCampaignService', serviceFunction: 'resumeCampaign',           argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    delete_campaign:            { serviceModule: 'backend/metaCampaignService', serviceFunction: 'deleteCampaign',           argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    create_ad_set_draft:        { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'createAdSetDraft',         argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    create_ad_set:              { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'createAdSet',              argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    update_ad_set_targeting:    { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'updateAdSetTargeting',     argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    update_ad_set_budget:       { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'updateAdSetBudget',        argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    update_ad_set_schedule:     { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'updateAdSetSchedule',      argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    pause_ad_set:               { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'pauseAdSet',               argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    resume_ad_set:              { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'resumeAdSet',              argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    delete_ad_set:              { serviceModule: 'backend/metaAdSetService',    serviceFunction: 'deleteAdSet',              argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    create_creative_draft:      { serviceModule: 'backend/metaCreativeService', serviceFunction: 'createCreativeDraft',      argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    create_creative:            { serviceModule: 'backend/metaCreativeService', serviceFunction: 'createCreative',           argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    update_creative:            { serviceModule: 'backend/metaCreativeService', serviceFunction: 'updateCreative',           argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    archive_creative:           { serviceModule: 'backend/metaCreativeService', serviceFunction: 'archiveCreative',          argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    create_ad:                  { serviceModule: 'backend/metaCampaignService', serviceFunction: 'createAd',                 argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    update_ad:                  { serviceModule: 'backend/metaCampaignService', serviceFunction: 'updateAd',                 argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    pause_ad:                   { serviceModule: 'backend/metaCampaignService', serviceFunction: 'pauseAd',                  argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    resume_ad:                  { serviceModule: 'backend/metaCampaignService', serviceFunction: 'resumeAd',                 argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    delete_ad:                  { serviceModule: 'backend/metaCampaignService', serviceFunction: 'deleteAd',                 argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    attach_creative_to_ad:      { serviceModule: 'backend/metaCreativeService', serviceFunction: 'attachCreativeToAd',       argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
  },

  // —— recruiter_paid_media_analytics: 16 actions ——
  recruiter_paid_media_analytics: {
    get_insights_campaign_level:    { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getInsightsCampaignLevel',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    get_insights_adset_level:       { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getInsightsAdSetLevel',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    get_insights_ad_level:          { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getInsightsAdLevel',          argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    get_insights_with_breakdowns:   { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getInsightsWithBreakdowns',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    create_async_report_job:        { serviceModule: 'backend/metaInsightsService', serviceFunction: 'createAsyncReportJob',        argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 10 } },
    get_async_report_status:        { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getAsyncReportStatus',        argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    download_report:                { serviceModule: 'backend/metaInsightsService', serviceFunction: 'downloadReport',              argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    get_creative_performance:       { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getCreativePerformance',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    get_placement_performance:      { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getPlacementPerformance',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    get_frequency_fatigue_alerts:   { serviceModule: 'backend/metaInsightsService', serviceFunction: 'getFrequencyFatigueAlerts',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',    requires_approval: false, rate_limit: 20 } },
    suggest_budget_reallocation:    { serviceModule: 'backend/metaInsightsService', serviceFunction: 'suggestBudgetReallocation',   argMapping: ['userId', 'params'], policy: { risk_level: 'suggest', requires_approval: false, rate_limit: 20 } },
    suggest_creative_rotation:      { serviceModule: 'backend/metaInsightsService', serviceFunction: 'suggestCreativeRotation',     argMapping: ['userId', 'params'], policy: { risk_level: 'suggest', requires_approval: false, rate_limit: 20 } },
    suggest_audience_narrowing:     { serviceModule: 'backend/metaInsightsService', serviceFunction: 'suggestAudienceNarrowing',    argMapping: ['userId', 'params'], policy: { risk_level: 'suggest', requires_approval: false, rate_limit: 20 } },
    apply_budget_reallocation:      { serviceModule: 'backend/metaOptimizationService', serviceFunction: 'applyBudgetReallocation', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
    apply_bid_adjustment:           { serviceModule: 'backend/metaOptimizationService', serviceFunction: 'applyBidAdjustment',      argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
    rotate_creative_variant:        { serviceModule: 'backend/metaOptimizationService', serviceFunction: 'rotateCreativeVariant',   argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
  },

  // ── recruiter_outreach: 15 actions ──
  recruiter_outreach: {
    create_sms_campaign:         { serviceModule: 'backend/smsCampaignService',        serviceFunction: 'createSMSCampaign',        argMapping: ['carrierDot', 'params'],                     policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    create_email_campaign:       { serviceModule: 'backend/emailCampaignService',      serviceFunction: 'createEmailCampaign',      argMapping: ['carrierDot', 'params'],                     policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_campaign_status:         { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'getCampaignStatus',        argMapping: ['recruiterId', 'campaignId', 'campaignType'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    pause_campaign:              { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'pauseCampaign',            argMapping: ['campaignId', 'campaignType'],               policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    resume_campaign:             { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'resumeCampaign',           argMapping: ['campaignId', 'campaignType'],               policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    get_campaign_history:        { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'getCampaignHistory',       argMapping: ['recruiterId', 'filters'],                   policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    syndicate_job_posting:       { serviceModule: 'backend/jobBoardService',           serviceFunction: 'syndicateJob',             argMapping: ['jobId', 'boards'],                         policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_syndication_status:      { serviceModule: 'backend/jobBoardService',           serviceFunction: 'getJobPostings',           argMapping: ['carrierDot', 'filters'],                   policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_social_post:          { serviceModule: 'backend/socialPostingService',      serviceFunction: 'createSocialPost',         argMapping: ['carrierDot', 'params'],                     policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_message_templates:       { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'getMessageTemplates',      argMapping: ['recruiterId', 'filters'],                   policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_message_template:     { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'createMessageTemplate',    argMapping: ['recruiterId', 'params'],                    policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    preview_campaign_reach:      { serviceModule: 'backend/recruiterOutreachService',  serviceFunction: 'previewCampaignReach',     argMapping: ['recruiterId', 'params'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_voice_campaign:       { serviceModule: 'backend/voiceCampaignService',      serviceFunction: 'createCampaign',           argMapping: ['recruiterId', 'params'],                    policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_voice_templates:         { serviceModule: 'backend/voiceAgentTemplates',       serviceFunction: 'getTemplatesByCategory',   argMapping: ['category'],                                 policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_voice_campaign_status:   { serviceModule: 'backend/voiceCampaignService',      serviceFunction: 'getCampaignStatus',        argMapping: ['campaignId'],                               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── recruiter_analytics: 10 actions ──
  recruiter_analytics: {
    get_attribution_report:  { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getAttributionBreakdown', argMapping: ['carrierDot', 'dateRange', 'metric'],   policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_cph_metrics:         { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'calculateCostPerHire',    argMapping: ['carrierDot', 'dateRange'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_funnel_analysis:     { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getFunnelMetrics',        argMapping: ['carrierDot', 'dateRange'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_competitor_intel:    { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getCompetitorComparison', argMapping: ['region', 'jobType'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_ml_forecast:         { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getHiringForecast',      argMapping: ['carrierDot'],                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_time_to_fill:        { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getTimeToFill',          argMapping: ['carrierDot', 'filters'],                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_source_roi:          { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getChannelROI',          argMapping: ['carrierDot', 'dateRange'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_drop_off_analysis:   { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getBottleneckAnalysis',  argMapping: ['carrierDot', 'dateRange'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_recruiter_scorecard: { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getRecruiterScorecard',  argMapping: ['recruiterId', 'dateRange'],             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    export_analytics:        { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'exportAnalytics',        argMapping: ['recruiterId', 'params'],                policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
  },

  // ── recruiter_onboarding: 12 actions ──
  recruiter_onboarding: {
    create_onboarding_workflow:    { serviceModule: 'backend/onboardingWorkflowService',  serviceFunction: 'createOnboardingWorkflow',  argMapping: ['driverId', 'carrierId', 'recruiterId'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    get_onboarding_status:         { serviceModule: 'backend/onboardingWorkflowService',  serviceFunction: 'getWorkflowStatus',         argMapping: ['workflowId'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    request_documents:             { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'requestDocuments',           argMapping: ['recruiterId', 'params'],                 policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 10 } },
    get_document_collection_status: { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'getDocumentCollectionStatus', argMapping: ['workflowId'],                          policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    initiate_bgc:                  { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'initiateBGC',               argMapping: ['recruiterId', 'params'],                 policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_bgc_status:                { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'getBGCStatus',              argMapping: ['checkId'],                               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    initiate_drug_test:            { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'initiateDrugTest',          argMapping: ['recruiterId', 'params'],                 policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_drug_test_status:          { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'getDrugTestStatus',         argMapping: ['testId'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    send_esign_request:            { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'sendESignRequest',          argMapping: ['recruiterId', 'params'],                 policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_esign_status:              { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'getESignStatus',            argMapping: ['requestId'],                             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    schedule_orientation:          { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'scheduleOrientation',       argMapping: ['recruiterId', 'params'],                 policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_orientation_slots:         { serviceModule: 'backend/recruiterOnboardingService', serviceFunction: 'getOrientationSlots',       argMapping: ['carrierId', 'filters'],                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── recruiter_pipeline: 10 actions ──
  recruiter_pipeline: {
    save_driver_search:          { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'saveDriverSearch',         argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    get_saved_searches:          { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'getSavedSearches',         argMapping: ['recruiterId'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    run_saved_search:            { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'runSavedSearch',           argMapping: ['recruiterId', 'searchId'],        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_pipeline_automation:  { serviceModule: 'backend/pipelineAutomationService',   serviceFunction: 'createAutomationRule',     argMapping: ['carrierDot', 'params'],           policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_pipeline_automations:    { serviceModule: 'backend/pipelineAutomationService',   serviceFunction: 'getAutomationRules',       argMapping: ['carrierDot'],                     policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_intervention_templates:  { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'getInterventionTemplates', argMapping: ['filters'],                        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    apply_intervention:          { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'applyIntervention',        argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 10 } },
    bulk_update_pipeline:        { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'bulkUpdatePipeline',       argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_stale_candidates:        { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'getStaleCandidates',       argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_call_outcomes_summary:   { serviceModule: 'backend/recruiterPipelineService',    serviceFunction: 'getCallOutcomesSummary',   argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── recruiter_retention: 8 actions ──
  recruiter_retention: {
    get_retention_risks:            { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'getRetentionRisks',            argMapping: ['recruiterId', 'filters'],        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_risk_score_detail:          { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'getRiskScoreDetail',           argMapping: ['driverId'],                      policy: { risk_level: 'read',         requires_approval: false, rate_limit: 30 } },
    add_to_watchlist:               { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'addToWatchlist',               argMapping: ['recruiterId', 'params'],         policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    remove_from_watchlist:          { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'removeFromWatchlist',          argMapping: ['recruiterId', 'driverId'],       policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    get_watchlist:                  { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'getWatchlist',                 argMapping: ['recruiterId', 'filters'],        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_retention_intervention:  { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'createRetentionIntervention',  argMapping: ['recruiterId', 'params'],         policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 5 } },
    get_retention_history:          { serviceModule: 'backend/recruiterRetentionService', serviceFunction: 'getRetentionHistory',          argMapping: ['recruiterId', 'filters'],        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_turnover_analytics:         { serviceModule: 'backend/recruiterAnalyticsService', serviceFunction: 'getTurnoverRiskAnalysis',      argMapping: ['carrierDot'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── recruiter_reverse_match: 8 actions ──
  recruiter_reverse_match: {
    reverse_search_drivers:     { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'reverseSearchDrivers',    argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_reverse_match_scores:   { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'getReverseMatchScores',   argMapping: ['recruiterId', 'matchId'],         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_match_subscription:  { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'createMatchSubscription', argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_match_subscriptions:    { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'getMatchSubscriptions',   argMapping: ['recruiterId'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    delete_match_subscription:  { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'deleteMatchSubscription', argMapping: ['recruiterId', 'subscriptionId'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
    get_subscription_alerts:    { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'getSubscriptionAlerts',   argMapping: ['recruiterId', 'filters'],         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_stripe_billing:         { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'getStripeBilling',        argMapping: ['recruiterId'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    upgrade_subscription:       { serviceModule: 'backend/recruiterReverseMatchService', serviceFunction: 'upgradeSubscription',     argMapping: ['recruiterId', 'params'],          policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
  },

  // ── Phase 3: Carrier Fleet Router (12 actions) ──
  carrier_fleet: {
    get_fleet_roster:        { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getFleetRoster',        argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_driver_scorecard:    { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getDriverScorecard',    argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_equipment_list:      { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getEquipmentList',      argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_equipment_status:    { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getEquipmentStatus',    argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_fleet_capacity:      { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getFleetCapacity',      argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_eld_fleet_summary:   { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getELDFleetSummary',    argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_fleet_utilization:   { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getFleetUtilization',   argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_fleet_costs:         { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getFleetCosts',         argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    assign_driver_to_unit:   { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'assignDriverToUnit',    argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    update_equipment_status: { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'updateEquipmentStatus', argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    get_fleet_alerts:        { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getFleetAlerts',        argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_driver_availability: { serviceModule: 'backend/carrierFleetAgentService',  serviceFunction: 'getDriverAvailability', argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 3: Carrier Compliance Router (10 actions) ──
  carrier_compliance: {
    get_compliance_calendar:  { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getComplianceCalendar',  argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_document_vault:       { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getDocumentVault',       argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    upload_carrier_document:  { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'uploadCarrierDocument',  argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    get_dq_tracker:           { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getDQTracker',           argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_dq_gaps:              { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getDQGaps',              argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_csa_scores:           { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getCSAScores',           argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_csa_alerts:           { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getCSAAlerts',           argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    log_incident:             { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'logIncident',             argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    get_incident_history:     { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getIncidentHistory',     argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_audit_readiness:      { serviceModule: 'backend/carrierComplianceAgentService', serviceFunction: 'getAuditReadiness',      argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 3: Carrier Communication Router (8 actions) ──
  carrier_communication: {
    create_announcement:      { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'createAnnouncement',     argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_announcements:        { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'getAnnouncements',       argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_policy_update:     { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'createPolicyUpdate',     argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_policies:             { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'getPolicies',            argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_recognition:       { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'createRecognition',      argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_recognitions:         { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'getRecognitions',        argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_feedback_request:  { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'createFeedbackRequest',  argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_feedback_responses:   { serviceModule: 'backend/carrierCommunicationAgentService', serviceFunction: 'getFeedbackResponses',   argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 3: Carrier Journey Router (8 actions) ──
  carrier_journey: {
    get_onboarding_flow:     { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'getOnboardingFlow',     argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_carrier_identity: { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'updateCarrierIdentity', argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_carrier_navigation:  { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'getCarrierNavigation',  argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    initiate_deposit:        { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'initiateDeposit',       argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_payment_history:     { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'getPaymentHistory',     argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_subscription_status: { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'getSubscriptionStatus', argMapping: ['carrierDot', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    upgrade_carrier_plan:    { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'upgradeCarrierPlan',    argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_checkout_session:    { serviceModule: 'backend/carrierJourneyService', serviceFunction: 'getCheckoutSession',    argMapping: ['carrierDot', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
  },

  // ── Phase 3: B2B Suite Router (18 actions) ──
  b2b_suite: {
    get_match_intelligence:   { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getMatchIntelligence',  argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_b2b_pipeline:         { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getB2BPipeline',        argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_opportunity_stage: { serviceModule: 'backend/b2bAgentService', serviceFunction: 'updateOpportunityStage', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    create_b2b_outreach:      { serviceModule: 'backend/b2bAgentService', serviceFunction: 'createOutreach',        argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_b2b_events:           { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getB2BEvents',          argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    run_research_agent:       { serviceModule: 'backend/b2bAgentService', serviceFunction: 'runResearchAgent',      argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 3 } },
    get_research_results:     { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getResearchResults',    argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_b2b_analytics:        { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getB2BAnalytics',       argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_b2b_account:       { serviceModule: 'backend/b2bAgentService', serviceFunction: 'createB2BAccount',      argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    update_b2b_account:       { serviceModule: 'backend/b2bAgentService', serviceFunction: 'updateB2BAccount',      argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_b2b_tasks:            { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getTasks',              argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_b2b_task:          { serviceModule: 'backend/b2bAgentService', serviceFunction: 'createTask',            argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    complete_b2b_task:        { serviceModule: 'backend/b2bAgentService', serviceFunction: 'completeTask',          argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_b2b_contacts:         { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getContacts',           argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    add_b2b_contact:          { serviceModule: 'backend/b2bAgentService', serviceFunction: 'addContact',            argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_b2b_notes:            { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getNotes',              argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    add_b2b_note:             { serviceModule: 'backend/b2bAgentService', serviceFunction: 'addNote',               argMapping: ['userId', 'params'],  policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_b2b_score:            { serviceModule: 'backend/b2bAgentService', serviceFunction: 'getAccountScore',       argMapping: ['userId', 'params'],  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 4: Admin Business Operations Router (10 actions) ──
  admin_business_ops: {
    get_revenue_dashboard:   { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getRevenueDashboard',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_billing_overview:    { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getBillingOverview',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_invoices:            { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getInvoices',          argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_invoice:          { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'createInvoice',        argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_commission_report:   { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getCommissionReport',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    approve_commission:      { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'approveCommission',    argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_mrr_metrics:         { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getMRRMetrics',        argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_churn_metrics:       { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getChurnMetrics',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_arpu_breakdown:      { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'getARPUBreakdown',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    export_financial_report: { serviceModule: 'backend/adminBusinessOpsAgentService', serviceFunction: 'exportFinancialReport', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
  },

  // ── Phase 4: Admin Platform Configuration Router (10 actions) ──
  admin_platform_config: {
    get_feature_flags:        { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'getFeatureFlags',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    toggle_feature_flag:      { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'toggleFeatureFlag',     argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_ab_tests:             { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'getABTests',            argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_ab_test:           { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'createABTest',          argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_email_templates:      { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'getEmailTemplates',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_email_template:    { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'updateEmailTemplate',   argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_notification_rules:   { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'getNotificationRules',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_notification_rule: { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'updateNotificationRule', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_platform_config:      { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'getPlatformConfig',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_platform_config:   { serviceModule: 'backend/adminPlatformConfigAgentService', serviceFunction: 'updatePlatformConfig',  argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
  },

  // ── Phase 4: Admin Portal Router (10 actions) ──
  admin_portal: {
    get_admin_dashboard: { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getAdminDashboard', argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_user_list:       { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getUserList',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_user_detail:     { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getUserDetail',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    suspend_user:        { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'suspendUser',       argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    unsuspend_user:      { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'unsuspendUser',     argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_moderation_queue: { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getModerationQueue', argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    moderate_content:    { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'moderateContent',   argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_ai_dashboard:    { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getAIDashboard',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_compliance_audit: { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getComplianceAudit', argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_login_activity:  { serviceModule: 'backend/adminPortalAgentService', serviceFunction: 'getLoginActivity',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 4: Admin Support Operations Router (8 actions) ──
  admin_support: {
    get_support_tickets: { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'getSupportTickets', argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_ticket_detail:   { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'getTicketDetail',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    update_ticket_status: { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'updateTicketStatus', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    assign_ticket:       { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'assignTicket',      argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    get_knowledge_base:  { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'getKnowledgeBase',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    create_kb_article:   { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'createKBArticle',   argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    get_nps_scores:      { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'getNPSScores',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_csat_report:     { serviceModule: 'backend/adminSupportAgentService', serviceFunction: 'getCSATReport',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 4: Admin Gamification Router (8 actions) ──
  admin_gamification: {
    get_gamification_config:   { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'getGamificationConfig',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_xp_rules:           { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'updateXPRules',          argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_achievement_list:      { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'getAchievementList',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_achievement:        { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'createAchievement',      argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    create_challenge:          { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'createChallenge',        argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_active_challenges:     { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'getActiveChallenges',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_global_leaderboard:    { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'getGlobalLeaderboard',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_gamification_analytics: { serviceModule: 'backend/adminGamificationAgentService', serviceFunction: 'getGamificationAnalytics', argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 4: Admin Feature Adoption Router (6 actions) ──
  admin_feature_adoption: {
    get_feature_adoption:     { serviceModule: 'backend/adminFeatureAdoptionAgentService', serviceFunction: 'getFeatureAdoption',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_adoption_funnels:     { serviceModule: 'backend/adminFeatureAdoptionAgentService', serviceFunction: 'getAdoptionFunnels',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_feature_health:       { serviceModule: 'backend/adminFeatureAdoptionAgentService', serviceFunction: 'getFeatureHealth',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_stickiness_metrics:   { serviceModule: 'backend/adminFeatureAdoptionAgentService', serviceFunction: 'getStickinessMetrics',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_adoption_cohorts:     { serviceModule: 'backend/adminFeatureAdoptionAgentService', serviceFunction: 'getAdoptionCohorts',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    create_adoption_campaign: { serviceModule: 'backend/adminFeatureAdoptionAgentService', serviceFunction: 'createAdoptionCampaign', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
  },

  // ── Phase 5: Cross-Role Utility Router (10 actions) ──
  cross_role_utility: {
    get_mutual_interest:       { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getMutualInterest',     argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_retention_for_carrier: { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getRetentionForCarrier', argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_match_explanation:     { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getMatchExplanation',   argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_recruiter_health:      { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getRecruiterHealth',    argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_platform_benchmarks:   { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getPlatformBenchmarks', argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_industry_trends:       { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getIndustryTrends',     argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_regional_analysis:     { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getRegionalAnalysis',   argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_seasonal_patterns:     { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getSeasonalPatterns',   argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    compare_carriers:          { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'compareCarriers',       argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
    get_driver_market_value:   { serviceModule: 'backend/crossRoleUtilityAgentService', serviceFunction: 'getDriverMarketValue',  argMapping: ['userId', 'params'], policy: { risk_level: 'read', requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 5: Observability Ops Router (5 actions) ──
  observability_ops: {
    get_tracing_dashboard: { serviceModule: 'backend/adminObservabilityAgentService', serviceFunction: 'getTracingDashboard', argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_tool_performance:  { serviceModule: 'backend/adminObservabilityAgentService', serviceFunction: 'getToolPerformance',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_scoring_accuracy:  { serviceModule: 'backend/adminObservabilityAgentService', serviceFunction: 'getScoringAccuracy',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    recalibrate_scoring:   { serviceModule: 'backend/adminObservabilityAgentService', serviceFunction: 'recalibrateScoring',  argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_agent_replay:      { serviceModule: 'backend/adminObservabilityAgentService', serviceFunction: 'getAgentReplay',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 5: External API Router (10 actions) ──
  external_api: {
    query_safety_api:     { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'querySafetyApi',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 5 } },
    query_intel_api:      { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'queryIntelApi',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 5 } },
    query_ops_api:        { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'queryOpsApi',        argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 5 } },
    query_matching_api:   { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'queryMatchingApi',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 5 } },
    query_document_api:   { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'queryDocumentApi',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 5 } },
    query_engagement_api: { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'queryEngagementApi', argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 5 } },
    get_api_usage:        { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'getApiUsage',        argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_api_health:       { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'getApiHealth',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    configure_api_key:    { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'configureApiKey',    argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    test_api_endpoint:    { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'testApiEndpoint',    argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
  },

  // ── Phase 5: Financial Extended Router (8 actions) ──
  financial_extended: {
    track_expenses:        { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'trackExpenses',       argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 5 } },
    get_expense_report:    { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'getExpenseReport',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_settlement_detail: { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'getSettlementDetail', argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    calculate_trip_cost:   { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'calculateTripCost',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_tax_summary:       { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'getTaxSummary',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_irs_per_diem:      { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'getIrsPerDiem',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    get_fuel_tax_report:   { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'getFuelTaxReport',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
    estimate_take_home:    { serviceModule: 'backend/financialExtAgentService', serviceFunction: 'estimateTakeHome',    argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 10 } },
  },

  // ── Phase 5: Lifecycle Ops Router (10 actions) ──
  lifecycle_ops: {
    get_driver_timeline:       { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getDriverTimeline',       argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_carrier_timeline:      { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getCarrierTimeline',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    update_disposition:        { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'updateDisposition',       argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_disposition_options:   { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getDispositionOptions',   argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    create_exit_survey:        { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'createExitSurvey',       argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
    get_survey_responses:      { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getSurveyResponses',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    submit_algorithm_feedback: { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'submitAlgorithmFeedback', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 5 } },
    get_feedback_summary:      { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getFeedbackSummary',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_lifecycle_analytics:   { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getLifecycleAnalytics',  argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_cohort_retention:      { serviceModule: 'backend/lifecycleOpsAgentService', serviceFunction: 'getCohortRetention',     argMapping: ['userId', 'params'], policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
  },

  // ── Cross-role paid media to pipeline attribution router (7 actions) ──
  cross_role_paid_media_pipeline: {
    get_paid_media_to_pipeline_funnel: { serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'getPaidMediaToPipelineFunnel', argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 15 } },
    get_cpl_to_hire_trend:             { serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'getCplToHireTrend',          argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 15 } },
    get_source_quality_score:          { serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'getSourceQualityScore',      argMapping: ['userId', 'params'], policy: { risk_level: 'read',        requires_approval: false, rate_limit: 15 } },
    suggest_channel_mix:               { serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'suggestChannelMix',          argMapping: ['userId', 'params'], policy: { risk_level: 'suggest',     requires_approval: false, rate_limit: 10 } },
    suggest_geo_expansion:             { serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'suggestGeoExpansion',        argMapping: ['userId', 'params'], policy: { risk_level: 'suggest',     requires_approval: false, rate_limit: 10 } },
    sync_campaign_taxonomy_to_pipeline:{ serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'syncCampaignTaxonomyToPipeline', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 8 } },
    backfill_missing_attribution:      { serviceModule: 'backend/metaAttributionBridgeService', serviceFunction: 'backfillMissingAttribution', argMapping: ['userId', 'params'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 8 } },
  },
};

// ── Router definitions sent to the AI (one per domain) ──
const ROUTER_DEFINITIONS = {
  driver_cockpit: {
    name: 'driver_cockpit',
    description: 'Driver cockpit operations: search jobs, view/apply/withdraw applications, messaging (send/read/threads), profile management, match browsing (view/express interest/dismiss), dashboard summary, notifications, document upload',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['search_jobs', 'get_job_details', 'quick_apply', 'save_job', 'get_saved_jobs',
                 'withdraw_application', 'check_application_status', 'get_application_history',
                 'send_message', 'get_messages', 'get_conversation', 'mark_read', 'get_unread_count',
                 'update_profile', 'get_profile_strength', 'get_profile_suggestions', 'upload_document',
                 'get_matches', 'get_match_details', 'express_interest', 'dismiss_match',
                 'get_dashboard_summary', 'get_notifications'],
          description: 'The cockpit operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_road: {
    name: 'driver_road',
    description: 'Road utility operations: find truck parking, fuel prices and trends, calculate fuel cost, weigh station status, rest stops, weather forecasts and alerts, road conditions, report hazards',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['find_parking', 'get_parking_details', 'report_parking_availability', 'save_favorite_parking',
                 'find_fuel_prices', 'get_fuel_price_trends', 'calculate_fuel_cost',
                 'get_weigh_station_status', 'get_weigh_stations_on_route',
                 'find_rest_stops', 'rate_rest_stop',
                 'get_weather_forecast', 'get_weather_alerts', 'get_road_conditions', 'report_road_hazard'],
          description: 'The road utility operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_community: {
    name: 'driver_community',
    description: 'Community operations: browse/create/reply/like/report forum posts, search forums, find/request mentors, rate mentorship, search pet-friendly locations, submit pet-friendly locations, browse health resources, submit health tips',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_forum_posts', 'create_forum_post', 'reply_to_post', 'like_post', 'report_post', 'search_forums',
                 'find_mentors', 'request_mentorship', 'get_mentorship_status', 'rate_mentor',
                 'search_pet_friendly_locations', 'submit_pet_friendly_location',
                 'get_health_resources', 'submit_health_tip'],
          description: 'The community operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_compliance: {
    name: 'driver_compliance',
    description: 'Compliance operations: upload/view compliance documents, check document expiry, HOS summary/log/violations, sync ELD data, browse/start training courses, track training progress, view certifications',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['upload_compliance_doc', 'get_compliance_docs', 'check_doc_expiry', 'get_expiring_docs',
                 'get_hos_summary', 'log_hos_entry', 'get_hos_violations', 'sync_eld_data',
                 'get_training_courses', 'start_training', 'get_training_progress', 'get_certifications'],
          description: 'The compliance operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_financial: {
    name: 'driver_financial',
    description: 'Financial operations: log/view/summarize/export expenses, view settlement history, dispute settlements, calculate trip costs, tax summary, deduction suggestions, per diem rates',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['log_expense', 'get_expenses', 'get_expense_summary', 'export_expenses',
                 'get_settlement_history', 'dispute_settlement', 'calculate_trip_cost',
                 'get_tax_summary', 'get_deduction_suggestions', 'get_per_diem_rates'],
          description: 'The financial operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_lifecycle: {
    name: 'driver_lifecycle',
    description: 'Lifecycle operations: view driver timeline, update job search disposition, get pending surveys, submit survey responses, submit match feedback',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_driver_timeline', 'update_disposition', 'get_pending_surveys', 'submit_survey_response', 'submit_match_feedback'],
          description: 'The lifecycle operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_utility: {
    name: 'driver_utility',
    description: 'Utility operations: profile strength score widget, send quick response templates, set reverse job alert, get personalized market insights',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_profile_strength_score', 'send_quick_response', 'set_reverse_alert', 'get_market_insights'],
          description: 'The utility operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  admin_meta_ads_governance: {
    name: 'admin_meta_ads_governance',
    description: 'Meta ads integration governance operations: integration inventory, token health, error digest, rate-limit posture, audit events, token refresh, guardrail and threshold policies, quarantine, credential rotation, ad-account rebinding, and integration disable controls',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['list_meta_integrations', 'get_token_health', 'get_meta_api_error_digest', 'get_rate_limit_posture', 'get_audit_events',
                 'refresh_system_user_token', 'set_campaign_guardrails', 'set_daily_budget_caps', 'set_approval_thresholds',
                 'quarantine_integration', 'rotate_credentials', 'rebind_ad_account', 'disable_integration'],
          description: 'The governance operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['admin']
  },

  recruiter_paid_media: {
    name: 'recruiter_paid_media',
    description: 'Meta paid media lifecycle operations: draft/create/update/pause/resume/delete campaigns, ad sets, ads, and creative linking',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['create_campaign_draft', 'create_campaign', 'update_campaign', 'pause_campaign', 'resume_campaign', 'delete_campaign',
                 'create_ad_set_draft', 'create_ad_set', 'update_ad_set_targeting', 'update_ad_set_budget', 'update_ad_set_schedule',
                 'pause_ad_set', 'resume_ad_set', 'delete_ad_set',
                 'create_creative_draft', 'create_creative', 'update_creative', 'archive_creative',
                 'create_ad', 'update_ad', 'pause_ad', 'resume_ad', 'delete_ad', 'attach_creative_to_ad'],
          description: 'The paid media operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters; include idempotencyKey for mutation safety' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_paid_media_analytics: {
    name: 'recruiter_paid_media_analytics',
    description: 'Meta paid media analytics operations: insights reads, breakdowns, async reports, creative/placement performance, fatigue alerts, optimization suggestions, and guarded apply actions',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_insights_campaign_level', 'get_insights_adset_level', 'get_insights_ad_level', 'get_insights_with_breakdowns',
                 'create_async_report_job', 'get_async_report_status', 'download_report',
                 'get_creative_performance', 'get_placement_performance', 'get_frequency_fatigue_alerts',
                 'suggest_budget_reallocation', 'suggest_creative_rotation', 'suggest_audience_narrowing',
                 'apply_budget_reallocation', 'apply_bid_adjustment', 'rotate_creative_variant'],
          description: 'The paid media analytics operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (dateRange, breakdownBy, reportScope, jobId, thresholds)' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_outreach: {
    name: 'recruiter_outreach',
    description: 'Multi-channel campaign management — SMS, email, voice, social, job board syndication, templates',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['create_sms_campaign', 'create_email_campaign', 'get_campaign_status', 'pause_campaign', 'resume_campaign',
                 'get_campaign_history', 'syndicate_job_posting', 'get_syndication_status', 'create_social_post',
                 'get_message_templates', 'create_message_template', 'preview_campaign_reach',
                 'create_voice_campaign', 'get_voice_templates', 'get_voice_campaign_status'],
          description: 'The outreach operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_analytics: {
    name: 'recruiter_analytics',
    description: 'Recruiting analytics — attribution, cost per hire, funnel, competitor intel, forecasts, scorecards',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_attribution_report', 'get_cph_metrics', 'get_funnel_analysis', 'get_competitor_intel', 'get_ml_forecast',
                 'get_time_to_fill', 'get_source_roi', 'get_drop_off_analysis', 'get_recruiter_scorecard', 'export_analytics'],
          description: 'The analytics operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_onboarding: {
    name: 'recruiter_onboarding',
    description: 'New hire onboarding — workflows, document collection, background checks, drug tests, e-signatures, orientation',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['create_onboarding_workflow', 'get_onboarding_status', 'request_documents', 'get_document_collection_status',
                 'initiate_bgc', 'get_bgc_status', 'initiate_drug_test', 'get_drug_test_status',
                 'send_esign_request', 'get_esign_status', 'schedule_orientation', 'get_orientation_slots'],
          description: 'The onboarding operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_pipeline: {
    name: 'recruiter_pipeline',
    description: 'Pipeline management — saved searches, automations, interventions, bulk updates, stale candidates',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['save_driver_search', 'get_saved_searches', 'run_saved_search',
                 'create_pipeline_automation', 'get_pipeline_automations',
                 'get_intervention_templates', 'apply_intervention', 'bulk_update_pipeline',
                 'get_stale_candidates', 'get_call_outcomes_summary'],
          description: 'The pipeline operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_retention: {
    name: 'recruiter_retention',
    description: 'Driver retention — risk scoring, watchlist, interventions, turnover analytics',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_retention_risks', 'get_risk_score_detail', 'add_to_watchlist', 'remove_from_watchlist',
                 'get_watchlist', 'create_retention_intervention', 'get_retention_history', 'get_turnover_analytics'],
          description: 'The retention operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  recruiter_reverse_match: {
    name: 'recruiter_reverse_match',
    description: 'Reverse matching — driver search by criteria, match subscriptions, alerts, billing',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['reverse_search_drivers', 'get_reverse_match_scores', 'create_match_subscription',
                 'get_match_subscriptions', 'delete_match_subscription', 'get_subscription_alerts',
                 'get_stripe_billing', 'upgrade_subscription'],
          description: 'The reverse match operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['recruiter']
  },

  // ── Phase 3: Carrier Routers ──
  carrier_fleet: {
    name: 'carrier_fleet',
    description: 'Fleet management: driver roster, equipment, capacity planning, ELD compliance, utilization, costs, and alerts. Requires carrierDot in params.',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_fleet_roster', 'get_driver_scorecard', 'get_equipment_list', 'get_equipment_status',
                 'get_fleet_capacity', 'get_eld_fleet_summary', 'get_fleet_utilization', 'get_fleet_costs',
                 'assign_driver_to_unit', 'update_equipment_status', 'get_fleet_alerts', 'get_driver_availability'],
          description: 'The fleet management operation to perform'
        },
        params: { type: 'object', description: 'Action parameters. carrierDot required. Additional: driverId, equipmentId, period, type, reason, updates.' }
      },
      required: ['action']
    },
    roles: ['carrier']
  },

  carrier_compliance: {
    name: 'carrier_compliance',
    description: 'Compliance management: calendars, document vault, DQ file tracking, CSA scores, incidents, and DOT audit readiness. Requires carrierDot in params.',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_compliance_calendar', 'get_document_vault', 'upload_carrier_document', 'get_dq_tracker',
                 'get_dq_gaps', 'get_csa_scores', 'get_csa_alerts', 'log_incident',
                 'get_incident_history', 'get_audit_readiness'],
          description: 'The compliance operation to perform'
        },
        params: { type: 'object', description: 'Action parameters. carrierDot required. Additional: filters, limit, incidentData.' }
      },
      required: ['action']
    },
    roles: ['carrier']
  },

  carrier_communication: {
    name: 'carrier_communication',
    description: 'Fleet communication: announcements, policy updates, driver recognitions, and feedback requests. Requires carrierDot in params.',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['create_announcement', 'get_announcements', 'create_policy_update', 'get_policies',
                 'create_recognition', 'get_recognitions', 'create_feedback_request', 'get_feedback_responses'],
          description: 'The communication operation to perform'
        },
        params: { type: 'object', description: 'Action parameters. carrierDot required. Additional: title, description, targetAudience, driverId, recognitionType.' }
      },
      required: ['action']
    },
    roles: ['carrier']
  },

  carrier_journey: {
    name: 'carrier_journey',
    description: 'Carrier onboarding, identity, navigation, payments, subscriptions, and plan management. Requires carrierDot in params.',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_onboarding_flow', 'update_carrier_identity', 'get_carrier_navigation', 'initiate_deposit',
                 'get_payment_history', 'get_subscription_status', 'upgrade_carrier_plan', 'get_checkout_session'],
          description: 'The journey operation to perform'
        },
        params: { type: 'object', description: 'Action parameters. carrierDot required. Additional: email, priceId, driverCount, billingPeriod, successUrl, cancelUrl.' }
      },
      required: ['action']
    },
    roles: ['carrier']
  },

  b2b_suite: {
    name: 'b2b_suite',
    description: 'B2B CRM operations: match intelligence, pipeline, outreach, research, analytics, account management, tasks, contacts, notes, and scoring.',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_match_intelligence', 'get_b2b_pipeline', 'update_opportunity_stage', 'create_b2b_outreach',
                 'get_b2b_events', 'run_research_agent', 'get_research_results', 'get_b2b_analytics',
                 'create_b2b_account', 'update_b2b_account', 'get_b2b_tasks', 'create_b2b_task',
                 'complete_b2b_task', 'get_b2b_contacts', 'add_b2b_contact', 'get_b2b_notes',
                 'add_b2b_note', 'get_b2b_score'],
          description: 'The B2B CRM operation to perform'
        },
        params: { type: 'object', description: 'Action parameters. Varies by action: accountId, opportunityId, carrierDot, taskId, title, notes.' }
      },
      required: ['action']
    },
    roles: ['carrier', 'admin']
  },

  // ── Phase 4: Admin Routers ──
  admin_business_ops: {
    name: 'admin_business_ops',
    description: 'Business operations: revenue dashboard, billing, invoices, commissions, MRR/churn/ARPU metrics, and financial exports.',
    input_schema: {
      type: 'object',
      properties: {
        action: { type: 'string', enum: ['get_revenue_dashboard', 'get_billing_overview', 'get_invoices', 'create_invoice', 'get_commission_report', 'approve_commission', 'get_mrr_metrics', 'get_churn_metrics', 'get_arpu_breakdown', 'export_financial_report'] },
        params: { type: 'object', description: 'Action parameters. Varies by action: period, carrierDot, invoiceData, commissionId, months, days, type.' }
      },
      required: ['action']
    },
    roles: ['admin']
  },
  admin_platform_config: {
    name: 'admin_platform_config',
    description: 'Platform configuration: feature flags, A/B tests, email templates, notification rules, and system settings.',
    input_schema: {
      type: 'object',
      properties: {
        action: { type: 'string', enum: ['get_feature_flags', 'toggle_feature_flag', 'get_ab_tests', 'create_ab_test', 'get_email_templates', 'update_email_template', 'get_notification_rules', 'update_notification_rule', 'get_platform_config', 'update_platform_config'] },
        params: { type: 'object', description: 'Action parameters. Varies: flagId, enabled, testData, templateId, ruleId, settingName, value.' }
      },
      required: ['action']
    },
    roles: ['admin']
  },
  admin_portal: {
    name: 'admin_portal',
    description: 'Admin portal: dashboard overview, user management, content moderation, AI usage metrics, compliance audit, and login activity.',
    input_schema: {
      type: 'object',
      properties: {
        action: { type: 'string', enum: ['get_admin_dashboard', 'get_user_list', 'get_user_detail', 'suspend_user', 'unsuspend_user', 'get_moderation_queue', 'moderate_content', 'get_ai_dashboard', 'get_compliance_audit', 'get_login_activity'] },
        params: { type: 'object', description: 'Action parameters. Varies: targetUserId, reason, contentId, contentType, decision, period, filters.' }
      },
      required: ['action']
    },
    roles: ['admin']
  },
  admin_support: {
    name: 'admin_support',
    description: 'Support operations: tickets, knowledge base, NPS scores, and CSAT reports.',
    input_schema: {
      type: 'object',
      properties: {
        action: { type: 'string', enum: ['get_support_tickets', 'get_ticket_detail', 'update_ticket_status', 'assign_ticket', 'get_knowledge_base', 'create_kb_article', 'get_nps_scores', 'get_csat_report'] },
        params: { type: 'object', description: 'Action parameters. Varies: ticketId, status, agentId, query, articleData, surveyType, days.' }
      },
      required: ['action']
    },
    roles: ['admin']
  },
  admin_gamification: {
    name: 'admin_gamification',
    description: 'Gamification administration: XP rules, achievements, challenges, leaderboards, and engagement analytics.',
    input_schema: {
      type: 'object',
      properties: {
        action: { type: 'string', enum: ['get_gamification_config', 'update_xp_rules', 'get_achievement_list', 'create_achievement', 'create_challenge', 'get_active_challenges', 'get_global_leaderboard', 'get_gamification_analytics'] },
        params: { type: 'object', description: 'Action parameters. Varies: rules, achievementData, challengeData, period, userType.' }
      },
      required: ['action']
    },
    roles: ['admin']
  },
  admin_feature_adoption: {
    name: 'admin_feature_adoption',
    description: 'Feature adoption analytics: adoption rates, funnels, health scores, stickiness metrics, cohorts, and nudge campaigns.',
    input_schema: {
      type: 'object',
      properties: {
        action: { type: 'string', enum: ['get_feature_adoption', 'get_adoption_funnels', 'get_feature_health', 'get_stickiness_metrics', 'get_adoption_cohorts', 'create_adoption_campaign'] },
        params: { type: 'object', description: 'Action parameters. Varies: featureId, days, campaignData.' }
      },
      required: ['action']
    },
    roles: ['admin']
  },

  // ── Phase 5: Cross-Role, Observability, External API, Financial Extended, Lifecycle ──
  cross_role_utility: {
    name: 'cross_role_utility',
    description: 'Cross-role intelligence: mutual interest checks, match explanations, carrier comparisons, market benchmarks, industry trends, regional analysis, seasonal patterns, driver market value',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_mutual_interest', 'get_retention_for_carrier', 'get_match_explanation', 'get_recruiter_health', 'get_platform_benchmarks', 'get_industry_trends', 'get_regional_analysis', 'get_seasonal_patterns', 'compare_carriers', 'get_driver_market_value'],
          description: 'The cross-role operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (driverId, carrierDot, region, period, etc.)' }
      },
      required: ['action']
    },
    roles: ['driver', 'recruiter', 'carrier', 'admin']
  },
  cross_role_paid_media_pipeline: {
    name: 'cross_role_paid_media_pipeline',
    description: 'Cross-role paid media attribution bridge: campaign-to-pipeline funnel joins, CPL-to-hire trends, source quality scoring, and taxonomy sync/backfill operations',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_paid_media_to_pipeline_funnel', 'get_cpl_to_hire_trend', 'get_source_quality_score', 'suggest_channel_mix', 'suggest_geo_expansion', 'sync_campaign_taxonomy_to_pipeline', 'backfill_missing_attribution'],
          description: 'The paid media pipeline attribution operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (carrierDot, campaignId, source, dateRange, sync controls)' }
      },
      required: ['action']
    },
    roles: ['recruiter', 'admin']
  },
  observability_ops: {
    name: 'observability_ops',
    description: 'Agent observability: distributed tracing dashboard, per-tool performance metrics, scoring accuracy, scoring recalibration, agent run replay',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_tracing_dashboard', 'get_tool_performance', 'get_scoring_accuracy', 'recalibrate_scoring', 'get_agent_replay'],
          description: 'The observability operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (runId, period, toolName, etc.)' }
      },
      required: ['action']
    },
    roles: ['admin']
  },
  external_api: {
    name: 'external_api',
    description: 'External API gateway: query safety/CSA data, market intelligence, operations data, matching/scoring, document verification, engagement APIs, API usage/health monitoring, API key management',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['query_safety_api', 'query_intel_api', 'query_ops_api', 'query_matching_api', 'query_document_api', 'query_engagement_api', 'get_api_usage', 'get_api_health', 'configure_api_key', 'test_api_endpoint'],
          description: 'The external API operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (endpoint, filters, apiKeyId, etc.)' }
      },
      required: ['action']
    },
    roles: ['admin', 'recruiter', 'carrier', 'driver']
  },
  financial_extended: {
    name: 'financial_extended',
    description: 'Extended financial tools: expense tracking/reports, settlement details, trip cost calculator, tax summaries, IRS per diem rates, IFTA fuel tax reports, take-home pay estimation',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['track_expenses', 'get_expense_report', 'get_settlement_detail', 'calculate_trip_cost', 'get_tax_summary', 'get_irs_per_diem', 'get_fuel_tax_report', 'estimate_take_home'],
          description: 'The financial operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (driverId, period, tripParams, taxYear, etc.)' }
      },
      required: ['action']
    },
    roles: ['driver', 'carrier']
  },
  lifecycle_ops: {
    name: 'lifecycle_ops',
    description: 'Lifecycle management: driver/carrier timelines, disposition updates, exit surveys, survey responses, algorithm feedback, feedback summaries, lifecycle stage analytics, cohort retention analysis',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_driver_timeline', 'get_carrier_timeline', 'update_disposition', 'get_disposition_options', 'create_exit_survey', 'get_survey_responses', 'submit_algorithm_feedback', 'get_feedback_summary', 'get_lifecycle_analytics', 'get_cohort_retention'],
          description: 'The lifecycle operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters (driverId, carrierId, disposition, surveyType, days, etc.)' }
      },
      required: ['action']
    },
    roles: ['driver', 'recruiter', 'admin']
  },
};

const EXECUTION_MODE = {
  SEQUENTIAL_ONLY: 'sequential_only',
  PARALLEL_SAFE: 'parallel_safe',
  PARALLEL_CHUNKED: 'parallel_chunked',
};

const SIDE_EFFECT_CLASS = {
  READ: 'read',
  SUGGEST: 'suggest',
  WRITE_REVERSIBLE: 'write_reversible',
  WRITE_IRREVERSIBLE: 'write_irreversible',
};

const IDEMPOTENCY = {
  REQUIRED: 'required',
  OPTIONAL: 'optional',
  NOT_APPLICABLE: 'not_applicable',
};

const PARALLEL_SAFE_ROUTERS = new Set([
  'driver_road',
  'driver_utility',
  'recruiter_analytics',
  'observability_ops',
  'cross_role_utility',
]);

const PARALLEL_SAFE_READ_PREFIXES = [
  'get_',
  'find_',
  'search_',
  'check_',
  'calculate_',
  'compare_',
  'query_',
  'list_',
  'suggest_',
  'preview_',
  'explain_',
];

const CHUNKABLE_WRITE_PREFIXES = ['bulk_', 'backfill_'];
const IDEMPOTENCY_REQUIRED_PREFIXES = [
  'create_',
  'send_',
  'process_',
  'initiate_',
  'upload_',
  'configure_',
  'refresh_',
  'approve_',
  'rebind_',
  'quarantine_',
  'disable_',
];

function _startsWithAny(value, prefixes) {
  return prefixes.some(prefix => value.startsWith(prefix));
}

function _inferSideEffectClass(riskLevel) {
  if (riskLevel === 'read') return SIDE_EFFECT_CLASS.READ;
  if (riskLevel === 'suggest') return SIDE_EFFECT_CLASS.SUGGEST;
  if (riskLevel === 'execute_high') return SIDE_EFFECT_CLASS.WRITE_IRREVERSIBLE;
  return SIDE_EFFECT_CLASS.WRITE_REVERSIBLE;
}

function _inferExecutionMode(context, sideEffectClass, requiresApproval) {
  const actionKey = context.actionName || context.toolName || '';
  if (requiresApproval) return EXECUTION_MODE.SEQUENTIAL_ONLY;
  if (_startsWithAny(actionKey, CHUNKABLE_WRITE_PREFIXES)) return EXECUTION_MODE.PARALLEL_CHUNKED;
  if (sideEffectClass === SIDE_EFFECT_CLASS.READ || sideEffectClass === SIDE_EFFECT_CLASS.SUGGEST) {
    if (context.routerName && PARALLEL_SAFE_ROUTERS.has(context.routerName)) {
      return EXECUTION_MODE.PARALLEL_SAFE;
    }
    if (_startsWithAny(actionKey, PARALLEL_SAFE_READ_PREFIXES)) {
      return EXECUTION_MODE.PARALLEL_SAFE;
    }
  }
  return EXECUTION_MODE.SEQUENTIAL_ONLY;
}

function _inferIdempotency(context, sideEffectClass) {
  const actionKey = context.actionName || context.toolName || '';
  if (sideEffectClass === SIDE_EFFECT_CLASS.READ || sideEffectClass === SIDE_EFFECT_CLASS.SUGGEST) {
    return IDEMPOTENCY.NOT_APPLICABLE;
  }
  if (_startsWithAny(actionKey, IDEMPOTENCY_REQUIRED_PREFIXES)) {
    return IDEMPOTENCY.REQUIRED;
  }
  if (sideEffectClass === SIDE_EFFECT_CLASS.WRITE_IRREVERSIBLE) {
    return IDEMPOTENCY.REQUIRED;
  }
  return IDEMPOTENCY.OPTIONAL;
}

function _inferTimeoutMs(context, sideEffectClass) {
  if (context.policy?.timeout_ms) return context.policy.timeout_ms;
  if (context.routerName === 'external_api') return 10000;
  if (context.routerName === 'observability_ops') return 6000;
  if (sideEffectClass === SIDE_EFFECT_CLASS.READ) return 5000;
  if (sideEffectClass === SIDE_EFFECT_CLASS.SUGGEST) return 7000;
  if (sideEffectClass === SIDE_EFFECT_CLASS.WRITE_IRREVERSIBLE) return 12000;
  return 8000;
}

function _inferMaxConcurrency(context, executionMode) {
  if (context.policy?.max_concurrency) return context.policy.max_concurrency;
  if (executionMode === EXECUTION_MODE.PARALLEL_SAFE) return 3;
  if (executionMode === EXECUTION_MODE.PARALLEL_CHUNKED) return 5;
  return 1;
}

function _normalizeExecutionPolicy(policy = {}, context = {}) {
  const normalizedPolicy = { ...policy };
  const sideEffectClass = normalizedPolicy.side_effect_class ||
    _inferSideEffectClass(normalizedPolicy.risk_level || 'read');
  const executionMode = normalizedPolicy.execution_mode ||
    _inferExecutionMode({ ...context, policy: normalizedPolicy }, sideEffectClass, !!normalizedPolicy.requires_approval);

  normalizedPolicy.side_effect_class = sideEffectClass;
  normalizedPolicy.execution_mode = executionMode;
  normalizedPolicy.idempotency = normalizedPolicy.idempotency ||
    _inferIdempotency(context, sideEffectClass);
  normalizedPolicy.timeout_ms = _inferTimeoutMs({ ...context, policy: normalizedPolicy }, sideEffectClass);
  normalizedPolicy.join_key = normalizedPolicy.join_key || '';
  normalizedPolicy.max_concurrency = _inferMaxConcurrency({ ...context, policy: normalizedPolicy }, executionMode);

  return normalizedPolicy;
}

function _applyExecutionMetadata() {
  for (const [toolName, toolDef] of Object.entries(TOOL_DEFINITIONS)) {
    toolDef.policy = _normalizeExecutionPolicy(toolDef.policy, {
      kind: 'flat',
      toolName,
    });
  }

  for (const [routerName, actions] of Object.entries(ACTION_REGISTRY)) {
    for (const [actionName, actionDef] of Object.entries(actions)) {
      actionDef.policy = _normalizeExecutionPolicy(actionDef.policy, {
        kind: 'router',
        routerName,
        actionName,
      });
    }
  }
}

_applyExecutionMetadata();

function _buildLedgerMetadata(policy, context = {}) {
  return {
    execution_mode: policy?.execution_mode || '',
    side_effect_class: policy?.side_effect_class || '',
    node_id: context.node_id || '',
    branch_id: context.branch_id || '',
    join_key: policy?.join_key || '',
    timeout_ms: policy?.timeout_ms || 0,
  };
}

// Export for tests
export { ACTION_REGISTRY, ROUTER_DEFINITIONS };

export function getToolExecutionMetadata(toolName, toolInput = null) {
  if (toolInput?.action && ACTION_REGISTRY[toolName]) {
    const actionDef = ACTION_REGISTRY[toolName][toolInput.action];
    if (!actionDef) return null;
    return {
      kind: 'router',
      toolName,
      routerName: toolName,
      actionName: toolInput.action,
      actionKey: `${toolName}.${toolInput.action}`,
      policy: actionDef.policy,
      serviceModule: actionDef.serviceModule,
      serviceFunction: actionDef.serviceFunction,
    };
  }

  const toolDef = TOOL_DEFINITIONS[toolName];
  if (!toolDef) return null;
  return {
    kind: 'flat',
    toolName,
    actionName: null,
    actionKey: toolName,
    policy: toolDef.policy,
    serviceModule: toolDef.serviceModule,
    serviceFunction: toolDef.serviceFunction,
  };
}

/**
 * Get policy metadata for a tool
 */
export function getToolPolicy(toolName, toolInput = null) {
  const metadata = getToolExecutionMetadata(toolName, toolInput);
  return metadata ? metadata.policy : null;
}

/**
 * Validate tool execution against rate limits
 * Uses in-memory tracking (resets on server restart)
 */
const _rateLimitMap = new Map(); // key: `${userId}:${toolName}`, value: { count, resetAt }

export function validateToolExecution(toolName, userId) {
  const policy = getToolPolicy(toolName);
  if (!policy) return { allowed: false, reason: 'Unknown tool' };

  const key = `${userId}:${toolName}`;
  const now = Date.now();
  const entry = _rateLimitMap.get(key);

  if (!entry || now > entry.resetAt) {
    _rateLimitMap.set(key, { count: 1, resetAt: now + 60000 });
    return { allowed: true };
  }

  if (entry.count >= policy.rate_limit) {
    return { allowed: false, reason: `Rate limit exceeded: ${policy.rate_limit}/min for ${toolName}` };
  }

  entry.count++;
  return { allowed: true };
}

// Role system prompts
const ROLE_SYSTEM_PROMPTS = {
  driver: 'You are LMDR, an AI copilot for CDL truck drivers. You have 10 domain tools:\n- driver_cockpit: Search jobs, apply, manage applications, messaging, profile, matches, dashboard, notifications, document upload\n- driver_road: Find parking, fuel prices, weigh stations, rest stops, weather, road conditions, report hazards\n- driver_community: Forums, mentorship, pet-friendly locations, health resources\n- driver_compliance: Document wallet, HOS tracking, ELD data, training courses, certifications\n- driver_financial: Expenses, settlements, trip costs, tax summaries, deductions, per diem\n- driver_lifecycle: Timeline, disposition, surveys, feedback\n- driver_utility: Profile strength scoring, quick responses, reverse alerts, market insights\n- cross_role_utility: Mutual interest checks, match explanations, carrier comparisons, market value estimation, industry trends, regional analysis, seasonal patterns\n- financial_extended: Extended expense tracking, settlement details, trip cost calculator, IRS per diem rates, IFTA fuel tax reports, take-home pay estimation\n- lifecycle_ops: Driver/carrier timelines, disposition updates, exit surveys, algorithm feedback\nEach tool takes an \'action\' parameter to select the operation and \'params\' for action-specific data. Use these tools to provide real data rather than generic answers. Be friendly, practical, and driver-focused. You can also check compensation benchmarks and query external APIs for safety data.',
  recruiter: 'You are VelocityMatch\'s AI recruiting assistant. You have 12 domain routers plus legacy flat tools:\n- recruiter_paid_media: Meta paid media campaign/ad set/ad/creative draft, launch, updates, pause/resume, and lifecycle controls\n- recruiter_paid_media_analytics: Paid media insights, breakdowns, async reports, placement/creative performance, fatigue alerts, and optimization suggestions\n- recruiter_outreach: Multi-channel campaigns (SMS, email, voice, social, job board syndication), message templates, campaign status/pause/resume, reach preview\n- recruiter_analytics: Attribution reports, cost per hire, funnel analysis, competitor intel, ML hiring forecasts, time to fill, source ROI, drop-off analysis, recruiter scorecards, data export\n- recruiter_onboarding: Onboarding workflows, document collection, background checks, drug tests, e-signatures, orientation scheduling\n- recruiter_pipeline: Saved searches, pipeline automations, intervention templates, bulk updates, stale candidate detection, call outcome summaries\n- recruiter_retention: Retention risk scoring, watchlist management, retention interventions, turnover analytics\n- recruiter_reverse_match: Reverse driver search by criteria, match subscriptions, subscription alerts, Stripe billing, plan upgrades\n- cross_role_utility: Mutual interest checks, retention insights per carrier, recruiter health status, industry trends, regional analysis, platform benchmarks\n- cross_role_paid_media_pipeline: Paid-media-to-pipeline funnel joins, CPL-to-hire trend, source quality scoring, channel/geo suggestions, taxonomy sync/backfill\n- external_api: Query matching/scoring APIs, document verification, engagement APIs, API usage monitoring\n- lifecycle_ops: Driver/carrier timelines, disposition management, exit surveys, lifecycle stage analytics, cohort retention\nEach router takes an \'action\' parameter to select the operation and \'params\' for action-specific data. You also have legacy flat tools for driver search, pipeline management, messaging, interview scheduling, call logging, and basic analytics. You can start autopilot campaigns, initiate voice screening calls, monitor pipeline health, and fire pipeline events. Be efficient and data-driven.',
  admin: 'You are VelocityMatch\'s AI platform admin assistant. You have 12 domain routers plus legacy flat tools:\n- admin_business_ops (10 actions): Revenue dashboard, billing overview, invoices (view/create), commission reports/approvals, MRR metrics, churn metrics, ARPU breakdown, financial report export\n- admin_platform_config (10 actions): Feature flags (view/toggle), A/B tests (view/create), email templates (view/update), notification rules (view/update), platform config (view/update)\n- admin_portal (10 actions): Admin dashboard overview, user list/detail, suspend/unsuspend users, moderation queue, moderate content, AI usage dashboard, compliance audit, login activity\n- admin_support (8 actions): Support tickets (list/detail/status/assign), knowledge base (browse/create articles), NPS scores, CSAT reports\n- admin_gamification (8 actions): Gamification config, XP rules, achievements (list/create), challenges (create/active), global leaderboard, gamification analytics\n- admin_feature_adoption (6 actions): Feature adoption rates, adoption funnels, feature health scores, stickiness metrics, adoption cohorts, nudge campaigns\n- admin_meta_ads_governance (13 actions): Meta integration inventory, token health, error digest, rate-limit posture, audit events, token refresh, guardrails, budget caps, approval thresholds, quarantine, credential rotation, ad-account rebinding, integration disable\n- observability_ops (5 actions): Distributed tracing dashboard, per-tool performance metrics, scoring accuracy analysis, scoring recalibration, agent run replay\n- external_api (10 actions): Query safety/CSA/intel/ops/matching/document/engagement APIs, API usage and health monitoring, API key management, endpoint testing\n- lifecycle_ops (10 actions): Driver/carrier timelines, lifecycle stage analytics, cohort retention analysis, feedback summaries, exit surveys\n- cross_role_utility (10 actions): Platform benchmarks, industry trends, regional analysis, carrier comparisons, mutual interest, market value\n- cross_role_paid_media_pipeline (7 actions): Paid-media-to-pipeline funnel, CPL-to-hire trend, source quality scoring, channel/geo suggestions, taxonomy sync/backfill\nEach router takes an \'action\' parameter to select the operation and \'params\' for action-specific data. You also have legacy flat tools for system health, driver stats, prompt management, agent KPIs, B2B CRM, market intel, lane demand, compensation benchmarks, hiring benchmarks, and conversion insights. Be thorough and data-driven.',
  carrier: 'You are VelocityMatch\'s AI assistant for carrier accounts. You have 8 domain routers plus legacy flat tools:\n- carrier_fleet (12 actions): Fleet management — driver roster, scorecards, equipment list/status, capacity planning, ELD fleet summary, utilization, costs, driver-to-unit assignment, equipment status updates, alerts, driver availability\n- carrier_compliance (10 actions): Compliance — calendar, document vault, document upload, DQ file tracking/gaps, CSA scores/alerts, incident logging/history, DOT audit readiness\n- carrier_communication (8 actions): Communication — create/view announcements, policy updates, driver recognitions, feedback requests/responses\n- carrier_journey (8 actions): Journey — onboarding flow, carrier identity, navigation, deposit initiation, payment history, subscription status, plan upgrades, checkout sessions\n- b2b_suite (18 actions): B2B CRM — match intelligence, pipeline, opportunity stage updates, outreach, events, research agent, analytics, account CRUD, tasks, contacts, notes, account scoring\n- cross_role_utility (10 actions): Retention insights per carrier, platform benchmarks, industry trends, regional analysis, seasonal patterns, carrier comparisons\n- external_api (10 actions): Query safety/CSA data, market intelligence APIs, API usage monitoring\n- financial_extended (8 actions): IFTA fuel tax reports, trip cost calculations, take-home pay estimation\nEach router takes an \'action\' parameter to select the operation and \'params\' for action-specific data. Most carrier routers require carrierDot in params. You also have legacy flat tools for account details, match signals, opportunities, hiring benchmarks, and conversion insights. Be efficient and data-driven.'
};

// Build tool list for a role — merges router definitions + legacy flat tools
function buildToolList(role) {
  const tools = [];

  // Add router definitions for the role
  for (const [key, router] of Object.entries(ROUTER_DEFINITIONS)) {
    if (router.roles.includes(role)) {
      tools.push({ name: router.name, description: router.description, input_schema: router.input_schema });
    }
  }

  // Keep existing flat tools that haven't been migrated to routers
  for (const [key, tool] of Object.entries(TOOL_DEFINITIONS)) {
    if (tool.roles && tool.roles.includes(role) && !ROUTER_DEFINITIONS[key]) {
      tools.push({ name: tool.name, description: tool.description, input_schema: tool.input_schema });
    }
  }

  return tools;
}

// Backward-compatible alias
function getToolsForRole(role) {
  return buildToolList(role);
}

/**
 * Reorder tools array in-place so intent-suggested tools appear first.
 * This influences the AI's tool selection when multiple tools are relevant.
 */
function _reorderToolsByPriority(tools, priorityHints) {
  if (!priorityHints || priorityHints.length === 0) return;
  const hintSet = new Set(priorityHints);
  const prioritized = [];
  const rest = [];
  for (const tool of tools) {
    if (hintSet.has(tool.name)) {
      prioritized.push(tool);
    } else {
      rest.push(tool);
    }
  }
  // Sort prioritized by hint order
  prioritized.sort((a, b) => priorityHints.indexOf(a.name) - priorityHints.indexOf(b.name));
  tools.length = 0;
  tools.push(...prioritized, ...rest);
}

// Execute a tool call against the real backend service
// Exported for VAPI webhook template-scoped tool access
export async function executeTool(toolName, toolInput, runContext = {}) {
  // ── Router dispatch (Phase 1+) ──
  if (toolInput.action && ACTION_REGISTRY[toolName]) {
    const actionDef = ACTION_REGISTRY[toolName][toolInput.action];
    if (!actionDef) {
      return { error: `Unknown action '${toolInput.action}' in router '${toolName}'` };
    }

    const actionMeta = getToolExecutionMetadata(toolName, toolInput);
    const actionPolicy = actionMeta?.policy || actionDef.policy;

    const { runId, userId } = runContext;

    // Rate limit check for router actions
    if (userId) {
      const actionKey = `${toolName}.${toolInput.action}`;
      const key = `${userId}:${actionKey}`;
      const now = Date.now();
      const entry = _rateLimitMap.get(key);
      if (entry && now <= entry.resetAt && entry.count >= actionPolicy.rate_limit) {
        return { error: `Rate limit exceeded: ${actionPolicy.rate_limit}/min for ${actionKey}`, type: 'rate_limited' };
      }
      if (!entry || now > entry.resetAt) {
        _rateLimitMap.set(key, { count: 1, resetAt: now + 60000 });
      } else {
        entry.count++;
      }
    }

    // Approval gate check for router actions
    if (actionPolicy.requires_approval && !runContext.approvedGateId) {
      const actionKey = `${toolName}.${toolInput.action}`;
      const ledgerMetadata = _buildLedgerMetadata(actionPolicy);
      const stepId = runId ? (await logStep(runId, actionKey, actionPolicy.risk_level, toolInput.params || {}, null, 0, 'pending_approval', ledgerMetadata)).stepId : '';
      const gate = runId ? await createGate(runId, stepId, actionKey, `Action "${actionKey}" requires approval (risk: ${actionPolicy.risk_level})`, actionPolicy.risk_level, ledgerMetadata) : { gateId: '' };
      return {
        type: 'approval_required',
        gateId: gate.gateId,
        stepId,
        toolName: actionKey,
        toolDescription: `${toolName} → ${toolInput.action}`,
        args: toolInput.params || {},
        riskLevel: actionPolicy.risk_level,
        auditFields: Object.keys(toolInput.params || {})
      };
    }

    const startTime = Date.now();
    try {
      const serviceModule = await import(actionDef.serviceModule);
      const fn = serviceModule[actionDef.serviceFunction];
      if (!fn) {
        return { error: `Function ${actionDef.serviceFunction} not found in ${actionDef.serviceModule}` };
      }

      // Map args — inject userId for identity keys, pass params for aggregate keys
      const mappedArgs = actionDef.argMapping.map(key => {
        if (key === 'driverId' || key === 'userId' || key === 'recruiterId') return runContext.userId;
        if (key === 'filters' || key === 'pagination' || key === 'payload' || key === 'report' ||
            key === 'rating' || key === 'data' || key === 'expense' || key === 'entry' ||
            key === 'dispute' || key === 'tripParams' || key === 'dateRange' || key === 'feedback' ||
            key === 'truckConfig' || key === 'location' || key === 'alertConfig' ||
            key === 'params' || key === 'config' || key === 'ruleData') {
          return toolInput.params || {};
        }
        return toolInput.params?.[key];
      });

      const result = await fn(...mappedArgs);
      const latencyMs = Date.now() - startTime;

      // Log to run ledger (best-effort)
      if (runId) {
        logStep(runId, `${toolName}.${toolInput.action}`, actionPolicy.risk_level, toolInput.params || {}, result, latencyMs, 'executed', _buildLedgerMetadata(actionPolicy))
          .catch(err => console.error('Step logging failed:', err));
      }

      return result;
    } catch (error) {
      const latencyMs = Date.now() - startTime;
      if (runId) {
        logStep(runId, `${toolName}.${toolInput.action}`, actionPolicy.risk_level, toolInput.params || {}, { error: error.message }, latencyMs, 'error', _buildLedgerMetadata(actionPolicy))
          .catch(err => console.error('Step logging failed:', err));
      }
      console.error(`Router action error [${toolName}.${toolInput.action}]:`, error);
      return { error: error.message };
    }
  }

  // ── Flat tool dispatch (legacy Phase 0 tools) ──
  const toolDef = TOOL_DEFINITIONS[toolName];
  if (!toolDef) {
    return { error: `Unknown tool: ${toolName}` };
  }
  const toolMeta = getToolExecutionMetadata(toolName, toolInput);
  const toolPolicy = toolMeta?.policy || toolDef.policy || {};

  const { runId, userId } = runContext;

  // Rate limit check
  if (userId) {
    const rateCheck = validateToolExecution(toolName, userId);
    if (!rateCheck.allowed) {
      return { error: rateCheck.reason, type: 'rate_limited' };
    }
  }

  // Approval gate check
  if (toolPolicy.requires_approval && !runContext.approvedGateId) {
    const ledgerMetadata = _buildLedgerMetadata(toolPolicy);
    const stepId = runId ? (await logStep(runId, toolName, toolPolicy.risk_level, toolInput, null, 0, 'pending_approval', ledgerMetadata)).stepId : '';
    const gate = runId ? await createGate(runId, stepId, toolName, `Tool "${toolName}" requires approval (risk: ${toolPolicy.risk_level})`, toolPolicy.risk_level, ledgerMetadata) : { gateId: '' };
    return {
      type: 'approval_required',
      gateId: gate.gateId,
      stepId,
      toolName,
      toolDescription: toolDef.description,
      args: toolInput,
      riskLevel: toolPolicy.risk_level,
      auditFields: toolPolicy.audit_fields
    };
  }

  const startTime = Date.now();
  try {
    const serviceModule = await import(toolDef.serviceModule);

    let result;
    if (toolName === 'manage_prompts') {
      const { operation, promptId, data } = toolInput;
      switch (operation) {
        case 'list': result = await serviceModule.getPrompts(data || {}); break;
        case 'get': result = await serviceModule.getActivePrompt(promptId); break;
        case 'create': result = await serviceModule.createPrompt(data); break;
        case 'update': result = await serviceModule.updatePrompt(promptId, data); break;
        default: result = { error: `Unknown prompt operation: ${operation}` };
      }
    } else if (toolName === 'start_autopilot') {
      // start_autopilot expects (recruiterId, config) — reshape from flat tool input
      const { carrier_dot, objective, max_contacts, cadence } = toolInput;
      result = await serviceModule.createAutopilotCampaign(runContext.userId || '', {
        carrier_dot, objective, max_contacts: max_contacts || 20, cadence: cadence || 'standard'
      });
    } else if (toolName === 'log_call') {
      // logCallOutcome(carrierDot, outcomeData) — bundle remaining fields
      const { carrierDot, ...outcomeData } = toolInput;
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn(carrierDot, outcomeData);
    } else if (toolName === 'road_conditions') {
      // getRouteConditions(routePoints, options) — lat/lon into routePoints array
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      const routePoints = [{ lat: toolInput.lat, lon: toolInput.lon }];
      result = await fn(routePoints, { zip: toolInput.zip });
    } else if (toolName === 'search_drivers') {
      // findMatchingDrivers(carrierDot, filters, options) — tool params are filters
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn('', toolInput);
    } else if (toolName === 'initiate_voice_screen') {
      // createAssistantFromTemplate(templateId, contextOverrides) — extract template_id
      const { template_id, ...contextOverrides } = toolInput;
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn(template_id, contextOverrides);
    } else if (toolName === 'emit_pipeline_event') {
      // emitEvent(eventType, payload) — extract event_type, rest is payload
      const { event_type, ...payload } = toolInput;
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn(event_type, payload);
    } else {
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) {
        return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      }
      // Use explicit arg mapping if defined, else pass full input object
      if (toolDef.argMapping) {
        const mappedArgs = toolDef.argMapping.map(key => toolInput[key]);
        result = await fn(...mappedArgs);
      } else {
        result = await fn(toolInput);
      }
    }

    const latencyMs = Date.now() - startTime;
    if (runId) {
      logStep(runId, toolName, toolPolicy.risk_level || 'unknown', toolInput, result, latencyMs, 'executed', _buildLedgerMetadata(toolPolicy))
        .catch(err => console.error('Step logging failed:', err));
    }

    return result;
  } catch (error) {
    const latencyMs = Date.now() - startTime;
    if (runId) {
      logStep(runId, toolName, toolPolicy.risk_level || 'unknown', toolInput, { error: error.message }, latencyMs, 'error', _buildLedgerMetadata(toolPolicy))
        .catch(err => console.error('Step logging failed:', err));
    }
    console.error(`Tool execution error [${toolName}]:`, error);
    return { error: error.message };
  }
}

/**
 * Main entry point - handles one agent turn
 * Loops tool_use responses until a text response is returned
 */
export async function handleAgentTurn(role, userId, message, context = {}) {
  if (!ROLE_SYSTEM_PROMPTS[role]) {
    throw new Error(`Unknown role: ${role}`);
  }

  // Get or create conversation
  let conversationId = context.conversationId;
  if (!conversationId) {
    const conv = await createConversation(role, userId);
    conversationId = conv.conversationId;
  }

  // Start run ledger
  let runId = null;
  try {
    const run = await startRun(conversationId, role, userId, message.substring(0, 200), {
      execution_model: 'sequential',
    });
    runId = run.runId;
  } catch (err) {
    console.error('Run ledger start failed (non-blocking):', err);
  }

  // Daily run limit check
  const dateKey = `${userId}:${new Date().toISOString().split('T')[0]}`;
  const dailyCount = (_dailyRunCounts.get(dateKey) || 0) + 1;
  _dailyRunCounts.set(dateKey, dailyCount);
  if (dailyCount > COST_CONTROLS.maxDailyRunsPerUser) {
    if (runId) completeRun(runId, 'rate_limited', 0, 0).catch(() => {});
    return {
      conversationId,
      runId,
      response: 'You\'ve reached your daily limit for AI assistant requests. Please try again tomorrow.',
      toolsUsed: false,
      role
    };
  }

  // Get recent context + run intent classification in parallel
  const recentContextPromise = getRecentContext(conversationId, 20);
  const recentSummaries = [];

  // Intent classification pre-flight (non-blocking on failure)
  let intentResult;
  let ragConfig = null;
  try {
    const [recentTurnsRaw, intentRes] = await Promise.all([
      recentContextPromise,
      classifyUserIntent(message, role, recentSummaries),
    ]);
    var recentTurns = recentTurnsRaw;
    intentResult = intentRes;

    // Build summaries from recent turns for intent context
    if (recentTurns && recentTurns.length > 0) {
      const lastFew = recentTurns.slice(-3);
      for (const t of lastFew) {
        recentSummaries.push(`${t.role}: ${(t.content || '').substring(0, 100)}`);
      }
    }

    // Build RAG config from intent result
    ragConfig = buildRagConfig(intentResult, role, context, userId);
  } catch (intentErr) {
    console.warn('[agentService] Intent pre-flight failed (non-blocking):', intentErr.message);
    var recentTurns = await recentContextPromise.catch(() => []);
    intentResult = null;
    ragConfig = null;
  }

  // Build messages array
  const messages = [];
  for (const turn of recentTurns) {
    messages.push({ role: turn.role, content: turn.content });
  }
  messages.push({ role: 'user', content: message });

  // Save user turn
  await addTurn(conversationId, 'user', message);

  // Get role-scoped tools (optionally reordered by intent tool priority hints)
  const tools = getToolsForRole(role);
  if (intentResult?.toolPriorityHints?.length > 0) {
    _reorderToolsByPriority(tools, intentResult.toolPriorityHints);
  }

  // Phase 2 planner scaffold — records a structured plan summary but does not
  // change the current sequential execution path unless a later executor uses it.
  let executionPlan = null;
  if (FEATURE_FLAGS.dagPlanningEnabled) {
    try {
      executionPlan = await buildExecutionPlan(role, message, {
        tools,
        intentResult,
        conversationId,
        userId,
      });
      if (runId && executionPlan?.summary) {
        updateRunPlanningMetadata(runId, {
          plan_id: executionPlan.plan_id,
          execution_model: executionPlan.execution_model,
          planned_nodes: executionPlan.summary.planned_nodes,
          parallel_nodes: executionPlan.summary.parallel_nodes,
        }).catch(err => console.error('Run planning metadata update failed:', err));
      }
    } catch (planErr) {
      console.warn('[agentService] Plan build failed (non-blocking):', planErr.message);
      executionPlan = null;
    }
  }

  let prefetchedPlanContext = '';
  if (FEATURE_FLAGS.parallelReadBranchesEnabled && executionPlan && isPlanExecutorEligible(executionPlan)) {
    try {
      const prefetchResult = await executePlannedReadNodes(
        executionPlan,
        { runId, userId, maxConcurrency: 3 },
        async (node, executionContext) => executeTool(
          node.tool,
          { action: node.action, params: node.params || {} },
          executionContext
        )
      );
      if (prefetchResult.summary_text) {
        prefetchedPlanContext = `Pre-fetched workflow context:\n${prefetchResult.summary_text}`;
      }
    } catch (prefetchErr) {
      console.warn('[agentService] Planned read prefetch failed (non-blocking):', prefetchErr.message);
    }
  }

  // Agent loop - keep calling AI until we get a text response (not tool_use)
  let currentMessages = [...messages];
  if (prefetchedPlanContext) {
    currentMessages.push({ role: 'assistant', content: prefetchedPlanContext });
  }
  const maxIterations = 5;
  let totalTokens = 0;
  const runStartTime = Date.now();

  for (let i = 0; i < maxIterations; i++) {
    // Token cap check
    const roleTokenCap = COST_CONTROLS.maxTokensPerRun[role] || 10000;
    if (totalTokens >= roleTokenCap) {
      const capText = 'I\'ve reached the processing limit for this request. Here\'s what I have so far.';
      await addTurn(conversationId, 'assistant', capText);
      if (runId) {
        completeRun(runId, 'token_cap', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }
      return { conversationId, runId, planId: executionPlan?.plan_id || null, response: capText, toolsUsed: true, role };
    }

    // Time cap check
    if (Date.now() - runStartTime > COST_CONTROLS.maxRunTimeMs) {
      const timeText = 'This request is taking longer than expected. Here\'s what I have so far.';
      await addTurn(conversationId, 'assistant', timeText);
      if (runId) {
        completeRun(runId, 'time_cap', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }
      return { conversationId, runId, planId: executionPlan?.plan_id || null, response: timeText, toolsUsed: true, role };
    }
    // Route AI step: external runtime (Phase 1) or legacy routeAIRequest
    let aiResponse;
    if (isRuntimeAvailable()) {
      try {
        aiResponse = await callRuntimeStep({
          systemPrompt: ROLE_SYSTEM_PROMPTS[role],
          messages: currentMessages,
          tools,
          maxTokens: 2048,
          traceId: runId || undefined,
          ragConfig: ragConfig || undefined,
        });
      } catch (runtimeErr) {
        console.warn('[agentService] Runtime step failed, falling back to legacy:', runtimeErr.message);
        aiResponse = await routeAIRequest('agent_orchestration', {
          system: ROLE_SYSTEM_PROMPTS[role],
          messages: currentMessages,
          tools,
          maxTokens: 2048,
        });
      }
    } else {
      aiResponse = await routeAIRequest('agent_orchestration', {
        system: ROLE_SYSTEM_PROMPTS[role],
        messages: currentMessages,
        tools,
        maxTokens: 2048,
      });
    }

    totalTokens += aiResponse.tokensUsed || 0;

    // Check if response contains tool_use blocks
    const toolUseBlocks = (aiResponse.contentBlocks || []).filter(b => b.type === 'tool_use');
    const textBlocks = (aiResponse.contentBlocks || []).filter(b => b.type === 'text');

    if (aiResponse.stopReason === 'tool_use' && toolUseBlocks.length > 0) {
      // Add assistant message with tool_use blocks
      currentMessages.push({ role: 'assistant', content: aiResponse.contentBlocks });

      // Execute each tool call
      const toolResults = [];
      for (const toolBlock of toolUseBlocks) {
        const result = await executeTool(toolBlock.name, toolBlock.input, { runId, userId });

        // Check if approval is required
        if (result && result.type === 'approval_required') {
          // Save what we have so far
          await addTurn(conversationId, 'assistant', JSON.stringify(toolUseBlocks), toolUseBlocks);

          // Complete run as paused
          if (runId) {
            completeRun(runId, 'awaiting_approval', totalTokens, 0)
              .catch(err => console.error('Run completion failed:', err));
          }

          return {
            type: 'approval_required',
            conversationId,
            runId,
            planId: executionPlan?.plan_id || null,
            gateId: result.gateId,
            stepId: result.stepId,
            toolName: result.toolName,
            toolDescription: result.toolDescription,
            args: result.args,
            riskLevel: result.riskLevel,
            auditFields: result.auditFields,
            pendingToolBlock: toolBlock,
            pendingMessages: currentMessages,
            role
          };
        }

        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolBlock.id,
          content: JSON.stringify(result)
        });
      }

      // Add tool results as user message
      currentMessages.push({ role: 'user', content: toolResults });

      // Save tool execution turn
      await addTurn(conversationId, 'assistant', JSON.stringify(toolUseBlocks), toolUseBlocks);
    } else {
      // Text response - we're done
      const responseText = aiResponse.content || textBlocks.map(b => b.text).join('\n');
      await addTurn(conversationId, 'assistant', responseText);

      // Complete run and evaluate outcome
      if (runId) {
        completeRun(runId, 'completed', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }

      // Fire-and-forget: ingest turn into conversation memory for RAG
      ingestTurnMemory(userId, role, conversationId, message, responseText)
        .catch(err => console.warn('[agentService] Turn memory ingestion failed (non-blocking):', err.message));

    return {
      conversationId,
      runId,
      planId: executionPlan?.plan_id || null,
      response: responseText,
      toolsUsed: currentMessages.length > messages.length + 1,
      intentClass: intentResult?.intentClass || null,
        ragUsed: !!ragConfig,
        role
      };
    }
  }

  // Safety: if we hit max iterations, return what we have
  const finalText = 'I\'ve been working on your request but need to summarize. Let me know if you need more details.';
  await addTurn(conversationId, 'assistant', finalText);
  if (runId) {
    completeRun(runId, 'max_iterations', totalTokens, 0)
      .then(() => _evaluateCompletedRun(runId))
      .catch(err => console.error('Run completion failed:', err));
  }
  return { conversationId, runId, planId: executionPlan?.plan_id || null, response: finalText, toolsUsed: true, role };
}

/**
 * Get available tools for a role (for UI display)
 */
export async function getAvailableTools(role) {
  return getToolsForRole(role);
}

/**
 * Get cost control configuration (for tests and admin display)
 */
export function getCostControls() {
  return { ...COST_CONTROLS };
}

/**
 * Resume agent loop after an approval gate decision
 */
export async function resumeAfterApproval(approvalContext, decision, decidedBy) {
  const { conversationId, runId, gateId, pendingToolBlock, pendingMessages, role } = approvalContext;

  // Resolve the gate
  const { resolveGate } = await import('backend/agentRunLedgerService');
  await resolveGate(gateId, decision, decidedBy);

  if (decision === 'rejected') {
    const toolResults = [{
      type: 'tool_result',
      tool_use_id: pendingToolBlock.id,
      content: JSON.stringify({ error: 'User rejected this action', decision: 'rejected' })
    }];
    const currentMessages = [...pendingMessages, { role: 'user', content: toolResults }];

    const aiResponse = await routeAIRequest('agent_orchestration', {
      system: ROLE_SYSTEM_PROMPTS[role],
      messages: currentMessages,
      tools: getToolsForRole(role),
      maxTokens: 2048
    });

    const responseText = aiResponse.content || (aiResponse.contentBlocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n') || 'Understood, I won\'t proceed with that action.';
    await addTurn(conversationId, 'assistant', responseText);

    if (runId) {
      const { completeRun: cr } = await import('backend/agentRunLedgerService');
      cr(runId, 'completed_with_rejection', aiResponse.tokensUsed || 0, 0).catch(() => {});
    }

    return { conversationId, runId, response: responseText, role };
  }

  // Approved — execute the tool and continue the loop
  const result = await executeTool(pendingToolBlock.name, pendingToolBlock.input, { runId, userId: decidedBy, approvedGateId: gateId });

  const toolResults = [{
    type: 'tool_result',
    tool_use_id: pendingToolBlock.id,
    content: JSON.stringify(result)
  }];
  const currentMessages = [...pendingMessages, { role: 'user', content: toolResults }];

  const aiResponse = await routeAIRequest('agent_orchestration', {
    system: ROLE_SYSTEM_PROMPTS[role],
    messages: currentMessages,
    tools: getToolsForRole(role),
    maxTokens: 2048
  });

  const responseText = aiResponse.content || (aiResponse.contentBlocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n') || 'Action completed.';
  await addTurn(conversationId, 'assistant', responseText);

  if (runId) {
    const { completeRun: cr } = await import('backend/agentRunLedgerService');
    cr(runId, 'completed', aiResponse.tokensUsed || 0, 0).catch(() => {});
  }

  return { conversationId, runId, response: responseText, role };
}

// ── Outcome Evaluation Hook ──
// Import is dynamic to avoid circular dependency issues
// Called after completeRun() in handleAgentTurn completion paths
export async function _evaluateCompletedRun(runId) {
  try {
    const { evaluateRun } = await import('backend/agentOutcomeService');
    return await evaluateRun(runId);
  } catch (err) {
    console.error('Outcome evaluation failed (non-blocking):', err);
    return null;
  }
}



// ============================================================================
// AGENT SERVICE - Central AI Orchestration Layer
// Takes user messages, builds role-scoped tools, calls AI with tool definitions,
// executes tool_use responses against real backend services, loops until text response
// ============================================================================

import { routeAIRequest } from 'backend/aiRouterService';
import { createConversation, addTurn, getRecentContext } from 'backend/agentConversationService';
import * as dataAccess from 'backend/dataAccess';
import { startRun, logStep, createGate, completeRun } from 'backend/agentRunLedgerService';

// ── Cost Control Configuration ──
const COST_CONTROLS = {
  maxTokensPerRun: {
    driver: 10000,
    recruiter: 15000,
    admin: 20000,
    carrier: 10000
  },
  maxRunTimeMs: 30000,
  maxDailyRunsPerUser: 100,
  costAlertThreshold: 0.50
};

const _dailyRunCounts = new Map();

// Tool definitions mapped to existing backend services
const TOOL_DEFINITIONS = {
  // Driver tools
  find_matches: {
    name: 'find_matches',
    description: 'Find carriers matching driver preferences (zip, distance, pay, run type)',
    input_schema: {
      type: 'object',
      properties: {
        zip: { type: 'string', description: 'Driver home zip code' },
        maxDistance: { type: 'number', description: 'Maximum commute distance in miles' },
        minCPM: { type: 'number', description: 'Minimum cents per mile' },
        operationType: { type: 'string', enum: ['OTR', 'Regional', 'Local', 'any'] }
      },
      required: ['zip']
    },
    serviceModule: 'backend/carrierMatching',
    serviceFunction: 'findMatchingCarriers',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'matches_returned > 0',
      rollback_strategy: null,
      audit_fields: ['zip', 'maxDistance']
    }
  },
  get_carrier_details: {
    name: 'get_carrier_details',
    description: 'Get detailed AI-enriched information about a specific carrier by DOT number',
    input_schema: {
      type: 'object',
      properties: {
        dotNumber: { type: 'string', description: 'USDOT number of the carrier' }
      },
      required: ['dotNumber']
    },
    serviceModule: 'backend/aiEnrichment',
    serviceFunction: 'enrichCarrier',
    roles: ['driver', 'recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'carrier_data_returned',
      rollback_strategy: null,
      audit_fields: ['dotNumber']
    },
    argMapping: ['dotNumber']
  },
  explain_match: {
    name: 'explain_match',
    description: 'Explain why a driver matched with a specific carrier',
    input_schema: {
      type: 'object',
      properties: {
        driverId: { type: 'string' },
        carrierDot: { type: 'string' }
      },
      required: ['driverId', 'carrierDot']
    },
    serviceModule: 'backend/matchExplanationService',
    serviceFunction: 'getMatchExplanationForDriver',
    roles: ['driver'],
    policy: {
      risk_level: 'suggest',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'explanation_generated',
      rollback_strategy: null,
      audit_fields: ['driverId', 'carrierDot']
    },
    argMapping: ['driverId', 'carrierDot']
  },
  get_fmcsa_data: {
    name: 'get_fmcsa_data',
    description: 'Get FMCSA safety data for a carrier',
    input_schema: {
      type: 'object',
      properties: {
        dotNumber: { type: 'string', description: 'USDOT number' }
      },
      required: ['dotNumber']
    },
    serviceModule: 'backend/externalFmcsaApi',
    serviceFunction: 'getExternalCarrierSafety',
    roles: ['driver', 'recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'safety_data_returned',
      rollback_strategy: null,
      audit_fields: ['dotNumber']
    },
    argMapping: ['dotNumber']
  },
  road_conditions: {
    name: 'road_conditions',
    description: 'Get current road conditions for a location',
    input_schema: {
      type: 'object',
      properties: {
        lat: { type: 'number' },
        lon: { type: 'number' },
        zip: { type: 'string' }
      }
    },
    serviceModule: 'backend/roadConditionService',
    serviceFunction: 'getRouteConditions',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'conditions_returned',
      rollback_strategy: null,
      audit_fields: ['zip']
    }
  },
  find_parking: {
    name: 'find_parking',
    description: 'Search for truck parking near a location',
    input_schema: {
      type: 'object',
      properties: {
        lat: { type: 'number' },
        lon: { type: 'number' },
        radius: { type: 'number', description: 'Search radius in miles' }
      }
    },
    serviceModule: 'backend/parkingService',
    serviceFunction: 'searchParking',
    roles: ['driver'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'parking_results_returned',
      rollback_strategy: null,
      audit_fields: ['lat', 'lon']
    },
    argMapping: ['lat', 'lon', 'radius']
  },
  // Recruiter tools
  search_drivers: {
    name: 'search_drivers',
    description: 'Search for CDL drivers matching criteria',
    input_schema: {
      type: 'object',
      properties: {
        zip: { type: 'string' },
        maxDistance: { type: 'number' },
        endorsements: { type: 'string', description: 'Comma-separated endorsements (Hazmat, Tanker, Doubles)' },
        minExperience: { type: 'number', description: 'Minimum years of experience' }
      }
    },
    serviceModule: 'backend/driverMatching',
    serviceFunction: 'findMatchingDrivers',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'drivers_returned > 0',
      rollback_strategy: null,
      audit_fields: ['zip', 'endorsements']
    }
  },
  get_pipeline: {
    name: 'get_pipeline',
    description: 'Get pipeline candidates for a carrier',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        status: { type: 'string', enum: ['new', 'contacted', 'screening', 'interview', 'offer', 'hired'] }
      },
      required: ['carrierDot']
    },
    serviceModule: 'backend/recruiter_service',
    serviceFunction: 'getPipelineCandidates',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'pipeline_data_returned',
      rollback_strategy: null,
      audit_fields: ['carrierDot']
    },
    argMapping: ['carrierDot']
  },
  update_candidate_status: {
    name: 'update_candidate_status',
    description: 'Update a candidate status in the pipeline',
    input_schema: {
      type: 'object',
      properties: {
        interestId: { type: 'string' },
        newStatus: { type: 'string', enum: ['new', 'contacted', 'screening', 'interview', 'offer', 'hired', 'rejected'] }
      },
      required: ['interestId', 'newStatus']
    },
    serviceModule: 'backend/recruiter_service',
    serviceFunction: 'updateCandidateStatus',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'status_changed',
      rollback_strategy: 'revert_to_previous_status',
      audit_fields: ['interestId', 'newStatus']
    },
    argMapping: ['interestId', 'newStatus']
  },
  send_message: {
    name: 'send_message',
    description: 'Send a message to a driver or recruiter',
    input_schema: {
      type: 'object',
      properties: {
        applicationId: { type: 'string' },
        content: { type: 'string' },
        receiverId: { type: 'string' }
      },
      required: ['applicationId', 'content', 'receiverId']
    },
    serviceModule: 'backend/messaging',
    serviceFunction: 'sendMessage',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'message_delivered',
      rollback_strategy: null,
      audit_fields: ['receiverId', 'content']
    },
    argMapping: ['applicationId', 'content', 'receiverId']
  },
  schedule_interview: {
    name: 'schedule_interview',
    description: 'Request interview availability from a candidate',
    input_schema: {
      type: 'object',
      properties: {
        applicationId: { type: 'string' }
      },
      required: ['applicationId']
    },
    serviceModule: 'backend/interviewScheduler',
    serviceFunction: 'requestAvailability',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'availability_requested',
      rollback_strategy: 'cancel_request',
      audit_fields: ['applicationId']
    },
    argMapping: ['applicationId']
  },
  log_call: {
    name: 'log_call',
    description: 'Log a call outcome with a driver',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        driverId: { type: 'string' },
        outcome: { type: 'string', enum: ['interested', 'callback', 'not_now', 'wrong_fit', 'no_answer', 'voicemail'] },
        notes: { type: 'string' }
      },
      required: ['carrierDot', 'outcome']
    },
    serviceModule: 'backend/callOutcomeService',
    serviceFunction: 'logCallOutcome',
    roles: ['recruiter'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'call_logged',
      rollback_strategy: 'delete_call_record',
      audit_fields: ['carrierDot', 'outcome']
    }
  },
  get_recruiter_analytics: {
    name: 'get_recruiter_analytics',
    description: 'Get funnel and recruiting analytics metrics',
    input_schema: {
      type: 'object',
      properties: {
        carrierDot: { type: 'string' },
        period: { type: 'string', enum: ['week', 'month', 'quarter'] }
      }
    },
    serviceModule: 'backend/recruiterAnalyticsService',
    serviceFunction: 'getFunnelMetrics',
    roles: ['recruiter'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'analytics_returned',
      rollback_strategy: null,
      audit_fields: ['carrierDot', 'period']
    },
    argMapping: ['carrierDot', 'period']
  },
  // Admin tools
  get_system_health: {
    name: 'get_system_health',
    description: 'Get system health and observability metrics',
    input_schema: { type: 'object', properties: {} },
    serviceModule: 'backend/observabilityService',
    serviceFunction: 'getMetrics',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'health_metrics_returned',
      rollback_strategy: null,
      audit_fields: []
    }
  },
  get_driver_stats: {
    name: 'get_driver_stats',
    description: 'Get driver statistics and listings for admin',
    input_schema: {
      type: 'object',
      properties: {
        page: { type: 'number' },
        pageSize: { type: 'number' },
        status: { type: 'string' }
      }
    },
    serviceModule: 'backend/admin_service',
    serviceFunction: 'getDriversList',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'driver_stats_returned',
      rollback_strategy: null,
      audit_fields: ['status']
    }
  },
  manage_prompts: {
    name: 'manage_prompts',
    description: 'Manage AI prompt templates (list, create, update)',
    input_schema: {
      type: 'object',
      properties: {
        operation: { type: 'string', enum: ['list', 'get', 'create', 'update'] },
        promptId: { type: 'string' },
        data: { type: 'object' }
      },
      required: ['operation']
    },
    serviceModule: 'backend/promptLibraryService',
    serviceFunction: null,
    roles: ['admin'],
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'prompt_operation_completed',
      rollback_strategy: 'revert_prompt_version',
      audit_fields: ['operation', 'promptId']
    }
  },
  // Carrier/B2B tools
  get_account: {
    name: 'get_account',
    description: 'Get B2B account details',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' }
      },
      required: ['accountId']
    },
    serviceModule: 'backend/b2bAccountService',
    serviceFunction: 'getAccount',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'account_data_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    },
    argMapping: ['accountId']
  },
  get_signals: {
    name: 'get_signals',
    description: 'Get match signals for a B2B account',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' }
      },
      required: ['accountId']
    },
    serviceModule: 'backend/b2bMatchSignalService',
    serviceFunction: 'getSignals',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'signals_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    },
    argMapping: ['accountId']
  },
  get_opportunities: {
    name: 'get_opportunities',
    description: 'Get pipeline opportunities for B2B',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string' },
        stage: { type: 'string' }
      }
    },
    serviceModule: 'backend/b2bPipelineService',
    serviceFunction: 'getOpportunities',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'opportunities_returned',
      rollback_strategy: null,
      audit_fields: ['accountId']
    },
    argMapping: ['accountId', 'stage']
  },
  get_agent_kpis: {
    name: 'get_agent_kpis',
    description: 'Get agent orchestration KPIs — success rates, quality scores, costs, approval stats',
    input_schema: {
      type: 'object',
      properties: {
        role: { type: 'string', enum: ['driver', 'recruiter', 'admin', 'carrier', 'all'], description: 'Filter by role or all' },
        days: { type: 'number', description: 'Number of days to analyze (default 7)' }
      }
    },
    serviceModule: 'backend/agentOutcomeService',
    serviceFunction: 'getOutcomeStats',
    roles: ['admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'stats_returned',
      rollback_strategy: null,
      audit_fields: ['role', 'days']
    },
    argMapping: ['role', 'days']
  },
  // Cross-role intelligence tools (Phase 2)
  get_market_intel: {
    name: 'get_market_intel',
    description: 'Get aggregated market intelligence — carrier demand signals, top regions/equipment, and pay ranges',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region filter (e.g. Southeast, Midwest)' },
        job_type: { type: 'string', description: 'Job type filter (OTR, Regional, Local, Dedicated)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getMarketIntel',
    roles: ['recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'intel_returned_with_data',
      rollback_strategy: null,
      audit_fields: ['region', 'job_type']
    },
    argMapping: ['region', 'job_type']
  },
  get_lane_demand: {
    name: 'get_lane_demand',
    description: 'Get lane-level demand analysis — demand scores, driver supply gaps, and forecast trends by region',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region filter (optional)' },
        period_days: { type: 'number', description: 'Analysis period in days (default 30)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getLaneDemand',
    roles: ['recruiter', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 15,
      success_metric: 'lanes_returned > 0',
      rollback_strategy: null,
      audit_fields: ['region']
    }
  },
  get_compensation_benchmarks: {
    name: 'get_compensation_benchmarks',
    description: 'Get compensation benchmarks — CPM percentiles, weekly max pay, sign-on bonuses by region and job type',
    input_schema: {
      type: 'object',
      properties: {
        region: { type: 'string', description: 'Region to benchmark' },
        job_type: { type: 'string', description: 'Job type (OTR, Regional, Local, Dedicated)' },
        equipment_type: { type: 'string', description: 'Equipment type (Dry Van, Reefer, Flatbed, Tanker)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getCompensationBenchmarks',
    roles: ['recruiter', 'driver', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'benchmarks_returned_with_sample',
      rollback_strategy: null,
      audit_fields: ['region', 'job_type']
    },
    argMapping: ['region', 'job_type', 'equipment_type']
  },
  get_hiring_benchmarks: {
    name: 'get_hiring_benchmarks',
    description: 'Get hiring benchmarks for a carrier — conversion rates by stage, time to fill, drop reasons, best channels',
    input_schema: {
      type: 'object',
      properties: {
        carrier_dot: { type: 'string', description: 'Carrier USDOT number' }
      },
      required: ['carrier_dot']
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getHiringBenchmarks',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 15,
      success_metric: 'benchmarks_returned',
      rollback_strategy: null,
      audit_fields: ['carrier_dot']
    },
    argMapping: ['carrier_dot']
  },
  get_conversion_insights: {
    name: 'get_conversion_insights',
    description: 'Get platform-wide conversion insights — overall rates, by source/equipment, touchpoints to hire, best contact windows',
    input_schema: {
      type: 'object',
      properties: {
        period_days: { type: 'number', description: 'Analysis period in days (default 30)' },
        equipment_type: { type: 'string', description: 'Equipment type filter (optional)' }
      }
    },
    serviceModule: 'backend/crossRoleIntelService',
    serviceFunction: 'getConversionInsights',
    roles: ['carrier', 'admin'],
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'insights_returned',
      rollback_strategy: null,
      audit_fields: ['period_days']
    }
  },
  // Knowledge Compendium curation tool
  run_curator: {
    name: 'run_curator',
    description: 'Run the Knowledge Curator to analyze recent agent outcomes and update the Compendium',
    input_schema: {
      type: 'object',
      properties: {
        department: { type: 'string', description: 'Department to curate (recruiter/carrier/driver/admin/dev or "all")' },
        days: { type: 'number', description: 'Analysis period in days (default 7)' }
      }
    },
    serviceModule: 'backend/compendiumService',
    serviceFunction: 'runCurator',
    roles: ['admin'],
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 5,
      success_metric: 'patterns_updated > 0',
      rollback_strategy: null,
      audit_fields: ['department', 'days']
    },
    argMapping: ['department', 'days']
  },

  // Autonomous operations tools (Phase 4)
  start_autopilot: {
    name: 'start_autopilot',
    description: 'Start a recruiter autopilot campaign — automated outreach with approval gates for each send',
    input_schema: {
      type: 'object',
      properties: {
        carrier_dot: { type: 'string', description: 'Target carrier DOT number' },
        objective: { type: 'string', description: 'Campaign objective: outreach, pipeline_advancement, or re_engagement' },
        max_contacts: { type: 'number', description: 'Maximum contacts to reach (default 20)' },
        cadence: { type: 'string', description: 'Outreach cadence: aggressive, standard, or gentle' }
      },
      required: ['carrier_dot', 'objective']
    },
    roles: ['recruiter'],
    serviceModule: 'backend/autopilotService',
    serviceFunction: 'createAutopilotCampaign',
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'campaign_created_with_contacts',
      rollback_strategy: 'pause_campaign',
      audit_fields: ['carrier_dot', 'objective', 'max_contacts']
    }
  },
  get_autopilot_status: {
    name: 'get_autopilot_status',
    description: 'Get status of a running autopilot campaign — progress, metrics, pending approvals',
    input_schema: {
      type: 'object',
      properties: {
        campaign_id: { type: 'string', description: 'Campaign ID to check' }
      },
      required: ['campaign_id']
    },
    roles: ['recruiter', 'admin'],
    serviceModule: 'backend/autopilotService',
    serviceFunction: 'getAutopilotStatus',
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'status_returned',
      rollback_strategy: null,
      audit_fields: ['campaign_id']
    },
    argMapping: ['campaign_id']
  },
  // Self-healing tools (Phase 4)
  detect_anomalies: {
    name: 'detect_anomalies',
    description: 'Run anomaly detection and triage — identify issues, match to known patterns, assess severity',
    input_schema: { type: 'object', properties: {} },
    roles: ['admin'],
    serviceModule: 'backend/selfHealingService',
    serviceFunction: 'detectAndTriage',
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'detection_completed',
      rollback_strategy: null,
      audit_fields: []
    }
  },
  propose_fix: {
    name: 'propose_fix',
    description: 'Generate a remediation proposal for an incident — includes actions, risk assessment, and approval gate',
    input_schema: {
      type: 'object',
      properties: {
        incident_id: { type: 'string', description: 'Incident ID to remediate' }
      },
      required: ['incident_id']
    },
    roles: ['admin'],
    serviceModule: 'backend/selfHealingService',
    serviceFunction: 'proposeRemediation',
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 10,
      success_metric: 'plan_created',
      rollback_strategy: null,
      audit_fields: ['incident_id']
    },
    argMapping: ['incident_id']
  },
  execute_fix: {
    name: 'execute_fix',
    description: 'Execute an approved remediation plan — runs fix actions and verifies resolution',
    input_schema: {
      type: 'object',
      properties: {
        plan_id: { type: 'string', description: 'Remediation plan ID to execute' },
        approved_by: { type: 'string', description: 'Admin who approved the fix' }
      },
      required: ['plan_id']
    },
    roles: ['admin'],
    serviceModule: 'backend/selfHealingService',
    serviceFunction: 'executeRemediation',
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 5,
      success_metric: 'remediation_verified',
      rollback_strategy: 'revert_config_changes',
      audit_fields: ['plan_id', 'approved_by']
    },
    argMapping: ['plan_id', 'approved_by']
  },

  // Pipeline Execution Agent tools
  initiate_voice_screen: {
    name: 'initiate_voice_screen',
    description: 'Create a VAPI voice assistant from a template and initiate an outbound screening call to a candidate',
    input_schema: {
      type: 'object',
      properties: {
        template_id: { type: 'string', description: 'Voice agent template ID (e.g. vat_qualification, vat_cold_outreach)' },
        candidate_id: { type: 'string', description: 'Candidate/driver record ID' },
        candidate_name: { type: 'string', description: 'Candidate display name' },
        candidate_phone: { type: 'string', description: 'Candidate phone number' },
        carrier_dot: { type: 'string', description: 'Carrier DOT number' },
        carrier_name: { type: 'string', description: 'Carrier display name' }
      },
      required: ['template_id', 'candidate_id', 'candidate_phone', 'carrier_dot']
    },
    roles: ['recruiter'],
    serviceModule: 'backend/voiceAgentTemplates',
    serviceFunction: 'createAssistantFromTemplate',
    policy: {
      risk_level: 'execute_high',
      requires_approval: true,
      rate_limit: 10,
      success_metric: 'assistant_created_and_call_initiated',
      rollback_strategy: null,
      audit_fields: ['template_id', 'candidate_id', 'carrier_dot']
    }
  },
  get_pipeline_health: {
    name: 'get_pipeline_health',
    description: 'Get pipeline health metrics — SLA compliance rate, conversion rates, average time to contact',
    input_schema: {
      type: 'object',
      properties: {
        recruiter_id: { type: 'string', description: 'Recruiter user ID' },
        days: { type: 'number', description: 'Look-back period in days (default 7)' }
      },
      required: ['recruiter_id']
    },
    roles: ['recruiter', 'admin'],
    serviceModule: 'backend/pipelineExecutionAgent',
    serviceFunction: 'getPipelineHealth',
    policy: {
      risk_level: 'read',
      requires_approval: false,
      rate_limit: 20,
      success_metric: 'health_metrics_returned',
      rollback_strategy: null,
      audit_fields: ['recruiter_id', 'days']
    },
    argMapping: ['recruiter_id', 'days']
  },
  emit_pipeline_event: {
    name: 'emit_pipeline_event',
    description: 'Fire a pipeline event to the event bus for processing by the pipeline execution agent',
    input_schema: {
      type: 'object',
      properties: {
        event_type: { type: 'string', description: 'Event type: stage_change, no_response, call_completed, document_received, application_submitted' },
        candidate_id: { type: 'string', description: 'Candidate/driver record ID' },
        carrier_dot: { type: 'string', description: 'Carrier DOT number' },
        stage_from: { type: 'string', description: 'Previous pipeline stage' },
        stage_to: { type: 'string', description: 'New pipeline stage' }
      },
      required: ['event_type', 'candidate_id']
    },
    roles: ['recruiter'],
    serviceModule: 'backend/pipelineEventBus',
    serviceFunction: 'emitEvent',
    policy: {
      risk_level: 'execute_low',
      requires_approval: false,
      rate_limit: 30,
      success_metric: 'event_emitted',
      rollback_strategy: null,
      audit_fields: ['event_type', 'candidate_id']
    }
  }
};

// ============================================================================
// DOMAIN ROUTER ARCHITECTURE — Phase 1+ (Driver: 83 actions → 7 routers)
// Collapses flat tool definitions into domain routers for AI prompt efficiency.
// Existing TOOL_DEFINITIONS above remain untouched for backward compatibility.
// ============================================================================

const ACTION_REGISTRY = {
  // ── driver_cockpit: 23 actions ──
  driver_cockpit: {
    search_jobs:              { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'searchJobs',              argMapping: ['driverId', 'filters', 'pagination'],                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_job_details:          { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getJobDetails',           argMapping: ['jobId', 'driverId'],                                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    quick_apply:              { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'submitApplication',       argMapping: ['driverId', 'jobId', 'payload'],                       policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    save_job:                 { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'saveJob',                 argMapping: ['driverId', 'jobId'],                                  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_saved_jobs:           { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getSavedJobs',            argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    withdraw_application:     { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'withdrawApplication',     argMapping: ['driverId', 'applicationId', 'reason'],                policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    check_application_status: { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getApplicationStatus',    argMapping: ['driverId', 'applicationId'],                          policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_application_history:  { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getApplicationHistory',   argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    send_message:             { serviceModule: 'backend/messagingService',      serviceFunction: 'sendDriverMessage',       argMapping: ['driverId', 'conversationId', 'payload'],              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_messages:             { serviceModule: 'backend/messagingService',      serviceFunction: 'getConversationMessages', argMapping: ['conversationId', 'driverId', 'pagination'],            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_conversation:         { serviceModule: 'backend/messagingService',      serviceFunction: 'getConversation',         argMapping: ['conversationId', 'driverId'],                         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    mark_read:                { serviceModule: 'backend/messagingService',      serviceFunction: 'markConversationRead',    argMapping: ['conversationId', 'driverId'],                         policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_unread_count:         { serviceModule: 'backend/messagingService',      serviceFunction: 'getDriverUnreadCount',    argMapping: ['driverId'],                                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    update_profile:           { serviceModule: 'backend/driverProfileService',  serviceFunction: 'updateDriverProfile',     argMapping: ['driverId', 'fields'],                                 policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_profile_strength:     { serviceModule: 'backend/driverProfileService',  serviceFunction: 'getProfileStrength',      argMapping: ['driverId'],                                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_profile_suggestions:  { serviceModule: 'backend/driverProfileService',  serviceFunction: 'getProfileSuggestions',   argMapping: ['driverId'],                                           policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 20 } },
    upload_document:          { serviceModule: 'backend/documentService',       serviceFunction: 'recordDriverDocumentUpload', argMapping: ['driverId', 'payload'],                             policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    get_matches:              { serviceModule: 'backend/matchingService',       serviceFunction: 'getDriverMatches',        argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_match_details:        { serviceModule: 'backend/matchingService',       serviceFunction: 'getMatchDetails',         argMapping: ['matchId', 'driverId'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    express_interest:         { serviceModule: 'backend/matchingService',       serviceFunction: 'expressDriverInterest',   argMapping: ['driverId', 'matchId', 'message'],                     policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    dismiss_match:            { serviceModule: 'backend/matchingService',       serviceFunction: 'dismissMatch',            argMapping: ['driverId', 'matchId', 'reason'],                      policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_dashboard_summary:    { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getDashboardSummary',     argMapping: ['driverId'],                                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_notifications:        { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'getDriverNotifications',  argMapping: ['driverId', 'filters'],                                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_road: 15 actions ──
  driver_road: {
    find_parking:                 { serviceModule: 'backend/parkingService',        serviceFunction: 'findTruckParking',          argMapping: ['filters'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_parking_details:          { serviceModule: 'backend/parkingService',        serviceFunction: 'getParkingDetails',         argMapping: ['locationId'],                                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    report_parking_availability:  { serviceModule: 'backend/parkingService',        serviceFunction: 'reportParkingAvailability', argMapping: ['driverId', 'locationId', 'report'],              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    save_favorite_parking:        { serviceModule: 'backend/parkingService',        serviceFunction: 'saveFavoriteParking',       argMapping: ['driverId', 'locationId'],                        policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    find_fuel_prices:             { serviceModule: 'backend/fuelService',           serviceFunction: 'findDieselPrices',          argMapping: ['location', 'filters'],                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_fuel_price_trends:        { serviceModule: 'backend/fuelService',           serviceFunction: 'getFuelPriceTrends',        argMapping: ['state', 'weeks', 'granularity'],                 policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    calculate_fuel_cost:          { serviceModule: 'backend/fuelService',           serviceFunction: 'calculateTripFuelCost',     argMapping: ['origin', 'destination', 'truckConfig'],          policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 20 } },
    get_weigh_station_status:     { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'getWeighStationStatus',     argMapping: ['stationId'],                                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_weigh_stations_on_route:  { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'getWeighStationsOnRoute',   argMapping: ['origin', 'destination', 'filters'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    find_rest_stops:              { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'findRestStops',             argMapping: ['filters'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    rate_rest_stop:               { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'rateRestStop',              argMapping: ['driverId', 'stopId', 'rating'],                  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_weather_forecast:         { serviceModule: 'backend/weatherService',        serviceFunction: 'getWeatherForecast',        argMapping: ['location', 'days', 'units'],                     policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_weather_alerts:           { serviceModule: 'backend/weatherService',        serviceFunction: 'getWeatherAlerts',          argMapping: ['location'],                                      policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_road_conditions:          { serviceModule: 'backend/weatherService',        serviceFunction: 'getRoadConditions',         argMapping: ['state', 'route', 'conditionType'],               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    report_road_hazard:           { serviceModule: 'backend/roadUtilitiesService',  serviceFunction: 'reportRoadHazard',          argMapping: ['driverId', 'report'],                            policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_community: 14 actions ──
  driver_community: {
    get_forum_posts:                { serviceModule: 'backend/communityService',     serviceFunction: 'getForumPosts',          argMapping: ['filters', 'pagination'],               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    create_forum_post:              { serviceModule: 'backend/communityService',     serviceFunction: 'createForumPost',        argMapping: ['driverId', 'payload'],                 policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    reply_to_post:                  { serviceModule: 'backend/communityService',     serviceFunction: 'replyToPost',            argMapping: ['driverId', 'postId', 'body', 'quoteReplyId'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
    like_post:                      { serviceModule: 'backend/communityService',     serviceFunction: 'toggleLike',             argMapping: ['driverId', 'itemId', 'itemType'],      policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    report_post:                    { serviceModule: 'backend/communityService',     serviceFunction: 'reportContent',          argMapping: ['driverId', 'itemId', 'itemType', 'reason', 'details'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 10 } },
    search_forums:                  { serviceModule: 'backend/communityService',     serviceFunction: 'searchForums',           argMapping: ['query', 'filters'],                    policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    find_mentors:                   { serviceModule: 'backend/mentorshipService',    serviceFunction: 'findMentors',            argMapping: ['filters'],                             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    request_mentorship:             { serviceModule: 'backend/mentorshipService',    serviceFunction: 'requestMentorship',      argMapping: ['driverId', 'mentorId', 'payload'],     policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_mentorship_status:          { serviceModule: 'backend/mentorshipService',    serviceFunction: 'getDriverMentorshipStatus', argMapping: ['driverId'],                         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    rate_mentor:                    { serviceModule: 'backend/mentorshipService',    serviceFunction: 'rateMentor',             argMapping: ['driverId', 'mentorshipId', 'rating'],  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    search_pet_friendly_locations:  { serviceModule: 'backend/petFriendlyService',   serviceFunction: 'searchLocations',        argMapping: ['filters'],                             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    submit_pet_friendly_location:   { serviceModule: 'backend/petFriendlyService',   serviceFunction: 'submitLocation',         argMapping: ['driverId', 'data'],                    policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_health_resources:           { serviceModule: 'backend/healthService',        serviceFunction: 'getResourcesByCategory', argMapping: ['category', 'resourceType'],             policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    submit_health_tip:              { serviceModule: 'backend/healthService',        serviceFunction: 'submitTip',              argMapping: ['driverId', 'data'],                    policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
  },

  // ── driver_compliance: 12 actions ──
  driver_compliance: {
    upload_compliance_doc:  { serviceModule: 'backend/documentService',    serviceFunction: 'uploadComplianceDoc',     argMapping: ['driverId', 'payload'],                            policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    get_compliance_docs:    { serviceModule: 'backend/documentService',    serviceFunction: 'getDriverComplianceDocs', argMapping: ['driverId', 'filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    check_doc_expiry:       { serviceModule: 'backend/documentService',    serviceFunction: 'checkDocumentExpiry',     argMapping: ['documentId', 'driverId'],                         policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_expiring_docs:      { serviceModule: 'backend/documentService',    serviceFunction: 'getExpiringDocuments',    argMapping: ['driverId', 'daysWindow', 'includeExpired'],        policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_hos_summary:        { serviceModule: 'backend/hosService',         serviceFunction: 'getHOSSummary',           argMapping: ['driverId'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    log_hos_entry:          { serviceModule: 'backend/hosService',         serviceFunction: 'logHOSEntry',             argMapping: ['driverId', 'entry'],                              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_hos_violations:     { serviceModule: 'backend/hosService',         serviceFunction: 'getHOSViolations',        argMapping: ['driverId', 'dateRange', 'severity'],              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    sync_eld_data:          { serviceModule: 'backend/eldService',         serviceFunction: 'syncELDData',             argMapping: ['driverId', 'provider', 'windowHours'],            policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_training_courses:   { serviceModule: 'backend/trainingService',    serviceFunction: 'getAvailableCourses',     argMapping: ['driverId', 'filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    start_training:         { serviceModule: 'backend/trainingService',    serviceFunction: 'enrollInCourse',          argMapping: ['driverId', 'courseId', 'acceptCost'],              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_training_progress:  { serviceModule: 'backend/trainingService',    serviceFunction: 'getTrainingProgress',     argMapping: ['driverId', 'statusFilter'],                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_certifications:     { serviceModule: 'backend/trainingService',    serviceFunction: 'getDriverCertifications', argMapping: ['driverId', 'filters'],                            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_financial: 10 actions ──
  driver_financial: {
    log_expense:             { serviceModule: 'backend/driverFinancialService', serviceFunction: 'logExpense',             argMapping: ['driverId', 'expense'],                              policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 20 } },
    get_expenses:            { serviceModule: 'backend/driverFinancialService', serviceFunction: 'getExpenses',            argMapping: ['driverId', 'filters', 'pagination'],                policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    get_expense_summary:     { serviceModule: 'backend/driverFinancialService', serviceFunction: 'getExpenseSummary',      argMapping: ['driverId', 'period', 'dateRange'],                   policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    export_expenses:         { serviceModule: 'backend/driverFinancialService', serviceFunction: 'exportExpenses',         argMapping: ['driverId', 'dateRange', 'format', 'categories'],     policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_settlement_history:  { serviceModule: 'backend/settlementService',      serviceFunction: 'getSettlementHistory',   argMapping: ['driverId', 'filters'],                              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    dispute_settlement:      { serviceModule: 'backend/settlementService',      serviceFunction: 'disputeSettlement',      argMapping: ['driverId', 'settlementId', 'dispute'],               policy: { risk_level: 'execute_high',  requires_approval: true,  rate_limit: 5 } },
    calculate_trip_cost:     { serviceModule: 'backend/driverFinancialService', serviceFunction: 'calculateTripCost',      argMapping: ['driverId', 'tripParams'],                            policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 20 } },
    get_tax_summary:         { serviceModule: 'backend/taxService',             serviceFunction: 'getDriverTaxSummary',    argMapping: ['driverId', 'taxYear', 'filingStatus'],               policy: { risk_level: 'read',         requires_approval: false, rate_limit: 10 } },
    get_deduction_suggestions: { serviceModule: 'backend/taxService',           serviceFunction: 'getDeductionSuggestions', argMapping: ['driverId', 'taxYear'],                              policy: { risk_level: 'suggest',      requires_approval: false, rate_limit: 10 } },
    get_per_diem_rates:      { serviceModule: 'backend/taxService',             serviceFunction: 'getPerDiemRates',        argMapping: ['taxYear', 'state'],                                  policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },

  // ── driver_lifecycle: 5 actions ──
  driver_lifecycle: {
    get_driver_timeline:     { serviceModule: 'backend/driverLifecycleService', serviceFunction: 'getDriverTimeline',       argMapping: ['driverId', 'filters'],                              policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    update_disposition:      { serviceModule: 'backend/driverLifecycleService', serviceFunction: 'updateDisposition',       argMapping: ['driverId', 'disposition', 'availableDate', 'notes'], policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_pending_surveys:     { serviceModule: 'backend/surveyService',          serviceFunction: 'getPendingSurveys',       argMapping: ['driverId', 'surveyType'],                           policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    submit_survey_response:  { serviceModule: 'backend/surveyService',          serviceFunction: 'submitSurveyResponse',    argMapping: ['driverId', 'surveyRequestId', 'responses'],         policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    submit_match_feedback:   { serviceModule: 'backend/driverLifecycleService', serviceFunction: 'submitMatchFeedback',     argMapping: ['driverId', 'matchId', 'feedback'],                  policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
  },

  // ── driver_utility: 4 actions ──
  driver_utility: {
    get_profile_strength_score: { serviceModule: 'backend/driverProfileService',  serviceFunction: 'getProfileStrengthScore', argMapping: ['driverId'],                                       policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
    send_quick_response:        { serviceModule: 'backend/driverCockpitService',  serviceFunction: 'sendQuickResponse',      argMapping: ['driverId', 'conversationId', 'templateKey', 'addendum'], policy: { risk_level: 'execute_low', requires_approval: false, rate_limit: 20 } },
    set_reverse_alert:          { serviceModule: 'backend/alertService',          serviceFunction: 'createReverseAlert',     argMapping: ['driverId', 'alertConfig'],                         policy: { risk_level: 'execute_low',   requires_approval: false, rate_limit: 10 } },
    get_market_insights:        { serviceModule: 'backend/marketIntelService',    serviceFunction: 'getDriverMarketInsights', argMapping: ['driverId', 'insightType', 'laneFocus'],            policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
  },
};

// ── Router definitions sent to the AI (one per domain) ──
const ROUTER_DEFINITIONS = {
  driver_cockpit: {
    name: 'driver_cockpit',
    description: 'Driver cockpit operations: search jobs, view/apply/withdraw applications, messaging (send/read/threads), profile management, match browsing (view/express interest/dismiss), dashboard summary, notifications, document upload',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['search_jobs', 'get_job_details', 'quick_apply', 'save_job', 'get_saved_jobs',
                 'withdraw_application', 'check_application_status', 'get_application_history',
                 'send_message', 'get_messages', 'get_conversation', 'mark_read', 'get_unread_count',
                 'update_profile', 'get_profile_strength', 'get_profile_suggestions', 'upload_document',
                 'get_matches', 'get_match_details', 'express_interest', 'dismiss_match',
                 'get_dashboard_summary', 'get_notifications'],
          description: 'The cockpit operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_road: {
    name: 'driver_road',
    description: 'Road utility operations: find truck parking, fuel prices and trends, calculate fuel cost, weigh station status, rest stops, weather forecasts and alerts, road conditions, report hazards',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['find_parking', 'get_parking_details', 'report_parking_availability', 'save_favorite_parking',
                 'find_fuel_prices', 'get_fuel_price_trends', 'calculate_fuel_cost',
                 'get_weigh_station_status', 'get_weigh_stations_on_route',
                 'find_rest_stops', 'rate_rest_stop',
                 'get_weather_forecast', 'get_weather_alerts', 'get_road_conditions', 'report_road_hazard'],
          description: 'The road utility operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_community: {
    name: 'driver_community',
    description: 'Community operations: browse/create/reply/like/report forum posts, search forums, find/request mentors, rate mentorship, search pet-friendly locations, submit pet-friendly locations, browse health resources, submit health tips',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_forum_posts', 'create_forum_post', 'reply_to_post', 'like_post', 'report_post', 'search_forums',
                 'find_mentors', 'request_mentorship', 'get_mentorship_status', 'rate_mentor',
                 'search_pet_friendly_locations', 'submit_pet_friendly_location',
                 'get_health_resources', 'submit_health_tip'],
          description: 'The community operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_compliance: {
    name: 'driver_compliance',
    description: 'Compliance operations: upload/view compliance documents, check document expiry, HOS summary/log/violations, sync ELD data, browse/start training courses, track training progress, view certifications',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['upload_compliance_doc', 'get_compliance_docs', 'check_doc_expiry', 'get_expiring_docs',
                 'get_hos_summary', 'log_hos_entry', 'get_hos_violations', 'sync_eld_data',
                 'get_training_courses', 'start_training', 'get_training_progress', 'get_certifications'],
          description: 'The compliance operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_financial: {
    name: 'driver_financial',
    description: 'Financial operations: log/view/summarize/export expenses, view settlement history, dispute settlements, calculate trip costs, tax summary, deduction suggestions, per diem rates',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['log_expense', 'get_expenses', 'get_expense_summary', 'export_expenses',
                 'get_settlement_history', 'dispute_settlement', 'calculate_trip_cost',
                 'get_tax_summary', 'get_deduction_suggestions', 'get_per_diem_rates'],
          description: 'The financial operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_lifecycle: {
    name: 'driver_lifecycle',
    description: 'Lifecycle operations: view driver timeline, update job search disposition, get pending surveys, submit survey responses, submit match feedback',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_driver_timeline', 'update_disposition', 'get_pending_surveys', 'submit_survey_response', 'submit_match_feedback'],
          description: 'The lifecycle operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },

  driver_utility: {
    name: 'driver_utility',
    description: 'Utility operations: profile strength score widget, send quick response templates, set reverse job alert, get personalized market insights',
    input_schema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['get_profile_strength_score', 'send_quick_response', 'set_reverse_alert', 'get_market_insights'],
          description: 'The utility operation to perform'
        },
        params: { type: 'object', description: 'Action-specific parameters' }
      },
      required: ['action']
    },
    roles: ['driver']
  },
};

// Export for tests
export { ACTION_REGISTRY, ROUTER_DEFINITIONS };

/**
 * Get policy metadata for a tool
 */
export function getToolPolicy(toolName) {
  const tool = TOOL_DEFINITIONS[toolName];
  return tool ? tool.policy : null;
}

/**
 * Validate tool execution against rate limits
 * Uses in-memory tracking (resets on server restart)
 */
const _rateLimitMap = new Map(); // key: `${userId}:${toolName}`, value: { count, resetAt }

export function validateToolExecution(toolName, userId) {
  const policy = getToolPolicy(toolName);
  if (!policy) return { allowed: false, reason: 'Unknown tool' };

  const key = `${userId}:${toolName}`;
  const now = Date.now();
  const entry = _rateLimitMap.get(key);

  if (!entry || now > entry.resetAt) {
    _rateLimitMap.set(key, { count: 1, resetAt: now + 60000 });
    return { allowed: true };
  }

  if (entry.count >= policy.rate_limit) {
    return { allowed: false, reason: `Rate limit exceeded: ${policy.rate_limit}/min for ${toolName}` };
  }

  entry.count++;
  return { allowed: true };
}

// Role system prompts
const ROLE_SYSTEM_PROMPTS = {
  driver: 'You are LMDR, an AI copilot for CDL truck drivers. You have 7 domain tools:\n- driver_cockpit: Search jobs, apply, manage applications, messaging, profile, matches, dashboard, notifications, document upload\n- driver_road: Find parking, fuel prices, weigh stations, rest stops, weather, road conditions, report hazards\n- driver_community: Forums, mentorship, pet-friendly locations, health resources\n- driver_compliance: Document wallet, HOS tracking, ELD data, training courses, certifications\n- driver_financial: Expenses, settlements, trip costs, tax summaries, deductions, per diem\n- driver_lifecycle: Timeline, disposition, surveys, feedback\n- driver_utility: Profile strength scoring, quick responses, reverse alerts, market insights\nEach tool takes an \'action\' parameter to select the operation and \'params\' for action-specific data. Use these tools to provide real data rather than generic answers. Be friendly, practical, and driver-focused. You can also check compensation benchmarks.',
  recruiter: 'You are VelocityMatch\'s AI recruiting assistant. Help recruiters find qualified drivers, manage their pipeline, schedule interviews, track analytics, and optimize their recruiting workflow. Be efficient and data-driven. You have access to market intelligence including carrier demand signals, lane-level demand analysis, and compensation benchmarks from across the platform. You can start autopilot campaigns for automated outreach with approval-gated sends, check campaign status, initiate voice screening calls, monitor pipeline health and SLA compliance, and fire pipeline events.',
  admin: 'You are the VelocityMatch platform admin assistant. Help administrators monitor system health, manage AI configurations, review driver and carrier data, and handle platform operations. You can trigger the Knowledge Curator to analyze recent agent runs and update department compendiums. You can detect anomalies, propose fixes, and execute approved remediations. The self-healing pipeline automatically triages issues against known patterns.',
  carrier: 'You are VelocityMatch\'s B2B assistant for carrier accounts. Help carriers understand their hiring pipeline, review match signals, and manage their account. You can access hiring benchmarks and conversion insights to understand how your recruiting pipeline compares to platform averages.'
};

// Build tool list for a role — merges router definitions + legacy flat tools
function buildToolList(role) {
  const tools = [];

  // Add router definitions for the role
  for (const [key, router] of Object.entries(ROUTER_DEFINITIONS)) {
    if (router.roles.includes(role)) {
      tools.push({ name: router.name, description: router.description, input_schema: router.input_schema });
    }
  }

  // Keep existing flat tools that haven't been migrated to routers
  for (const [key, tool] of Object.entries(TOOL_DEFINITIONS)) {
    if (tool.roles && tool.roles.includes(role) && !ROUTER_DEFINITIONS[key]) {
      tools.push({ name: tool.name, description: tool.description, input_schema: tool.input_schema });
    }
  }

  return tools;
}

// Backward-compatible alias
function getToolsForRole(role) {
  return buildToolList(role);
}

// Execute a tool call against the real backend service
// Exported for VAPI webhook template-scoped tool access
export async function executeTool(toolName, toolInput, runContext = {}) {
  // ── Router dispatch (Phase 1+) ──
  if (toolInput.action && ACTION_REGISTRY[toolName]) {
    const actionDef = ACTION_REGISTRY[toolName][toolInput.action];
    if (!actionDef) {
      return { error: `Unknown action '${toolInput.action}' in router '${toolName}'` };
    }

    const { runId, userId } = runContext;

    // Rate limit check for router actions
    if (userId) {
      const actionKey = `${toolName}.${toolInput.action}`;
      const key = `${userId}:${actionKey}`;
      const now = Date.now();
      const entry = _rateLimitMap.get(key);
      if (entry && now <= entry.resetAt && entry.count >= actionDef.policy.rate_limit) {
        return { error: `Rate limit exceeded: ${actionDef.policy.rate_limit}/min for ${actionKey}`, type: 'rate_limited' };
      }
      if (!entry || now > entry.resetAt) {
        _rateLimitMap.set(key, { count: 1, resetAt: now + 60000 });
      } else {
        entry.count++;
      }
    }

    // Approval gate check for router actions
    if (actionDef.policy.requires_approval && !runContext.approvedGateId) {
      const actionKey = `${toolName}.${toolInput.action}`;
      const stepId = runId ? (await logStep(runId, actionKey, actionDef.policy.risk_level, toolInput.params || {}, null, 0, 'pending_approval')).stepId : '';
      const gate = runId ? await createGate(runId, stepId, actionKey, `Action "${actionKey}" requires approval (risk: ${actionDef.policy.risk_level})`, actionDef.policy.risk_level) : { gateId: '' };
      return {
        type: 'approval_required',
        gateId: gate.gateId,
        stepId,
        toolName: actionKey,
        toolDescription: `${toolName} → ${toolInput.action}`,
        args: toolInput.params || {},
        riskLevel: actionDef.policy.risk_level,
        auditFields: Object.keys(toolInput.params || {})
      };
    }

    const startTime = Date.now();
    try {
      const serviceModule = await import(actionDef.serviceModule);
      const fn = serviceModule[actionDef.serviceFunction];
      if (!fn) {
        return { error: `Function ${actionDef.serviceFunction} not found in ${actionDef.serviceModule}` };
      }

      // Map args — inject userId for identity keys, pass params for aggregate keys
      const mappedArgs = actionDef.argMapping.map(key => {
        if (key === 'driverId' || key === 'userId' || key === 'recruiterId') return runContext.userId;
        if (key === 'filters' || key === 'pagination' || key === 'payload' || key === 'report' ||
            key === 'rating' || key === 'data' || key === 'expense' || key === 'entry' ||
            key === 'dispute' || key === 'tripParams' || key === 'dateRange' || key === 'feedback' ||
            key === 'truckConfig' || key === 'location' || key === 'alertConfig') {
          return toolInput.params || {};
        }
        return toolInput.params?.[key];
      });

      const result = await fn(...mappedArgs);
      const latencyMs = Date.now() - startTime;

      // Log to run ledger (best-effort)
      if (runId) {
        logStep(runId, `${toolName}.${toolInput.action}`, actionDef.policy.risk_level, toolInput.params || {}, result, latencyMs, 'executed')
          .catch(err => console.error('Step logging failed:', err));
      }

      return result;
    } catch (error) {
      const latencyMs = Date.now() - startTime;
      if (runId) {
        logStep(runId, `${toolName}.${toolInput.action}`, actionDef.policy.risk_level, toolInput.params || {}, { error: error.message }, latencyMs, 'error')
          .catch(err => console.error('Step logging failed:', err));
      }
      console.error(`Router action error [${toolName}.${toolInput.action}]:`, error);
      return { error: error.message };
    }
  }

  // ── Flat tool dispatch (legacy Phase 0 tools) ──
  const toolDef = TOOL_DEFINITIONS[toolName];
  if (!toolDef) {
    return { error: `Unknown tool: ${toolName}` };
  }

  const { runId, userId } = runContext;

  // Rate limit check
  if (userId) {
    const rateCheck = validateToolExecution(toolName, userId);
    if (!rateCheck.allowed) {
      return { error: rateCheck.reason, type: 'rate_limited' };
    }
  }

  // Approval gate check
  if (toolDef.policy && toolDef.policy.requires_approval && !runContext.approvedGateId) {
    const stepId = runId ? (await logStep(runId, toolName, toolDef.policy.risk_level, toolInput, null, 0, 'pending_approval')).stepId : '';
    const gate = runId ? await createGate(runId, stepId, toolName, `Tool "${toolName}" requires approval (risk: ${toolDef.policy.risk_level})`, toolDef.policy.risk_level) : { gateId: '' };
    return {
      type: 'approval_required',
      gateId: gate.gateId,
      stepId,
      toolName,
      toolDescription: toolDef.description,
      args: toolInput,
      riskLevel: toolDef.policy.risk_level,
      auditFields: toolDef.policy.audit_fields
    };
  }

  const startTime = Date.now();
  try {
    const serviceModule = await import(toolDef.serviceModule);

    let result;
    if (toolName === 'manage_prompts') {
      const { operation, promptId, data } = toolInput;
      switch (operation) {
        case 'list': result = await serviceModule.getPrompts(data || {}); break;
        case 'get': result = await serviceModule.getActivePrompt(promptId); break;
        case 'create': result = await serviceModule.createPrompt(data); break;
        case 'update': result = await serviceModule.updatePrompt(promptId, data); break;
        default: result = { error: `Unknown prompt operation: ${operation}` };
      }
    } else if (toolName === 'start_autopilot') {
      // start_autopilot expects (recruiterId, config) — reshape from flat tool input
      const { carrier_dot, objective, max_contacts, cadence } = toolInput;
      result = await serviceModule.createAutopilotCampaign(runContext.userId || '', {
        carrier_dot, objective, max_contacts: max_contacts || 20, cadence: cadence || 'standard'
      });
    } else if (toolName === 'log_call') {
      // logCallOutcome(carrierDot, outcomeData) — bundle remaining fields
      const { carrierDot, ...outcomeData } = toolInput;
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn(carrierDot, outcomeData);
    } else if (toolName === 'road_conditions') {
      // getRouteConditions(routePoints, options) — lat/lon into routePoints array
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      const routePoints = [{ lat: toolInput.lat, lon: toolInput.lon }];
      result = await fn(routePoints, { zip: toolInput.zip });
    } else if (toolName === 'search_drivers') {
      // findMatchingDrivers(carrierDot, filters, options) — tool params are filters
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn('', toolInput);
    } else if (toolName === 'initiate_voice_screen') {
      // createAssistantFromTemplate(templateId, contextOverrides) — extract template_id
      const { template_id, ...contextOverrides } = toolInput;
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn(template_id, contextOverrides);
    } else if (toolName === 'emit_pipeline_event') {
      // emitEvent(eventType, payload) — extract event_type, rest is payload
      const { event_type, ...payload } = toolInput;
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      result = await fn(event_type, payload);
    } else {
      const fn = serviceModule[toolDef.serviceFunction];
      if (!fn) {
        return { error: `Function ${toolDef.serviceFunction} not found in ${toolDef.serviceModule}` };
      }
      // Use explicit arg mapping if defined, else pass full input object
      if (toolDef.argMapping) {
        const mappedArgs = toolDef.argMapping.map(key => toolInput[key]);
        result = await fn(...mappedArgs);
      } else {
        result = await fn(toolInput);
      }
    }

    const latencyMs = Date.now() - startTime;
    if (runId) {
      logStep(runId, toolName, toolDef.policy?.risk_level || 'unknown', toolInput, result, latencyMs, 'executed')
        .catch(err => console.error('Step logging failed:', err));
    }

    return result;
  } catch (error) {
    const latencyMs = Date.now() - startTime;
    if (runId) {
      logStep(runId, toolName, toolDef.policy?.risk_level || 'unknown', toolInput, { error: error.message }, latencyMs, 'error')
        .catch(err => console.error('Step logging failed:', err));
    }
    console.error(`Tool execution error [${toolName}]:`, error);
    return { error: error.message };
  }
}

/**
 * Main entry point - handles one agent turn
 * Loops tool_use responses until a text response is returned
 */
export async function handleAgentTurn(role, userId, message, context = {}) {
  if (!ROLE_SYSTEM_PROMPTS[role]) {
    throw new Error(`Unknown role: ${role}`);
  }

  // Get or create conversation
  let conversationId = context.conversationId;
  if (!conversationId) {
    const conv = await createConversation(role, userId);
    conversationId = conv.conversationId;
  }

  // Start run ledger
  let runId = null;
  try {
    const run = await startRun(conversationId, role, userId, message.substring(0, 200));
    runId = run.runId;
  } catch (err) {
    console.error('Run ledger start failed (non-blocking):', err);
  }

  // Daily run limit check
  const dateKey = `${userId}:${new Date().toISOString().split('T')[0]}`;
  const dailyCount = (_dailyRunCounts.get(dateKey) || 0) + 1;
  _dailyRunCounts.set(dateKey, dailyCount);
  if (dailyCount > COST_CONTROLS.maxDailyRunsPerUser) {
    if (runId) completeRun(runId, 'rate_limited', 0, 0).catch(() => {});
    return {
      conversationId,
      runId,
      response: 'You\'ve reached your daily limit for AI assistant requests. Please try again tomorrow.',
      toolsUsed: false,
      role
    };
  }

  // Get recent context
  const recentTurns = await getRecentContext(conversationId, 20);

  // Build messages array
  const messages = [];
  for (const turn of recentTurns) {
    messages.push({ role: turn.role, content: turn.content });
  }
  messages.push({ role: 'user', content: message });

  // Save user turn
  await addTurn(conversationId, 'user', message);

  // Get role-scoped tools
  const tools = getToolsForRole(role);

  // Agent loop - keep calling AI until we get a text response (not tool_use)
  let currentMessages = [...messages];
  const maxIterations = 5;
  let totalTokens = 0;
  const runStartTime = Date.now();

  for (let i = 0; i < maxIterations; i++) {
    // Token cap check
    const roleTokenCap = COST_CONTROLS.maxTokensPerRun[role] || 10000;
    if (totalTokens >= roleTokenCap) {
      const capText = 'I\'ve reached the processing limit for this request. Here\'s what I have so far.';
      await addTurn(conversationId, 'assistant', capText);
      if (runId) {
        completeRun(runId, 'token_cap', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }
      return { conversationId, runId, response: capText, toolsUsed: true, role };
    }

    // Time cap check
    if (Date.now() - runStartTime > COST_CONTROLS.maxRunTimeMs) {
      const timeText = 'This request is taking longer than expected. Here\'s what I have so far.';
      await addTurn(conversationId, 'assistant', timeText);
      if (runId) {
        completeRun(runId, 'time_cap', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }
      return { conversationId, runId, response: timeText, toolsUsed: true, role };
    }
    const aiResponse = await routeAIRequest('agent_orchestration', {
      system: ROLE_SYSTEM_PROMPTS[role],
      messages: currentMessages,
      tools,
      maxTokens: 2048
    });

    totalTokens += aiResponse.tokensUsed || 0;

    // Check if response contains tool_use blocks
    const toolUseBlocks = (aiResponse.contentBlocks || []).filter(b => b.type === 'tool_use');
    const textBlocks = (aiResponse.contentBlocks || []).filter(b => b.type === 'text');

    if (aiResponse.stopReason === 'tool_use' && toolUseBlocks.length > 0) {
      // Add assistant message with tool_use blocks
      currentMessages.push({ role: 'assistant', content: aiResponse.contentBlocks });

      // Execute each tool call
      const toolResults = [];
      for (const toolBlock of toolUseBlocks) {
        const result = await executeTool(toolBlock.name, toolBlock.input, { runId, userId });

        // Check if approval is required
        if (result && result.type === 'approval_required') {
          // Save what we have so far
          await addTurn(conversationId, 'assistant', JSON.stringify(toolUseBlocks), toolUseBlocks);

          // Complete run as paused
          if (runId) {
            completeRun(runId, 'awaiting_approval', totalTokens, 0)
              .catch(err => console.error('Run completion failed:', err));
          }

          return {
            type: 'approval_required',
            conversationId,
            runId,
            gateId: result.gateId,
            stepId: result.stepId,
            toolName: result.toolName,
            toolDescription: result.toolDescription,
            args: result.args,
            riskLevel: result.riskLevel,
            auditFields: result.auditFields,
            pendingToolBlock: toolBlock,
            pendingMessages: currentMessages,
            role
          };
        }

        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolBlock.id,
          content: JSON.stringify(result)
        });
      }

      // Add tool results as user message
      currentMessages.push({ role: 'user', content: toolResults });

      // Save tool execution turn
      await addTurn(conversationId, 'assistant', JSON.stringify(toolUseBlocks), toolUseBlocks);
    } else {
      // Text response - we're done
      const responseText = aiResponse.content || textBlocks.map(b => b.text).join('\n');
      await addTurn(conversationId, 'assistant', responseText);

      // Complete run and evaluate outcome
      if (runId) {
        completeRun(runId, 'completed', totalTokens, 0)
          .then(() => _evaluateCompletedRun(runId))
          .catch(err => console.error('Run completion failed:', err));
      }

      return {
        conversationId,
        runId,
        response: responseText,
        toolsUsed: currentMessages.length > messages.length + 1,
        role
      };
    }
  }

  // Safety: if we hit max iterations, return what we have
  const finalText = 'I\'ve been working on your request but need to summarize. Let me know if you need more details.';
  await addTurn(conversationId, 'assistant', finalText);
  if (runId) {
    completeRun(runId, 'max_iterations', totalTokens, 0)
      .then(() => _evaluateCompletedRun(runId))
      .catch(err => console.error('Run completion failed:', err));
  }
  return { conversationId, runId, response: finalText, toolsUsed: true, role };
}

/**
 * Get available tools for a role (for UI display)
 */
export async function getAvailableTools(role) {
  return getToolsForRole(role);
}

/**
 * Get cost control configuration (for tests and admin display)
 */
export function getCostControls() {
  return { ...COST_CONTROLS };
}

/**
 * Resume agent loop after an approval gate decision
 */
export async function resumeAfterApproval(approvalContext, decision, decidedBy) {
  const { conversationId, runId, gateId, pendingToolBlock, pendingMessages, role } = approvalContext;

  // Resolve the gate
  const { resolveGate } = await import('backend/agentRunLedgerService');
  await resolveGate(gateId, decision, decidedBy);

  if (decision === 'rejected') {
    const toolResults = [{
      type: 'tool_result',
      tool_use_id: pendingToolBlock.id,
      content: JSON.stringify({ error: 'User rejected this action', decision: 'rejected' })
    }];
    const currentMessages = [...pendingMessages, { role: 'user', content: toolResults }];

    const aiResponse = await routeAIRequest('agent_orchestration', {
      system: ROLE_SYSTEM_PROMPTS[role],
      messages: currentMessages,
      tools: getToolsForRole(role),
      maxTokens: 2048
    });

    const responseText = aiResponse.content || (aiResponse.contentBlocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n') || 'Understood, I won\'t proceed with that action.';
    await addTurn(conversationId, 'assistant', responseText);

    if (runId) {
      const { completeRun: cr } = await import('backend/agentRunLedgerService');
      cr(runId, 'completed_with_rejection', aiResponse.tokensUsed || 0, 0).catch(() => {});
    }

    return { conversationId, runId, response: responseText, role };
  }

  // Approved — execute the tool and continue the loop
  const result = await executeTool(pendingToolBlock.name, pendingToolBlock.input, { runId, userId: decidedBy, approvedGateId: gateId });

  const toolResults = [{
    type: 'tool_result',
    tool_use_id: pendingToolBlock.id,
    content: JSON.stringify(result)
  }];
  const currentMessages = [...pendingMessages, { role: 'user', content: toolResults }];

  const aiResponse = await routeAIRequest('agent_orchestration', {
    system: ROLE_SYSTEM_PROMPTS[role],
    messages: currentMessages,
    tools: getToolsForRole(role),
    maxTokens: 2048
  });

  const responseText = aiResponse.content || (aiResponse.contentBlocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n') || 'Action completed.';
  await addTurn(conversationId, 'assistant', responseText);

  if (runId) {
    const { completeRun: cr } = await import('backend/agentRunLedgerService');
    cr(runId, 'completed', aiResponse.tokensUsed || 0, 0).catch(() => {});
  }

  return { conversationId, runId, response: responseText, role };
}

// ── Outcome Evaluation Hook ──
// Import is dynamic to avoid circular dependency issues
// Called after completeRun() in handleAgentTurn completion paths
export async function _evaluateCompletedRun(runId) {
  try {
    const { evaluateRun } = await import('backend/agentOutcomeService');
    return await evaluateRun(runId);
  } catch (err) {
    console.error('Outcome evaluation failed (non-blocking):', err);
    return null;
  }
}

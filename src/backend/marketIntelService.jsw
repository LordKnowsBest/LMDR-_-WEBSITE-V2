/**
 * Market Intelligence Service
 *
 * Provides AI-generated market insights tailored to driver CDL class, endorsements, and lanes.
 *
 * Data Source: Airtable (via dataAccess.jsw)
 * @module backend/marketIntelService
 */

import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  intelligence: 'marketIntelligence',
  profiles: 'driverProfiles'
};

/**
 * Get market insights for a driver
 * @param {string} driverId
 * @param {string} [insightType="all"] - "all" | "pay_trends" | "demand_hotspots" | "hiring_surges" | "lane_analysis"
 * @param {string} [laneFocus] - specific lane or corridor
 * @returns {Promise<object>} { insights, driver_context, totalCount } or { error }
 */
export async function getDriverMarketInsights(driverId, insightType = 'all', laneFocus) {
  try {
    const queryFilters = {};

    if (insightType && insightType !== 'all') {
      queryFilters.insight_type = insightType;
    }

    if (laneFocus) {
      queryFilters.lane = { contains: laneFocus };
    }

    const result = await dataAccess.queryRecords(COLLECTIONS.intelligence, {
      filters: queryFilters,
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 20,
      suppressAuth: true
    });

    // Optionally personalize with driver profile context
    let driverContext = null;
    if (driverId) {
      const profileResult = await dataAccess.queryRecords(COLLECTIONS.profiles, {
        filters: { _id: driverId },
        limit: 1,
        suppressAuth: true
      });
      if (profileResult.items && profileResult.items.length > 0) {
        const p = profileResult.items[0];
        driverContext = {
          cdl_class: p.cdl_class,
          endorsements: p.endorsements,
          home_state: p.home_state,
          preferred_job_types: p.job_types_preferred
        };
      }
    }

    return {
      insights: result.items || [],
      driver_context: driverContext,
      totalCount: result.totalCount || 0
    };
  } catch (error) {
    console.error('marketIntelService.getDriverMarketInsights error:', error);
    return { error: error.message };
  }
}

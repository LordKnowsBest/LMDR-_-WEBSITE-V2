/**
 * SEED DATA: Observability
 * ========================
 * Seeds observability collections for Wave 2 verification.
 *
 * Collections seeded:
 *   - systemLogs (10 records)
 *   - systemTraces (3 records - 1 root + 2 child spans)
 *   - systemErrors (5 records)
 *   - systemMetrics (10 records)
 *
 * Edge cases included:
 *   - Mixed log levels (info, warn, error, debug)
 *   - Trace hierarchy (parent/child spans)
 *   - Resolved vs unresolved errors
 *   - Various error types
 *
 * @module backend/seeds/seedObservability
 */

import wixData from 'wix-data';
import { usesAirtable, getAirtableTableName, getWixCollectionName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// =============================================================================
// DUAL-SOURCE HELPERS (do not modify)
// =============================================================================

async function insertData(collectionKey, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const { _id, ...airtableData } = data;
        return await airtable.createRecord(tableName, airtableData);
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.insert(wixName, data, { suppressAuth: true });
}

async function countData(collectionKey) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, { maxRecords: 1 });
        return (result.records || []).length;
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.query(wixName).limit(1).count({ suppressAuth: true });
}

// =============================================================================
// COLLECTION KEYS
// =============================================================================

const COLLECTIONS = {
    logs: 'systemLogs',
    traces: 'systemTraces',
    errors: 'systemErrors',
    metrics: 'systemMetrics'
};

// =============================================================================
// DATA GENERATORS
// =============================================================================

/**
 * Generate system logs
 * Levels: info, warn, error, debug
 * Sources: matchEngine, enrichment, api, scheduler
 */
function generateSystemLogs() {
    const now = new Date();
    const levels = ['info', 'warn', 'error', 'debug'];
    const sources = ['matchEngine', 'enrichment', 'api', 'scheduler'];

    const records = [
        {
            level: 'info',
            source: 'matchEngine',
            message: 'Match batch completed successfully',
            metadata: JSON.stringify({ batchId: 'batch_001', processedCount: 150, duration: 2340 }),
            timestamp: new Date(now.getTime() - 1 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'warn',
            source: 'enrichment',
            message: 'FMCSA API rate limit approaching',
            metadata: JSON.stringify({ currentRate: 95, limit: 100, windowMs: 60000 }),
            timestamp: new Date(now.getTime() - 2 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'error',
            source: 'api',
            message: 'Failed to process webhook payload',
            metadata: JSON.stringify({ endpoint: '/webhook/stripe', error: 'Invalid signature', requestId: 'req_abc123' }),
            timestamp: new Date(now.getTime() - 3 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'debug',
            source: 'matchEngine',
            message: 'Driver scoring weights applied',
            metadata: JSON.stringify({ driverId: 'drv_001', weights: { experience: 0.3, safety: 0.4, location: 0.3 } }),
            timestamp: new Date(now.getTime() - 4 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'info',
            source: 'scheduler',
            message: 'Scheduled job started: enrichmentBatch',
            metadata: JSON.stringify({ jobId: 'job_enrich_001', scheduledTime: now.toISOString() }),
            timestamp: new Date(now.getTime() - 5 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'warn',
            source: 'api',
            message: 'Slow query detected',
            metadata: JSON.stringify({ query: 'getDriverMatches', duration: 3500, threshold: 2000 }),
            timestamp: new Date(now.getTime() - 6 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'info',
            source: 'enrichment',
            message: 'Carrier enrichment completed',
            metadata: JSON.stringify({ carrierDot: '1234567', fieldsUpdated: ['safety_data', 'reviews', 'social_sentiment'] }),
            timestamp: new Date(now.getTime() - 7 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'error',
            source: 'scheduler',
            message: 'Job execution timeout',
            metadata: JSON.stringify({ jobId: 'job_backfill_002', timeout: 300000, actual: 350000 }),
            timestamp: new Date(now.getTime() - 8 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'debug',
            source: 'api',
            message: 'Request trace captured',
            metadata: JSON.stringify({ traceId: 'trace_001', spanCount: 5, totalDuration: 1234 }),
            timestamp: new Date(now.getTime() - 9 * 60 * 60 * 1000).toISOString()
        },
        {
            level: 'info',
            source: 'matchEngine',
            message: 'Cache invalidated for carrier',
            metadata: JSON.stringify({ carrierDot: '2345678', cacheKey: 'carrier_matches_2345678' }),
            timestamp: new Date(now.getTime() - 10 * 60 * 60 * 1000).toISOString()
        }
    ];

    return records;
}

/**
 * Generate system traces
 * 1 root trace with 2 child spans
 */
function generateSystemTraces() {
    const now = new Date();
    const rootTraceId = '__TEST_SEED__trace_root';

    const records = [
        {
            trace_id: rootTraceId,
            span_name: 'handleMatchRequest',
            duration_ms: 1250,
            status: 'ok',
            parent_trace_id: null,
            metadata: JSON.stringify({
                handler: 'matchController.getMatches',
                inputParams: { driverId: 'drv_001', limit: 10 }
            }),
            start_time: new Date(now.getTime() - 1 * 60 * 1000).toISOString(),
            end_time: new Date(now.getTime() - 1 * 60 * 1000 + 1250).toISOString()
        },
        {
            trace_id: '__TEST_SEED__trace_child1',
            span_name: 'queryDriverProfile',
            duration_ms: 350,
            status: 'ok',
            parent_trace_id: rootTraceId,
            metadata: JSON.stringify({
                collection: 'driverProfiles',
                query: { driverId: 'drv_001' }
            }),
            start_time: new Date(now.getTime() - 1 * 60 * 1000 + 10).toISOString(),
            end_time: new Date(now.getTime() - 1 * 60 * 1000 + 360).toISOString()
        },
        {
            trace_id: '__TEST_SEED__trace_child2',
            span_name: 'scoreCarriers',
            duration_ms: 800,
            status: 'ok',
            parent_trace_id: rootTraceId,
            metadata: JSON.stringify({
                carrierCount: 25,
                scoringAlgorithm: 'weighted_multi_factor'
            }),
            start_time: new Date(now.getTime() - 1 * 60 * 1000 + 400).toISOString(),
            end_time: new Date(now.getTime() - 1 * 60 * 1000 + 1200).toISOString()
        }
    ];

    return records;
}

/**
 * Generate system errors
 * Types: timeout, validation, auth, api_error, unknown
 * 2 resolved, 3 unresolved
 */
function generateSystemErrors() {
    const now = new Date();

    const records = [
        {
            error_type: 'timeout',
            message: 'FMCSA API request timed out after 30s',
            stack_trace: 'Error: Timeout\n    at fetchFMCSAData (enrichmentService.jsw:145)\n    at processCarrier (enrichmentService.jsw:89)',
            source: 'enrichment_service',
            resolved: true,
            resolution_notes: 'Increased timeout to 60s, implemented retry logic',
            timestamp: new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000).toISOString(),
            resolved_at: new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            error_type: 'validation',
            message: 'Invalid DOT number format: ABC123',
            stack_trace: 'ValidationError: DOT must be numeric\n    at validateCarrierInput (carrierService.jsw:42)',
            source: 'carrier_service',
            resolved: true,
            resolution_notes: 'Added input sanitization before validation',
            timestamp: new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000).toISOString(),
            resolved_at: new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            error_type: 'auth',
            message: 'Stripe webhook signature verification failed',
            stack_trace: 'AuthError: Invalid signature\n    at verifyWebhook (subscriptionService.jsw:201)',
            source: 'subscription_service',
            resolved: false,
            resolution_notes: null,
            timestamp: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            error_type: 'api_error',
            message: 'OpenAI API returned 503 Service Unavailable',
            stack_trace: 'APIError: 503 Service Unavailable\n    at callOpenAI (aiRouterService.jsw:156)\n    at enrichCarrier (enrichmentService.jsw:234)',
            source: 'ai_router_service',
            resolved: false,
            resolution_notes: null,
            timestamp: new Date(now.getTime() - 12 * 60 * 60 * 1000).toISOString()
        },
        {
            error_type: 'unknown',
            message: 'Unexpected null reference in match scoring',
            stack_trace: 'TypeError: Cannot read property \'score\' of null\n    at calculateScore (matchEngine.js:312)\n    at scoreDriver (matchEngine.js:189)',
            source: 'match_engine',
            resolved: false,
            resolution_notes: null,
            timestamp: new Date(now.getTime() - 6 * 60 * 60 * 1000).toISOString()
        }
    ];

    return records;
}

/**
 * Generate system metrics
 * 7 consecutive days for multiple metrics
 */
function generateSystemMetrics() {
    const now = new Date();
    const metrics = [
        { name: 'api_latency_p99', unit: 'ms', baseValue: 500 },
        { name: 'match_accuracy', unit: 'percent', baseValue: 85 },
        { name: 'enrichment_success_rate', unit: 'percent', baseValue: 95 },
        { name: 'active_sessions', unit: 'count', baseValue: 150 }
    ];

    const records = [];

    // Generate 7 days of metrics for api_latency_p99 to test time-series
    for (let day = 0; day < 7; day++) {
        const variance = Math.random() * 100 - 50; // -50 to +50
        records.push({
            metric_name: 'api_latency_p99',
            value: 500 + variance,
            unit: 'ms',
            source: 'api_gateway',
            timestamp: new Date(now.getTime() - day * 24 * 60 * 60 * 1000).toISOString()
        });
    }

    // Add single snapshots for other metrics
    records.push({
        metric_name: 'match_accuracy',
        value: 87.5,
        unit: 'percent',
        source: 'match_engine',
        timestamp: now.toISOString()
    });

    records.push({
        metric_name: 'enrichment_success_rate',
        value: 96.2,
        unit: 'percent',
        source: 'enrichment_service',
        timestamp: now.toISOString()
    });

    records.push({
        metric_name: 'active_sessions',
        value: 178,
        unit: 'count',
        source: 'session_manager',
        timestamp: now.toISOString()
    });

    return records;
}

// =============================================================================
// SEED FUNCTIONS
// =============================================================================

export async function seedSystemLogs() {
    const key = COLLECTIONS.logs;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateSystemLogs();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(async (item) => {
                try {
                    const result = await insertData(key, item);
                    return { success: true, id: result._id || result.id };
                } catch (error) {
                    console.error(`[Seed] Failed to insert into ${key}:`, error.message);
                    return { success: false, error: error.message };
                }
            })
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedSystemTraces() {
    const key = COLLECTIONS.traces;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateSystemTraces();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    for (const item of items) {
        try {
            const result = await insertData(key, item);
            ids.push(result._id || result.id);
        } catch (error) {
            console.error(`[Seed] Failed to insert into ${key}:`, error.message);
        }
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedSystemErrors() {
    const key = COLLECTIONS.errors;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateSystemErrors();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    for (const item of items) {
        try {
            const result = await insertData(key, item);
            ids.push(result._id || result.id);
        } catch (error) {
            console.error(`[Seed] Failed to insert into ${key}:`, error.message);
        }
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedSystemMetrics() {
    const key = COLLECTIONS.metrics;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateSystemMetrics();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(item => insertData(key, item)
                .then(r => ({ success: true, id: r._id || r.id }))
                .catch(e => ({ success: false, error: e.message }))
            )
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

// =============================================================================
// ORCHESTRATOR
// =============================================================================

/**
 * Seed all observability collections
 *
 * Usage from Wix page:
 * ```javascript
 * import { seedAllObservability } from 'backend/seeds/seedObservability';
 * const result = await seedAllObservability();
 * console.log('Seed result:', result);
 * ```
 */
export async function seedAllObservability() {
    console.log('='.repeat(50));
    console.log('[Seed] Starting Observability seed...');
    console.log('='.repeat(50));

    const results = {};

    // Seed all collections (no dependencies between them)
    results.logs = await seedSystemLogs();
    results.traces = await seedSystemTraces();
    results.errors = await seedSystemErrors();
    results.metrics = await seedSystemMetrics();

    console.log('='.repeat(50));
    console.log('[Seed] Complete:', JSON.stringify(results, null, 2));
    console.log('='.repeat(50));

    return results;
}

// Alias for consistency with template
export const seedAll = seedAllObservability;

// =============================================================================
// UTILITIES
// =============================================================================

function chunkArray(arr, size) {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
    }
    return chunks;
}

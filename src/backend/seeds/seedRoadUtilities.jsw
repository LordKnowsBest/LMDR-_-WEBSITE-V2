/**
 * SEED DATA - Road Utilities
 * ===========================
 * Seeds 5 collections for the Road Utilities page:
 *   - parkingLocations  -> v2_Parking Locations
 *   - parkingReports    -> v2_Parking Reports
 *   - fuelPrices        -> v2_Fuel Prices  (complementary to seedMockData.jsw)
 *   - fuelCards         -> v2_Fuel Cards
 *   - roadUtilityCache  -> v2_Road Utility Cache
 *
 * NOTE: seedMockData.jsw already seeds fuelPrices (via generateMockFuelData)
 * and road conditions. This file adds parking, fuel cards, and cache data
 * that seedMockData does NOT cover.
 *
 * @module backend/seeds/seedRoadUtilities
 */

import wixData from 'wix-data';
import { usesAirtable, getAirtableTableName, getWixCollectionName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// =============================================================================
// DUAL-SOURCE HELPERS (do not modify)
// =============================================================================

async function insertData(collectionKey, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const { _id, ...airtableData } = data;
        return await airtable.createRecord(tableName, airtableData);
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.insert(wixName, data, { suppressAuth: true });
}

async function countData(collectionKey) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, { maxRecords: 1 });
        return (result.records || []).length;
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.query(wixName).limit(1).count({ suppressAuth: true });
}

// =============================================================================
// COLLECTION KEYS
// =============================================================================

const COLLECTIONS = {
    PARKING_LOCATIONS: 'parkingLocations',
    PARKING_REPORTS: 'parkingReports',
    FUEL_PRICES: 'fuelPrices',
    FUEL_CARDS: 'fuelCards',
    ROAD_UTILITY_CACHE: 'roadUtilityCache',
};

// =============================================================================
// DATA GENERATORS
// =============================================================================

/**
 * Generate parking location records.
 * Covers truck stops, rest areas, and Walmart lots across major corridors.
 */
function generateParkingLocations() {
    return [
        {
            name: '__TEST_SEED__ Pilot Travel Center #412',
            location_type: 'truck_stop',
            lat: 35.1495,
            lng: -90.0490,
            address: '2989 Interstate Dr, Memphis, TN 38118',
            total_spaces: 120,
            available_spaces: 45,
            amenities: ['shower', 'restaurant', 'wifi', 'scales', 'def', 'laundry'],
            brand: 'Pilot',
            overnight_allowed: true,
            hourly_rate: 0,
            status: 'open',
            last_report_at: new Date().toISOString(),
        },
        {
            name: '__TEST_SEED__ Love\'s Travel Stop #327',
            location_type: 'truck_stop',
            lat: 32.7767,
            lng: -96.7970,
            address: '4500 S Loop 12, Dallas, TX 75216',
            total_spaces: 85,
            available_spaces: 12,
            amenities: ['shower', 'restaurant', 'wifi', 'def'],
            brand: 'Loves',
            overnight_allowed: true,
            hourly_rate: 0,
            status: 'open',
            last_report_at: new Date().toISOString(),
        },
        {
            name: '__TEST_SEED__ I-40 Rest Area MM 156',
            location_type: 'rest_area',
            lat: 35.4676,
            lng: -97.5164,
            address: 'I-40 Westbound MM 156, Oklahoma City, OK 73120',
            total_spaces: 30,
            available_spaces: 0,
            amenities: ['restroom', 'vending'],
            brand: null,
            overnight_allowed: false,
            hourly_rate: 0,
            status: 'full',
            last_report_at: new Date().toISOString(),
        },
        {
            name: '__TEST_SEED__ Walmart Supercenter #1182',
            location_type: 'walmart',
            lat: 36.1540,
            lng: -95.9928,
            address: '1234 S Memorial Dr, Tulsa, OK 74112',
            total_spaces: 8,
            available_spaces: 3,
            amenities: [],
            brand: 'Walmart',
            overnight_allowed: true,
            hourly_rate: 0,
            status: 'open',
            last_report_at: new Date().toISOString(),
        },
        {
            name: '__TEST_SEED__ TA Petro #219',
            location_type: 'truck_stop',
            lat: 39.7392,
            lng: -104.9903,
            address: '5600 Quebec St, Denver, CO 80216',
            total_spaces: 200,
            available_spaces: 75,
            amenities: ['shower', 'restaurant', 'wifi', 'scales', 'def', 'truck_wash', 'atm', 'laundry'],
            brand: 'TA',
            overnight_allowed: true,
            hourly_rate: 0,
            status: 'open',
            last_report_at: new Date().toISOString(),
        },
        // Edge case: closed location
        {
            name: '__TEST_SEED__ Closed Rest Area MM 88',
            location_type: 'rest_area',
            lat: 34.0522,
            lng: -118.2437,
            address: 'I-10 Eastbound MM 88, Los Angeles, CA 90001',
            total_spaces: 15,
            available_spaces: 0,
            amenities: [],
            brand: null,
            overnight_allowed: false,
            hourly_rate: 0,
            status: 'closed',
            last_report_at: new Date().toISOString(),
        },
        // Edge case: empty optional fields
        {
            name: '__TEST_SEED__ Unnamed Gravel Lot',
            location_type: 'other',
            lat: 41.2524,
            lng: -95.9980,
            address: '',
            total_spaces: 5,
            available_spaces: 5,
            amenities: [],
            brand: null,
            overnight_allowed: true,
            hourly_rate: 0,
            status: 'open',
            last_report_at: null,
        },
    ];
}

/**
 * Generate parking report records.
 * Represents crowdsourced availability updates from drivers.
 */
function generateParkingReports(parkingIds = []) {
    const reports = [];
    const sampleId = parkingIds[0] || 'loc_placeholder';

    reports.push({
        location_id: sampleId,
        driver_id: '__TEST_SEED__driver_1',
        spaces_available: 42,
        notes: 'Plenty of spots in the back row.',
        report_type: 'availability',
        created_at: new Date().toISOString(),
    });

    reports.push({
        location_id: sampleId,
        driver_id: '__TEST_SEED__driver_2',
        spaces_available: 5,
        notes: 'Filling up fast. Front row is full.',
        report_type: 'availability',
        created_at: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
    });

    reports.push({
        location_id: parkingIds[1] || sampleId,
        driver_id: '__TEST_SEED__driver_3',
        spaces_available: 0,
        notes: '',
        report_type: 'full',
        created_at: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
    });

    // Edge case: report with null notes
    reports.push({
        location_id: parkingIds[2] || sampleId,
        driver_id: '__TEST_SEED__driver_1',
        spaces_available: 15,
        notes: null,
        report_type: 'availability',
        created_at: new Date(Date.now() - 60 * 60 * 1000).toISOString(),
    });

    return reports;
}

/**
 * Generate fuel card records.
 * NOTE: seedMockData.jsw seeds fuel PRICES. This seeds fuel CARDS (driver-linked cards).
 */
function generateFuelCards() {
    return [
        {
            driver_id: '__TEST_SEED__driver_1',
            card_type: 'comdata',
            card_last4: '4321',
            nickname: 'Primary Comdata',
            status: 'active',
            linked_at: new Date().toISOString(),
        },
        {
            driver_id: '__TEST_SEED__driver_1',
            card_type: 'efs',
            card_last4: '8765',
            nickname: 'EFS Backup',
            status: 'active',
            linked_at: new Date().toISOString(),
        },
        {
            driver_id: '__TEST_SEED__driver_2',
            card_type: 'tcheck',
            card_last4: '1234',
            nickname: 'TCheck',
            status: 'active',
            linked_at: new Date().toISOString(),
        },
        // Edge case: inactive card
        {
            driver_id: '__TEST_SEED__driver_3',
            card_type: 'fleetone',
            card_last4: '0000',
            nickname: '',
            status: 'inactive',
            linked_at: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString(),
        },
    ];
}

/**
 * Generate road utility cache records.
 * Cached API responses for parking, fuel, and weigh station queries.
 */
function generateCacheRecords() {
    return [
        {
            cache_key: '__TEST_SEED__parking_35.15_-90.05_25',
            cache_type: 'parking_search',
            data: JSON.stringify({ items: [], searchCenter: { lat: 35.15, lng: -90.05 }, radius: 25 }),
            ttl_seconds: 300,
            created_at: new Date().toISOString(),
            expires_at: new Date(Date.now() + 300 * 1000).toISOString(),
        },
        {
            cache_key: '__TEST_SEED__fuel_35.15_-90.05_50',
            cache_type: 'fuel_search',
            data: JSON.stringify({ items: [], searchCenter: { lat: 35.15, lng: -90.05 }, radius: 50 }),
            ttl_seconds: 600,
            created_at: new Date().toISOString(),
            expires_at: new Date(Date.now() + 600 * 1000).toISOString(),
        },
        // Edge case: expired cache entry
        {
            cache_key: '__TEST_SEED__expired_cache',
            cache_type: 'weigh_station_search',
            data: JSON.stringify({ items: [] }),
            ttl_seconds: 60,
            created_at: new Date(Date.now() - 120 * 1000).toISOString(),
            expires_at: new Date(Date.now() - 60 * 1000).toISOString(),
        },
    ];
}

// =============================================================================
// SEED FUNCTIONS
// =============================================================================

export async function seedParkingLocations() {
    const key = COLLECTIONS.PARKING_LOCATIONS;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateParkingLocations();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(async (item) => {
                try {
                    const result = await insertData(key, item);
                    return { success: true, id: result._id || result.id };
                } catch (error) {
                    console.error(`[Seed] Failed to insert into ${key}:`, error.message);
                    return { success: false, error: error.message };
                }
            })
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedParkingReports(parkingIds = []) {
    const key = COLLECTIONS.PARKING_REPORTS;
    if (!parkingIds?.length) {
        console.log(`[Seed] No parking IDs provided for ${key}. Skipping.`);
        return { seeded: false, count: 0 };
    }

    const items = generateParkingReports(parkingIds);
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(item => insertData(key, item)
                .then(r => ({ success: true, id: r._id || r.id }))
                .catch(e => ({ success: false, error: e.message }))
            )
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedFuelCards() {
    const key = COLLECTIONS.FUEL_CARDS;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateFuelCards();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(async (item) => {
                try {
                    const result = await insertData(key, item);
                    return { success: true, id: result._id || result.id };
                } catch (error) {
                    console.error(`[Seed] Failed to insert into ${key}:`, error.message);
                    return { success: false, error: error.message };
                }
            })
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedRoadUtilityCache() {
    const key = COLLECTIONS.ROAD_UTILITY_CACHE;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateCacheRecords();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(item => insertData(key, item)
                .then(r => ({ success: true, id: r._id || r.id }))
                .catch(e => ({ success: false, error: e.message }))
            )
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

// =============================================================================
// ORCHESTRATOR
// =============================================================================

/**
 * Seed all Road Utilities collections.
 * NOTE: fuelPrices seeding is handled by seedMockData.jsw (seedFuelPrices).
 * This orchestrator seeds the 4 collections unique to this domain.
 *
 * Usage from Wix page:
 * ```javascript
 * import { seedAllRoadUtilities } from 'backend/seeds/seedRoadUtilities';
 * const result = await seedAllRoadUtilities();
 * console.log('Seed result:', result);
 * ```
 */
export async function seedAllRoadUtilities() {
    console.log('='.repeat(50));
    console.log('[Seed] Starting RoadUtilities seed...');
    console.log('='.repeat(50));

    const results = {};

    // Step 1: Parking locations (no dependencies)
    results.parkingLocations = await seedParkingLocations();

    // Step 2: Parking reports (depends on parking location IDs)
    if (results.parkingLocations.ids?.length) {
        results.parkingReports = await seedParkingReports(results.parkingLocations.ids);
    }

    // Step 3: Fuel cards (no dependencies)
    results.fuelCards = await seedFuelCards();

    // Step 4: Road utility cache (no dependencies)
    results.roadUtilityCache = await seedRoadUtilityCache();

    console.log('='.repeat(50));
    console.log('[Seed] RoadUtilities complete:', JSON.stringify(results, null, 2));
    console.log('='.repeat(50));

    return results;
}

// =============================================================================
// UTILITIES
// =============================================================================

function chunkArray(arr, size) {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
    }
    return chunks;
}

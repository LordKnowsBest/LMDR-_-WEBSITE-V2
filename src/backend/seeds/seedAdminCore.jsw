/**
 * SEED DATA: Admin Core
 * ======================
 * Seeds admin-specific collections for Wave 2 verification.
 *
 * Collections seeded:
 *   - adminAuditLog (8 records)
 *   - systemAlerts (5 records)
 *   - aiUsageLog (10 records)
 *   - carrierSafetyData (3 records)
 *
 * Edge cases included:
 *   - 1 critical alert (active)
 *   - 1 resolved alert
 *   - 1 failed AI request
 *   - Various admin actions (verify, suspend, export, etc.)
 *
 * NOTE: driverProfiles and carriers overlap with Wave 1 (seedDriverProfiles).
 * This seed focuses on admin-specific collections only.
 *
 * @module backend/seeds/seedAdminCore
 */

import wixData from 'wix-data';
import { usesAirtable, getAirtableTableName, getWixCollectionName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// =============================================================================
// DUAL-SOURCE HELPERS (do not modify)
// =============================================================================

async function insertData(collectionKey, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const { _id, ...airtableData } = data;
        return await airtable.createRecord(tableName, airtableData);
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.insert(wixName, data, { suppressAuth: true });
}

async function countData(collectionKey) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, { maxRecords: 1 });
        return (result.records || []).length;
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.query(wixName).limit(1).count({ suppressAuth: true });
}

// =============================================================================
// COLLECTION KEYS
// =============================================================================

const COLLECTIONS = {
    auditLog: 'auditLog',
    systemAlerts: 'systemAlerts',
    aiUsageLog: 'aiUsageLog',
    carrierSafetyData: 'carrierSafetyData'
};

// =============================================================================
// DATA GENERATORS
// =============================================================================

/**
 * Generate admin audit log records
 * Actions: verify_driver, suspend_driver, resolve_alert, update_config, export_data
 * Entity types: driver, carrier, alert, config
 */
function generateAuditLogRecords() {
    const now = new Date();
    const adminIds = ['admin_001', 'admin_002', 'admin_003'];

    const records = [
        {
            admin_id: adminIds[0],
            action: 'verify_driver',
            entity_type: 'driver',
            entity_id: '__TEST_SEED__driver_1',
            details: 'Verified driver CDL and medical card documents',
            timestamp: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[0],
            action: 'suspend_driver',
            entity_type: 'driver',
            entity_id: '__TEST_SEED__driver_2',
            details: 'Suspended for failed background check',
            timestamp: new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[1],
            action: 'resolve_alert',
            entity_type: 'alert',
            entity_id: '__TEST_SEED__alert_1',
            details: 'Resolved API timeout alert - service restored',
            timestamp: new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[1],
            action: 'update_config',
            entity_type: 'config',
            entity_id: 'ai_router_config',
            details: 'Changed default AI provider from openai to anthropic',
            timestamp: new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[2],
            action: 'export_data',
            entity_type: 'driver',
            entity_id: 'bulk_export_2024',
            details: 'Exported 500 driver profiles for analytics',
            timestamp: new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[0],
            action: 'verify_driver',
            entity_type: 'driver',
            entity_id: '__TEST_SEED__driver_3',
            details: 'Verified driver with HAZMAT endorsement',
            timestamp: new Date(now.getTime() - 6 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[2],
            action: 'update_config',
            entity_type: 'carrier',
            entity_id: 'carrier_1234567',
            details: 'Updated carrier enrichment settings',
            timestamp: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            admin_id: adminIds[1],
            action: 'resolve_alert',
            entity_type: 'alert',
            entity_id: '__TEST_SEED__alert_2',
            details: 'False positive - no action required',
            timestamp: new Date(now.getTime() - 8 * 24 * 60 * 60 * 1000).toISOString()
        }
    ];

    return records;
}

/**
 * Generate system alerts
 * Severities: critical, warning, info
 * Statuses: active, resolved
 */
function generateSystemAlerts() {
    const now = new Date();

    const records = [
        {
            alert_type: 'api_error',
            severity: 'critical',
            message: 'FMCSA API returning 503 errors - enrichment degraded',
            status: 'active',
            source: 'enrichment_service',
            created_at: new Date(now.getTime() - 1 * 60 * 60 * 1000).toISOString()
        },
        {
            alert_type: 'api_error',
            severity: 'warning',
            message: 'OpenAI API latency exceeding 5s threshold',
            status: 'resolved',
            source: 'ai_router',
            created_at: new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString(),
            resolved_at: new Date(now.getTime() - 20 * 60 * 60 * 1000).toISOString()
        },
        {
            alert_type: 'quota_warning',
            severity: 'warning',
            message: 'Carrier 1234567 approaching view quota limit (90%)',
            status: 'active',
            source: 'subscription_service',
            created_at: new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            alert_type: 'system_info',
            severity: 'info',
            message: 'Scheduled maintenance completed successfully',
            status: 'active',
            source: 'system',
            created_at: new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000).toISOString()
        },
        {
            alert_type: 'data_sync',
            severity: 'info',
            message: 'Airtable sync completed - 1,234 records updated',
            status: 'active',
            source: 'sync_service',
            created_at: new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000).toISOString()
        }
    ];

    return records;
}

/**
 * Generate AI usage log records
 * Providers: openai, anthropic, google
 * Functions: enrichment, matching, ocr
 */
function generateAIUsageLog() {
    const now = new Date();
    const providers = ['openai', 'anthropic', 'google'];
    const models = {
        openai: ['gpt-4', 'gpt-4-turbo', 'gpt-3.5-turbo'],
        anthropic: ['claude-3-opus', 'claude-3-sonnet', 'claude-3-haiku'],
        google: ['gemini-pro', 'gemini-pro-vision']
    };
    const functions = ['enrichment', 'matching', 'ocr', 'summarization', 'classification'];

    const records = [];

    for (let i = 0; i < 10; i++) {
        const provider = providers[i % providers.length];
        const model = models[provider][i % models[provider].length];
        const isFailed = i === 7; // One failed request

        records.push({
            provider: provider,
            model: model,
            function_name: functions[i % functions.length],
            tokens_used: isFailed ? 0 : (100 + Math.floor(Math.random() * 9900)), // 100 to 10000
            latency_ms: isFailed ? 30000 : (200 + Math.floor(Math.random() * 4800)), // 200ms to 5s
            success: !isFailed,
            error_message: isFailed ? 'Request timeout after 30s' : null,
            timestamp: new Date(now.getTime() - i * 2 * 60 * 60 * 1000).toISOString()
        });
    }

    return records;
}

/**
 * Generate carrier safety data
 * Linked to sample carrier DOT numbers
 */
function generateCarrierSafetyData() {
    const records = [
        {
            carrier_dot: '1234567',
            safety_rating: 'Satisfactory',
            overall_percentile: 85,
            basics: JSON.stringify({
                unsafe_driving: 12,
                hours_of_service: 8,
                driver_fitness: 5,
                controlled_substances: 0,
                vehicle_maintenance: 15,
                hazmat: null,
                crash_indicator: 10
            }),
            inspections_30_day: 12,
            violations_30_day: 2,
            last_updated: new Date().toISOString()
        },
        {
            carrier_dot: '2345678',
            safety_rating: 'Conditional',
            overall_percentile: 45,
            basics: JSON.stringify({
                unsafe_driving: 65,
                hours_of_service: 55,
                driver_fitness: 30,
                controlled_substances: 0,
                vehicle_maintenance: 70,
                hazmat: null,
                crash_indicator: 40
            }),
            inspections_30_day: 8,
            violations_30_day: 5,
            last_updated: new Date().toISOString()
        },
        {
            carrier_dot: '3456789',
            safety_rating: 'Satisfactory',
            overall_percentile: 92,
            basics: JSON.stringify({
                unsafe_driving: 5,
                hours_of_service: 3,
                driver_fitness: 2,
                controlled_substances: 0,
                vehicle_maintenance: 8,
                hazmat: 2,
                crash_indicator: 5
            }),
            inspections_30_day: 25,
            violations_30_day: 1,
            last_updated: new Date().toISOString()
        }
    ];

    return records;
}

// =============================================================================
// SEED FUNCTIONS
// =============================================================================

export async function seedAuditLog() {
    const key = COLLECTIONS.auditLog;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateAuditLogRecords();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(async (item) => {
                try {
                    const result = await insertData(key, item);
                    return { success: true, id: result._id || result.id };
                } catch (error) {
                    console.error(`[Seed] Failed to insert into ${key}:`, error.message);
                    return { success: false, error: error.message };
                }
            })
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedSystemAlerts() {
    const key = COLLECTIONS.systemAlerts;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateSystemAlerts();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    for (const item of items) {
        try {
            const result = await insertData(key, item);
            ids.push(result._id || result.id);
        } catch (error) {
            console.error(`[Seed] Failed to insert into ${key}:`, error.message);
        }
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedAIUsageLog() {
    const key = COLLECTIONS.aiUsageLog;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateAIUsageLog();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(item => insertData(key, item)
                .then(r => ({ success: true, id: r._id || r.id }))
                .catch(e => ({ success: false, error: e.message }))
            )
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedCarrierSafetyData() {
    const key = COLLECTIONS.carrierSafetyData;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateCarrierSafetyData();
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    for (const item of items) {
        try {
            const result = await insertData(key, item);
            ids.push(result._id || result.id);
        } catch (error) {
            console.error(`[Seed] Failed to insert into ${key}:`, error.message);
        }
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

// =============================================================================
// ORCHESTRATOR
// =============================================================================

/**
 * Seed all admin core collections
 *
 * Usage from Wix page:
 * ```javascript
 * import { seedAllAdminCore } from 'backend/seeds/seedAdminCore';
 * const result = await seedAllAdminCore();
 * console.log('Seed result:', result);
 * ```
 */
export async function seedAllAdminCore() {
    console.log('='.repeat(50));
    console.log('[Seed] Starting AdminCore seed...');
    console.log('='.repeat(50));

    const results = {};

    // Seed all collections (no dependencies between them)
    results.auditLog = await seedAuditLog();
    results.systemAlerts = await seedSystemAlerts();
    results.aiUsageLog = await seedAIUsageLog();
    results.carrierSafetyData = await seedCarrierSafetyData();

    console.log('='.repeat(50));
    console.log('[Seed] Complete:', JSON.stringify(results, null, 2));
    console.log('='.repeat(50));

    return results;
}

// Alias for consistency with template
export const seedAll = seedAllAdminCore;

// =============================================================================
// UTILITIES
// =============================================================================

function chunkArray(arr, size) {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
    }
    return chunks;
}

/**
 * SEED DATA: Driver Profiles
 * ==========================
 * Seeds driver profiles and driver-carrier interests for Wave 1 verification.
 *
 * Collections seeded:
 *   - driverProfiles (10 records)
 *   - driverCarrierInterests (15 records)
 *
 * Edge cases included:
 *   - 1 inactive driver (status: 'inactive')
 *   - 1 driver with no endorsements (empty array)
 *   - 1 driver with max experience (30+ years)
 *   - 1 driver with minimal data (only required fields)
 *   - 1 dormant profile (no recent activity)
 *
 * @module backend/seeds/seedDriverProfiles
 */

import wixData from 'wix-data';
import { usesAirtable, getAirtableTableName, getWixCollectionName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// =============================================================================
// DUAL-SOURCE HELPERS (do not modify)
// =============================================================================

async function insertData(collectionKey, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const { _id, ...airtableData } = data;
        return await airtable.createRecord(tableName, airtableData);
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.insert(wixName, data, { suppressAuth: true });
}

async function countData(collectionKey) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, { maxRecords: 1 });
        return (result.records || []).length;
    }
    const wixName = getWixCollectionName(collectionKey);
    return await wixData.query(wixName).limit(1).count({ suppressAuth: true });
}

async function queryData(collectionKey, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.queryRecords(tableName, options);
    }
    const wixName = getWixCollectionName(collectionKey);
    let query = wixData.query(wixName);
    if (options.maxRecords) query = query.limit(options.maxRecords);
    const result = await query.find({ suppressAuth: true });
    return { records: result.items };
}

// =============================================================================
// COLLECTION KEYS
// =============================================================================

const COLLECTIONS = {
    profiles: 'driverProfiles',
    interests: 'driverCarrierInterests'
};

// =============================================================================
// DATA GENERATORS
// =============================================================================

const CDL_CLASSES = ['A', 'B', 'C'];
const ENDORSEMENTS = ['H', 'N', 'P', 'S', 'T', 'X'];
const OPERATION_TYPES = ['otr', 'regional', 'local', 'dedicated', 'no_preference'];
const FLEET_SIZES = ['small', 'medium', 'large', 'no_preference'];
const PROFILE_STATUSES = ['active', 'incomplete', 'dormant'];

const STATES = ['TX', 'CA', 'FL', 'GA', 'IL', 'OH', 'PA', 'NY', 'NC', 'MI'];
const ZIP_CODES = ['75001', '90210', '33101', '30301', '60601', '44101', '19101', '10001', '27601', '48201'];

function generateDriverProfiles(count = 10) {
    const records = [];
    const now = new Date();

    for (let i = 0; i < count; i++) {
        const isInactive = i === 0;
        const hasNoEndorsements = i === 1;
        const isMaxExperience = i === 2;
        const isMinimalData = i === 3;
        const isDormant = i === 4;

        const yearsExp = isMaxExperience ? 32 : (isMinimalData ? null : Math.floor(Math.random() * 20) + 1);
        const endorsements = hasNoEndorsements ? [] :
            ENDORSEMENTS.slice(0, Math.floor(Math.random() * 4) + 1);

        const profile = {
            // Identifiable test data
            wix_member_id: `__TEST_SEED__driver_${i + 1}`,
            display_name: isMinimalData ? '' : `TestDriver${i + 1} Seed`,
            email: `driver${i + 1}@test.lmdr.com`,
            phone: isMinimalData ? '' : `555010000${i}`,

            // Location
            home_zip: ZIP_CODES[i % ZIP_CODES.length],
            max_commute_miles: 50 + (i * 10),

            // Preferences
            min_cpm: isMinimalData ? 0 : (0.50 + (i * 0.05)),
            preferred_operation_type: OPERATION_TYPES[i % OPERATION_TYPES.length],
            max_turnover_percent: 70 + (i * 3),
            max_truck_age_years: 3 + (i % 5),
            fleet_size_preference: FLEET_SIZES[i % FLEET_SIZES.length],

            // Experience & Qualifications
            years_experience: yearsExp,
            cdl_class: isMinimalData ? '' : CDL_CLASSES[i % CDL_CLASSES.length],
            endorsements: endorsements,
            clean_mvr: isMinimalData ? null : (i % 3 !== 0),
            accidents_last_3_years: isMinimalData ? null : (i % 4 === 0 ? 1 : 0),
            violations_last_3_years: isMinimalData ? null : (i % 5 === 0 ? 1 : 0),

            // Documents (placeholder URLs for test data)
            cdl_front_image: isMinimalData ? null : `https://test.lmdr.com/cdl/front_${i}.jpg`,
            cdl_back_image: isMinimalData ? null : `https://test.lmdr.com/cdl/back_${i}.jpg`,
            med_card_image: i % 2 === 0 ? `https://test.lmdr.com/medcard/${i}.jpg` : null,
            resume_file: i % 3 === 0 ? `https://test.lmdr.com/resume/${i}.pdf` : null,

            // Activity tracking
            last_search_date: isDormant ? new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000).toISOString() :
                              new Date(now.getTime() - (i * 2) * 24 * 60 * 60 * 1000).toISOString(),
            total_searches: isDormant ? 1 : (10 + i * 5),

            // Status
            profile_completeness_score: isMinimalData ? 15 : (isInactive ? 45 : (60 + i * 4)),
            profile_status: isInactive ? 'inactive' : (isDormant ? 'dormant' : (isMinimalData ? 'incomplete' : 'active')),
            is_discoverable: !isInactive && !isMinimalData && !isDormant,

            // Timestamps
            created_date: new Date(now.getTime() - (30 - i) * 24 * 60 * 60 * 1000).toISOString(),
            updated_date: now.toISOString()
        };

        records.push(profile);
    }

    return records;
}

function generateDriverCarrierInterests(profileIds = []) {
    const records = [];
    const now = new Date();

    // Sample carrier DOT numbers and names
    const carriers = [
        { dot: '1234567', name: 'Swift Transportation' },
        { dot: '2345678', name: 'Werner Enterprises' },
        { dot: '3456789', name: 'J.B. Hunt' },
        { dot: '4567890', name: 'Schneider National' },
        { dot: '5678901', name: 'Landstar System' }
    ];

    const actions = ['interested', 'applied', 'saved', 'contacted'];
    const outcomes = [null, 'hired', 'rejected', 'pending', 'withdrew'];

    // Create 1-3 interests per driver (first 5 drivers only to keep reasonable)
    for (let driverIdx = 0; driverIdx < Math.min(5, profileIds.length); driverIdx++) {
        const numInterests = 1 + (driverIdx % 3); // 1, 2, or 3 interests

        for (let j = 0; j < numInterests; j++) {
            const carrier = carriers[(driverIdx + j) % carriers.length];
            const daysAgo = (driverIdx * 3) + j;

            records.push({
                driver_id: profileIds[driverIdx],
                carrier_dot: carrier.dot,
                carrier_name: carrier.name,
                match_score: 65 + Math.floor(Math.random() * 30), // 65-95
                action: actions[(driverIdx + j) % actions.length],
                action_timestamp: new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                driver_zip_at_match: ZIP_CODES[driverIdx % ZIP_CODES.length],
                outcome: j === 0 ? outcomes[driverIdx % outcomes.length] : null,
                outcome_date: j === 0 && driverIdx % 2 === 0 ?
                    new Date(now.getTime() - (daysAgo - 2) * 24 * 60 * 60 * 1000).toISOString().split('T')[0] : null,
                notes: j === 0 ? `Test interest ${driverIdx + 1}-${j + 1}` : null
            });
        }
    }

    return records;
}

// =============================================================================
// SEED FUNCTIONS
// =============================================================================

export async function seedDriverProfiles() {
    const key = COLLECTIONS.profiles;
    const existing = await countData(key);
    if (existing > 0) {
        console.log(`[Seed] ${key} already has data. Skipping.`);
        return { seeded: false, count: existing };
    }

    const items = generateDriverProfiles(10);
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(async (item) => {
                try {
                    const result = await insertData(key, item);
                    return { success: true, id: result._id || result.id };
                } catch (error) {
                    console.error(`[Seed] Failed to insert into ${key}:`, error.message);
                    return { success: false, error: error.message };
                }
            })
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200)); // Rate limit
    }

    return { seeded: true, count: ids.length, ids };
}

export async function seedDriverCarrierInterests(profileIds) {
    const key = COLLECTIONS.interests;
    if (!profileIds?.length) {
        console.log(`[Seed] No profile IDs provided for ${key}. Skipping.`);
        return { seeded: false, count: 0 };
    }

    const items = generateDriverCarrierInterests(profileIds);
    console.log(`[Seed] Seeding ${items.length} records into ${key}...`);

    const ids = [];
    const chunks = chunkArray(items, 10);

    for (const chunk of chunks) {
        const results = await Promise.all(
            chunk.map(item => insertData(key, item)
                .then(r => ({ success: true, id: r._id || r.id }))
                .catch(e => ({ success: false, error: e.message }))
            )
        );
        ids.push(...results.filter(r => r.success).map(r => r.id));
        await new Promise(r => setTimeout(r, 200));
    }

    return { seeded: true, count: ids.length, ids };
}

// =============================================================================
// ORCHESTRATOR
// =============================================================================

/**
 * Seed all driver-related collections
 *
 * Usage from Wix page:
 * ```javascript
 * import { seedAllDriverProfiles } from 'backend/seeds/seedDriverProfiles';
 * const result = await seedAllDriverProfiles();
 * console.log('Seed result:', result);
 * ```
 */
export async function seedAllDriverProfiles() {
    console.log('='.repeat(50));
    console.log('[Seed] Starting DriverProfiles seed...');
    console.log('='.repeat(50));

    const results = {};

    // Step 1: Seed driver profiles
    results.profiles = await seedDriverProfiles();

    // Step 2: Seed interests (depends on profile IDs)
    if (results.profiles.ids?.length) {
        results.interests = await seedDriverCarrierInterests(results.profiles.ids);
    }

    console.log('='.repeat(50));
    console.log('[Seed] Complete:', JSON.stringify(results, null, 2));
    console.log('='.repeat(50));

    return results;
}

// Alias for consistency with template
export const seedAll = seedAllDriverProfiles;

// =============================================================================
// UTILITIES
// =============================================================================

function chunkArray(arr, size) {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
        chunks.push(arr.slice(i, i + size));
    }
    return chunks;
}

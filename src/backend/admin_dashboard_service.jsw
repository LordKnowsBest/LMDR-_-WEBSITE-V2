import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    // Collection keys for dataAccess
    keys: {
        drivers: 'driverProfiles',
        carriers: 'carriers',
        matches: 'matchEvents',
        interests: 'driverCarrierInterests',
        enrichments: 'carrierEnrichments',
        safetyData: 'carrierSafetyData',
        auditLog: 'auditLog',
        alerts: 'systemAlerts',
        aiUsageLog: 'aiUsageLog'
    },
    // Token pricing per 1M tokens
    tokenPricing: {
        anthropic: { input: 3.00, output: 15.00 },
        openai: { input: 2.50, output: 10.00 },
        groq: { input: 0.05, output: 0.10 },
        perplexity: { input: 1.00, output: 1.00 },
        google: { input: 0.075, output: 0.30 },
        mistral: { input: 2.00, output: 6.00 },
        cohere: { input: 0.50, output: 1.50 }
    },
    budgetThresholds: { warning: 100, critical: 250 }
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) { return false; }
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized');
}

// ============================================
// DASHBOARD OVERVIEW DATA
// ============================================

export async function getDashboardOverview() {
    await requireAdmin();
    try {
        const [driverStats, carrierStats, matchStats, enrichmentStats, recentActivity, systemAlerts, platformHealth] = await Promise.all([
            getDriverStats(), getCarrierStats(), getMatchStats(), getEnrichmentStats(), getRecentActivity(), getSystemAlerts(), getPlatformHealth()
        ]);
        return { drivers: driverStats, carriers: carrierStats, matches: matchStats, enrichment: enrichmentStats, activity: recentActivity, alerts: systemAlerts, health: platformHealth, generatedAt: new Date() };
    } catch (error) {
        console.error('getDashboardOverview error:', error);
        throw new Error('Failed to fetch dashboard data');
    }
}

// ============================================
// DRIVER STATISTICS
// ============================================

async function getDriverStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const [total, active, pending, newThisWeek, newThisMonth] = await Promise.all([
        dataAccess.countRecords(CONFIG.keys.drivers, {}),
        dataAccess.countRecords(CONFIG.keys.drivers, { status: 'active' }),
        dataAccess.countRecords(CONFIG.keys.drivers, { verificationStatus: 'in_review' }),
        dataAccess.countRecords(CONFIG.keys.drivers, { _createdDate: { gte: weekAgo } }),
        dataAccess.countRecords(CONFIG.keys.drivers, { _createdDate: { gte: monthAgo } })
    ]);

    return { total, active, pending, newThisWeek, newThisMonth, activePercent: total > 0 ? Math.round((active / total) * 100) : 0 };
}

// ============================================
// CARRIER STATISTICS
// ============================================

async function getCarrierStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [total, active, flagged, newThisWeek] = await Promise.all([
        dataAccess.countRecords(CONFIG.keys.carriers, {}),
        dataAccess.countRecords(CONFIG.keys.carriers, { status: 'active' }),
        dataAccess.countRecords(CONFIG.keys.carriers, { isFlagged: true }),
        dataAccess.countRecords(CONFIG.keys.carriers, { _createdDate: { gte: weekAgo } })
    ]);

    return { total, active, flagged, newThisWeek, activePercent: total > 0 ? Math.round((active / total) * 100) : 0 };
}

// ============================================
// MATCH STATISTICS
// ============================================

async function getMatchStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [totalMatches, weekMatches, totalInterests] = await Promise.all([
        dataAccess.countRecords(CONFIG.keys.matches, {}),
        dataAccess.countRecords(CONFIG.keys.matches, { timestamp: { gte: weekAgo } }),
        dataAccess.countRecords(CONFIG.keys.interests, {})
    ]);

    return { total: totalMatches, thisWeek: weekMatches, interests: { total: totalInterests } };
}

// ============================================
// ENRICHMENT STATISTICS
// ============================================

async function getEnrichmentStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [totalEnrichments, totalCarriers, freshEnrichments] = await Promise.all([
        dataAccess.countRecords(CONFIG.keys.enrichments, {}),
        dataAccess.countRecords(CONFIG.keys.carriers, {}),
        dataAccess.countRecords(CONFIG.keys.enrichments, { enriched_date: { gte: weekAgo } })
    ]);

    return { total: totalEnrichments, fresh: freshEnrichments, coverage: totalCarriers > 0 ? Math.round((totalEnrichments / totalCarriers) * 100) : 0 };
}

// ============================================
// RECENT ACTIVITY
// ============================================

async function getRecentActivity() {
    try {
        const [adminRes, matchRes, driverRes] = await Promise.all([
            dataAccess.queryRecords(CONFIG.keys.auditLog, { sort: [{ field: 'timestamp', direction: 'desc' }], limit: 10, suppressAuth: true }),
            dataAccess.queryRecords(CONFIG.keys.matches, { sort: [{ field: 'timestamp', direction: 'desc' }], limit: 10, suppressAuth: true }),
            dataAccess.queryRecords(CONFIG.keys.drivers, { sort: [{ field: '_createdDate', direction: 'desc' }], limit: 5, suppressAuth: true })
        ]);

        const activities = [];
        (adminRes.items || []).forEach(a => activities.push({ type: 'admin_action', action: a.action, adminEmail: a.adminEmail, timestamp: a.timestamp, icon: 'admin_panel_settings', color: 'blue' }));
        (matchRes.items || []).forEach(m => activities.push({ type: 'match', driverName: m.driver_name, carrierName: m.carrier_name, score: m.match_score, timestamp: m.timestamp, icon: 'handshake', color: 'green' }));
        (driverRes.items || []).forEach(d => activities.push({ type: 'new_driver', name: `${d.firstName || ''} ${d.lastName || ''}`, timestamp: d._createdDate, icon: 'person_add', color: 'purple' }));

        return activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).slice(0, 15);
    } catch (error) { return []; }
}

// ============================================
// SYSTEM ALERTS
// ============================================

async function getSystemAlerts() {
    try {
        const result = await dataAccess.queryRecords(CONFIG.keys.alerts, { filters: { resolved: false }, sort: [{ field: 'createdAt', direction: 'desc' }], limit: 10, suppressAuth: true });
        const items = result.items || [];
        return { items, unresolvedCount: result.totalCount || items.length };
    } catch (error) { return { items: [], unresolvedCount: 0 }; }
}

// ============================================
// PLATFORM HEALTH
// ============================================

async function getPlatformHealth() {
    try {
        const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
        const [recentMatches, recentEnrichments] = await Promise.all([
            dataAccess.countRecords(CONFIG.keys.matches, { timestamp: { gte: hourAgo } }),
            dataAccess.countRecords(CONFIG.keys.enrichments, { enriched_date: { gte: hourAgo } })
        ]);
        const score = Math.round(((recentMatches > 0 ? 100 : 50) + (recentEnrichments >= 0 ? 100 : 75)) / 2);
        return { overall: score, status: score >= 90 ? 'healthy' : 'degraded', lastChecked: new Date() };
    } catch (error) { return { overall: 0, status: 'unknown' }; }
}

export async function resolveAlert(alertId) {
    await requireAdmin();
    try {
        const alert = await dataAccess.getRecord(CONFIG.keys.alerts, alertId, { suppressAuth: true });
        if (!alert) throw new Error('Not found');
        const member = await currentMember.getMember();
        const updated = await dataAccess.updateRecord(CONFIG.keys.alerts, { ...alert, resolved: true, resolvedBy: member?._id || 'admin', resolvedAt: new Date() }, { suppressAuth: true });
        return updated.record;
    } catch (error) { throw new Error('Failed to resolve alert'); }
}

export async function getQuickStats() {
    await requireAdmin();
    try {
        const [drivers, carriers, pending, flagged] = await Promise.all([
            dataAccess.countRecords(CONFIG.keys.drivers, {}),
            dataAccess.countRecords(CONFIG.keys.carriers, {}),
            dataAccess.countRecords(CONFIG.keys.drivers, { verificationStatus: 'in_review' }),
            dataAccess.countRecords(CONFIG.keys.carriers, { isFlagged: true })
        ]);
        return { drivers, carriers, pendingVerifications: pending, flaggedCarriers: flagged, needsAttention: pending + flagged };
    } catch (error) { throw new Error('Failed to fetch quick stats'); }
}

export async function getAIUsageStats(period = 'week') {
    await requireAdmin();
    try {
        const now = new Date();
        const days = period === 'month' ? 30 : (period === 'day' ? 1 : 7);
        const start = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);

        const res = await dataAccess.queryRecords(CONFIG.keys.aiUsageLog, { filters: { timestamp: { gte: start } }, limit: 1000, suppressAuth: true });
        const logs = res.items || [];

        const providerStats = {};
        let totalCost = 0, totalRequests = 0;

        for (const log of logs) {
            const p = log.provider || 'unknown';
            if (!providerStats[p]) providerStats[p] = { provider: p, requests: 0, tokens: 0, cost: 0 };
            providerStats[p].requests++; totalRequests++;
            const t = log.tokensUsed || 0; providerStats[p].tokens += t;
            const pricing = CONFIG.tokenPricing[p] || { input: 1.00, output: 1.00 };
            const cost = (t / 1000000) * ((pricing.input + pricing.output) / 2);
            providerStats[p].cost += cost; totalCost += cost;
        }

        return { period, summary: { totalRequests, totalCost: Math.round(totalCost * 100) / 100 }, byProvider: Object.values(providerStats) };
    } catch (error) { throw new Error('Failed to fetch AI usage stats'); }
}
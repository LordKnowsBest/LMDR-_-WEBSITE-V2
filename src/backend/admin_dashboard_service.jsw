/**
 * Admin Dashboard Service - Backend functions for Admin Dashboard Overview
 * Provides system-wide statistics, alerts, activity feeds, and health metrics
 */

import wixData from 'wix-data';
import { currentMember } from 'wix-members-backend';

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    collections: {
        drivers: 'DriverProfiles',
        carriers: 'Carriers',
        matches: 'MatchEvents',
        interests: 'DriverCarrierInterests',
        enrichments: 'CarrierEnrichments',
        safetyData: 'CarrierSafetyData',
        auditLog: 'AdminAuditLog',
        alerts: 'SystemAlerts',
        aiUsageLog: 'AIUsageLog'
    },
    // Token pricing per 1M tokens (approximate USD costs)
    tokenPricing: {
        anthropic: { input: 3.00, output: 15.00 },      // Claude Sonnet
        openai: { input: 2.50, output: 10.00 },         // GPT-4o
        groq: { input: 0.05, output: 0.10 },            // Llama via Groq
        perplexity: { input: 1.00, output: 1.00 },      // Sonar
        google: { input: 0.075, output: 0.30 },         // Gemini Flash
        mistral: { input: 2.00, output: 6.00 },         // Mistral Large
        cohere: { input: 0.50, output: 1.50 }           // Command R
    },
    // Monthly budget thresholds for alerts
    budgetThresholds: {
        warning: 100,   // $100 warning
        critical: 250   // $250 critical
    }
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;

        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';

        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) {
        console.error('Admin check failed:', error);
        return false;
    }
}

async function requireAdmin() {
    const authorized = await isAdmin();
    if (!authorized) {
        throw new Error('Unauthorized: Admin access required');
    }
}

// ============================================
// DASHBOARD OVERVIEW DATA
// ============================================

/**
 * Get comprehensive dashboard overview data
 * @returns {Promise<Object>} - Dashboard data
 */
export async function getDashboardOverview() {
    await requireAdmin();

    try {
        const [
            driverStats,
            carrierStats,
            matchStats,
            enrichmentStats,
            recentActivity,
            systemAlerts,
            platformHealth
        ] = await Promise.all([
            getDriverStats(),
            getCarrierStats(),
            getMatchStats(),
            getEnrichmentStats(),
            getRecentActivity(),
            getSystemAlerts(),
            getPlatformHealth()
        ]);

        return {
            drivers: driverStats,
            carriers: carrierStats,
            matches: matchStats,
            enrichment: enrichmentStats,
            activity: recentActivity,
            alerts: systemAlerts,
            health: platformHealth,
            generatedAt: new Date()
        };

    } catch (error) {
        console.error('Error fetching dashboard overview:', error);
        throw new Error('Failed to fetch dashboard data');
    }
}

// ============================================
// DRIVER STATISTICS
// ============================================

async function getDriverStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const [total, active, pending, newThisWeek, newThisMonth] = await Promise.all([
        wixData.query(CONFIG.collections.drivers).count(),
        wixData.query(CONFIG.collections.drivers).eq('status', 'active').count(),
        wixData.query(CONFIG.collections.drivers).eq('verificationStatus', 'in_review').count(),
        wixData.query(CONFIG.collections.drivers).ge('_createdDate', weekAgo).count(),
        wixData.query(CONFIG.collections.drivers).ge('_createdDate', monthAgo).count()
    ]);

    // Calculate week-over-week growth
    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
    const previousWeek = await wixData.query(CONFIG.collections.drivers)
        .ge('_createdDate', twoWeeksAgo)
        .lt('_createdDate', weekAgo)
        .count();

    const weeklyGrowth = previousWeek > 0
        ? Math.round(((newThisWeek - previousWeek) / previousWeek) * 100)
        : newThisWeek > 0 ? 100 : 0;

    return {
        total,
        active,
        pending,
        newThisWeek,
        newThisMonth,
        weeklyGrowth,
        activePercent: total > 0 ? Math.round((active / total) * 100) : 0
    };
}

// ============================================
// CARRIER STATISTICS
// ============================================

async function getCarrierStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [total, active, flagged, newThisWeek] = await Promise.all([
        wixData.query(CONFIG.collections.carriers).count(),
        wixData.query(CONFIG.collections.carriers).eq('status', 'active').count(),
        wixData.query(CONFIG.collections.carriers).eq('isFlagged', true).count(),
        wixData.query(CONFIG.collections.carriers).ge('_createdDate', weekAgo).count()
    ]);

    // Fleet size distribution
    const [small, medium, large] = await Promise.all([
        wixData.query(CONFIG.collections.carriers).lt('nbr_power_unit', 50).count(),
        wixData.query(CONFIG.collections.carriers).ge('nbr_power_unit', 50).lt('nbr_power_unit', 200).count(),
        wixData.query(CONFIG.collections.carriers).ge('nbr_power_unit', 200).count()
    ]);

    return {
        total,
        active,
        flagged,
        newThisWeek,
        fleetDistribution: { small, medium, large },
        activePercent: total > 0 ? Math.round((active / total) * 100) : 0
    };
}

// ============================================
// MATCH STATISTICS
// ============================================

async function getMatchStats() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const [totalMatches, todayMatches, weekMatches, monthMatches] = await Promise.all([
        wixData.query(CONFIG.collections.matches).count(),
        wixData.query(CONFIG.collections.matches).ge('timestamp', today).count(),
        wixData.query(CONFIG.collections.matches).ge('timestamp', weekAgo).count(),
        wixData.query(CONFIG.collections.matches).ge('timestamp', monthAgo).count()
    ]);

    // Driver interests/applications
    const [totalInterests, weekInterests] = await Promise.all([
        wixData.query(CONFIG.collections.interests).count(),
        wixData.query(CONFIG.collections.interests).ge('_createdDate', weekAgo).count()
    ]);

    // Calculate daily average
    const dailyAverage = Math.round(weekMatches / 7);

    return {
        total: totalMatches,
        today: todayMatches,
        thisWeek: weekMatches,
        thisMonth: monthMatches,
        dailyAverage,
        interests: {
            total: totalInterests,
            thisWeek: weekInterests
        }
    };
}

// ============================================
// ENRICHMENT STATISTICS
// ============================================

async function getEnrichmentStats() {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);

    const [totalEnrichments, totalCarriers] = await Promise.all([
        wixData.query(CONFIG.collections.enrichments).count(),
        wixData.query(CONFIG.collections.carriers).count()
    ]);

    // Fresh enrichments (< 7 days old)
    const freshEnrichments = await wixData.query(CONFIG.collections.enrichments)
        .ge('enriched_date', weekAgo)
        .count();

    // Stale enrichments (7-14 days old)
    const staleEnrichments = await wixData.query(CONFIG.collections.enrichments)
        .ge('enriched_date', twoWeeksAgo)
        .lt('enriched_date', weekAgo)
        .count();

    // Expired enrichments (> 14 days old)
    const expiredEnrichments = totalEnrichments - freshEnrichments - staleEnrichments;

    // Coverage percentage
    const coveragePercent = totalCarriers > 0
        ? Math.round((totalEnrichments / totalCarriers) * 100)
        : 0;

    return {
        total: totalEnrichments,
        fresh: freshEnrichments,
        stale: staleEnrichments,
        expired: Math.max(0, expiredEnrichments),
        coverage: coveragePercent,
        needsRefresh: staleEnrichments + Math.max(0, expiredEnrichments)
    };
}

// ============================================
// RECENT ACTIVITY
// ============================================

async function getRecentActivity() {
    try {
        // Get recent admin actions
        const adminActions = await wixData.query(CONFIG.collections.auditLog)
            .descending('timestamp')
            .limit(10)
            .find({ suppressAuth: true });

        // Get recent matches
        const recentMatches = await wixData.query(CONFIG.collections.matches)
            .descending('timestamp')
            .limit(10)
            .find();

        // Get recent driver registrations
        const recentDrivers = await wixData.query(CONFIG.collections.drivers)
            .descending('_createdDate')
            .limit(5)
            .find();

        // Combine and sort by timestamp
        const activities = [];

        for (const action of adminActions.items) {
            activities.push({
                type: 'admin_action',
                action: action.action,
                targetType: action.targetType,
                adminEmail: action.adminEmail,
                timestamp: action.timestamp,
                icon: 'admin_panel_settings',
                color: 'blue'
            });
        }

        for (const match of recentMatches.items) {
            activities.push({
                type: 'match',
                driverName: match.driver_name || 'Anonymous',
                carrierName: match.carrier_name,
                score: match.match_score,
                timestamp: match.timestamp,
                icon: 'handshake',
                color: 'green'
            });
        }

        for (const driver of recentDrivers.items) {
            activities.push({
                type: 'new_driver',
                name: `${driver.firstName || ''} ${driver.lastName || ''}`.trim() || 'New Driver',
                email: driver.email,
                timestamp: driver._createdDate,
                icon: 'person_add',
                color: 'purple'
            });
        }

        // Sort by timestamp descending
        activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        return activities.slice(0, 15);

    } catch (error) {
        console.error('Error fetching recent activity:', error);
        return [];
    }
}

// ============================================
// SYSTEM ALERTS
// ============================================

async function getSystemAlerts() {
    try {
        // Get unresolved alerts
        const alerts = await wixData.query(CONFIG.collections.alerts)
            .eq('resolved', false)
            .descending('createdAt')
            .limit(10)
            .find({ suppressAuth: true });

        // Also generate dynamic alerts based on system state
        const dynamicAlerts = [];

        // Check for pending driver verifications
        const pendingVerifications = await wixData.query(CONFIG.collections.drivers)
            .eq('verificationStatus', 'in_review')
            .count();

        if (pendingVerifications > 5) {
            dynamicAlerts.push({
                type: 'warning',
                category: 'compliance',
                title: 'Pending Verifications',
                message: `${pendingVerifications} drivers awaiting document verification`,
                createdAt: new Date(),
                isDynamic: true
            });
        }

        // Check for flagged carriers
        const flaggedCarriers = await wixData.query(CONFIG.collections.carriers)
            .eq('isFlagged', true)
            .count();

        if (flaggedCarriers > 0) {
            dynamicAlerts.push({
                type: 'warning',
                category: 'compliance',
                title: 'Flagged Carriers',
                message: `${flaggedCarriers} carriers flagged for review`,
                createdAt: new Date(),
                isDynamic: true
            });
        }

        // Check for stale enrichments
        const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
        const expiredEnrichments = await wixData.query(CONFIG.collections.enrichments)
            .lt('enriched_date', twoWeeksAgo)
            .count();

        if (expiredEnrichments > 10) {
            dynamicAlerts.push({
                type: 'info',
                category: 'enrichment',
                title: 'Stale Enrichments',
                message: `${expiredEnrichments} carrier enrichments need refresh`,
                createdAt: new Date(),
                isDynamic: true
            });
        }

        // Combine stored and dynamic alerts
        const allAlerts = [...alerts.items, ...dynamicAlerts];
        allAlerts.sort((a, b) => {
            const typeOrder = { critical: 0, warning: 1, info: 2 };
            return (typeOrder[a.type] || 3) - (typeOrder[b.type] || 3);
        });

        return {
            items: allAlerts.slice(0, 10),
            unresolvedCount: alerts.totalCount + dynamicAlerts.length
        };

    } catch (error) {
        console.error('Error fetching system alerts:', error);
        return { items: [], unresolvedCount: 0 };
    }
}

// ============================================
// PLATFORM HEALTH
// ============================================

async function getPlatformHealth() {
    try {
        const now = new Date();
        const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);

        // Check recent activity as proxy for health
        const recentMatches = await wixData.query(CONFIG.collections.matches)
            .ge('timestamp', hourAgo)
            .count();

        // Check enrichment system
        const recentEnrichments = await wixData.query(CONFIG.collections.enrichments)
            .ge('enriched_date', hourAgo)
            .count();

        // Calculate health scores
        const matchingHealth = recentMatches > 0 ? 100 : 50;
        const enrichmentHealth = recentEnrichments >= 0 ? 100 : 75; // Enrichment may not run every hour

        // Overall health
        const overallHealth = Math.round((matchingHealth + enrichmentHealth) / 2);

        return {
            overall: overallHealth,
            status: overallHealth >= 90 ? 'healthy' : overallHealth >= 70 ? 'degraded' : 'unhealthy',
            services: {
                matching: { status: matchingHealth >= 90 ? 'up' : 'degraded', score: matchingHealth },
                enrichment: { status: enrichmentHealth >= 90 ? 'up' : 'degraded', score: enrichmentHealth },
                database: { status: 'up', score: 100 } // If we got here, DB is working
            },
            lastChecked: now
        };

    } catch (error) {
        console.error('Error checking platform health:', error);
        return {
            overall: 0,
            status: 'unknown',
            services: {},
            error: error.message
        };
    }
}

// ============================================
// RESOLVE ALERT
// ============================================

/**
 * Mark an alert as resolved
 * @param {string} alertId - Alert ID
 * @returns {Promise<Object>} - Updated alert
 */
export async function resolveAlert(alertId) {
    await requireAdmin();

    try {
        const alert = await wixData.get(CONFIG.collections.alerts, alertId);
        if (!alert) {
            throw new Error('Alert not found');
        }

        const member = await currentMember.getMember();

        alert.resolved = true;
        alert.resolvedBy = member?._id || 'admin';
        alert.resolvedAt = new Date();

        const updated = await wixData.update(CONFIG.collections.alerts, alert, { suppressAuth: true });

        return updated;

    } catch (error) {
        console.error('Error resolving alert:', error);
        throw new Error('Failed to resolve alert');
    }
}

// ============================================
// QUICK STATS (Lightweight)
// ============================================

/**
 * Get quick stats for header display
 * @returns {Promise<Object>} - Quick stats
 */
export async function getQuickStats() {
    await requireAdmin();

    try {
        const [drivers, carriers, pendingVerifications, flaggedCarriers] = await Promise.all([
            wixData.query(CONFIG.collections.drivers).count(),
            wixData.query(CONFIG.collections.carriers).count(),
            wixData.query(CONFIG.collections.drivers).eq('verificationStatus', 'in_review').count(),
            wixData.query(CONFIG.collections.carriers).eq('isFlagged', true).count()
        ]);

        return {
            drivers,
            carriers,
            pendingVerifications,
            flaggedCarriers,
            needsAttention: pendingVerifications + flaggedCarriers
        };

    } catch (error) {
        console.error('Error fetching quick stats:', error);
        throw new Error('Failed to fetch quick stats');
    }
}

// ============================================
// ACTIVITY CHART DATA
// ============================================

/**
 * Get activity data for charts
 * @param {string} period - 'week' or 'month'
 * @returns {Promise<Object>} - Chart data
 */
export async function getActivityChartData(period = 'week') {
    await requireAdmin();

    try {
        const now = new Date();
        const days = period === 'month' ? 30 : 7;
        const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);

        // Get matches in period
        const matches = await wixData.query(CONFIG.collections.matches)
            .ge('timestamp', startDate)
            .ascending('timestamp')
            .limit(1000)
            .find();

        // Get new drivers in period
        const drivers = await wixData.query(CONFIG.collections.drivers)
            .ge('_createdDate', startDate)
            .ascending('_createdDate')
            .limit(1000)
            .find();

        // Group by day
        const matchesByDay = {};
        const driversByDay = {};

        for (let i = 0; i < days; i++) {
            const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);
            const key = date.toISOString().split('T')[0];
            matchesByDay[key] = 0;
            driversByDay[key] = 0;
        }

        for (const match of matches.items) {
            const key = new Date(match.timestamp).toISOString().split('T')[0];
            if (matchesByDay[key] !== undefined) {
                matchesByDay[key]++;
            }
        }

        for (const driver of drivers.items) {
            const key = new Date(driver._createdDate).toISOString().split('T')[0];
            if (driversByDay[key] !== undefined) {
                driversByDay[key]++;
            }
        }

        return {
            labels: Object.keys(matchesByDay),
            matches: Object.values(matchesByDay),
            drivers: Object.values(driversByDay)
        };

    } catch (error) {
        console.error('Error fetching chart data:', error);
        throw new Error('Failed to fetch chart data');
    }
}

// ============================================
// AI/LLM USAGE STATISTICS
// ============================================

/**
 * Get comprehensive AI usage statistics
 * @param {string} period - 'day', 'week', or 'month'
 * @returns {Promise<Object>} - AI usage data
 */
export async function getAIUsageStats(period = 'week') {
    await requireAdmin();

    try {
        const now = new Date();
        let startDate;

        switch (period) {
            case 'day':
                startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                break;
            case 'month':
                startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                break;
            default: // week
                startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        }

        // Fetch usage logs for the period
        const usageLogs = await wixData.query(CONFIG.collections.aiUsageLog)
            .ge('timestamp', startDate)
            .limit(1000)
            .find({ suppressAuth: true });

        // Calculate stats by provider
        const providerStats = {};
        let totalTokens = 0;
        let totalCost = 0;
        let totalRequests = 0;
        let totalErrors = 0;
        let totalLatency = 0;

        for (const log of usageLogs.items) {
            const provider = log.provider || 'unknown';

            if (!providerStats[provider]) {
                providerStats[provider] = {
                    provider,
                    name: getProviderDisplayName(provider),
                    requests: 0,
                    tokens: 0,
                    inputTokens: 0,
                    outputTokens: 0,
                    cost: 0,
                    errors: 0,
                    avgLatency: 0,
                    totalLatency: 0,
                    fallbackCount: 0
                };
            }

            const stats = providerStats[provider];
            stats.requests++;
            totalRequests++;

            // Token counts
            const tokens = log.tokensUsed || 0;
            const inputTokens = log.inputTokens || Math.floor(tokens * 0.3);
            const outputTokens = log.outputTokens || Math.floor(tokens * 0.7);

            stats.tokens += tokens;
            stats.inputTokens += inputTokens;
            stats.outputTokens += outputTokens;
            totalTokens += tokens;

            // Calculate cost based on token pricing
            const pricing = CONFIG.tokenPricing[provider] || { input: 1.00, output: 1.00 };
            const cost = ((inputTokens / 1000000) * pricing.input) + ((outputTokens / 1000000) * pricing.output);
            stats.cost += cost;
            totalCost += cost;

            // Latency
            if (log.latencyMs) {
                stats.totalLatency += log.latencyMs;
                totalLatency += log.latencyMs;
            }

            // Errors
            if (log.error) {
                stats.errors++;
                totalErrors++;
            }

            // Fallback usage
            if (log.usedFallback) {
                stats.fallbackCount++;
            }
        }

        // Calculate averages
        for (const provider in providerStats) {
            const stats = providerStats[provider];
            stats.avgLatency = stats.requests > 0 ? Math.round(stats.totalLatency / stats.requests) : 0;
            stats.errorRate = stats.requests > 0 ? Math.round((stats.errors / stats.requests) * 100) : 0;
            stats.cost = Math.round(stats.cost * 100) / 100; // Round to 2 decimals
            delete stats.totalLatency; // Clean up
        }

        // Sort providers by cost (highest first)
        const sortedProviders = Object.values(providerStats).sort((a, b) => b.cost - a.cost);

        // Calculate budget status
        const monthlyProjection = period === 'month' ? totalCost : (totalCost * (30 / (period === 'day' ? 1 : 7)));
        const budgetStatus = getBudgetStatus(monthlyProjection);

        // Get usage by function
        const functionStats = await getFunctionUsageStats(startDate);

        // Get usage trends
        const usageTrends = await getUsageTrends(startDate, period);

        return {
            period,
            startDate,
            endDate: now,
            summary: {
                totalRequests,
                totalTokens,
                totalCost: Math.round(totalCost * 100) / 100,
                totalErrors,
                errorRate: totalRequests > 0 ? Math.round((totalErrors / totalRequests) * 100) : 0,
                avgLatency: totalRequests > 0 ? Math.round(totalLatency / totalRequests) : 0,
                monthlyProjection: Math.round(monthlyProjection * 100) / 100,
                budgetStatus
            },
            byProvider: sortedProviders,
            byFunction: functionStats,
            trends: usageTrends
        };

    } catch (error) {
        console.error('Error fetching AI usage stats:', error);
        throw new Error('Failed to fetch AI usage statistics');
    }
}

/**
 * Get provider display name
 */
function getProviderDisplayName(providerId) {
    const names = {
        anthropic: 'Claude (Anthropic)',
        openai: 'GPT (OpenAI)',
        groq: 'Groq (Fast)',
        perplexity: 'Perplexity',
        google: 'Gemini (Google)',
        mistral: 'Mistral',
        cohere: 'Cohere'
    };
    return names[providerId] || providerId;
}

/**
 * Get budget status based on projected monthly spend
 */
function getBudgetStatus(monthlyProjection) {
    if (monthlyProjection >= CONFIG.budgetThresholds.critical) {
        return {
            status: 'critical',
            message: 'Projected spend exceeds critical threshold',
            percentOfWarning: Math.round((monthlyProjection / CONFIG.budgetThresholds.warning) * 100),
            percentOfCritical: Math.round((monthlyProjection / CONFIG.budgetThresholds.critical) * 100)
        };
    } else if (monthlyProjection >= CONFIG.budgetThresholds.warning) {
        return {
            status: 'warning',
            message: 'Projected spend exceeds warning threshold',
            percentOfWarning: Math.round((monthlyProjection / CONFIG.budgetThresholds.warning) * 100),
            percentOfCritical: Math.round((monthlyProjection / CONFIG.budgetThresholds.critical) * 100)
        };
    } else {
        return {
            status: 'healthy',
            message: 'Spend within budget',
            percentOfWarning: Math.round((monthlyProjection / CONFIG.budgetThresholds.warning) * 100),
            percentOfCritical: Math.round((monthlyProjection / CONFIG.budgetThresholds.critical) * 100)
        };
    }
}

/**
 * Get usage statistics by function
 */
async function getFunctionUsageStats(startDate) {
    try {
        const logs = await wixData.query(CONFIG.collections.aiUsageLog)
            .ge('timestamp', startDate)
            .limit(1000)
            .find({ suppressAuth: true });

        const functionStats = {};

        for (const log of logs.items) {
            const functionId = log.functionId || 'unknown';

            if (!functionStats[functionId]) {
                functionStats[functionId] = {
                    functionId,
                    name: getFunctionDisplayName(functionId),
                    requests: 0,
                    tokens: 0,
                    cost: 0,
                    avgLatency: 0,
                    totalLatency: 0
                };
            }

            const stats = functionStats[functionId];
            stats.requests++;
            stats.tokens += log.tokensUsed || 0;

            // Calculate cost
            const provider = log.provider || 'anthropic';
            const pricing = CONFIG.tokenPricing[provider] || { input: 1.00, output: 1.00 };
            const inputTokens = log.inputTokens || Math.floor((log.tokensUsed || 0) * 0.3);
            const outputTokens = log.outputTokens || Math.floor((log.tokensUsed || 0) * 0.7);
            stats.cost += ((inputTokens / 1000000) * pricing.input) + ((outputTokens / 1000000) * pricing.output);

            if (log.latencyMs) {
                stats.totalLatency += log.latencyMs;
            }
        }

        // Calculate averages
        for (const func in functionStats) {
            const stats = functionStats[func];
            stats.avgLatency = stats.requests > 0 ? Math.round(stats.totalLatency / stats.requests) : 0;
            stats.cost = Math.round(stats.cost * 100) / 100;
            delete stats.totalLatency;
        }

        return Object.values(functionStats).sort((a, b) => b.requests - a.requests);

    } catch (error) {
        console.error('Error fetching function usage stats:', error);
        return [];
    }
}

/**
 * Get function display name
 */
function getFunctionDisplayName(functionId) {
    const names = {
        carrier_synthesis: 'Carrier Synthesis',
        web_research: 'Web Research',
        social_scanning: 'Social Scanning',
        document_ocr: 'Document OCR',
        quick_classification: 'Quick Classification',
        sentiment_analysis: 'Sentiment Analysis',
        driver_chat: 'Driver Chat',
        admin_assistant: 'Admin Assistant',
        data_extraction: 'Data Extraction',
        translation: 'Translation',
        embeddings: 'Embeddings'
    };
    return names[functionId] || functionId;
}

/**
 * Get usage trends over time
 */
async function getUsageTrends(startDate, period) {
    try {
        const logs = await wixData.query(CONFIG.collections.aiUsageLog)
            .ge('timestamp', startDate)
            .ascending('timestamp')
            .limit(1000)
            .find({ suppressAuth: true });

        // Determine grouping interval
        const days = period === 'day' ? 1 : period === 'month' ? 30 : 7;
        const intervalHours = days === 1 ? 1 : days === 30 ? 24 : 6; // Hourly for day, daily for month, 6-hourly for week

        const trends = {};
        const now = new Date();

        // Initialize buckets
        if (days === 1) {
            for (let i = 0; i < 24; i++) {
                const hour = new Date(startDate.getTime() + i * 60 * 60 * 1000);
                const key = hour.toISOString().slice(0, 13); // YYYY-MM-DDTHH
                trends[key] = { label: `${i}:00`, requests: 0, tokens: 0, cost: 0 };
            }
        } else {
            for (let i = 0; i < days; i++) {
                const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);
                const key = date.toISOString().split('T')[0];
                trends[key] = { label: key, requests: 0, tokens: 0, cost: 0 };
            }
        }

        // Aggregate data
        for (const log of logs.items) {
            const timestamp = new Date(log.timestamp);
            const key = days === 1
                ? timestamp.toISOString().slice(0, 13)
                : timestamp.toISOString().split('T')[0];

            if (trends[key]) {
                trends[key].requests++;
                trends[key].tokens += log.tokensUsed || 0;

                const provider = log.provider || 'anthropic';
                const pricing = CONFIG.tokenPricing[provider] || { input: 1.00, output: 1.00 };
                const inputTokens = log.inputTokens || Math.floor((log.tokensUsed || 0) * 0.3);
                const outputTokens = log.outputTokens || Math.floor((log.tokensUsed || 0) * 0.7);
                trends[key].cost += ((inputTokens / 1000000) * pricing.input) + ((outputTokens / 1000000) * pricing.output);
            }
        }

        // Convert to arrays for charting
        const labels = [];
        const requests = [];
        const tokens = [];
        const costs = [];

        for (const key of Object.keys(trends).sort()) {
            labels.push(trends[key].label);
            requests.push(trends[key].requests);
            tokens.push(trends[key].tokens);
            costs.push(Math.round(trends[key].cost * 100) / 100);
        }

        return { labels, requests, tokens, costs };

    } catch (error) {
        console.error('Error fetching usage trends:', error);
        return { labels: [], requests: [], tokens: [], costs: [] };
    }
}

/**
 * Get AI health check for dashboard
 */
export async function getAIHealthCheck() {
    await requireAdmin();

    try {
        const hourAgo = new Date(Date.now() - 60 * 60 * 1000);

        // Get recent logs
        const recentLogs = await wixData.query(CONFIG.collections.aiUsageLog)
            .ge('timestamp', hourAgo)
            .limit(100)
            .find({ suppressAuth: true });

        if (recentLogs.items.length === 0) {
            return {
                status: 'idle',
                message: 'No AI activity in the last hour',
                providers: {}
            };
        }

        const providerHealth = {};
        let hasErrors = false;
        let hasSlowResponses = false;

        for (const log of recentLogs.items) {
            const provider = log.provider || 'unknown';

            if (!providerHealth[provider]) {
                providerHealth[provider] = {
                    requests: 0,
                    errors: 0,
                    avgLatency: 0,
                    totalLatency: 0,
                    status: 'healthy'
                };
            }

            providerHealth[provider].requests++;
            providerHealth[provider].totalLatency += log.latencyMs || 0;

            if (log.error) {
                providerHealth[provider].errors++;
                hasErrors = true;
            }
        }

        // Calculate health status for each provider
        for (const provider in providerHealth) {
            const health = providerHealth[provider];
            health.avgLatency = Math.round(health.totalLatency / health.requests);
            health.errorRate = Math.round((health.errors / health.requests) * 100);
            delete health.totalLatency;

            if (health.errorRate > 50) {
                health.status = 'critical';
            } else if (health.errorRate > 10 || health.avgLatency > 5000) {
                health.status = 'degraded';
                hasSlowResponses = true;
            }
        }

        let overallStatus = 'healthy';
        if (hasErrors && Object.values(providerHealth).some(p => p.status === 'critical')) {
            overallStatus = 'critical';
        } else if (hasErrors || hasSlowResponses) {
            overallStatus = 'degraded';
        }

        return {
            status: overallStatus,
            message: overallStatus === 'healthy'
                ? 'All AI providers operating normally'
                : overallStatus === 'degraded'
                    ? 'Some providers experiencing issues'
                    : 'Critical issues detected with AI providers',
            providers: providerHealth,
            lastChecked: new Date()
        };

    } catch (error) {
        console.error('Error checking AI health:', error);
        return {
            status: 'unknown',
            message: 'Unable to check AI health',
            error: error.message
        };
    }
}

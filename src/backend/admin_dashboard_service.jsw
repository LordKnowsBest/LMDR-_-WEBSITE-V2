/**
 * Admin Dashboard Service - Backend functions for Admin Dashboard Overview
 * Provides system-wide statistics, alerts, activity feeds, and health metrics
 *
 * DUAL-SOURCE SUPPORT: This service supports both Wix and Airtable data sources.
 * The data source is determined by the config.jsw configuration.
 *
 * Collections used:
 * - DriverProfiles (drivers)
 * - Carriers (carriers)
 * - MatchEvents (matches)
 * - DriverCarrierInterests (interests)
 * - CarrierEnrichments (enrichments)
 * - CarrierSafetyData (safetyData)
 * - AdminAuditLog (auditLog)
 * - SystemAlerts (alerts)
 * - AIUsageLog (aiUsageLog)
 */

import wixData from 'wix-data';
import { currentMember } from 'wix-members-backend';
import { getDataSource, getWixCollectionName, getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    // Collection config keys mapped to Wix collection names
    // These keys are used with getDataSource() to check the data source
    collections: {
        drivers: 'DriverProfiles',
        carriers: 'Carriers',
        matches: 'MatchEvents',
        interests: 'DriverCarrierInterests',
        enrichments: 'CarrierEnrichments',
        safetyData: 'CarrierSafetyData',
        auditLog: 'AdminAuditLog',
        alerts: 'SystemAlerts',
        aiUsageLog: 'AIUsageLog'
    },
    // Config keys for data source lookup (camelCase)
    configKeys: {
        drivers: 'driverProfiles',
        carriers: 'carriers',
        matches: 'matchEvents',
        interests: 'driverCarrierInterests',
        enrichments: 'carrierEnrichments',
        safetyData: 'carrierSafetyData',
        auditLog: 'auditLog',
        alerts: 'systemAlerts',
        aiUsageLog: 'aiUsageLog'
    },
    // Token pricing per 1M tokens (approximate USD costs)
    tokenPricing: {
        anthropic: { input: 3.00, output: 15.00 },      // Claude Sonnet
        openai: { input: 2.50, output: 10.00 },         // GPT-4o
        groq: { input: 0.05, output: 0.10 },            // Llama via Groq
        perplexity: { input: 1.00, output: 1.00 },      // Sonar
        google: { input: 0.075, output: 0.30 },         // Gemini Flash
        mistral: { input: 2.00, output: 6.00 },         // Mistral Large
        cohere: { input: 0.50, output: 1.50 }           // Command R
    },
    // Monthly budget thresholds for alerts
    budgetThresholds: {
        warning: 100,   // $100 warning
        critical: 250   // $250 critical
    }
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;

        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';

        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) {
        console.error('Admin check failed:', error);
        return false;
    }
}

async function requireAdmin() {
    const authorized = await isAdmin();
    if (!authorized) {
        throw new Error('Unauthorized: Admin access required');
    }
}

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

/**
 * Get the data source for a collection
 * @param {string} collectionKey - Key from CONFIG.configKeys
 * @returns {'wix' | 'airtable'}
 */
function getSource(collectionKey) {
    const configKey = CONFIG.configKeys[collectionKey];
    return getDataSource(configKey);
}

/**
 * Query and count records from appropriate data source
 * @param {string} collectionKey - Key from CONFIG.collections
 * @param {Object} options - Query options
 * @returns {Promise<number>} Count of matching records
 */
async function countFromSource(collectionKey, options = {}) {
    const configKey = CONFIG.configKeys[collectionKey];
    const collectionName = CONFIG.collections[collectionKey];

    if (getDataSource(configKey) === 'airtable') {
        // Build Airtable filter formula
        let filterFormula = '';
        const conditions = [];

        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                const airtableField = field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                if (typeof value === 'string') {
                    conditions.push(`{${airtableField}} = '${value}'`);
                } else if (typeof value === 'boolean') {
                    conditions.push(`{${airtableField}} = ${value ? 'TRUE()' : 'FALSE()'}`);
                } else {
                    conditions.push(`{${airtableField}} = ${value}`);
                }
            }
        }

        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                const airtableField = field === '_createdDate' ? 'Created' : field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                if (value instanceof Date) {
                    conditions.push(`IS_AFTER({${airtableField}}, '${value.toISOString()}')`);
                } else {
                    conditions.push(`{${airtableField}} >= ${value}`);
                }
            }
        }

        if (options.lt) {
            for (const [field, value] of Object.entries(options.lt)) {
                const airtableField = field === '_createdDate' ? 'Created' : field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                if (value instanceof Date) {
                    conditions.push(`IS_BEFORE({${airtableField}}, '${value.toISOString()}')`);
                } else {
                    conditions.push(`{${airtableField}} < ${value}`);
                }
            }
        }

        if (conditions.length > 0) {
            filterFormula = conditions.length === 1 ? conditions[0] : `AND(${conditions.join(', ')})`;
        }

        const records = await airtable.getAllRecords(collectionName, filterFormula || null);
        return records.length;
    } else {
        // Wix Data source
        let query = wixData.query(collectionName);

        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                query = query.eq(field, value);
            }
        }

        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                query = query.ge(field, value);
            }
        }

        if (options.lt) {
            for (const [field, value] of Object.entries(options.lt)) {
                query = query.lt(field, value);
            }
        }

        return await query.count();
    }
}

/**
 * Query records from appropriate data source
 * @param {string} collectionKey - Key from CONFIG.collections
 * @param {Object} options - Query options
 * @returns {Promise<Object>} Query result with items
 */
async function queryFromSource(collectionKey, options = {}) {
    const configKey = CONFIG.configKeys[collectionKey];
    const collectionName = CONFIG.collections[collectionKey];

    if (getDataSource(configKey) === 'airtable') {
        // Build Airtable query options
        const airtableOptions = {};
        const conditions = [];

        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                const airtableField = field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                if (typeof value === 'string') {
                    conditions.push(`{${airtableField}} = '${value}'`);
                } else if (typeof value === 'boolean') {
                    conditions.push(`{${airtableField}} = ${value ? 'TRUE()' : 'FALSE()'}`);
                } else {
                    conditions.push(`{${airtableField}} = ${value}`);
                }
            }
        }

        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                const airtableField = field === '_createdDate' ? 'Created' :
                                     field === 'timestamp' ? 'Timestamp' :
                                     field === 'enriched_date' ? 'Enriched Date' :
                                     field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                if (value instanceof Date) {
                    conditions.push(`IS_AFTER({${airtableField}}, '${value.toISOString()}')`);
                } else {
                    conditions.push(`{${airtableField}} >= ${value}`);
                }
            }
        }

        if (options.lt) {
            for (const [field, value] of Object.entries(options.lt)) {
                const airtableField = field === '_createdDate' ? 'Created' :
                                     field === 'timestamp' ? 'Timestamp' :
                                     field === 'enriched_date' ? 'Enriched Date' :
                                     field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                if (value instanceof Date) {
                    conditions.push(`IS_BEFORE({${airtableField}}, '${value.toISOString()}')`);
                } else {
                    conditions.push(`{${airtableField}} < ${value}`);
                }
            }
        }

        if (conditions.length > 0) {
            airtableOptions.filterByFormula = conditions.length === 1 ? conditions[0] : `AND(${conditions.join(', ')})`;
        }

        if (options.limit) {
            airtableOptions.maxRecords = options.limit;
        }

        if (options.sortField) {
            const airtableSortField = options.sortField === '_createdDate' ? 'Created' :
                                     options.sortField === 'timestamp' ? 'Timestamp' :
                                     options.sortField.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
            airtableOptions.sort = [{
                field: airtableSortField,
                direction: options.sortDirection || 'desc'
            }];
        }

        const result = await airtable.queryRecords(collectionName, airtableOptions);
        return {
            items: result.records || [],
            totalCount: result.records?.length || 0
        };
    } else {
        // Wix Data source
        let query = wixData.query(collectionName);

        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                query = query.eq(field, value);
            }
        }

        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                query = query.ge(field, value);
            }
        }

        if (options.lt) {
            for (const [field, value] of Object.entries(options.lt)) {
                query = query.lt(field, value);
            }
        }

        if (options.sortField) {
            if (options.sortDirection === 'asc') {
                query = query.ascending(options.sortField);
            } else {
                query = query.descending(options.sortField);
            }
        }

        if (options.limit) {
            query = query.limit(options.limit);
        }

        const findOptions = options.suppressAuth ? { suppressAuth: true } : {};
        return await query.find(findOptions);
    }
}

/**
 * Get a single record by ID from appropriate data source
 * @param {string} collectionKey - Key from CONFIG.collections
 * @param {string} recordId - Record ID
 * @returns {Promise<Object|null>} Record or null
 */
async function getFromSource(collectionKey, recordId) {
    const configKey = CONFIG.configKeys[collectionKey];
    const collectionName = CONFIG.collections[collectionKey];

    if (getDataSource(configKey) === 'airtable') {
        const result = await airtable.getRecord(collectionName, recordId);
        return result.error ? null : result;
    } else {
        return await wixData.get(collectionName, recordId);
    }
}

/**
 * Update a record in appropriate data source
 * @param {string} collectionKey - Key from CONFIG.collections
 * @param {Object} record - Record to update (must include _id)
 * @param {Object} options - Update options
 * @returns {Promise<Object>} Updated record
 */
async function updateInSource(collectionKey, record, options = {}) {
    const configKey = CONFIG.configKeys[collectionKey];
    const collectionName = CONFIG.collections[collectionKey];

    if (getDataSource(configKey) === 'airtable') {
        const { _id, ...fields } = record;
        return await airtable.updateRecord(collectionName, _id, fields);
    } else {
        const updateOptions = options.suppressAuth ? { suppressAuth: true } : {};
        return await wixData.update(collectionName, record, updateOptions);
    }
}

// ============================================
// DASHBOARD OVERVIEW DATA
// ============================================

/**
 * Get comprehensive dashboard overview data
 * @returns {Promise<Object>} - Dashboard data
 */
export async function getDashboardOverview() {
    await requireAdmin();

    try {
        const [
            driverStats,
            carrierStats,
            matchStats,
            enrichmentStats,
            recentActivity,
            systemAlerts,
            platformHealth
        ] = await Promise.all([
            getDriverStats(),
            getCarrierStats(),
            getMatchStats(),
            getEnrichmentStats(),
            getRecentActivity(),
            getSystemAlerts(),
            getPlatformHealth()
        ]);

        return {
            drivers: driverStats,
            carriers: carrierStats,
            matches: matchStats,
            enrichment: enrichmentStats,
            activity: recentActivity,
            alerts: systemAlerts,
            health: platformHealth,
            generatedAt: new Date()
        };

    } catch (error) {
        console.error('Error fetching dashboard overview:', error);
        throw new Error('Failed to fetch dashboard data');
    }
}

// ============================================
// DRIVER STATISTICS
// ============================================

async function getDriverStats() {
    // Collection: DriverProfiles (drivers)
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const [total, active, pending, newThisWeek, newThisMonth] = await Promise.all([
        countFromSource('drivers', {}),
        countFromSource('drivers', { eq: { status: 'active' } }),
        countFromSource('drivers', { eq: { verificationStatus: 'in_review' } }),
        countFromSource('drivers', { ge: { _createdDate: weekAgo } }),
        countFromSource('drivers', { ge: { _createdDate: monthAgo } })
    ]);

    // Calculate week-over-week growth
    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
    const previousWeek = await countFromSource('drivers', {
        ge: { _createdDate: twoWeeksAgo },
        lt: { _createdDate: weekAgo }
    });

    const weeklyGrowth = previousWeek > 0
        ? Math.round(((newThisWeek - previousWeek) / previousWeek) * 100)
        : newThisWeek > 0 ? 100 : 0;

    return {
        total,
        active,
        pending,
        newThisWeek,
        newThisMonth,
        weeklyGrowth,
        activePercent: total > 0 ? Math.round((active / total) * 100) : 0
    };
}

// ============================================
// CARRIER STATISTICS
// ============================================

async function getCarrierStats() {
    // Collection: Carriers (carriers)
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [total, active, flagged, newThisWeek] = await Promise.all([
        countFromSource('carriers', {}),
        countFromSource('carriers', { eq: { status: 'active' } }),
        countFromSource('carriers', { eq: { isFlagged: true } }),
        countFromSource('carriers', { ge: { _createdDate: weekAgo } })
    ]);

    // Fleet size distribution - for Airtable, we need a different approach
    const configKey = CONFIG.configKeys.carriers;
    let small = 0, medium = 0, large = 0;

    if (getDataSource(configKey) === 'airtable') {
        // For Airtable, fetch all carriers and count locally
        const allCarriers = await airtable.getAllRecords(CONFIG.collections.carriers);
        for (const carrier of allCarriers) {
            const units = carrier.nbr_power_unit || carrier.total_power_units || 0;
            if (units < 50) small++;
            else if (units < 200) medium++;
            else large++;
        }
    } else {
        // Wix Data source
        [small, medium, large] = await Promise.all([
            wixData.query(CONFIG.collections.carriers).lt('nbr_power_unit', 50).count(),
            wixData.query(CONFIG.collections.carriers).ge('nbr_power_unit', 50).lt('nbr_power_unit', 200).count(),
            wixData.query(CONFIG.collections.carriers).ge('nbr_power_unit', 200).count()
        ]);
    }

    return {
        total,
        active,
        flagged,
        newThisWeek,
        fleetDistribution: { small, medium, large },
        activePercent: total > 0 ? Math.round((active / total) * 100) : 0
    };
}

// ============================================
// MATCH STATISTICS
// ============================================

async function getMatchStats() {
    // Collections: MatchEvents (matches), DriverCarrierInterests (interests)
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const [totalMatches, todayMatches, weekMatches, monthMatches] = await Promise.all([
        countFromSource('matches', {}),
        countFromSource('matches', { ge: { timestamp: today } }),
        countFromSource('matches', { ge: { timestamp: weekAgo } }),
        countFromSource('matches', { ge: { timestamp: monthAgo } })
    ]);

    // Driver interests/applications
    const [totalInterests, weekInterests] = await Promise.all([
        countFromSource('interests', {}),
        countFromSource('interests', { ge: { _createdDate: weekAgo } })
    ]);

    // Calculate daily average
    const dailyAverage = Math.round(weekMatches / 7);

    return {
        total: totalMatches,
        today: todayMatches,
        thisWeek: weekMatches,
        thisMonth: monthMatches,
        dailyAverage,
        interests: {
            total: totalInterests,
            thisWeek: weekInterests
        }
    };
}

// ============================================
// ENRICHMENT STATISTICS
// ============================================

async function getEnrichmentStats() {
    // Collections: CarrierEnrichments (enrichments), Carriers (carriers)
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);

    const [totalEnrichments, totalCarriers] = await Promise.all([
        countFromSource('enrichments', {}),
        countFromSource('carriers', {})
    ]);

    // Fresh enrichments (< 7 days old)
    const freshEnrichments = await countFromSource('enrichments', {
        ge: { enriched_date: weekAgo }
    });

    // Stale enrichments (7-14 days old)
    const staleEnrichments = await countFromSource('enrichments', {
        ge: { enriched_date: twoWeeksAgo },
        lt: { enriched_date: weekAgo }
    });

    // Expired enrichments (> 14 days old)
    const expiredEnrichments = totalEnrichments - freshEnrichments - staleEnrichments;

    // Coverage percentage
    const coveragePercent = totalCarriers > 0
        ? Math.round((totalEnrichments / totalCarriers) * 100)
        : 0;

    return {
        total: totalEnrichments,
        fresh: freshEnrichments,
        stale: staleEnrichments,
        expired: Math.max(0, expiredEnrichments),
        coverage: coveragePercent,
        needsRefresh: staleEnrichments + Math.max(0, expiredEnrichments)
    };
}

// ============================================
// RECENT ACTIVITY
// ============================================

async function getRecentActivity() {
    // Collections: AdminAuditLog (auditLog), MatchEvents (matches), DriverProfiles (drivers)
    try {
        // Get recent admin actions
        const adminActions = await queryFromSource('auditLog', {
            sortField: 'timestamp',
            sortDirection: 'desc',
            limit: 10,
            suppressAuth: true
        });

        // Get recent matches
        const recentMatches = await queryFromSource('matches', {
            sortField: 'timestamp',
            sortDirection: 'desc',
            limit: 10
        });

        // Get recent driver registrations
        const recentDrivers = await queryFromSource('drivers', {
            sortField: '_createdDate',
            sortDirection: 'desc',
            limit: 5
        });

        // Combine and sort by timestamp
        const activities = [];

        for (const action of adminActions.items) {
            activities.push({
                type: 'admin_action',
                action: action.action,
                targetType: action.targetType,
                adminEmail: action.adminEmail,
                timestamp: action.timestamp,
                icon: 'admin_panel_settings',
                color: 'blue'
            });
        }

        for (const match of recentMatches.items) {
            activities.push({
                type: 'match',
                driverName: match.driver_name || 'Anonymous',
                carrierName: match.carrier_name,
                score: match.match_score,
                timestamp: match.timestamp,
                icon: 'handshake',
                color: 'green'
            });
        }

        for (const driver of recentDrivers.items) {
            activities.push({
                type: 'new_driver',
                name: `${driver.firstName || ''} ${driver.lastName || ''}`.trim() || 'New Driver',
                email: driver.email,
                timestamp: driver._createdDate,
                icon: 'person_add',
                color: 'purple'
            });
        }

        // Sort by timestamp descending
        activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        return activities.slice(0, 15);

    } catch (error) {
        console.error('Error fetching recent activity:', error);
        return [];
    }
}

// ============================================
// SYSTEM ALERTS
// ============================================

async function getSystemAlerts() {
    // Collections: SystemAlerts (alerts), DriverProfiles (drivers), Carriers (carriers), CarrierEnrichments (enrichments)
    try {
        // Get unresolved alerts
        const alerts = await queryFromSource('alerts', {
            eq: { resolved: false },
            sortField: 'createdAt',
            sortDirection: 'desc',
            limit: 10,
            suppressAuth: true
        });

        // Also generate dynamic alerts based on system state
        const dynamicAlerts = [];

        // Check for pending driver verifications
        const pendingVerifications = await countFromSource('drivers', {
            eq: { verificationStatus: 'in_review' }
        });

        if (pendingVerifications > 5) {
            dynamicAlerts.push({
                type: 'warning',
                category: 'compliance',
                title: 'Pending Verifications',
                message: `${pendingVerifications} drivers awaiting document verification`,
                createdAt: new Date(),
                isDynamic: true
            });
        }

        // Check for flagged carriers
        const flaggedCarriers = await countFromSource('carriers', {
            eq: { isFlagged: true }
        });

        if (flaggedCarriers > 0) {
            dynamicAlerts.push({
                type: 'warning',
                category: 'compliance',
                title: 'Flagged Carriers',
                message: `${flaggedCarriers} carriers flagged for review`,
                createdAt: new Date(),
                isDynamic: true
            });
        }

        // Check for stale enrichments
        const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
        const expiredEnrichments = await countFromSource('enrichments', {
            lt: { enriched_date: twoWeeksAgo }
        });

        if (expiredEnrichments > 10) {
            dynamicAlerts.push({
                type: 'info',
                category: 'enrichment',
                title: 'Stale Enrichments',
                message: `${expiredEnrichments} carrier enrichments need refresh`,
                createdAt: new Date(),
                isDynamic: true
            });
        }

        // Combine stored and dynamic alerts
        const allAlerts = [...alerts.items, ...dynamicAlerts];
        allAlerts.sort((a, b) => {
            const typeOrder = { critical: 0, warning: 1, info: 2 };
            return (typeOrder[a.type] || 3) - (typeOrder[b.type] || 3);
        });

        return {
            items: allAlerts.slice(0, 10),
            unresolvedCount: alerts.totalCount + dynamicAlerts.length
        };

    } catch (error) {
        console.error('Error fetching system alerts:', error);
        return { items: [], unresolvedCount: 0 };
    }
}

// ============================================
// PLATFORM HEALTH
// ============================================

async function getPlatformHealth() {
    // Collections: MatchEvents (matches), CarrierEnrichments (enrichments)
    try {
        const now = new Date();
        const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);

        // Check recent activity as proxy for health
        const recentMatches = await countFromSource('matches', {
            ge: { timestamp: hourAgo }
        });

        // Check enrichment system
        const recentEnrichments = await countFromSource('enrichments', {
            ge: { enriched_date: hourAgo }
        });

        // Calculate health scores
        const matchingHealth = recentMatches > 0 ? 100 : 50;
        const enrichmentHealth = recentEnrichments >= 0 ? 100 : 75; // Enrichment may not run every hour

        // Overall health
        const overallHealth = Math.round((matchingHealth + enrichmentHealth) / 2);

        return {
            overall: overallHealth,
            status: overallHealth >= 90 ? 'healthy' : overallHealth >= 70 ? 'degraded' : 'unhealthy',
            services: {
                matching: { status: matchingHealth >= 90 ? 'up' : 'degraded', score: matchingHealth },
                enrichment: { status: enrichmentHealth >= 90 ? 'up' : 'degraded', score: enrichmentHealth },
                database: { status: 'up', score: 100 } // If we got here, DB is working
            },
            lastChecked: now
        };

    } catch (error) {
        console.error('Error checking platform health:', error);
        return {
            overall: 0,
            status: 'unknown',
            services: {},
            error: error.message
        };
    }
}

// ============================================
// RESOLVE ALERT
// ============================================

/**
 * Mark an alert as resolved
 * @param {string} alertId - Alert ID
 * @returns {Promise<Object>} - Updated alert
 */
export async function resolveAlert(alertId) {
    // Collection: SystemAlerts (alerts)
    await requireAdmin();

    try {
        const alert = await getFromSource('alerts', alertId);
        if (!alert) {
            throw new Error('Alert not found');
        }

        const member = await currentMember.getMember();

        alert.resolved = true;
        alert.resolvedBy = member?._id || 'admin';
        alert.resolvedAt = new Date();

        const updated = await updateInSource('alerts', alert, { suppressAuth: true });

        return updated;

    } catch (error) {
        console.error('Error resolving alert:', error);
        throw new Error('Failed to resolve alert');
    }
}

// ============================================
// QUICK STATS (Lightweight)
// ============================================

/**
 * Get quick stats for header display
 * @returns {Promise<Object>} - Quick stats
 */
export async function getQuickStats() {
    // Collections: DriverProfiles (drivers), Carriers (carriers)
    await requireAdmin();

    try {
        const [drivers, carriers, pendingVerifications, flaggedCarriers] = await Promise.all([
            countFromSource('drivers', {}),
            countFromSource('carriers', {}),
            countFromSource('drivers', { eq: { verificationStatus: 'in_review' } }),
            countFromSource('carriers', { eq: { isFlagged: true } })
        ]);

        return {
            drivers,
            carriers,
            pendingVerifications,
            flaggedCarriers,
            needsAttention: pendingVerifications + flaggedCarriers
        };

    } catch (error) {
        console.error('Error fetching quick stats:', error);
        throw new Error('Failed to fetch quick stats');
    }
}

// ============================================
// ACTIVITY CHART DATA
// ============================================

/**
 * Get activity data for charts
 * @param {string} period - 'week' or 'month'
 * @returns {Promise<Object>} - Chart data
 */
export async function getActivityChartData(period = 'week') {
    // Collections: MatchEvents (matches), DriverProfiles (drivers)
    await requireAdmin();

    try {
        const now = new Date();
        const days = period === 'month' ? 30 : 7;
        const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);

        // Get matches in period
        const matches = await queryFromSource('matches', {
            ge: { timestamp: startDate },
            sortField: 'timestamp',
            sortDirection: 'asc',
            limit: 1000
        });

        // Get new drivers in period
        const drivers = await queryFromSource('drivers', {
            ge: { _createdDate: startDate },
            sortField: '_createdDate',
            sortDirection: 'asc',
            limit: 1000
        });

        // Group by day
        const matchesByDay = {};
        const driversByDay = {};

        for (let i = 0; i < days; i++) {
            const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);
            const key = date.toISOString().split('T')[0];
            matchesByDay[key] = 0;
            driversByDay[key] = 0;
        }

        for (const match of matches.items) {
            const key = new Date(match.timestamp).toISOString().split('T')[0];
            if (matchesByDay[key] !== undefined) {
                matchesByDay[key]++;
            }
        }

        for (const driver of drivers.items) {
            const key = new Date(driver._createdDate).toISOString().split('T')[0];
            if (driversByDay[key] !== undefined) {
                driversByDay[key]++;
            }
        }

        return {
            labels: Object.keys(matchesByDay),
            matches: Object.values(matchesByDay),
            drivers: Object.values(driversByDay)
        };

    } catch (error) {
        console.error('Error fetching chart data:', error);
        throw new Error('Failed to fetch chart data');
    }
}

// ============================================
// AI/LLM USAGE STATISTICS
// ============================================

/**
 * Get comprehensive AI usage statistics
 * @param {string} period - 'day', 'week', or 'month'
 * @returns {Promise<Object>} - AI usage data
 */
export async function getAIUsageStats(period = 'week') {
    // Collection: AIUsageLog (aiUsageLog)
    await requireAdmin();

    try {
        const now = new Date();
        let startDate;

        switch (period) {
            case 'day':
                startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                break;
            case 'month':
                startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                break;
            default: // week
                startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        }

        // Fetch usage logs for the period
        const usageLogs = await queryFromSource('aiUsageLog', {
            ge: { timestamp: startDate },
            limit: 1000,
            suppressAuth: true
        });

        // Calculate stats by provider
        const providerStats = {};
        let totalTokens = 0;
        let totalCost = 0;
        let totalRequests = 0;
        let totalErrors = 0;
        let totalLatency = 0;

        for (const log of usageLogs.items) {
            const provider = log.provider || 'unknown';

            if (!providerStats[provider]) {
                providerStats[provider] = {
                    provider,
                    name: getProviderDisplayName(provider),
                    requests: 0,
                    tokens: 0,
                    inputTokens: 0,
                    outputTokens: 0,
                    cost: 0,
                    errors: 0,
                    avgLatency: 0,
                    totalLatency: 0,
                    fallbackCount: 0
                };
            }

            const stats = providerStats[provider];
            stats.requests++;
            totalRequests++;

            // Token counts
            const tokens = log.tokensUsed || 0;
            const inputTokens = log.inputTokens || Math.floor(tokens * 0.3);
            const outputTokens = log.outputTokens || Math.floor(tokens * 0.7);

            stats.tokens += tokens;
            stats.inputTokens += inputTokens;
            stats.outputTokens += outputTokens;
            totalTokens += tokens;

            // Calculate cost based on token pricing
            const pricing = CONFIG.tokenPricing[provider] || { input: 1.00, output: 1.00 };
            const cost = ((inputTokens / 1000000) * pricing.input) + ((outputTokens / 1000000) * pricing.output);
            stats.cost += cost;
            totalCost += cost;

            // Latency
            if (log.latencyMs) {
                stats.totalLatency += log.latencyMs;
                totalLatency += log.latencyMs;
            }

            // Errors
            if (log.error) {
                stats.errors++;
                totalErrors++;
            }

            // Fallback usage
            if (log.usedFallback) {
                stats.fallbackCount++;
            }
        }

        // Calculate averages
        for (const provider in providerStats) {
            const stats = providerStats[provider];
            stats.avgLatency = stats.requests > 0 ? Math.round(stats.totalLatency / stats.requests) : 0;
            stats.errorRate = stats.requests > 0 ? Math.round((stats.errors / stats.requests) * 100) : 0;
            stats.cost = Math.round(stats.cost * 100) / 100; // Round to 2 decimals
            delete stats.totalLatency; // Clean up
        }

        // Sort providers by cost (highest first)
        const sortedProviders = Object.values(providerStats).sort((a, b) => b.cost - a.cost);

        // Calculate budget status
        const monthlyProjection = period === 'month' ? totalCost : (totalCost * (30 / (period === 'day' ? 1 : 7)));
        const budgetStatus = getBudgetStatus(monthlyProjection);

        // Get usage by function
        const functionStats = await getFunctionUsageStats(startDate);

        // Get usage trends
        const usageTrends = await getUsageTrends(startDate, period);

        return {
            period,
            startDate,
            endDate: now,
            summary: {
                totalRequests,
                totalTokens,
                totalCost: Math.round(totalCost * 100) / 100,
                totalErrors,
                errorRate: totalRequests > 0 ? Math.round((totalErrors / totalRequests) * 100) : 0,
                avgLatency: totalRequests > 0 ? Math.round(totalLatency / totalRequests) : 0,
                monthlyProjection: Math.round(monthlyProjection * 100) / 100,
                budgetStatus
            },
            byProvider: sortedProviders,
            byFunction: functionStats,
            trends: usageTrends
        };

    } catch (error) {
        console.error('Error fetching AI usage stats:', error);
        throw new Error('Failed to fetch AI usage statistics');
    }
}

/**
 * Get provider display name
 */
function getProviderDisplayName(providerId) {
    const names = {
        anthropic: 'Claude (Anthropic)',
        openai: 'GPT (OpenAI)',
        groq: 'Groq (Fast)',
        perplexity: 'Perplexity',
        google: 'Gemini (Google)',
        mistral: 'Mistral',
        cohere: 'Cohere'
    };
    return names[providerId] || providerId;
}

/**
 * Get budget status based on projected monthly spend
 */
function getBudgetStatus(monthlyProjection) {
    if (monthlyProjection >= CONFIG.budgetThresholds.critical) {
        return {
            status: 'critical',
            message: 'Projected spend exceeds critical threshold',
            percentOfWarning: Math.round((monthlyProjection / CONFIG.budgetThresholds.warning) * 100),
            percentOfCritical: Math.round((monthlyProjection / CONFIG.budgetThresholds.critical) * 100)
        };
    } else if (monthlyProjection >= CONFIG.budgetThresholds.warning) {
        return {
            status: 'warning',
            message: 'Projected spend exceeds warning threshold',
            percentOfWarning: Math.round((monthlyProjection / CONFIG.budgetThresholds.warning) * 100),
            percentOfCritical: Math.round((monthlyProjection / CONFIG.budgetThresholds.critical) * 100)
        };
    } else {
        return {
            status: 'healthy',
            message: 'Spend within budget',
            percentOfWarning: Math.round((monthlyProjection / CONFIG.budgetThresholds.warning) * 100),
            percentOfCritical: Math.round((monthlyProjection / CONFIG.budgetThresholds.critical) * 100)
        };
    }
}

/**
 * Get usage statistics by function
 */
async function getFunctionUsageStats(startDate) {
    // Collection: AIUsageLog (aiUsageLog)
    try {
        const logs = await queryFromSource('aiUsageLog', {
            ge: { timestamp: startDate },
            limit: 1000,
            suppressAuth: true
        });

        const functionStats = {};

        for (const log of logs.items) {
            const functionId = log.functionId || 'unknown';

            if (!functionStats[functionId]) {
                functionStats[functionId] = {
                    functionId,
                    name: getFunctionDisplayName(functionId),
                    requests: 0,
                    tokens: 0,
                    cost: 0,
                    avgLatency: 0,
                    totalLatency: 0
                };
            }

            const stats = functionStats[functionId];
            stats.requests++;
            stats.tokens += log.tokensUsed || 0;

            // Calculate cost
            const provider = log.provider || 'anthropic';
            const pricing = CONFIG.tokenPricing[provider] || { input: 1.00, output: 1.00 };
            const inputTokens = log.inputTokens || Math.floor((log.tokensUsed || 0) * 0.3);
            const outputTokens = log.outputTokens || Math.floor((log.tokensUsed || 0) * 0.7);
            stats.cost += ((inputTokens / 1000000) * pricing.input) + ((outputTokens / 1000000) * pricing.output);

            if (log.latencyMs) {
                stats.totalLatency += log.latencyMs;
            }
        }

        // Calculate averages
        for (const func in functionStats) {
            const stats = functionStats[func];
            stats.avgLatency = stats.requests > 0 ? Math.round(stats.totalLatency / stats.requests) : 0;
            stats.cost = Math.round(stats.cost * 100) / 100;
            delete stats.totalLatency;
        }

        return Object.values(functionStats).sort((a, b) => b.requests - a.requests);

    } catch (error) {
        console.error('Error fetching function usage stats:', error);
        return [];
    }
}

/**
 * Get function display name
 */
function getFunctionDisplayName(functionId) {
    const names = {
        carrier_synthesis: 'Carrier Synthesis',
        web_research: 'Web Research',
        social_scanning: 'Social Scanning',
        document_ocr: 'Document OCR',
        quick_classification: 'Quick Classification',
        sentiment_analysis: 'Sentiment Analysis',
        driver_chat: 'Driver Chat',
        admin_assistant: 'Admin Assistant',
        data_extraction: 'Data Extraction',
        translation: 'Translation',
        embeddings: 'Embeddings'
    };
    return names[functionId] || functionId;
}

/**
 * Get usage trends over time
 */
async function getUsageTrends(startDate, period) {
    // Collection: AIUsageLog (aiUsageLog)
    try {
        const logs = await queryFromSource('aiUsageLog', {
            ge: { timestamp: startDate },
            sortField: 'timestamp',
            sortDirection: 'asc',
            limit: 1000,
            suppressAuth: true
        });

        // Determine grouping interval
        const days = period === 'day' ? 1 : period === 'month' ? 30 : 7;
        const intervalHours = days === 1 ? 1 : days === 30 ? 24 : 6; // Hourly for day, daily for month, 6-hourly for week

        const trends = {};
        const now = new Date();

        // Initialize buckets
        if (days === 1) {
            for (let i = 0; i < 24; i++) {
                const hour = new Date(startDate.getTime() + i * 60 * 60 * 1000);
                const key = hour.toISOString().slice(0, 13); // YYYY-MM-DDTHH
                trends[key] = { label: `${i}:00`, requests: 0, tokens: 0, cost: 0 };
            }
        } else {
            for (let i = 0; i < days; i++) {
                const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);
                const key = date.toISOString().split('T')[0];
                trends[key] = { label: key, requests: 0, tokens: 0, cost: 0 };
            }
        }

        // Aggregate data
        for (const log of logs.items) {
            const timestamp = new Date(log.timestamp);
            const key = days === 1
                ? timestamp.toISOString().slice(0, 13)
                : timestamp.toISOString().split('T')[0];

            if (trends[key]) {
                trends[key].requests++;
                trends[key].tokens += log.tokensUsed || 0;

                const provider = log.provider || 'anthropic';
                const pricing = CONFIG.tokenPricing[provider] || { input: 1.00, output: 1.00 };
                const inputTokens = log.inputTokens || Math.floor((log.tokensUsed || 0) * 0.3);
                const outputTokens = log.outputTokens || Math.floor((log.tokensUsed || 0) * 0.7);
                trends[key].cost += ((inputTokens / 1000000) * pricing.input) + ((outputTokens / 1000000) * pricing.output);
            }
        }

        // Convert to arrays for charting
        const labels = [];
        const requests = [];
        const tokens = [];
        const costs = [];

        for (const key of Object.keys(trends).sort()) {
            labels.push(trends[key].label);
            requests.push(trends[key].requests);
            tokens.push(trends[key].tokens);
            costs.push(Math.round(trends[key].cost * 100) / 100);
        }

        return { labels, requests, tokens, costs };

    } catch (error) {
        console.error('Error fetching usage trends:', error);
        return { labels: [], requests: [], tokens: [], costs: [] };
    }
}

/**
 * Get AI health check for dashboard
 */
export async function getAIHealthCheck() {
    // Collection: AIUsageLog (aiUsageLog)
    await requireAdmin();

    try {
        const hourAgo = new Date(Date.now() - 60 * 60 * 1000);

        // Get recent logs
        const recentLogs = await queryFromSource('aiUsageLog', {
            ge: { timestamp: hourAgo },
            limit: 100,
            suppressAuth: true
        });

        if (recentLogs.items.length === 0) {
            return {
                status: 'idle',
                message: 'No AI activity in the last hour',
                providers: {}
            };
        }

        const providerHealth = {};
        let hasErrors = false;
        let hasSlowResponses = false;

        for (const log of recentLogs.items) {
            const provider = log.provider || 'unknown';

            if (!providerHealth[provider]) {
                providerHealth[provider] = {
                    requests: 0,
                    errors: 0,
                    avgLatency: 0,
                    totalLatency: 0,
                    status: 'healthy'
                };
            }

            providerHealth[provider].requests++;
            providerHealth[provider].totalLatency += log.latencyMs || 0;

            if (log.error) {
                providerHealth[provider].errors++;
                hasErrors = true;
            }
        }

        // Calculate health status for each provider
        for (const provider in providerHealth) {
            const health = providerHealth[provider];
            health.avgLatency = Math.round(health.totalLatency / health.requests);
            health.errorRate = Math.round((health.errors / health.requests) * 100);
            delete health.totalLatency;

            if (health.errorRate > 50) {
                health.status = 'critical';
            } else if (health.errorRate > 10 || health.avgLatency > 5000) {
                health.status = 'degraded';
                hasSlowResponses = true;
            }
        }

        let overallStatus = 'healthy';
        if (hasErrors && Object.values(providerHealth).some(p => p.status === 'critical')) {
            overallStatus = 'critical';
        } else if (hasErrors || hasSlowResponses) {
            overallStatus = 'degraded';
        }

        return {
            status: overallStatus,
            message: overallStatus === 'healthy'
                ? 'All AI providers operating normally'
                : overallStatus === 'degraded'
                    ? 'Some providers experiencing issues'
                    : 'Critical issues detected with AI providers',
            providers: providerHealth,
            lastChecked: new Date()
        };

    } catch (error) {
        console.error('Error checking AI health:', error);
        return {
            status: 'unknown',
            message: 'Unable to check AI health',
            error: error.message
        };
    }
}

/**
 * CONNECTION TEST: Carrier Matching
 * ==================================
 * Verifies the full Airtable pipeline for carrier matching collections:
 *   1. API Connection - Can we reach Airtable?
 *   2. Table Mapping  - Does config.jsw map our collection to the right v2_ table?
 *   3. Field Transform - Do snake_case fields round-trip to Title Case correctly?
 *   4. CRUD Ops       - Can we Create, Read, Update, Delete a test record?
 *
 * Collections tested:
 *   - carrierAccounts -> v2_Carriers
 *   - carrierHiringPreferences -> v2_Carrier Hiring Preferences
 *
 * @module backend/tests/carrierMatchingConnectionTest
 */

import {
    testConnection,
    queryRecords,
    createRecord,
    updateRecord,
    deleteRecord,
    toWixFormat,
    toAirtableFormat
} from 'backend/airtableClient';

import { getAirtableTableName } from 'backend/configData';

// =============================================================================
// TEST CONFIGURATION
// =============================================================================

const DOMAIN_NAME = 'CarrierMatching';

/**
 * Collections this domain uses.
 * Keys = config.jsw collection keys
 * Values = expected Airtable table names (v2_ prefix)
 */
const TEST_COLLECTIONS = {
    'carrierAccounts': 'v2_Carriers',
    'carrierHiringPreferences': 'v2_Carrier Hiring Preferences'
};

/**
 * A sample carrier record in snake_case (Wix format) for CRUD testing.
 * Use obviously-fake data so test records are easy to identify and clean up.
 */
const TEST_CARRIER = {
    dot_number: 9999999,
    legal_name: '__TEST_CONNECTION__ Test Carrier',
    dba_name: 'Test Carrier DBA',
    mc_number: 9999999,
    city: 'TestCity',
    state: 'TX',
    zip_code: 99999,
    telephone: '555-999-9999',
    email_address: 'connectiontest@test.lmdr.com',
    fleet_size: 10,
    power_units: 8,
    driver_total: 9,
    truck_age_avg: 3,
    pay_rate_min: 0.50,
    pay_rate_max: 0.65,
    pay_cpm: 55,
    carrier_operation: 'Authorized For Hire',
    turnover_rate_pct: 25,
    priority_score: 50,
    fleet_score: 60,
    recruitment_score: 55,
    combined_score: 55,
    created_date: new Date().toISOString().split('T')[0],
    updated_date: new Date().toISOString().split('T')[0]
};

/**
 * A sample hiring preferences record for CRUD testing.
 */
const TEST_PREFERENCES = {
    carrier_dot: 9999999,
    required_cdl_class: 'A',
    required_cdl_types: JSON.stringify(['A', 'B']),
    required_endorsements: JSON.stringify(['H', 'T']),
    min_experience_years: 2,
    max_experience_years: 10,
    accepts_recent_grads: 'No',
    max_accidents_3yr: 1,
    max_violations_3yr: 2,
    target_states: JSON.stringify(['TX', 'CA']),
    target_zip_codes: JSON.stringify(['75001']),
    target_radius_miles: 100,
    offered_pay_min_cpm: 50,
    offered_pay_max_cpm: 65,
    equipment_types: JSON.stringify(['Dry Van', 'Reefer']),
    urgency: '30_day',
    is_active: 'Yes',
    weight_qualifications: 30,
    weight_experience: 20,
    weight_location: 20,
    weight_availability: 15,
    weight_salary_fit: 10,
    weight_engagement: 5
};

/**
 * Expected Airtable field names after transformation for carriers.
 */
const EXPECTED_CARRIER_FIELDS = {
    'dot_number': 'DOT Number',
    'legal_name': 'Legal Name',
    'city': 'City',
    'state': 'State',
    'fleet_size': 'Fleet Size',
    'pay_rate_min': 'Pay Rate Min',
    'pay_rate_max': 'Pay Rate Max'
};

/**
 * Expected Airtable field names after transformation for preferences.
 */
const EXPECTED_PREFERENCES_FIELDS = {
    'carrier_dot': 'Carrier DOT',
    'min_experience_years': 'Min Experience Years',
    'required_cdl_class': 'Required CDL Class',
    'target_radius_miles': 'Target Radius Miles',
    'urgency': 'Urgency',
    'is_active': 'Is Active'
};

// The primary collection key to run CRUD tests against
const PRIMARY_COLLECTION = 'carrierAccounts';
const SECONDARY_COLLECTION = 'carrierHiringPreferences';

// =============================================================================
// MAIN TEST RUNNER
// =============================================================================

/**
 * Run the full connection test suite for carrier matching
 *
 * @returns {Promise<Object>} Structured test results
 */
export async function runConnectionTest() {
    const startTime = Date.now();
    const results = {
        domain: DOMAIN_NAME,
        success: false,
        timestamp: new Date().toISOString(),
        tests: {},
        summary: { passed: 0, failed: 0, total: 0 }
    };

    console.log('='.repeat(60));
    console.log(`${DOMAIN_NAME} CONNECTION TEST - Starting`);
    console.log('='.repeat(60));

    // Phase 1: API Connection
    results.tests.connection = await testApiConnection();
    tally(results.summary, results.tests.connection.passed);

    if (!results.tests.connection.passed) {
        results.duration = Date.now() - startTime;
        console.log('\n[FAIL] Connection failed - skipping remaining tests');
        return results;
    }

    // Phase 2: Table Mapping
    results.tests.tableMapping = await testTableMapping();
    tally(results.summary, results.tests.tableMapping.passed);

    // Phase 3: Field Transformation (Carriers)
    results.tests.fieldTransformCarriers = await testFieldTransformation(
        'v2_Carriers',
        TEST_CARRIER,
        EXPECTED_CARRIER_FIELDS
    );
    tally(results.summary, results.tests.fieldTransformCarriers.passed);

    // Phase 3b: Field Transformation (Preferences)
    results.tests.fieldTransformPreferences = await testFieldTransformation(
        'v2_Carrier Hiring Preferences',
        TEST_PREFERENCES,
        EXPECTED_PREFERENCES_FIELDS
    );
    tally(results.summary, results.tests.fieldTransformPreferences.passed);

    // Phase 4: CRUD Operations (Carriers)
    results.tests.crudCarriers = await testCRUDOperations(
        PRIMARY_COLLECTION,
        TEST_CARRIER
    );
    tally(results.summary, results.tests.crudCarriers.passed);

    // Phase 4b: CRUD Operations (Preferences)
    results.tests.crudPreferences = await testCRUDOperations(
        SECONDARY_COLLECTION,
        TEST_PREFERENCES
    );
    tally(results.summary, results.tests.crudPreferences.passed);

    // Final
    results.success = results.summary.failed === 0;
    results.duration = Date.now() - startTime;

    console.log('\n' + '='.repeat(60));
    console.log(`${DOMAIN_NAME} TEST: ${results.success ? 'PASSED' : 'FAILED'}`);
    console.log(`Passed: ${results.summary.passed}/${results.summary.total} | ${results.duration}ms`);
    console.log('='.repeat(60));

    return results;
}

/**
 * Quick health check - lightweight version for status dashboards
 */
export async function quickCheck() {
    try {
        const conn = await testConnection();
        if (!conn.success) return { healthy: false, error: conn.error };

        const tableName = getAirtableTableName(PRIMARY_COLLECTION);
        const query = await queryRecords(tableName, { maxRecords: 1 });

        return {
            healthy: !query.error,
            collection: PRIMARY_COLLECTION,
            tableName,
            recordsAccessible: (query.records || []).length > 0
        };
    } catch (error) {
        return { healthy: false, error: error.message };
    }
}

// =============================================================================
// PHASE 1: API CONNECTION
// =============================================================================

async function testApiConnection() {
    console.log('\n--- Phase 1: API Connection ---');
    const result = { name: 'API Connection', passed: false, details: {} };

    try {
        const conn = await testConnection();
        result.details = {
            baseId: conn.baseId,
            tableCount: conn.tableCount,
            tables: conn.tables || []
        };

        if (conn.success) {
            result.passed = true;
            result.message = `Connected. Found ${conn.tableCount} tables.`;
            console.log(`  [PASS] ${result.message}`);
        } else {
            result.message = conn.error || 'Connection failed';
            console.log(`  [FAIL] ${result.message}`);
        }
    } catch (error) {
        result.message = `Exception: ${error.message}`;
        console.log(`  [FAIL] ${result.message}`);
    }

    return result;
}

// =============================================================================
// PHASE 2: TABLE MAPPING
// =============================================================================

async function testTableMapping() {
    console.log('\n--- Phase 2: Table Mapping ---');
    const result = { name: 'Table Mapping', passed: false, details: {} };

    try {
        const mismatches = [];

        for (const [collectionKey, expectedTable] of Object.entries(TEST_COLLECTIONS)) {
            const actualTable = getAirtableTableName(collectionKey);
            if (actualTable !== expectedTable) {
                mismatches.push({
                    collection: collectionKey,
                    expected: expectedTable,
                    actual: actualTable
                });
            } else {
                console.log(`  [OK] ${collectionKey} -> ${actualTable}`);
            }
        }

        result.details.collectionsChecked = Object.keys(TEST_COLLECTIONS).length;
        result.details.mismatches = mismatches;

        if (mismatches.length === 0) {
            result.passed = true;
            result.message = `All ${result.details.collectionsChecked} table mappings correct.`;
            console.log(`  [PASS] ${result.message}`);
        } else {
            result.message = `${mismatches.length} mapping mismatch(es)`;
            console.log(`  [FAIL] ${result.message}`);
            mismatches.forEach(m => console.log(`    ${m.collection}: expected ${m.expected}, got ${m.actual}`));
        }
    } catch (error) {
        result.message = `Exception: ${error.message}`;
        console.log(`  [FAIL] ${result.message}`);
    }

    return result;
}

// =============================================================================
// PHASE 3: FIELD TRANSFORMATION
// =============================================================================

async function testFieldTransformation(mapperName, testRecord, expectedFields) {
    console.log(`\n--- Phase 3: Field Transformation (${mapperName}) ---`);
    const result = { name: `Field Transformation (${mapperName})`, passed: false, details: {} };

    try {
        // Wix -> Airtable
        const airtableFormatted = toAirtableFormat(testRecord, mapperName);
        result.details.wixToAirtable = { input: testRecord, output: airtableFormatted };

        const errors = [];

        // Check key fields transformed correctly
        for (const [snakeField, titleField] of Object.entries(expectedFields)) {
            const inputValue = testRecord[snakeField];
            const outputValue = airtableFormatted[titleField];

            // Skip array/JSON comparison
            if (typeof inputValue === 'string' && inputValue.startsWith('[')) continue;

            if (outputValue !== inputValue) {
                errors.push(`${snakeField} -> ${titleField}: expected "${inputValue}", got "${outputValue}"`);
            }
        }

        // Airtable -> Wix (round-trip)
        const fakeAirtableRecord = {
            id: 'recTEST_ROUNDTRIP',
            createdTime: new Date().toISOString(),
            fields: airtableFormatted
        };
        const wixFormatted = toWixFormat(fakeAirtableRecord, mapperName);
        result.details.airtableToWix = { input: fakeAirtableRecord, output: wixFormatted };

        // Verify round-trip for key fields
        for (const snakeField of Object.keys(expectedFields)) {
            const inputValue = testRecord[snakeField];
            const outputValue = wixFormatted[snakeField];

            // Skip array/JSON comparison
            if (typeof inputValue === 'string' && inputValue.startsWith('[')) continue;

            if (outputValue !== inputValue) {
                errors.push(`Round-trip ${snakeField}: expected "${inputValue}", got "${outputValue}"`);
            }
        }

        if (errors.length === 0) {
            result.passed = true;
            result.message = 'Field transformations round-trip correctly.';
            console.log(`  [PASS] ${result.message}`);
        } else {
            result.message = `${errors.length} transformation error(s)`;
            result.details.errors = errors;
            console.log(`  [FAIL] ${result.message}`);
            errors.forEach(e => console.log(`    ${e}`));
        }
    } catch (error) {
        result.message = `Exception: ${error.message}`;
        result.details.error = error.message;
        console.log(`  [FAIL] ${result.message}`);
    }

    return result;
}

// =============================================================================
// PHASE 4: CRUD OPERATIONS
// =============================================================================

async function testCRUDOperations(collectionKey, testRecord) {
    console.log(`\n--- Phase 4: CRUD Operations (${collectionKey}) ---`);
    const result = { name: `CRUD Operations (${collectionKey})`, passed: false, details: {} };

    let createdId = null;

    try {
        const tableName = getAirtableTableName(collectionKey);

        // CREATE
        console.log('  Creating test record...');
        const created = await createRecord(tableName, testRecord);
        createdId = created?.id || created?._id;
        result.details.create = { success: !!createdId, id: createdId };
        console.log(createdId ? `  [OK] Created: ${createdId}` : '  [FAIL] Create returned no ID');

        if (!createdId) {
            result.message = 'Create failed - cannot continue CRUD test';
            return result;
        }

        // READ
        console.log('  Reading back record...');
        const queried = await queryRecords(tableName, {
            maxRecords: 1,
            filterByFormula: `RECORD_ID()='${createdId}'`
        });
        const readSuccess = (queried.records || []).length > 0;
        result.details.read = { success: readSuccess, recordCount: (queried.records || []).length };
        console.log(readSuccess ? '  [OK] Read back successfully' : '  [FAIL] Could not read back');

        // UPDATE
        console.log('  Updating test record...');
        const updateFields = collectionKey === PRIMARY_COLLECTION
            ? { priority_score: 99, legal_name: '__TEST_CONNECTION__ Updated Carrier' }
            : { urgency: 'immediate', min_experience_years: 1 };
        const updated = await updateRecord(tableName, createdId, updateFields);
        const updateSuccess = !!updated;
        result.details.update = { success: updateSuccess };
        console.log(updateSuccess ? '  [OK] Updated successfully' : '  [FAIL] Update failed');

        // DELETE (cleanup)
        console.log('  Deleting test record...');
        const deleted = await deleteRecord(tableName, createdId);
        const deleteSuccess = !!deleted;
        result.details.delete = { success: deleteSuccess };
        console.log(deleteSuccess ? '  [OK] Deleted (cleaned up)' : '  [WARN] Delete may have failed');
        createdId = null; // Mark as cleaned up

        // All 4 ops must pass
        result.passed = result.details.create.success && readSuccess && updateSuccess && deleteSuccess;
        result.message = result.passed ? 'All CRUD operations succeeded.' : 'One or more CRUD operations failed.';
        console.log(`  [${result.passed ? 'PASS' : 'FAIL'}] ${result.message}`);

    } catch (error) {
        result.message = `Exception: ${error.message}`;
        console.log(`  [FAIL] ${result.message}`);

        // Attempt cleanup if we created a record
        if (createdId) {
            try {
                const tableName = getAirtableTableName(collectionKey);
                await deleteRecord(tableName, createdId);
                console.log(`  [CLEANUP] Deleted orphaned test record ${createdId}`);
            } catch (cleanupError) {
                console.log(`  [WARN] Could not clean up test record ${createdId}`);
            }
        }
    }

    return result;
}

// =============================================================================
// HELPERS
// =============================================================================

function tally(summary, passed) {
    summary.total++;
    if (passed) summary.passed++;
    else summary.failed++;
}

import { createNotification } from 'backend/memberService';
import * as dataAccess from 'backend/dataAccess';
import wixSecretsBackend from 'wix-secrets-backend';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
  notificationLog: 'matchNotificationLog',
  driverProfiles: 'driverProfiles',
  carrierSubscriptions: 'carrierSubscriptions',
  carrierHiringPreferences: 'carrierHiringPreferences',
  recruiterCarriers: 'recruiterCarriers'
};

const NOTIFICATION_CHANNELS = { PROFILE_VIEWED: 'profile_viewed', CONTACTED: 'contacted', NEW_MATCH: 'new_match' };
const NOTIFICATION_TYPES = { EMAIL: 'email', SMS: 'sms', IN_APP: 'in_app' };
const DEFAULT_NOTIFICATION_PREFERENCES = { profile_viewed: true, contacted: true };
const MATCH_SCORE_THRESHOLD = 70;

// Lazy-loaded services
async function getSubscriptionService() { return await import('backend/subscriptionService'); }
async function getDriverScoring() { return await import('backend/driverScoring'); }
async function getEmailService() {
  try { return await import('wix-users-backend'); } catch (err) { return null; }
}

function shouldNotifyDriver(preferences, channel) {
  const prefs = preferences || DEFAULT_NOTIFICATION_PREFERENCES;
  return !!prefs[channel];
}

function parsePreferences(raw) {
  if (!raw) return DEFAULT_NOTIFICATION_PREFERENCES;
  if (typeof raw === 'object') return raw;
  try { return JSON.parse(raw); } catch { return DEFAULT_NOTIFICATION_PREFERENCES; }
}

function isEnterpriseTier(subscription) {
  if (!subscription) return false;
  const tier = (subscription.plan_type || subscription.tier || '').toLowerCase();
  return tier === 'enterprise';
}

async function logNotification(data) {
  try {
    await dataAccess.insertRecord(COLLECTION_KEYS.notificationLog, {
      carrier_dot: data.carrier_dot || '', driver_id: data.driver_id || '',
      notification_type: data.notification_type || 'in_app', channel: data.channel || '',
      recipient_id: data.recipient_id || '', sent_at: new Date().toISOString(),
      status: data.status || 'sent', error_message: data.error_message || '',
      metadata: typeof data.metadata === 'string' ? data.metadata : JSON.stringify(data.metadata || {})
    }, { suppressAuth: true });
  } catch (err) { }
}

export async function notifyDriverProfileViewed(driverId, carrierInfo = {}) {
  try {
    const profile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, driverId, { suppressAuth: true });
    const prefs = parsePreferences(profile?.notification_preferences);
    if (!shouldNotifyDriver(prefs, NOTIFICATION_CHANNELS.PROFILE_VIEWED)) return { success: true, skipped: true };

    const name = carrierInfo.carrierName || 'A carrier';
    await createNotification(driverId, NOTIFICATION_CHANNELS.PROFILE_VIEWED, 'Your Profile Was Viewed', `${name} viewed your driver profile.`, '/dashboard');
    await logNotification({ carrier_dot: carrierInfo.carrierDot, driver_id: driverId, notification_type: NOTIFICATION_TYPES.IN_APP, channel: NOTIFICATION_CHANNELS.PROFILE_VIEWED, recipient_id: driverId });
    return { success: true };
  } catch (err) {
    await logNotification({ carrier_dot: carrierInfo.carrierDot, driver_id: driverId, status: 'failed', error_message: err.message });
    return { success: false, error: err.message };
  }
}

export async function notifyDriverContacted(driverId, contactInfo = {}) {
  try {
    const profile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, driverId, { suppressAuth: true });
    const prefs = parsePreferences(profile?.notification_preferences);
    if (!shouldNotifyDriver(prefs, NOTIFICATION_CHANNELS.CONTACTED)) return { success: true, skipped: true };

    const msg = contactInfo.messagePreview ? `: "${contactInfo.messagePreview.substring(0, 80)}..."` : '';
    await createNotification(driverId, NOTIFICATION_CHANNELS.CONTACTED, 'New Message', `A recruiter sent you a message${msg}.`, '/dashboard');

    const wixUsers = await getEmailService();
    if (wixUsers?.default?.emailUser) {
      await wixUsers.default.emailUser('recruiterContactNotification', driverId, { variables: { messagePreview: contactInfo.messagePreview || 'New message' } });
    }

    await logNotification({ carrier_dot: contactInfo.carrierDot, driver_id: driverId, notification_type: NOTIFICATION_TYPES.IN_APP, channel: NOTIFICATION_CHANNELS.CONTACTED, recipient_id: driverId });
    return { success: true };
  } catch (err) {
    await logNotification({ carrier_dot: contactInfo.carrierDot, driver_id: driverId, status: 'failed', error_message: err.message });
    return { success: false, error: err.message };
  }
}

export async function notifyCarrierNewMatches(carrierDot, matchingDrivers) {
  try {
    if (!matchingDrivers?.length) return { success: true, skipped: true };
    const subSvc = await getSubscriptionService();
    const sub = await subSvc.getSubscription(carrierDot);
    if (!isEnterpriseTier(sub)) return { success: true, skipped: true };

    const wixUsers = await getEmailService();
    const contactRes = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, { filters: { carrier_dot: carrierDot }, limit: 1, suppressAuth: true });
    const contact = contactRes.items?.[0];

    if (wixUsers?.default?.emailUser && contact?.member_id) {
      const summary = matchingDrivers.slice(0, 5).map(m => `${m.first_name} (${m.score}%)`).join('\n');
      await wixUsers.default.emailUser('newMatchAlert', contact.member_id, { variables: { matchCount: String(matchingDrivers.length), topMatchSummary: summary } });
    }

    await logNotification({ carrier_dot: carrierDot, notification_type: NOTIFICATION_TYPES.EMAIL, channel: NOTIFICATION_CHANNELS.NEW_MATCH, recipient_id: carrierDot, metadata: { count: matchingDrivers.length } });
    return { success: true };
  } catch (err) { return { success: false, error: err.message }; }
}

export async function scanForNewMatchingDrivers() {
  const startTime = Date.now();
  try {
    const cutoff = new Date(Date.now() - 24 * 3600000).toISOString();
    const dRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, { filters: { is_searchable: true, updated_date: { gte: cutoff } }, limit: 500, suppressAuth: true });
    const newDrivers = dRes.items || [];
    if (!newDrivers.length) return { success: true, carriersNotified: 0 };

    const sRes = await dataAccess.queryRecords(COLLECTION_KEYS.carrierSubscriptions, { filters: { plan_type: 'enterprise', is_active: true }, limit: 200, suppressAuth: true });
    const enterpriseCarriers = sRes.items || [];
    const scoring = await getDriverScoring();

    let notifiedCount = 0;
    for (const carrier of enterpriseCarriers) {
      const dot = carrier.carrier_dot;
      const pRes = await dataAccess.queryRecords(COLLECTION_KEYS.carrierHiringPreferences, { filters: { carrier_dot: dot }, limit: 1, suppressAuth: true });
      const prefs = pRes.items?.[0];
      if (!prefs) continue;

      const matches = [];
      for (const d of newDrivers) {
        const s = scoring.calculateDriverMatchScore(d, prefs);
        if ((s.totalScore || s.score || 0) >= MATCH_SCORE_THRESHOLD) matches.push({ first_name: d.display_name, score: s.totalScore || s.score });
      }
      if (matches.length) { await notifyCarrierNewMatches(dot, matches); notifiedCount++; }
    }
    return { success: true, carriersNotified: notifiedCount, duration: Date.now() - startTime };
  } catch (err) { return { success: false, error: err.message }; }
}

export async function updateDriverNotificationPreferences(driverId, preferences) {
  try {
    const profile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, driverId, { suppressAuth: true });
    if (!profile) return { success: false, error: 'Not found' };
    await dataAccess.updateRecord(COLLECTION_KEYS.driverProfiles, { ...profile, notification_preferences: JSON.stringify(preferences), _id: driverId }, { suppressAuth: true });
    return { success: true, preferences };
  } catch (err) { return { success: false, error: err.message }; }
}
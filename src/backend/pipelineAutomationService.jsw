import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import { logFeatureInteraction } from 'backend/featureAdoptionService';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
  pipelineAutomationRules: 'pipelineAutomationRules',
  automationLog: 'automationLog',
  interests: 'driverCarrierInterests'
};

const VALID_TRIGGER_EVENTS = [
  'status_change', 'document_uploaded', 'cdl_verified',
  'background_check_clear', 'no_response_7d', 'driver_message'
];

const VALID_STAGES = [
  'interested', 'applied', 'in_review', 'contacted', 'offer', 'hired', 'rejected', 'withdrawn'
];

// Helper to get current user ID
async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

// ============================================================================
// GET AUTOMATION RULES
// ============================================================================

export async function getAutomationRules(carrierDot) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.pipelineAutomationRules, {
      filters: { carrier_dot: String(carrierDot), is_active: true },
      sort: [{ field: 'priority', direction: 'asc' }],
      limit: 50, suppressAuth: true
    });
    return { success: true, rules: result.items || [] };
  } catch (error) {
    console.error('getAutomationRules error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CREATE/UPDATE/DELETE/TOGGLE RULE
// ============================================================================

export async function createAutomationRule(carrierDot, ruleData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const { ruleName, triggerEvent, triggerConditions, fromStage, toStage, autoNote, notifyRecruiter } = ruleData;
    if (!ruleName?.trim() || !VALID_TRIGGER_EVENTS.includes(triggerEvent)) return { success: false, error: 'Invalid data' };

    // Determine priority
    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.pipelineAutomationRules, {
      filters: { carrier_dot: String(carrierDot), is_active: true },
      limit: 100, suppressAuth: true
    });
    const maxPriority = (existingResult.items || []).reduce((max, r) => Math.max(max, r.priority || 0), 0);

    const record = {
      carrier_dot: String(carrierDot), rule_name: ruleName.trim(), trigger_event: triggerEvent,
      trigger_conditions_json: JSON.stringify(triggerConditions || {}), from_stage: fromStage || '',
      to_stage: toStage || '', auto_note: autoNote || '', notify_recruiter: notifyRecruiter !== false,
      is_active: true, priority: maxPriority + 1, is_default: false
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.pipelineAutomationRules, record, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    logFeatureInteraction('pipeline_automation', userId, 'create_rule', { carrierDot, triggerEvent }).catch(() => {});
    return { success: true, rule: result.record };
  } catch (error) {
    console.error('createAutomationRule error:', error);
    return { success: false, error: error.message };
  }
}

export async function updateAutomationRule(ruleId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.pipelineAutomationRules, ruleId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Rule not found' };

    const updatedRecord = {
      ...existing,
      rule_name: updates.ruleName || existing.rule_name,
      trigger_event: VALID_TRIGGER_EVENTS.includes(updates.triggerEvent) ? updates.triggerEvent : existing.trigger_event,
      trigger_conditions_json: updates.triggerConditions ? JSON.stringify(updates.triggerConditions) : existing.trigger_conditions_json,
      from_stage: updates.fromStage !== undefined ? updates.fromStage : existing.from_stage,
      to_stage: updates.toStage !== undefined ? updates.toStage : existing.to_stage,
      auto_note: updates.autoNote !== undefined ? updates.autoNote : existing.auto_note,
      notify_recruiter: updates.notifyRecruiter !== undefined ? updates.notifyRecruiter : existing.notify_recruiter
    };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.pipelineAutomationRules, updatedRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);
    return { success: true, rule: result.record };
  } catch (error) {
    console.error('updateAutomationRule error:', error);
    return { success: false, error: error.message };
  }
}

export async function deleteAutomationRule(ruleId) {
  try {
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.pipelineAutomationRules, ruleId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Rule not found' };
    await dataAccess.updateRecord(COLLECTION_KEYS.pipelineAutomationRules, { ...existing, is_active: false }, { suppressAuth: true });
    return { success: true };
  } catch (error) {
    console.error('deleteAutomationRule error:', error);
    return { success: false, error: error.message };
  }
}

export async function toggleRuleStatus(ruleId, isActive) {
  try {
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.pipelineAutomationRules, ruleId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Rule not found' };
    await dataAccess.updateRecord(COLLECTION_KEYS.pipelineAutomationRules, { ...existing, is_active: !!isActive }, { suppressAuth: true });
    return { success: true, isActive: !!isActive };
  } catch (error) {
    console.error('toggleRuleStatus error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// PROCESS EVENT
// ============================================================================

export async function processEvent(carrierDot, eventType, eventData) {
  try {
    if (!VALID_TRIGGER_EVENTS.includes(eventType)) return { success: false, error: 'Invalid event' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.pipelineAutomationRules, {
      filters: { 
        carrier_dot: String(carrierDot), trigger_event: eventType, is_active: true,
        from_stage: eventData.fromStatus ? { in: [eventData.fromStatus, ''] } : undefined
      },
      sort: [{ field: 'priority', direction: 'asc' }], limit: 10, suppressAuth: true
    });

    if (!result.items?.length) return { success: true, matched: false };

    const rule = result.items[0];
    let executionSuccess = true, errorMessage = '';

    try {
      if (rule.to_stage && eventData.interestId) {
        const { updateCandidateStatus } = await import('backend/recruiter_service');
        await updateCandidateStatus(eventData.interestId, rule.to_stage, rule.auto_note || `Auto-transition: ${rule.rule_name}`);
      }
    } catch (e) { executionSuccess = false; errorMessage = e.message; }

    await dataAccess.insertRecord(COLLECTION_KEYS.automationLog, {
      rule_id: rule._id, carrier_dot: String(carrierDot), driver_id: eventData.driverId || '',
      interest_id: eventData.interestId || '', trigger_event: eventType, from_stage: eventData.fromStatus || '',
      to_stage: rule.to_stage || '', executed_at: new Date().toISOString(), success: executionSuccess, error_message: errorMessage
    }, { suppressAuth: true });

    return { success: true, matched: true, ruleName: rule.rule_name, toStage: rule.to_stage, executionSuccess };
  } catch (error) {
    console.error('processEvent error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET AUTOMATION LOG & PROCESS STALE
// ============================================================================

export async function getAutomationLog(carrierDot, options = {}) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.automationLog, {
      filters: { carrier_dot: String(carrierDot) },
      sort: [{ field: 'executed_at', direction: 'desc' }],
      limit: options.limit || 20, suppressAuth: true
    });
    return { success: true, log: result.items || [] };
  } catch (error) {
    console.error('getAutomationLog error:', error);
    return { success: false, error: error.message };
  }
}

export async function processStaleAutomation() {
  const startTime = Date.now();
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.pipelineAutomationRules, {
      filters: { trigger_event: 'no_response_7d', is_active: true }, limit: 100, suppressAuth: true
    });
    if (!result.items?.length) return { success: true, processed: 0 };

    const carrierDots = [...new Set(result.items.map(r => r.carrier_dot))];
    let totalProcessed = 0;
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();

    for (const carrierDot of carrierDots) {
      const staleResult = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
        filters: { 
          carrier_dot: String(carrierDot), status: { hasSome: ['contacted', 'in_review'] },
          action_timestamp: { lt: sevenDaysAgo }
        }, limit: 50, suppressAuth: true
      });

      for (const candidate of (staleResult.items || [])) {
        await processEvent(carrierDot, 'no_response_7d', { driverId: candidate.driver_id, interestId: candidate._id, fromStatus: candidate.status });
        totalProcessed++;
      }
    }
    return { success: true, processed: totalProcessed, durationMs: Date.now() - startTime };
  } catch (error) {
    console.error('[PipelineAutomation] Stale detection failed:', error);
    return { success: false, error: error.message };
  }
}

export async function seedDefaultRules(carrierDot) {
  const defaults = [
    { rule_name: 'Auto-advance on CDL verification', trigger_event: 'cdl_verified', from_stage: 'applied', to_stage: 'in_review', auto_note: 'CDL verified - auto-advanced to review', notify_recruiter: true },
    { rule_name: 'Flag stale candidates', trigger_event: 'no_response_7d', from_stage: 'contacted', to_stage: '', auto_note: 'No response for 7+ days - needs follow-up', notify_recruiter: true }
  ];

  let created = 0;
  for (let i = 0; i < defaults.length; i++) {
    try {
      await dataAccess.insertRecord(COLLECTION_KEYS.pipelineAutomationRules, {
        ...defaults[i], carrier_dot: String(carrierDot), trigger_conditions_json: '{}',
        is_active: true, priority: i + 1, is_default: true
      }, { suppressAuth: true });
      created++;
    } catch (err) { }
  }
  return { success: true, created, total: defaults.length };
}

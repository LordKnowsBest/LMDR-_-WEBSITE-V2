/**
 * Airtable Client - Core Abstraction Layer for Wix-Airtable Integration
 *
 * This module provides a complete abstraction layer for interacting with Airtable,
 * replacing wixData calls with Airtable API calls. It handles:
 * - Rate limiting (5 requests/second with 200ms delays)
 * - Field name transformations (Wix snake_case <-> Airtable Title Case)
 * - Pagination for large result sets
 * - Error handling with exponential backoff for rate limits
 * - Bulk operations (max 10 records per request)
 *
 * @module backend/airtableClient
 */

import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  baseId: 'app9N1YCJ3gdhExA0', // Last Mile Driver Recruiting base
  baseUrl: 'https://api.airtable.com/v0',
  secretNames: ['AIRTABLE_PAT', 'AIRTABLE_API_KEY'], // Try PAT first, then legacy key

  // Rate Limiting: Airtable allows 5 requests/second
  rateLimit: {
    requestDelayMs: 200, // 200ms between requests = 5/sec max
    maxRetries: 5,
    baseBackoffMs: 1000,
    maxBackoffMs: 32000
  },

  // Pagination
  pagination: {
    maxRecordsPerPage: 100 // Airtable's max
  },

  // Request timeout
  timeoutMs: 30000
};

// ============================================================================
// TABLE NAME MAPPINGS (Wix Collection -> Airtable Table)
// ============================================================================

/**
 * Maps Wix collection names to Airtable table names.
 * All Airtable tables use v2_ prefix per migration standards.
 */
const TABLE_NAMES = {
  // Core Data
  'Carriers': 'Carriers (Master)', // Legacy table with actual carrier data
  'v2_Carriers': 'v2_Carriers', // User-facing carrier accounts (has Owner field for Wix user linkage)
  'DriverProfiles': 'v2_Driver Profiles',
  'DriverJobs': 'v2_Driver Jobs',
  'LegacyDriverLeads': 'Legacy Driver Leads',
  'DriverApplications': 'Applications',
  'FBCampaignDrivers': 'CDL DRIVERS NJ FB CAMPAIGN',
  'ScoredDrivers': 'Scored Drivers',

  // Matching & Interests
  'DriverCarrierInterests': 'v2_Driver Carrier Interests',
  'CarrierDriverViews': 'v2_Carrier Driver Views',
  'CarrierDriverOutreach': 'v2_Carrier Driver Outreach',
  'MatchEvents': 'v2_Match Events',
  'CarrierHiringPreferences': 'v2_Carrier Hiring Preferences',
  'DriverJobPreferences': 'v2_Driver Job Preferences',

  // Messaging & Notifications
  'Messages': 'v2_Messages',
  'MemberNotifications': 'v2_Member Notifications',
  'MemberActivity': 'v2_Member Activity',
  'CarrierAnnouncements': 'v2_Carrier Announcements',
  'AnnouncementReadReceipts': 'v2_Announcement Read Receipts',
  'AnnouncementComments': 'v2_Announcement Comments',
  'CarrierNotificationSettings': 'v2_Carrier Notification Settings',
  'DriverNotificationPreferences': 'v2_Driver Notification Preferences',

  // Enrichment & Cache
  'CarrierEnrichments': 'v2_Carrier Enrichments',
  'CarrierSafetyData': 'v2_FMCSA Safety Data',

  // Billing & Subscriptions
  'CarrierSubscriptions': 'v2_Subscriptions',
  'ProfileViews': 'v2_Profile Views',
  'BillingHistory': 'v2_Billing History',
  'StripeEvents': 'v2_Stripe Events',
  'CheckoutAbandonment': 'v2_Checkout Abandonment',
  'AbandonmentEmailLog': 'v2_Abandonment Email Log',

  // Onboarding & Admin
  'PartnerOnboarding': 'v2_Partner Onboarding',
  'CarrierOnboarding': 'v2_Carrier Onboarding',
  'RecruiterProfiles': 'v2_Recruiter Profiles',
  'RecruiterCarriers': 'v2_Recruiter Carriers',
  'recruiterCarriers': 'v2_Recruiter Carriers',

  // Content & CMS
  'BlogPosts': 'v2_Blog Posts',
  'BlogCategories': 'v2_Blog Categories',
  'FAQs': 'v2_FAQs',
  'ComplianceGuides': 'v2_Compliance Guides',
  'BestPracticesGuides': 'v2_Best Practices Guides',
  'PricingTiers': 'v2_Pricing Tiers',
  'ServiceFeatures': 'v2_Service Features',
  'CaseStudies': 'v2_Case Studies',
  'IndustryComparisons': 'v2_Industry Comparisons',

  // Reviews & Testimonials
  'CarrierReviews': 'v2_Carrier Reviews',
  'CarrierTestimonials': 'v2_Carrier Testimonials',
  'DriverTestimonials': 'v2_Driver Testimonials',

  // Admin
  'AdminUsers': 'v2_Admin Users',
  'JobPostings': 'v2_Job Postings',
  'TeamMembers': 'v2_Team Members',
  'CompanyMilestones': 'v2_Company Milestones',

  // Leads & Requests
  'carrierStaffingRequests': 'v2_Carrier Staffing Requests',

  // AI & Prompts
  'AIRouterConfig': 'v2_AI Router Config',
  'AIUsageLog': 'v2_AI Usage Log',
  'AdminAuditLog': 'v2_Audit Log',
  'PromptLibrary': 'v2_Prompt Library',

  // Observability & Analytics
  'SystemTraces': 'v2_System Traces',
  'SystemLogs': 'v2_System Logs',
  'SystemErrors': 'v2_System Errors',
  'SystemMetrics': 'v2_System Metrics',
  'FeatureAdoptionLogs': 'v2_Feature Adoption Logs',
  'FeatureFunnels': 'v2_Feature Funnels',
  'FeatureMetricsDaily': 'v2_Feature Metrics Daily',
  'FeatureRegistry': 'v2_Feature Registry',

  // Support & Operations
  'SupportTickets': 'v2_Support Tickets',
  'TicketComments': 'v2_Ticket Comments',
  'TicketTags': 'v2_Ticket Tags',
  'KnowledgeArticles': 'v2_Knowledge Articles',
  'ArticleCategories': 'v2_Article Categories',
  'ArticleVersions': 'v2_Article Versions',
  'NPSResponses': 'v2_NPS Responses',
  'SurveyConfig': 'v2_Survey Config',
  'NPSTrends': 'v2_NPS Trends',
  'ChatSessions': 'v2_Chat Sessions',
  'ChatMessages': 'v2_Chat Messages',
  'CannedResponses': 'v2_Canned Responses',

  // Driver Lifecycle & Disposition
  'lifecycleEvents': 'v2_Lifecycle Events',
  'terminationLogs': 'v2_Termination Logs',
  'surveyDefinitions': 'v2_Survey Definitions',
  'surveyResponses': 'v2_Survey Responses',

  // Gamification System
  'v2_Driver Progression': 'v2_Driver Progression',
  'v2_Driver Achievements': 'v2_Driver Achievements',
  'v2_Driver Challenges': 'v2_Driver Challenges',
  'v2_Recruiter Progression': 'v2_Recruiter Progression',
  'v2_Recruiter Badges': 'v2_Recruiter Badges',
  'v2_Recruiter Challenges': 'v2_Recruiter Challenges',
  'v2_Leaderboard Snapshots': 'v2_Leaderboard Snapshots',
  'v2_Achievement Definitions': 'v2_Achievement Definitions',
  'v2_Badge Definitions': 'v2_Badge Definitions',
  'v2_Challenge Definitions': 'v2_Challenge Definitions',
  'v2_Gamification Events': 'v2_Gamification Events',
  'v2_Seasonal Events': 'v2_Seasonal Events',
  'v2_Match Notification Log': 'v2_Match Notification Log',

  // Recruiter Utility Expansion
  'SavedSearches': 'v2_Saved Searches',
  'v2_Saved Searches': 'v2_Saved Searches',
  'SavedSearchAlerts': 'v2_Saved Search Alerts',
  'v2_Saved Search Alerts': 'v2_Saved Search Alerts',
  'CallOutcomes': 'v2_Call Outcomes',
  'v2_Call Outcomes': 'v2_Call Outcomes',
  'CallFeedback': 'v2_Call Feedback',
  'v2_Call Feedback': 'v2_Call Feedback',
  'InterventionTemplates': 'v2_Intervention Templates',
  'v2_Intervention Templates': 'v2_Intervention Templates',
  'InterventionLog': 'v2_Intervention Log',
  'v2_Intervention Log': 'v2_Intervention Log',
  'PipelineAutomationRules': 'v2_Pipeline Automation Rules',
  'v2_Pipeline Automation Rules': 'v2_Pipeline Automation Rules',
  'AutomationLog': 'v2_Automation Log',
  'v2_Automation Log': 'v2_Automation Log',

  // =========================================================================
  // camelCase aliases (config.jsw keys) — allows callers to pass config keys
  // directly without resolving through getAirtableTableName() first
  // =========================================================================
  'carriers': 'Carriers (Master)',
  'carrierAccounts': 'v2_Carriers',
  'driverProfiles': 'v2_Driver Profiles',
  'driverJobs': 'v2_Driver Jobs',
  'legacyDriverLeads': 'Legacy Driver Leads',
  'driverApplications': 'Applications',
  'fbCampaignDrivers': 'CDL DRIVERS NJ FB CAMPAIGN',
  'scoredDrivers': 'Scored Drivers',
  'driverCarrierInterests': 'v2_Driver Carrier Interests',
  'carrierDriverViews': 'v2_Carrier Driver Views',
  'recruiterOutreachHistory': 'v2_Carrier Driver Outreach',
  'matchEvents': 'v2_Match Events',
  'carrierHiringPreferences': 'v2_Carrier Hiring Preferences',
  'driverJobPreferences': 'v2_Driver Job Preferences',
  'messages': 'v2_Messages',
  'memberNotifications': 'v2_Member Notifications',
  'memberActivity': 'v2_Member Activity',
  'carrierAnnouncements': 'v2_Carrier Announcements',
  'announcementReadReceipts': 'v2_Announcement Read Receipts',
  'announcementComments': 'v2_Announcement Comments',
  'carrierNotificationSettings': 'v2_Carrier Notification Settings',
  'driverNotificationPreferences': 'v2_Driver Notification Preferences',
  'carrierEnrichments': 'v2_Carrier Enrichments',
  'carrierSafetyData': 'v2_FMCSA Safety Data',
  'carrierSubscriptions': 'v2_Subscriptions',
  'profileViews': 'v2_Profile Views',
  'billingHistory': 'v2_Billing History',
  'stripeEvents': 'v2_Stripe Events',
  'partnerOnboarding': 'v2_Partner Onboarding',
  'carrierOnboarding': 'v2_Carrier Onboarding',
  'callFeedback': 'v2_Call Feedback',
  'recruiterProfiles': 'v2_Recruiter Profiles',
  'blogPosts': 'v2_Blog Posts',
  'blogCategories': 'v2_Blog Categories',
  'faqs': 'v2_FAQs',
  'complianceGuides': 'v2_Compliance Guides',
  'bestPracticesGuides': 'v2_Best Practices Guides',
  'pricingTiers': 'v2_Pricing Tiers',
  'serviceFeatures': 'v2_Service Features',
  'caseStudies': 'v2_Case Studies',
  'industryComparisons': 'v2_Industry Comparisons',
  'carrierReviews': 'v2_Carrier Reviews',
  'carrierTestimonials': 'v2_Carrier Testimonials',
  'driverTestimonials': 'v2_Driver Testimonials',
  'forumCategories': 'v2_Forum Categories',
  'forumThreads': 'v2_Forum Threads',
  'forumPosts': 'v2_Forum Posts',
  'forumReplies': 'v2_Forum Replies',
  'adminUsers': 'v2_Admin Users',
  'platformSettings': 'v2_Platform Settings',
  'jobPostings': 'v2_Job Postings',
  'teamMembers': 'v2_Team Members',
  'companyMilestones': 'v2_Company Milestones',
  'interviews': 'v2_Interviews',
  'checkoutAbandonment': 'v2_Checkout Abandonment',
  'abandonmentEmailLog': 'v2_Abandonment Email Log',
  'auditLog': 'v2_Audit Log',
  'aiUsageLog': 'v2_AI Usage Log',
  'aiRouterConfig': 'v2_AI Router Config',
  'promptLibrary': 'v2_Prompt Library',
  'systemLogs': 'v2_System Logs',
  'systemErrors': 'v2_System Errors',
  'systemMetrics': 'v2_System Metrics',
  'systemTraces': 'v2_System Traces',
  'petFriendlyLocations': 'v2_Pet Friendly Locations',
  'petFriendlyReviews': 'v2_Pet Friendly Reviews',
  'healthResources': 'v2_Health Resources',
  'healthTips': 'v2_Health Tips',
  'driverProgression': 'v2_Driver Progression',
  'petFriendlyLocations': 'v2_Pet Friendly Locations',
  'petFriendlyReviews': 'v2_Pet Friendly Reviews',
  'healthResources': 'v2_Health Resources',
  'healthTips': 'v2_Health Tips',
  'driverAchievements': 'v2_Driver Achievements',
  'driverChallenges': 'v2_Driver Challenges',
  'recruiterProgression': 'v2_Recruiter Progression',
  'recruiterBadges': 'v2_Recruiter Badges',
  'recruiterChallenges': 'v2_Recruiter Challenges',
  'leaderboardSnapshots': 'v2_Leaderboard Snapshots',
  'achievementDefinitions': 'v2_Achievement Definitions',
  'badgeDefinitions': 'v2_Badge Definitions',
  'challengeDefinitions': 'v2_Challenge Definitions',
  'gamificationEvents': 'v2_Gamification Events',
  'featureAdoptionLogs': 'v2_Feature Adoption Logs',
  'featureFunnels': 'v2_Feature Funnels',
  'featureMetricsDaily': 'v2_Feature Metrics Daily',
  'featureRegistry': 'v2_Feature Registry',

  // Support & Operations Aliases
  'supportTickets': 'v2_Support Tickets',
  'ticketComments': 'v2_Ticket Comments',
  'ticketTags': 'v2_Ticket Tags',
  'knowledgeArticles': 'v2_Knowledge Articles',
  'articleCategories': 'v2_Article Categories',
  'articleVersions': 'v2_Article Versions',
  'npsResponses': 'v2_NPS Responses',
  'surveyConfig': 'v2_Survey Config',
  'npsTrends': 'v2_NPS Trends',
  'chatSessions': 'v2_Chat Sessions',
  'chatMessages': 'v2_Chat Messages',
  'cannedResponses': 'v2_Canned Responses',

  // Async search pipeline
  'searchJobs': 'v2_Search Jobs',

  // Agent & Voice collections
  'competitorIntel': 'v2_Competitor Intel',
  'agentConversations': 'v2_Agent Conversations',
  'agentTurns': 'v2_Agent Turns',
  'agentRuns': 'v2_Agent Runs',
  'agentSteps': 'v2_Agent Steps',
  'approvalGates': 'v2_Approval Gates',
  'runOutcomes': 'v2_Run Outcomes',
  'compendiumEntries': 'v2_Compendium Entries',
  'agentEvaluations': 'v2_Agent Evaluations',
  'voiceCallLogs': 'v2_Voice Call Logs',
  'voiceAssistants': 'v2_Voice Assistants',
  'voiceCampaigns': 'v2_Voice Campaigns',
  'voiceCampaignContacts': 'v2_Voice Campaign Contacts',
};

// ============================================================================
// FIELD NAME MAPPINGS (Wix snake_case <-> Airtable Title Case)
// ============================================================================

/**
 * Field mappings per table.
 * Keys are Wix field names (snake_case), values are Airtable field names (Title Case).
 * Common fields like _id, _createdDate, _updatedDate are handled automatically.
 */
const FIELD_MAPPINGS = {
  // Common fields across all tables
  '_common': {
    '_id': 'Record ID',
    '_createdDate': 'Created',
    '_updatedDate': 'Last Modified',
    '_owner': 'Owner'
  },

  // Carriers (Master) - Legacy table uses UPPERCASE field names
  'Carriers': {
    'dot_number': 'DOT_NUMBER',
    'legal_name': 'LEGAL_NAME',
    'carrier_operation': 'CARRIER_OPERATION',
    'phy_city': 'PHY_CITY',
    'phy_state': 'PHY_STATE',
    'phy_zip': 'PHY_ZIP',
    'telephone': 'TELEPHONE',
    'email': 'EMAIL_ADDRESS',
    'nbr_power_unit': 'NBR_POWER_UNIT',
    'driver_total': 'DRIVER_TOTAL',
    'recent_mileage': 'RECENT_MILEAGE',
    'recent_mileage_year': 'RECENT_MILEAGE_YEAR',
    'priority_score': 'PRIORITY_SCORE',
    'fleet_score': 'Fleet Score',
    'ratio_score': 'Ratio Score',
    'geo_score': 'Geo Score',
    'mileage_score': 'Mileage Score',
    'pay_cpm': 'PAY_CPM',
    'turnover_percent': 'TURNOVER_PERCENT',
    'accident_rate': 'ACCIDENT_RATE',
    'avg_truck_age': 'AVG_TRUCK_AGE',
    'load_truck_ratio': 'LOAD_TRUCK_RATIO',
    'fleet_mpg': 'FLEET_MPG',
    'recruitment_score': 'RECRUITMENT_SCORE',
    'combined_score': 'COMBINED_SCORE',
    'logo_url': 'LOGO_URL',
    'is_hiring': '__SKIP__'
  },

  // v2_Carriers - User-facing carrier accounts (Title Case field names, has Owner)
  'v2_Carriers': {
    'legal_name': 'Legal Name',
    'dot_number': 'DOT Number',
    'mc_number': 'MC Number',
    'city': 'City',
    'state': 'State',
    'pay_rate_min': 'Pay Rate Min',
    'pay_rate_max': 'Pay Rate Max',
    'fleet_size': 'Fleet Size',
    'truck_age_avg': 'Truck Age Avg',
    'turnover_rate_pct': 'Turnover Rate Pct',
    'legacy_wix_id': 'Legacy Wix ID',
    'title': 'Title',
    'created_date': 'Created Date',
    'updated_date': 'Updated Date',
    'owner': 'Owner',
    'dba_name': 'DBA Name',
    'carrier_operation': 'Carrier Operation',
    'zip_code': 'Zip Code',
    'telephone': 'Telephone',
    'email_address': 'Email Address',
    'power_units': 'Power Units',
    'driver_total': 'Driver Total',
    'recent_mileage': 'Recent Mileage',
    'recent_mileage_year': 'Recent Mileage Year',
    'priority_score': 'Priority Score',
    'fleet_score': 'Fleet Score',
    'ratio_score': 'Ratio Score',
    'geo_score': 'Geo Score',
    'mileage_score': 'Mileage Score',
    'pay_cpm': 'Pay CPM',
    'accident_rate': 'Accident Rate',
    'load_truck_ratio': 'Load Truck Ratio',
    'fleet_mpg': 'Fleet MPG',
    'recruitment_score': 'Recruitment Score',
    'combined_score': 'Combined Score',
    'client_carriers': 'Client Carriers',
    'client_carriers_2': 'Client Carriers 2',
    'jobs': 'Jobs'
  },

  // Forum tables use camelCase field names in Airtable — map explicitly to avoid
  // the snake_case→Title Case fallback which produces wrong names (IsDeleted vs isDeleted).
  'forumThreads': {
    'categoryId': 'categoryId',
    'authorId': 'authorId',
    'isDeleted': 'isDeleted',
    'isPinned': 'isPinned',
    'isLocked': 'isLocked',
    'lastActivityAt': 'lastActivityAt',
    'viewCount': 'viewCount',
    'replyCount': 'replyCount',
    'createdAt': 'createdAt',
    'updatedAt': 'updatedAt',
    'contentPreview': 'contentPreview'
  },
  'forumPosts': {
    'threadId': 'threadId',
    'authorId': 'authorId',
    'isDeleted': 'isDeleted',
    'isBestAnswer': 'isBestAnswer',
    'parentPostId': 'parentPostId',
    'likeCount': 'likeCount',
    'createdAt': 'createdAt',
    'updatedAt': 'updatedAt'
  },

  'DriverProfiles': {
    // Override common _owner → maps to Wix Member ID in this table
    '_owner': 'Wix Member ID',
    // Identity / Contact
    'display_name': 'Display Name',
    'email': 'Email',
    'phone': 'Phone',
    'home_zip': 'Home Zip',
    'member_id': 'Wix Member ID',
    'wix_member_id': 'Wix Member ID',
    'legacy_wix_id': 'Legacy Wix ID',
    // Personal Info
    'first_name': 'First Name',
    'last_name': 'Last Name',
    'date_of_birth': 'Date of Birth',
    'city': 'City',
    'state': 'State',
    'zip_code': 'ZIP Code',
    // CDL / Licensing
    'cdl_class': 'CDL Class',
    'cdl_number': 'CDL Number',
    'cdl_state': 'CDL State',
    'cdl_expiration': 'CDL Expiration',
    'cdl_front_image': 'CDL Front URL',
    'cdl_front_url': 'CDL Front URL',
    'cdl_back_image': 'CDL Back URL',
    'cdl_back_url': 'CDL Back URL',
    'endorsements': 'Endorsements',
    'restrictions': 'Restrictions',
    // Medical / Documents
    'med_card_image': 'Med Card URL',
    'med_card_url': 'Med Card URL',
    'med_card_expiration': 'Med Card Expiration',
    'cdl_expiration_date': 'CDL Expiration',
    'med_card_expiration_date': 'Med Card Expiration',
    'resume_file': 'Resume URL',
    'resume_url': 'Resume URL',
    // Safety / Record
    'years_experience': 'Years Experience',
    'clean_mvr': 'Clean MVR',
    'accidents_last_3_years': 'Accidents 3yr',
    'violations_last_3_years': 'Violations 3yr',
    // Compensation
    'min_cpm': 'Min CPM',
    // Work History
    'employer_1_name': 'Employer 1 Name',
    'employer_1_duration': 'Employer 1 Duration',
    'employer_2_name': 'Employer 2 Name',
    'employer_2_duration': 'Employer 2 Duration',
    'employer_3_name': 'Employer 3 Name',
    'employer_3_duration': 'Employer 3 Duration',
    'companies_last_3_years': 'Companies Last 3 Years',
    'work_history': 'Work History',
    // Preferences
    'preferred_operation_type': 'Preferred Operation Type',
    'preferred_operation_types': 'Preferred Operation Type',
    'preferred_routes': 'Preferred Routes',
    'home_time_preference': 'Home Time Preference',
    'desired_home_time': 'Home Time Preference',
    'max_commute_miles': 'Max Commute Miles',
    'max_turnover_percent': 'Max Turnover Percent',
    'max_truck_age_years': 'Max Truck Age Years',
    'fleet_size_preference': 'Fleet Size Preference',
    'equipment_experience': 'Equipment Experience',
    'availability': 'Availability',
    // Status / Admin
    'profile_completeness_score': 'Profile Score',
    'profile_completeness': 'Profile Score',
    'profile_score': 'Profile Score',
    'status': 'Status',
    'profile_status': 'Profile Status',
    'status_history': 'Status History',
    'docs_submitted': 'Docs Submitted',
    'docs_complete': 'Docs Complete',
    'mvr_status': 'MVR Status',
    'visibility_level': 'Visibility Level',
    'is_searchable': 'Is Searchable',
    'is_discoverable': 'Is Discoverable',
    // Dates
    'application_date': 'Application Date',
    'created_date': 'Created Date',
    'updated_date': 'Updated Date',
    'last_search_date': 'Last Search Date',
    // Metrics
    'total_searches': 'Total Searches'
  },

  'DriverJobs': {
    'carrier_id': 'Carrier',
    'title': 'Title',
    'description': 'Description',
    'job_type': 'Job Type',
    'operation_type': 'Operation Type',
    'cargo_types': 'Cargo Types',
    'equipment_types': 'Equipment Types',
    'pay_rate_min': 'Pay Rate Min',
    'pay_rate_max': 'Pay Rate Max',
    'pay_type': 'Pay Type',
    'home_time': 'Home Time',
    'location_city': 'Location City',
    'location_state': 'Location State',
    'location_zip': 'Location ZIP',
    'experience_required': 'Experience Required',
    'cdl_class_required': 'CDL Class Required',
    'endorsements_required': 'Endorsements Required',
    'benefits': 'Benefits',
    'sign_on_bonus': 'Sign-On Bonus',
    'status': 'Status',
    'posted_date': 'Posted Date',
    'expires_date': 'Expires Date',
    'views_count': 'Views Count',
    'applications_count': 'Applications Count'
  },

  'DriverCarrierInterests': {
    'driver_id': 'Driver',
    'carrier_id': 'Carrier',
    'carrier_dot': 'Carrier',  // Code uses carrier_dot, maps to same field as carrier_id
    'carrier_name': 'Carrier Name',
    'job_id': 'Job',
    'interest_type': 'Interest Type',
    'action': 'Interest Type',  // Code uses action, maps to Interest Type
    'status': 'Status',
    'match_score': 'Match Score',
    'applied_date': 'Applied Date',
    'application_date': 'Applied Date',  // applicationService uses application_date
    'action_timestamp': 'Applied Date',  // Code uses action_timestamp, maps to Applied Date
    'last_status_change': 'Last Status Change',
    'notes': 'Notes',
    'recruiter_notes': 'Recruiter Notes',
    'driver_zip_at_match': 'Driver ZIP',
    'outcome': 'Status',
    'outcome_date': 'Applied Date',
    // Application form fields
    'contact_phone': 'Contact Phone',
    'contact_email': 'Contact Email',
    'preferred_contact': 'Preferred Contact',
    'availability': 'Availability',
    'driver_message': 'Driver Message',
    'cdl_front_url': 'CDL Front URL',
    'cdl_back_url': 'CDL Back URL',
    'med_card_url': 'Med Card URL',
    'resume_url': 'Resume URL',
    'status_history': 'Status History',
    'origin': '__SKIP__'
  },

  // CarrierDriverOutreach - v2_Carrier Driver Outreach table
  'CarrierDriverOutreach': {
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'linked_driver': 'Linked Driver',
    'recruiter_id': 'Recruiter ID',
    'action_type': 'Outreach Type',
    'outreach_type': 'Outreach Type',
    'status': 'Status',
    'message_content': 'Message Content',
    'notes': 'Notes',
    'timestamp': 'Requested Time',
    'requested_time': 'Requested Time',
    'status_updated_at': 'Status Updated At',
    'wix_id': 'Wix ID'
  },

  'Messages': {
    'sender_id': 'Sender ID',
    'sender_type': 'Sender Type',
    'recipient_id': 'Recipient ID',
    'receiver_id': 'Recipient ID',  // Alias: code uses receiver_id
    'recipient_type': 'Recipient Type',
    'thread_id': 'Thread ID',
    'subject': 'Subject',
    'body': 'Body',
    'is_read': 'Read',
    'read_date': 'Read Date',
    'is_archived': 'Is Archived',
    'attachments': 'Attachments',
    'timestamp': 'Sent Date',
    'sent_date': 'Sent Date',
    'application_id': 'Application ID'
  },

  'CarrierSubscriptions': {
    'carrier_dot': 'Carrier DOT',
    'stripe_customer_id': 'Stripe Customer ID',
    'stripe_subscription_id': 'Stripe Subscription ID',
    'plan_tier': 'Plan Tier',
    'plan_type': 'Plan Tier',
    'status': 'Status',
    'monthly_views_quota': 'Monthly Views Quota',
    'monthly_view_quota': 'Monthly Views Quota',
    'views_used': 'Views Used',
    'views_used_this_month': 'Views Used',
    'period_start': 'Period Start',
    'period_end': 'Period End',
    'stripe_price_id': 'Stripe Price ID',
    'cancel_at_period_end': 'Cancel At Period End',
    'is_active': 'Is Active',
    'quota_reset_date': 'Quota Reset Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // MatchEvents - v2_Match Events table
  'MatchEvents': {
    'driver_id': 'Driver ID',
    'driver_name': 'Driver Name',
    'driver_zip': 'Driver ZIP',
    'carrier_dot': 'Carrier DOT',
    'carrier_name': 'Carrier Name',
    'match_score': 'Match Score',
    'action': 'Action',
    'event_type': 'Event Type',
    'event_date': 'Event Date',
    'timestamp': 'Timestamp'
  },

  // CarrierEnrichments - v2_Carrier Enrichments table
  'CarrierEnrichments': {
    'dot_number': 'Carrier DOT',
    'freight_types': 'Freight Types',
    'route_types': 'Route Types',
    'home_time': 'Home Time',
    'pay_cpm_range': 'Pay CPM Range',
    'sign_on_bonus': 'Sign On Bonus',
    'benefits': 'Benefits',
    'hiring_status': 'Hiring Status',
    'driver_sentiment': 'Driver Sentiment',
    'sentiment_score': 'Sentiment Score',
    'sentiment_pros': 'Sentiment Pros',
    'sentiment_cons': 'Sentiment Cons',
    'sources_found': 'Source URLs',
    'data_confidence': 'Data Confidence',
    'ai_summary': 'AI Summary',
    'enriched_date': 'Enriched Date',
    'enrichment_version': 'Enrichment Version',
    'match_count': 'Match Count',
    'last_matched_date': 'Last Matched Date',
    'source': 'Source',
    'enrichment_data': 'Enrichment Data'
  },

  'carrierStaffingRequests': {
    'company_name': 'Company Name',
    'contact_name': 'Contact Name',
    'email': 'Email',
    'phone': 'Phone',
    'dot_number': 'DOT Number',
    'linked_carrier_id': 'Linked Carrier ID',
    'staffing_type': 'Staffing Type',
    'drivers_needed': 'Drivers Needed',
    'driver_types': 'Driver Types',
    'additional_notes': 'Notes',
    'urgency': 'Urgency',
    'notes': 'Notes',
    'status': 'Status',
    'submitted_date': 'Submitted Date',
    'last_updated': 'Last Updated',
    'source': 'Source',
    'source_url': 'Source URL',
    'status_history': 'Status History',
    'legacy_wix_id': 'Legacy Wix ID',
    'utm_source': 'UTM Source',
    'utm_medium': 'UTM Medium',
    'utm_campaign': 'UTM Campaign'
  },

  // SystemTraces - v2_System Traces table
  'SystemTraces': {
    'trace_id': 'Trace ID',
    'name': 'Name',
    'start_time': 'Start Time',
    'end_time': 'End Time',
    'status': 'Status',
    'spans': 'Spans',
    'metadata': 'Metadata',
    'tags': 'Tags',
    'duration': 'Duration',
    'summary': 'Summary'
  },

  // FeatureAdoptionLogs - v2_Feature Adoption Logs table
  'FeatureAdoptionLogs': {
    'feature_id': 'Feature ID',
    'feature_version': 'Feature Version',
    'user_id': 'User ID',
    'user_role': 'User Role',
    'action': 'Action',
    'timestamp': 'Timestamp',
    'session_id': 'Session ID',
    'device_type': 'Device Type',
    'referrer': 'Referrer',
    'entry_point': 'Entry Point',
    'duration_ms': 'Duration (ms)',
    'scroll_depth': 'Scroll Depth',
    'interaction_count': 'Interaction Count',
    'outcome': 'Outcome',
    'conversion_value': 'Conversion Value',
    'next_feature': 'Next Feature',
    'error_code': 'Error Code',
    'error_message': 'Error Message',
    'metadata': 'Metadata'
  },

  // =========================================================================
  // GROUP: CORE & MATCHING
  // =========================================================================

  // CarrierDriverViews - v2_Carrier Driver Views table
  'CarrierDriverViews': {
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'view_date': 'View Date',
    'view_timestamp': 'View Date',
    'view_duration_sec': 'View Duration Sec',
    'legacy_wix_id': 'Legacy Wix ID',
    'recruiter_id': 'Recruiter ID',
    'view_type': 'View Type',
    'billing_period': 'Billing Period',
    'match_score': 'Match Score'
  },

  // CarrierHiringPreferences - v2_Carrier Hiring Preferences table
  'CarrierHiringPreferences': {
    'carrier_dot': 'Carrier DOT',
    'min_experience_years': 'Min Experience Years',
    'required_cdl_class': 'Required CDL Class',
    'accepts_recent_grads': 'Accepts Recent Grads',
    'max_accidents_3yr': 'Max Accidents 3yr',
    'max_violations_3yr': 'Max Violations 3yr',
    'legacy_wix_id': 'Legacy Wix ID',
    'is_active': 'Is Active',
    'required_cdl_types': 'Required CDL Types',
    'required_endorsements': 'Required Endorsements',
    'max_experience_years': 'Max Experience Years',
    'equipment_types': 'Equipment Types',
    'target_zip_codes': 'Target ZIP Codes',
    'target_states': 'Target States',
    'target_radius_miles': 'Target Radius Miles',
    'urgency': 'Urgency',
    'offered_pay_min_cpm': 'Offered Pay Min CPM',
    'offered_pay_max_cpm': 'Offered Pay Max CPM',
    'weight_salary_fit': 'Weight Salary Fit',
    'weight_salaryFit': 'Weight Salary Fit',
    'weight_engagement': 'Weight Engagement',
    'weight_location': 'Weight Location',
    'weight_availability': 'Weight Availability',
    'weight_experience': 'Weight Experience',
    'weight_qualifications': 'Weight Qualifications',
    'recruiter_id': '__SKIP__',
    'is_customized': '__SKIP__',
    '_createdDate': '__SKIP__',
    '_updatedDate': '__SKIP__'
  },

  // DriverJobPreferences - v2_Driver Job Preferences table
  'DriverJobPreferences': {
    'driver_id': 'Driver ID',
    'preferred_home_time': 'Preferred Home Time',
    'max_miles_from_home': 'Max Miles From Home',
    'willing_to_team': 'Willing to Team',
    'legacy_wix_id': 'Legacy Wix ID',
    'linked_driver': 'Linked Driver',
    'carrier_dot': 'Carrier DOT',
    'status': 'Status',
    'interest_level': 'Interest Level',
    'notes': 'Notes',
    'created_date': 'Created Date'
  },

  // MemberActivity - v2_Member Activity table
  'MemberActivity': {
    'member_id': 'Member ID',
    'activity_type': 'Activity Type',
    'target_id': 'Target ID',
    'activity_date': 'Activity Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'profile_views': 'Profile Views',
    'profile_views_trend': 'Profile Views Trend',
    'searches_this_week': 'Searches This Week',
    'match_score_trend': 'Match Score Trend',
    'last_active': 'Last Active'
  },

  // =========================================================================
  // GROUP: BILLING & SAFETY
  // =========================================================================

  // ProfileViews - v2_Profile Views table
  'ProfileViews': {
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'view_date': 'View Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'recruiter_id': 'Recruiter ID',
    'view_type': 'View Type',
    'billing_period': 'Billing Period',
    'match_score': 'Match Score'
  },

  // BillingHistory - v2_Billing History table
  'BillingHistory': {
    'carrier_dot': 'Carrier DOT',
    'event_type': 'Event Type',
    'amount': 'Amount',
    'event_date': 'Event Date',
    'stripe_event_id': 'Stripe Event ID',
    'legacy_wix_id': 'Legacy Wix ID',
    'currency': 'Currency',
    'invoice_id': 'Invoice ID',
    'description': 'Description',
    'timestamp': 'Timestamp'
  },

  // StripeEvents - v2_Stripe Events table
  'StripeEvents': {
    'event_id': 'Event ID',
    'event_type': 'Event Type',
    'processed': 'Processed',
    'processed_date': 'Processed Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'carrier_dot': 'Carrier DOT',
    'data_summary': 'Data Summary'
  },

  // CarrierSafetyData - v2_FMCSA Safety Data table (7-day enrichment cache)
  'CarrierSafetyData': {
    'dot_number': 'DOT Number',
    'basic_scores': 'BASIC Scores',
    'inspections': 'Inspections',
    'crashes': 'Crashes',
    'fetched_date': 'Fetched Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // =========================================================================
  // GROUP: ONBOARDING
  // =========================================================================

  // PartnerOnboarding - v2_Partner Onboarding table
  'PartnerOnboarding': {
    'partner_name': 'Partner Name',
    'contact_email': 'Contact Email',
    'contact_phone': 'Contact Phone',
    'status': 'Status',
    'step': 'Step',
    'started_date': 'Started Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // CarrierOnboarding - v2_Carrier Onboarding table
  'CarrierOnboarding': {
    'carrier_dot': 'Carrier DOT',
    'company_name': 'Company Name',
    'contact_email': 'Contact Email',
    'status': 'Status',
    'step': 'Step',
    'started_date': 'Started Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // RecruiterCarriers / recruiterCarriers - v2_Recruiter Carriers table
  'RecruiterCarriers': {
    'recruiter_id': 'Recruiter ID',
    'carrier_dot': 'Carrier DOT',
    'role': 'Role',
    'added_date': 'Added Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'carrier_name': 'Carrier Name',
    'is_active': 'Is Active',
    'verification_status': '__SKIP__'
  },
  'recruiterCarriers': {
    'recruiter_id': 'Recruiter ID',
    'carrier_dot': 'Carrier DOT',
    'role': 'Role',
    'added_date': 'Added Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'carrier_name': 'Carrier Name',
    'is_active': 'Is Active',
    'verification_status': '__SKIP__'
  },

  // =========================================================================
  // GROUP: CONTENT & CMS
  // =========================================================================

  // BlogPosts - v2_Blog Posts table
  'BlogPosts': {
    'title': 'Title',
    'slug': 'Slug',
    'content': 'Content',
    'excerpt': 'Excerpt',
    'category': 'Category',
    'tags': 'Tags',
    'status': 'Status',
    'published_date': 'Published Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // BlogCategories - v2_Blog Categories table
  'BlogCategories': {
    'name': 'Name',
    'slug': 'Slug',
    'description': 'Description',
    'order': 'Order',
    'display_order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // FAQs - v2_FAQs table
  'FAQs': {
    'question': 'Question',
    'answer': 'Answer',
    'category': 'Category',
    'order': 'Order',
    'display_order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // ComplianceGuides - v2_Compliance Guides table
  'ComplianceGuides': {
    'title': 'Title',
    'slug': 'Slug',
    'content': 'Content',
    'category': 'Category',
    'order': 'Order',
    'display_order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // BestPracticesGuides - v2_Best Practices Guides table
  'BestPracticesGuides': {
    'title': 'Title',
    'slug': 'Slug',
    'content': 'Content',
    'category': 'Category',
    'order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // PricingTiers - v2_Pricing Tiers table
  'PricingTiers': {
    'name': 'Name',
    'price_monthly': 'Price Monthly',
    'price_6month': 'Price 6Month',
    'job_posts': 'Job Posts',
    'driver_views': 'Driver Views',
    'features': 'Features',
    'order': 'Order',
    'display_order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // ServiceFeatures - v2_Service Features table
  'ServiceFeatures': {
    'name': 'Name',
    'description': 'Description',
    'tier': 'Tier',
    'icon': 'Icon',
    'order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // CaseStudies - v2_Case Studies table
  'CaseStudies': {
    'title': 'Title',
    'company': 'Company',
    'challenge': 'Challenge',
    'solution': 'Solution',
    'results': 'Results',
    'quote': 'Quote',
    'status': 'Status',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // IndustryComparisons - v2_Industry Comparisons table
  'IndustryComparisons': {
    'title': 'Title',
    'competitor': 'Competitor',
    'comparison_data': 'Comparison Data',
    'summary': 'Summary',
    'order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // =========================================================================
  // GROUP: REVIEWS & ADMIN
  // =========================================================================

  // CarrierReviews - v2_Carrier Reviews table
  'CarrierReviews': {
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'rating': 'Rating',
    'title': 'Title',
    'content': 'Content',
    'status': 'Status',
    'submitted_date': 'Submitted Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'carrier_name': 'Carrier Name',
    'reviewer_name': 'Reviewer Name',
    'moderation_reason': 'Moderation Reason',
    'moderated_at': 'Moderated At'
  },

  // CarrierTestimonials - v2_Carrier Testimonials table
  'CarrierTestimonials': {
    'carrier_name': 'Carrier Name',
    'contact_name': 'Contact Name',
    'title': 'Title',
    'quote': 'Quote',
    'rating': 'Rating',
    'status': 'Status',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // DriverTestimonials - v2_Driver Testimonials table
  'DriverTestimonials': {
    'driver_name': 'Driver Name',
    'quote': 'Quote',
    'hired_by': 'Hired By',
    'rating': 'Rating',
    'status': 'Status',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // AdminUsers - v2_Admin Users table
  'AdminUsers': {
    'name': 'Name',
    'email': 'Email',
    'role': 'Role',
    'status': 'Status',
    'wix_member_id': 'Wix Member ID',
    'permissions': 'Permissions',
    'created_by': 'Created By',
    'legacy_wix_id': 'Legacy Wix ID',
    'last_login': 'Last Login',
    'created_at': 'Created At'
  },

  // JobPostings - v2_Job Postings table
  'JobPostings': {
    'title': 'Title',
    'carrier_dot': 'Carrier DOT',
    'description': 'Description',
    'status': 'Status',
    'submitted_date': 'Submitted Date',
    'legacy_wix_id': 'Legacy Wix ID',
    'carrier_name': 'Carrier Name',
    'moderated_at': 'Moderated At'
  },

  // TeamMembers - v2_Team Members table
  'TeamMembers': {
    'name': 'Name',
    'title': 'Title',
    'bio': 'Bio',
    'photo_url': 'Photo URL',
    'order': 'Order',
    'display_order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // CompanyMilestones - v2_Company Milestones table
  'CompanyMilestones': {
    'title': 'Title',
    'description': 'Description',
    'date': 'Date',
    'order': 'Order',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // =========================================================================
  // GROUP: AI & OBSERVABILITY (Extended)
  // =========================================================================

  // AIUsageLog - v2_AI Usage Log table
  'AIUsageLog': {
    // Map aiRouterService fields to existing Airtable columns
    'functionId': '__SKIP__',
    'provider': 'Provider',
    'model': 'Model',
    'latencyMs': '__SKIP__',
    'tokensUsed': '__SKIP__',
    'inputTokens': 'Tokens In',
    'outputTokens': 'Tokens Out',
    'error': '__SKIP__',
    'usedFallback': '__SKIP__',
    'timestamp': 'Call Date',
    // Legacy fields
    'call_id': 'Call ID',
    'tokens_in': 'Tokens In',
    'tokens_out': 'Tokens Out',
    'cost_usd': 'Cost USD',
    'purpose': 'Purpose',
    'call_date': 'Call Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // AdminAuditLog - v2_Audit Log table (NOTE: table name is v2_Audit Log, not v2_Admin Audit Log)
  'AdminAuditLog': {
    // Preferred fields (admin_* services payload)
    'adminId': 'Admin Id',
    'adminEmail': 'Admin Email',
    'action': 'Action',
    'targetType': 'Target Type',
    'targetId': 'Target Id',
    'details': 'Details',
    'timestamp': 'Timestamp',
    'ipAddress': 'IP Address',
    // Legacy fields
    'actor_id': 'Actor ID',
    'category': 'Category',
    'target_id': 'Target ID',
    'action_date': 'Action Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // PromptLibrary - v2_Prompt Library table
  'PromptLibrary': {
    'name': 'Name',
    'category': 'Category',
    'prompt_text': 'Prompt Text',
    'version': 'Version',
    'active': 'Active',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // SystemLogs - v2_System Logs table
  'SystemLogs': {
    'log_id': 'Log ID',
    'level': 'Level',
    'service': 'Service',
    'message': 'Message',
    'log_date': 'Log Date',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // SystemErrors - v2_System Errors table
  'SystemErrors': {
    'wix_id': 'Wix ID',
    'timestamp': 'Timestamp',
    'level': 'Level',
    'level_num': 'Level Num',
    'source': 'Source',
    'message': 'Message',
    'details': 'Details',
    'trace_id': 'Trace ID',
    'span_id': 'Span ID',
    'parent_span_id': 'Parent Span ID',
    'user_id': 'User ID',
    'session_id': 'Session ID',
    'duration': 'Duration',
    'tags': 'Tags'
  },

  // SystemMetrics - v2_System Metrics table
  'SystemMetrics': {
    'wix_id': 'Wix ID',
    'timestamp': 'Timestamp',
    'metric_name': 'Metric Name',
    'value': 'Value',
    'source': 'Source',
    'tags': 'Tags',
    'metadata': 'Metadata'
  },

  // FeatureFunnels - v2_Feature Funnels table
  'FeatureFunnels': {
    'funnel_id': 'Funnel ID',
    'display_name': 'Display Name',
    'description': 'Description',
    'steps': 'Steps',
    'created_at': 'Created At',
    'updated_at': 'Updated At',
    'is_active': 'Is Active',
    'wix_id': 'Wix ID'
  },

  // FeatureMetricsDaily - v2_Feature Metrics Daily table
  'FeatureMetricsDaily': {
    'feature_id': 'Feature ID',
    'date': 'Date',
    'unique_users': 'Unique Users',
    'total_interactions': 'Total Interactions',
    'completion_rate': 'Completion Rate',
    'avg_duration_ms': 'Avg Duration (ms)',
    'error_rate': 'Error Rate',
    'abandon_rate': 'Abandon Rate',
    'by_role': 'By Role',
    'by_device': 'By Device',
    'by_entry_point': 'By Entry Point',
    'top_errors': 'Top Errors',
    'conversion_value_total': 'Conversion Value Total',
    'wix_id': 'Wix ID'
  },

  // FeatureRegistry - v2_Feature Registry table
  'FeatureRegistry': {
    'feature_id': 'Feature ID',
    'display_name': 'Display Name',
    'description': 'Description',
    'category': 'Category',
    'launch_date': 'Launch Date',
    'status': 'Status',
    'expected_usage_pattern': 'Expected Usage Pattern',
    'target_roles': 'Target Roles',
    'owner': 'Owner',
    'success_metric': 'Success Metric',
    'retirement_threshold': 'Retirement Threshold',
    'related_features': 'Related Features',
    'documentation_url': 'Documentation URL',
    'wix_id': 'Wix ID'
  },

  // =========================================================================
  // GROUP: SUPPORT & OPERATIONS
  // =========================================================================

  'SupportTickets': {
    'ticket_number': 'Ticket Number',
    'subject': 'Subject',
    'description': 'Description',
    'status': 'Status',
    'priority': 'Priority',
    'category': 'Category',
    'user_id': 'User ID',
    'user_email': 'User Email',
    'user_role': 'User Role',
    'assigned_to': 'Assigned To',
    'created_at': 'Created At',
    'updated_at': 'Updated At',
    'response_due': 'Response Due',
    'resolution_due': 'Resolution Due',
    'resolved_at': 'Resolved At',
    'is_escalated': 'Is Escalated',
    'escalation_reason': 'Escalation Reason',
    'metadata': 'Metadata'
  },

  'TicketComments': {
    'ticket_id': 'Ticket ID',
    'user_id': 'User ID',
    'user_email': 'User Email',
    'user_role': 'User Role',
    'content': 'Content',
    'is_internal': 'Is Internal',
    'created_at': 'Created At'
  },

  'TicketTags': {
    'tag_name': 'Tag Name',
    'color': 'Color',
    'usage_count': 'Usage Count'
  },

  'KnowledgeArticles': {
    'title': 'Title',
    'slug': 'Slug',
    'content': 'Content',
    'category_id': 'Category ID',
    'subcategory_id': 'Subcategory ID',
    'status': 'Status',
    'visibility': 'Visibility',
    'author_id': 'Author ID',
    'author_email': 'Author Email',
    'tags': 'Tags',
    'view_count': 'View Count',
    'helpful_votes': 'Helpful Votes',
    'not_helpful_votes': 'Not Helpful Votes',
    'meta_title': 'Meta Title',
    'meta_description': 'Meta Description',
    'related_articles': 'Related Articles',
    'created_at': 'Created At',
    'updated_at': 'Updated At',
    'published_at': 'Published At',
    'version': 'Version'
  },

  'ArticleCategories': {
    'name': 'Name',
    'slug': 'Slug',
    'description': 'Description',
    'parent_id': 'Parent ID',
    'display_order': 'Display Order',
    'icon': 'Icon',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  'ArticleVersions': {
    'article_id': 'Article ID',
    'content': 'Content',
    'title': 'Title',
    'version_number': 'Version Number',
    'created_by': 'Created By',
    'created_at': 'Created At',
    'change_summary': 'Change Summary'
  },

  'NPSResponses': {
    'user_id': 'User ID',
    'user_email': 'User Email',
    'user_role': 'User Role',
    'score': 'Score',
    'comment': 'Comment',
    'category': 'Category',
    'survey_type': 'Survey Type',
    'trigger_type': 'Trigger Type',
    'created_at': 'Created At',
    'metadata': 'Metadata'
  },

  'SurveyConfig': {
    'trigger_type': 'Trigger Type',
    'survey_type': 'Survey Type',
    'is_active': 'Is Active',
    'cooldown_days': 'Cooldown Days',
    'sample_rate': 'Sample Rate',
    'updated_at': 'Updated At'
  },

  'NPSTrends': {
    'period_date': 'Period Date',
    'granularity': 'Granularity',
    'nps_score': 'NPS Score',
    'total_responses': 'Total Responses',
    'promoters': 'Promoters',
    'detractors': 'Detractors'
  },

  'ChatSessions': {
    'user_id': 'User ID',
    'user_email': 'User Email',
    'user_role': 'User Role',
    'topic': 'Topic',
    'status': 'Status',
    'assigned_to': 'Assigned To',
    'created_at': 'Created At',
    'updated_at': 'Updated At',
    'queue_start_at': 'Queue Start At',
    'active_since': 'Active Since',
    'ended_at': 'Ended At',
    'rating': 'Rating',
    'ticket_id': 'Ticket ID',
    'metadata': 'Metadata'
  },

  'ChatMessages': {
    'session_id': 'Session ID',
    'sender_id': 'Sender ID',
    'sender_email': 'Sender Email',
    'sender_type': 'Sender Type',
    'content': 'Content',
    'created_at': 'Created At'
  },

  'CannedResponses': {
    'title': 'Title',
    'shortcode': 'Shortcode',
    'category': 'Category',
    'content': 'Content',
    'usage_count': 'Usage Count',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  // v2_Lifecycle Events table
  'lifecycleEvents': {
    'driver_id': 'Driver ID',
    'carrier_id': 'Carrier ID',
    'event_type': 'Event Type',
    'event_date': 'Event Date',
    'metadata': 'Metadata',
    'created_by': 'Created By',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // v2_Termination Logs table
  'terminationLogs': {
    'driver_id': 'Driver ID',
    'carrier_id': 'Carrier ID',
    'tenure_days': 'Tenure Days',
    'is_early_churn': 'Is Early Churn',
    'category': 'Category',
    'reason_code': 'Reason Code',
    'notes': 'Notes',
    'driver_feedback': 'Driver Feedback',
    'source': 'Source',
    'rehire_eligible': 'Rehire Eligible',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // v2_Survey Definitions table
  'surveyDefinitions': {
    'trigger_event': 'Trigger Event',
    'questions': 'Questions',
    'is_active': 'Is Active',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // v2_Survey Responses table
  'surveyResponses': {
    'survey_id': 'Survey ID',
    'driver_id': 'Driver ID',
    'carrier_id': 'Carrier ID',
    'scores': 'Scores',
    'comments': 'Comments',
    'legacy_wix_id': 'Legacy Wix ID'
  },

  // =========================================================================
  // GROUP: GAMIFICATION SYSTEM
  // =========================================================================

  // v2_Recruiter Badges table
  'v2_Recruiter Badges': {
    'recruiter_id': 'Recruiter ID',
    'badge_id': 'Badge ID',
    'badge_category': 'Badge Category',
    'current_tier': 'Current Tier',
    'tier_name': 'Tier Name',
    'badge_color': 'Badge Color',
    'earned_at': 'Earned At',
    'last_upgraded': 'Last Upgraded',
    'progress': 'Progress',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  // v2_Badge Definitions table
  'v2_Badge Definitions': {
    'badge_id': 'Badge ID',
    'name': 'Name',
    'description': 'Description',
    'category': 'Category',
    'icon': 'Icon',
    'color': 'Color',
    'user_type': 'User Type',
    'max_tier': 'Max Tier',
    'tier_names': 'Tier Names',
    'tier_thresholds': 'Tier Thresholds',
    'is_active': 'Is Active',
    'display_order': 'Display Order'
  },

  // v2_Recruiter Progression table
  'v2_Recruiter Progression': {
    'recruiter_id': 'Recruiter ID',
    'carrier_id': 'Carrier ID',
    'current_points': 'Current Points',
    'rank': 'Rank',
    'rank_title': 'Rank Title',
    'points_to_next_rank': 'Points To Next Rank',
    'total_hires': 'Total Hires',
    'total_outreach': 'Total Outreach',
    'avg_response_hours': 'Avg Response Hours',
    'hire_acceptance_rate': 'Hire Acceptance Rate',
    'retention_90_day_rate': 'Retention 90 Day Rate',
    'driver_satisfaction_avg': 'Driver Satisfaction Avg',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  // v2_Driver Progression table
  'v2_Driver Progression': {
    'driver_id': 'Driver ID',
    'current_xp': 'Current XP',
    'level': 'Level',
    'level_title': 'Level Title',
    'xp_to_next_level': 'XP To Next Level',
    'streak_days': 'Streak Days',
    'longest_streak': 'Longest Streak',
    'last_login_date': 'Last Login Date',
    'streak_freeze_available': 'Streak Freeze Available',
    'total_applications': 'Total Applications',
    'total_responses': 'Total Responses',
    'avg_response_hours': 'Avg Response Hours',
    'profile_completion': 'Profile Completion',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  // v2_Driver Achievements table
  'v2_Driver Achievements': {
    'user_id': 'Driver ID',
    'user_type': 'User Type',
    'achievement_id': 'Achievement ID',
    'achievement_name': 'Achievement Name',
    'earned_at': 'Earned At',
    'progress': 'Progress',
    'is_complete': 'Is Complete',
    'notified': 'Notified',
    'display_order': 'Display Order'
  },

  // v2_Achievement Definitions table
  'v2_Achievement Definitions': {
    'achievement_id': 'Achievement ID',
    'name': 'Name',
    'description': 'Description',
    'category': 'Category',
    'icon': 'Icon',
    'color': 'Color',
    'user_type': 'User Type',
    'requirement_type': 'Requirement Type',
    'requirement_field': 'Requirement Field',
    'requirement_value': 'Requirement Value',
    'xp_reward': 'XP Reward',
    'is_hidden': 'Is Hidden',
    'is_active': 'Is Active',
    'display_order': 'Display Order'
  },

  // v2_Gamification Events table
  'v2_Gamification Events': {
    'event_id': 'Event ID',
    'user_id': 'User ID',
    'user_type': 'User Type',
    'event_type': 'Event Type',
    'action': 'Action',
    'xp_earned': 'XP Earned',
    'points_earned': 'Points Earned',
    'streak_bonus': 'Streak Bonus',
    'source_id': 'Source ID',
    'source_type': 'Source Type',
    'metadata_json': 'Metadata JSON',
    'created_at': 'Created At'
  },

  // v2_Leaderboard Snapshots table
  'v2_Leaderboard Snapshots': {
    'snapshot_id': 'Snapshot ID',
    'period_type': 'Period Type',
    'period_start': 'Period Start',
    'period_end': 'Period End',
    'leaderboard_type': 'Leaderboard Type',
    'rankings_json': 'Rankings JSON',
    'created_at': 'Created At'
  },

  // v2_Seasonal Events table
  'v2_Seasonal Events': {
    'event_id': 'Event ID',
    'event_name': 'Event Name',
    'description': 'Description',
    'start_date': 'Start Date',
    'end_date': 'End Date',
    'is_active': 'Is Active',
    'xp_multiplier': 'XP Multiplier',
    'points_multiplier': 'Points Multiplier',
    'badges_json': 'Badges JSON',
    'challenges_json': 'Challenges JSON',
    'created_at': 'Created At'
  },

  // v2_Challenge Definitions table
  'v2_Challenge Definitions': {
    'challenge_id': 'Challenge ID',
    'name': 'Name',
    'description': 'Description',
    'challenge_type': 'Challenge Type',
    'user_type': 'User Type',
    'action_type': 'Action Type',
    'action_subtype': 'Action Subtype',
    'target_value': 'Target Value',
    'xp_reward': 'XP Reward',
    'points_reward': 'Points Reward',
    'icon': 'Icon',
    'color': 'Color',
    'is_repeatable': 'Is Repeatable',
    'auto_assign': 'Auto Assign',
    'is_active': 'Is Active',
    'display_order': 'Display Order',
    'event_start_date': 'Event Start Date',
    'event_end_date': 'Event End Date'
  },

  // v2_Driver Challenges table
  'v2_Driver Challenges': {
    'user_id': 'User ID',
    'challenge_definition_id': 'Challenge Definition ID',
    'challenge_name': 'Challenge Name',
    'challenge_type': 'Challenge Type',
    'status': 'Status',
    'current_value': 'Current Value',
    'target_value': 'Target Value',
    'xp_reward': 'XP Reward',
    'points_reward': 'Points Reward',
    'started_at': 'Started At',
    'expires_at': 'Expires At',
    'completed_at': 'Completed At',
    'claimed_at': 'Claimed At',
    'expired_at': 'Expired At',
    'reminder_sent': 'Reminder Sent',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  // v2_Recruiter Challenges table
  'v2_Recruiter Challenges': {
    'user_id': 'User ID',
    'challenge_definition_id': 'Challenge Definition ID',
    'challenge_name': 'Challenge Name',
    'challenge_type': 'Challenge Type',
    'status': 'Status',
    'current_value': 'Current Value',
    'target_value': 'Target Value',
    'xp_reward': 'XP Reward',
    'points_reward': 'Points Reward',
    'started_at': 'Started At',
    'expires_at': 'Expires At',
    'completed_at': 'Completed At',
    'claimed_at': 'Claimed At',
    'expired_at': 'Expired At',
    'reminder_sent': 'Reminder Sent',
    'created_at': 'Created At',
    'updated_at': 'Updated At'
  },

  // v2_Match Notification Log table
  'v2_Match Notification Log': {
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'notification_type': 'Notification Type',
    'channel': 'Channel',
    'recipient_id': 'Recipient ID',
    'sent_at': 'Sent At',
    'status': 'Status',
    'error_message': 'Error Message',
    'metadata': 'Metadata'
  },

  // =========================================================================
  // GROUP: RECRUITER UTILITY EXPANSION
  // =========================================================================

  // v2_Saved Searches table
  'SavedSearches': {
    'carrier_dot': 'Carrier DOT',
    'recruiter_id': 'Recruiter ID',
    'search_name': 'Search Name',
    'criteria_json': 'Criteria JSON',
    'alert_frequency': 'Alert Frequency',
    'alert_channel': 'Alert Channel',
    'last_run_date': 'Last Run Date',
    'last_match_count': 'Last Match Count',
    'new_matches_since_last': 'New Matches Since Last',
    'is_active': 'Is Active'
  },

  // v2_Saved Search Alerts table
  'SavedSearchAlerts': {
    'saved_search_id': 'Saved Search ID',
    'recruiter_id': 'Recruiter ID',
    'driver_ids_json': 'Driver IDs JSON',
    'alert_status': 'Alert Status',
    'sent_at': 'Sent At',
    'viewed_at': 'Viewed At',
    'channel_used': 'Channel Used'
  },

  // v2_Call Outcomes table
  'CallOutcomes': {
    'recruiter_id': 'Recruiter ID',
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'call_timestamp': 'Call Timestamp',
    'call_duration_seconds': 'Call Duration Seconds',
    'outcome': 'Outcome',
    'outcome_details': 'Outcome Details',
    'follow_up_date': 'Follow Up Date',
    'follow_up_type': 'Follow Up Type',
    'match_score_at_call': 'Match Score At Call',
    'source': 'Source',
    'sentiment': 'Sentiment',
    'notes': 'Notes'
  },

  // v2_Call Feedback table
  'CallFeedback': {
    'carrier_dot': 'Carrier DOT',
    'criteria_key': 'Criteria Key',
    'outcome_count': 'Outcome Count',
    'positive_weight': 'Positive Weight',
    'negative_weight': 'Negative Weight',
    'last_calculated': 'Last Calculated'
  },

  // v2_Intervention Templates table
  'InterventionTemplates': {
    'carrier_dot': 'Carrier DOT',
    'risk_type': 'Risk Type',
    'template_name': 'Template Name',
    'channel': 'Channel',
    'subject_line': 'Subject Line',
    'body_template': 'Body Template',
    'tone': 'Tone',
    'is_default': 'Is Default',
    'usage_count': 'Usage Count',
    'success_rate': 'Success Rate',
    'is_active': 'Is Active'
  },

  // v2_Intervention Log table
  'InterventionLog': {
    'template_id': 'Template ID',
    'driver_id': 'Driver ID',
    'recruiter_id': 'Recruiter ID',
    'carrier_dot': 'Carrier DOT',
    'sent_at': 'Sent At',
    'channel_used': 'Channel Used',
    'message_sent': 'Message Sent',
    'outcome': 'Outcome',
    'outcome_date': 'Outcome Date',
    'is_active': 'Is Active'
  },

  // v2_Pipeline Automation Rules table
  'PipelineAutomationRules': {
    'carrier_dot': 'Carrier DOT',
    'rule_name': 'Rule Name',
    'trigger_event': 'Trigger Event',
    'trigger_conditions_json': 'Trigger Conditions JSON',
    'from_stage': 'From Stage',
    'to_stage': 'To Stage',
    'auto_note': 'Auto Note',
    'notify_recruiter': 'Notify Recruiter',
    'is_active': 'Is Active',
    'priority': 'Priority',
    'is_default': 'Is Default'
  },

  // v2_Automation Log table
  'AutomationLog': {
    'rule_id': 'Rule ID',
    'carrier_dot': 'Carrier DOT',
    'driver_id': 'Driver ID',
    'interest_id': 'Interest ID',
    'trigger_event': 'Trigger Event',
    'from_stage': 'From Stage',
    'to_stage': 'To Stage',
    'executed_at': 'Executed At',
    'success': 'Success',
    'error_message': 'Error Message'
  },

  // v2_Recruiter Profiles table
  'RecruiterProfiles': {
    '_owner': 'Wix ID',
    'wix_id': 'Wix ID',
    'agency_name': 'Agency Name',
    'is_independent': 'Is Independent',
    'display_name': 'Display Name',
    'email': 'Email',
    'phone': 'Phone',
    'role': 'Role',
    'created_date': 'Created Date',
    'last_active_date': 'Last Active Date',
    'is_active': 'Is Active',
    'recruiter_id': 'Recruiter ID'
  },

  // Legacy Driver Leads table (pre-existing, no v2_ prefix)
  'LegacyDriverLeads': {
    'first_name': 'First Name',
    'last_name': 'Last Name',
    'email': 'Email 1',
    'phone': 'Phone 1',
    'formatted_phone': 'Formatted Phone Number 1',
    'created_at': 'Created At (UTC+0)'
  },

  // Applications table (pre-existing, no v2_ prefix)
  'Applications': {
    'first_name': 'First Name',
    'last_name': 'Last Name',
    'phone': 'Phone Number',
    'email': 'Email',
    'cdl_class': 'CDL Class',
    'has_valid_cdl': 'Do you have a valid CDL?',
    'years_experience': 'Years of Experience',
    'cdl_state': 'State of Issue',
    'violations_3yr': 'Any violations in the last 3 years?',
    'accidents_3yr': 'Any Accidents in the last 3 years?',
    'endorsements': 'Endorsements?',
    'route_pref_1': 'Route Types - First Option',
    'route_pref_2': 'Route Types - Second Option',
    'route_pref_3': 'Route Types - Third Option',
    'availability': 'When can you start?',
    'total_score': 'Total_Score',
    'cdl_front_url': 'Upload front of CDL',
    'cdl_back_url': 'Upload back of CDL',
    'med_card_url': 'Upload valid med card',
    'birthdate': 'Birthdate',
    'has_hazmat': 'HasHazmatEndorsement',
    'has_tanker': 'HasTankerEndorsement',
    'is_otr_friendly': 'IsOTRFriendly',
    'is_regional_friendly': 'IsRegionalFriendly',
    'is_local_friendly': 'IsLocalFriendly',
    'has_cdl_a': 'HasCDLClassA',
    'has_cdl_b': 'HasCDLClassB',
    'has_cdl_c': 'HasCDLClassC',
    'clean_record': 'CleanRecord',
    'years_exp_num': 'YearsExpNum',
    'driver_category': 'Driver Category',
    'route_preference_vector': 'RoutePreferenceVector',
    'submission_date': 'Submission Date'
  },

  // CDL DRIVERS NJ FB CAMPAIGN table (pre-existing, no v2_ prefix)
  'FBCampaignDrivers': {
    'created_time': 'created_time',
    'platform': 'platform',
    'cdl_type': 'what_type_of_cdl_do_you_currently_hold?',
    'can_start_soon': 'are_you_able_to_start_within_the_next_7\u201314_days?',
    'email': 'email',
    'full_name': 'full_name',
    'phone': 'phone',
    'phone_e164': 'Phone (E164)',
    'state': 'State (from Area Code)'
  },

  // Scored Drivers table (pre-existing, no v2_ prefix)
  'ScoredDrivers': {
    'first_name': 'First name',
    'last_name': 'Last Name',
    'email': 'Email',
    'phone': 'Phone',
    'date_of_birth': 'Date of birth',
    'cdl_class': 'cdl_class',
    'cdl_state': 'State of Issue',
    'endorsements': 'endorsements',
    'years_experience': 'years_experience',
    'accidents_3yr': 'accidents_3yr',
    'violations_3yr': 'violations_3yr',
    'route_pref_1': 'Route Types - First Option',
    'route_pref_2': 'Route Types - Second Option',
    'route_pref_3': 'Route Types - Third Option',
    'availability': 'Start Date Availability',
    'priority_score': 'Priority Score',
    'driver_id': 'Driver ID',
    'status': 'Status',
    'driver_category': 'Driver Category',
    'last_date_modified': 'Last Date Modified',
    'ending': 'Ending'
  },

  // Async search pipeline — v2_Search Jobs uses snake_case column names
  'searchJobs': {
    'job_id':       'job_id',
    'status':       'status',
    'started_at':   'started_at',
    'completed_at': 'completed_at',
    'driver_prefs': 'driver_prefs',
    'is_premium':   'is_premium',
    'results':      'results',
    'error':        'error',
    'total_found':  'total_found',
    'total_scored': 'total_scored',
    'elapsed_ms':   'elapsed_ms'
  },

  // Agent & Voice collections — camelCase fields need explicit mapping
  'agentConversations': {
    'role': 'Role',
    'userId': 'User Id',
    'startedAt': 'Started At',
    'endedAt': 'Ended At',
    'status': 'Status',
    'turnCount': 'Turn Count'
  },
  'agentTurns': {
    'conversationId': 'Conversation Id',
    'role': 'Role',
    'content': 'Content',
    'toolCalls': 'Tool Calls',
    'timestamp': 'Timestamp'
  },
  'agentRuns': {
    'run_id': 'Run Id',
    'conversation_id': 'Conversation Id',
    'initiator_id': 'Initiator Id',
    'role': 'Role',
    'goal_text': 'Goal Text',
    'status': 'Status',
    'total_tokens': 'Total Tokens',
    'total_cost_usd': 'Total Cost Usd',
    'steps_count': 'Steps Count',
    'started_at': 'Started At',
    'completed_at': 'Completed At',
    'sla_ms': 'Sla Ms'
  },
  'agentSteps': {
    'step_id': '__SKIP__',
    'run_id': 'run_id',
    'tool_name': 'tool_name',
    'risk_level': 'risk_level',
    'args_hash': 'args_hash',
    'result_summary': 'result_summary',
    'latency_ms': 'latency_ms',
    'retries': 'retries',
    'status': 'status',
    'approval_gate_id': 'approval_gate_id',
    'created_at': 'created_at'
  },
  'approvalGates': {
    'gate_id': '__SKIP__',
    'run_id': 'Run Id',
    'step_id': 'Step Id',
    'tool_name': 'Tool Name',
    'reason': 'Reason',
    'risk_level': 'Risk Level',
    'presented_at': 'Presented At',
    'decision': 'Decision',
    'decided_by': 'Decided By',
    'decided_at': 'Decided At'
  },
  'runOutcomes': {
    'run_id': 'Run Id',
    'role': 'Role',
    'outcome': 'Outcome',
    'quality_score': 'Quality Score',
    'created_at': 'Created At'
  },
  'voiceCallLogs': {
    'call_id': 'Call Id',
    'assistant_id': 'Assistant Id',
    'status': 'Status',
    'duration': 'Duration',
    'transcript': 'Transcript',
    'summary': 'Summary',
    'created_at': 'Created At'
  },
  'voiceCampaigns': {
    'recruiter_id': 'Recruiter Id',
    'name': 'Name',
    'status': 'Status',
    'created_at': 'Created At'
  },
  'voiceCampaignContacts': {
    'campaign_id': 'Campaign Id',
    'driver_id': 'Driver Id',
    'status': 'Status',
    'called_at': 'Called At'
  }
};

// ============================================================================
// RATE LIMITING STATE
// ============================================================================

let lastRequestTime = 0;
const requestQueue = [];
let isProcessingQueue = false;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Promise-based delay
 * @param {number} ms - Milliseconds to wait
 * @returns {Promise<void>}
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Get the API key from Wix Secrets Manager (cached for 1 hour)
 * @returns {Promise<string>} The Airtable API key
 * @throws {Error} If no API key is found
 */
let __apiKeyCache = null;
let __apiKeyCacheTime = 0;
const API_KEY_CACHE_TTL = 3600000; // 1 hour

async function getApiKey() {
  const now = Date.now();
  if (__apiKeyCache && (now - __apiKeyCacheTime < API_KEY_CACHE_TTL)) {
    return __apiKeyCache;
  }

  for (const secretName of CONFIG.secretNames) {
    try {
      const key = await getSecret(secretName);
      if (key) {
        __apiKeyCache = key;
        __apiKeyCacheTime = now;
        return key;
      }
    } catch (e) {
      // Try next secret name
    }
  }
  throw new Error('Airtable API key not found in Secrets Manager. Add AIRTABLE_PAT or AIRTABLE_API_KEY.');
}

/**
 * Get the Airtable table name for a Wix collection
 * @param {string} wixCollectionName - The Wix collection name
 * @returns {string} The Airtable table name
 */
function getTableName(wixCollectionName) {
  // Defensive: catch non-string arguments (e.g. unresolved Promises)
  if (typeof wixCollectionName !== 'string') {
    const repr = String(wixCollectionName);
    const stack = new Error('NON_STRING_TABLE_NAME').stack;
    console.error(`[airtableClient] Non-string table name (${typeof wixCollectionName}): ${repr}. Check for missing 'await' on an async function.\nStack trace:\n${stack}`);
    return repr;
  }

  const tableName = TABLE_NAMES[wixCollectionName];
  if (tableName) {
    return tableName;
  }

  // If it's already a v2_ prefixed name (from callers using getAirtableTableName), use as-is
  if (wixCollectionName.startsWith('v2_')) {
    return wixCollectionName;
  }

  console.warn(`[airtableClient] No mapping for collection "${wixCollectionName}", using as-is`);
  return wixCollectionName;
}

/**
 * Get field mappings for a table
 * @param {string} tableName - The Wix collection name
 * @returns {Object} Field mappings (wix -> airtable)
 */
function getFieldMappings(tableName) {
  // Direct lookup (PascalCase Wix collection name)
  if (FIELD_MAPPINGS[tableName]) {
    return { ...FIELD_MAPPINGS['_common'], ...FIELD_MAPPINGS[tableName] };
  }

  // Resolve camelCase or Airtable table name → PascalCase FIELD_MAPPINGS key
  // e.g. 'memberActivity' → TABLE_NAMES → 'v2_Member Activity' → reverse → 'MemberActivity'
  // e.g. 'v2_Member Activity' → directly reverse → 'MemberActivity'
  const resolvedAirtable = TABLE_NAMES[tableName] || tableName;
  for (const key of Object.keys(FIELD_MAPPINGS)) {
    if (key === '_common') continue;
    if (TABLE_NAMES[key] === resolvedAirtable) {
      return { ...FIELD_MAPPINGS['_common'], ...FIELD_MAPPINGS[key] };
    }
  }

  return { ...FIELD_MAPPINGS['_common'] };
}

/**
 * Public wrapper for getFieldMappings (exported for sort field mapping in dataAccess)
 */
export function getFieldMappingsPublic(tableName) {
  return getFieldMappings(tableName);
}

/**
 * Get reverse field mappings for a table (airtable -> wix)
 * @param {string} tableName - The Wix collection name
 * @returns {Object} Reverse field mappings
 */
function getReverseFieldMappings(tableName) {
  const mappings = getFieldMappings(tableName);
  const reverse = {};
  for (const [wix, airtable] of Object.entries(mappings)) {
    if (!reverse[airtable]) {
      reverse[airtable] = wix;
    }
  }
  return reverse;
}

// ============================================================================
// FIELD TRANSFORMATION FUNCTIONS
// ============================================================================

/**
 * Transform a record from Wix format to Airtable format
 * @param {Object} record - The Wix-formatted record
 * @param {string} tableName - The Wix collection name
 * @returns {Object} Airtable-formatted fields object
 */
export function toAirtableFormat(record, tableName) {
  const mappings = getFieldMappings(tableName);
  const airtableFields = {};

  warnOnUnmappedFields(record, tableName, mappings);

  for (const [wixField, value] of Object.entries(record)) {
    // Skip internal Wix fields that Airtable manages
    if (['_id', '_createdDate', '_updatedDate', '_owner'].includes(wixField)) {
      continue;
    }

    // Get the Airtable field name
    const airtableField = mappings[wixField];

    if (airtableField === '__SKIP__') {
      // Explicitly skipped — field has no Airtable column
      continue;
    } else if (airtableField) {
      // Use mapped name
      airtableFields[airtableField] = transformValueToAirtable(value);
    } else {
      // Convert snake_case to Title Case if no explicit mapping
      const titleCase = wixField
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
      airtableFields[titleCase] = transformValueToAirtable(value);
    }
  }

  return airtableFields;
}

/**
 * Lightweight schema validation: warn if a record uses fields without explicit mappings.
 * This helps catch Airtable column mismatches early.
 *
 * @param {Object} record - Wix-formatted record
 * @param {string} tableName - Wix collection name
 * @param {Object} mappings - Resolved field mappings for the table
 */
function warnOnUnmappedFields(record, tableName, mappings) {
  if (!record || typeof record !== 'object') return;

  // Only warn when a table has explicit mappings defined.
  const hasExplicitMapping = !!FIELD_MAPPINGS[tableName] ||
    Object.keys(FIELD_MAPPINGS).some(key => key !== '_common' && TABLE_NAMES[key] === (TABLE_NAMES[tableName] || tableName));

  if (!hasExplicitMapping) return;

  const strictTables = new Set([
    'AIUsageLog',
    'AdminAuditLog',
    'SystemLogs',
    'SystemErrors',
    'SystemTraces',
    'SystemMetrics'
  ]);

  const ignore = new Set(['_id', '_createdDate', '_updatedDate', '_owner']);
  const unmapped = [];

  for (const key of Object.keys(record)) {
    if (ignore.has(key)) continue;
    if (!mappings[key]) unmapped.push(key);
  }

  if (unmapped.length > 0) {
    const message = `Airtable schema mismatch for ${tableName}. Unmapped fields: ${unmapped.join(', ')}.`;
    if (strictTables.has(tableName)) {
      throw new Error(message);
    }
    console.warn(`[airtableClient] ${message} These will be Title Cased.`);
  }
}

/**
 * Transform a record from Airtable format to Wix format
 * @param {Object} airtableRecord - The Airtable record (with id and fields)
 * @param {string} tableName - The Wix collection name
 * @returns {Object} Wix-formatted record
 */
export function toWixFormat(airtableRecord, tableName) {
  const reverseMappings = getReverseFieldMappings(tableName);
  const wixRecord = {
    _id: airtableRecord.id,
    _createdDate: airtableRecord.createdTime ? new Date(airtableRecord.createdTime) : null
  };

  const fields = airtableRecord.fields || {};

  for (const [airtableField, value] of Object.entries(fields)) {
    // Check for explicit reverse mapping
    const wixField = reverseMappings[airtableField];

    if (wixField) {
      // Use mapped name
      wixRecord[wixField] = transformValueFromAirtable(value);
    } else {
      // Convert Title Case to snake_case if no explicit mapping
      const snakeCase = airtableField
        .replace(/([A-Z])/g, '_$1')
        .replace(/\s+/g, '_')
        .toLowerCase()
        .replace(/^_/, '')
        .replace(/__+/g, '_');
      wixRecord[snakeCase] = transformValueFromAirtable(value);
    }
  }

  return wixRecord;
}

/**
 * Transform a value for Airtable storage
 * @param {*} value - The value to transform
 * @returns {*} The transformed value
 */
function transformValueToAirtable(value) {
  if (value === null || value === undefined) {
    return null;
  }

  // Handle Date objects
  if (value instanceof Date) {
    return value.toISOString();
  }

  // Handle arrays (for multi-select or linked records)
  if (Array.isArray(value)) {
    return value.map(v => transformValueToAirtable(v));
  }

  // Handle objects (stringify for long text fields)
  if (typeof value === 'object') {
    return JSON.stringify(value);
  }

  return value;
}

/**
 * Transform a value from Airtable format
 * @param {*} value - The Airtable value
 * @returns {*} The transformed value
 */
function transformValueFromAirtable(value) {
  if (value === null || value === undefined) {
    return null;
  }

  // Try to parse JSON strings back to objects
  if (typeof value === 'string') {
    // Check if it looks like JSON
    if ((value.startsWith('{') && value.endsWith('}')) ||
        (value.startsWith('[') && value.endsWith(']'))) {
      try {
        return JSON.parse(value);
      } catch (e) {
        // Not valid JSON, return as-is
        return value;
      }
    }

    // Check if it's an ISO date string
    if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
      return new Date(value);
    }
  }

  return value;
}

// ============================================================================
// RATE-LIMITED REQUEST HANDLER
// ============================================================================

/**
 * Execute a rate-limited request to Airtable
 * Ensures at least 200ms between requests (5/sec limit)
 * @param {Function} requestFn - The request function to execute
 * @returns {Promise<*>} The request result
 */
async function executeRateLimited(requestFn) {
  const now = Date.now();
  const timeSinceLastRequest = now - lastRequestTime;

  if (timeSinceLastRequest < CONFIG.rateLimit.requestDelayMs) {
    await sleep(CONFIG.rateLimit.requestDelayMs - timeSinceLastRequest);
  }

  lastRequestTime = Date.now();
  return requestFn();
}

// ============================================================================
// CORE API REQUEST FUNCTION
// ============================================================================

/**
 * Make a request to the Airtable API with rate limiting and error handling
 *
 * @param {string} endpoint - The API endpoint (relative to base URL + base ID)
 * @param {string} method - HTTP method (GET, POST, PATCH, DELETE)
 * @param {Object} [body] - Request body for POST/PATCH requests
 * @returns {Promise<Object>} The API response
 * @throws {Error} If the request fails after retries
 *
 * @example
 * // Get a record
 * const record = await airtableRequest('/v2_Carriers/recXXX', 'GET');
 *
 * @example
 * // Create a record
 * const newRecord = await airtableRequest('/v2_Carriers', 'POST', {
 *   fields: { 'Company Name': 'Test Carrier' }
 * });
 */
export async function airtableRequest(endpoint, method = 'GET', body = null) {
  const apiKey = await getApiKey();
  const url = `${CONFIG.baseUrl}/${CONFIG.baseId}${endpoint}`;

  const headers = {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  };

  const options = {
    method,
    headers
  };

  if (body && (method === 'POST' || method === 'PATCH' || method === 'PUT')) {
    options.body = JSON.stringify(body);
  }

  let lastError;

  for (let attempt = 0; attempt < CONFIG.rateLimit.maxRetries; attempt++) {
    try {
      const response = await executeRateLimited(() => fetch(url, options));

      // Handle rate limiting (429)
      if (response.status === 429) {
        const retryAfter = parseInt(response.headers.get('Retry-After') || '30', 10);
        const backoff = Math.min(
          CONFIG.rateLimit.baseBackoffMs * Math.pow(2, attempt) + Math.random() * 1000,
          CONFIG.rateLimit.maxBackoffMs
        );
        const waitTime = Math.max(retryAfter * 1000, backoff);

        console.warn(`[airtableClient] Rate limited. Waiting ${waitTime}ms before retry ${attempt + 1}/${CONFIG.rateLimit.maxRetries}`);
        await sleep(waitTime);
        continue;
      }

      // Handle other errors
      if (!response.ok) {
        const errorBody = await readResponseText(response);
        let errorMessage;
        try {
          const errorJson = JSON.parse(errorBody);
          errorMessage = errorJson.error?.message || (typeof errorJson.error === 'string' ? errorJson.error : JSON.stringify(errorJson.error)) || errorBody;
        } catch {
          errorMessage = errorBody;
        }

        // Don't retry client errors (4xx except 429)
        if (response.status >= 400 && response.status < 500) {
          throw new Error(`Airtable API error (${response.status}): ${errorMessage}`);
        }

        // Retry server errors (5xx)
        lastError = new Error(`Airtable API error (${response.status}): ${errorMessage}`);
        const backoff = CONFIG.rateLimit.baseBackoffMs * Math.pow(2, attempt);
        console.warn(`[airtableClient] Server error. Retry ${attempt + 1}/${CONFIG.rateLimit.maxRetries} in ${backoff}ms`);
        await sleep(backoff);
        continue;
      }

      // Success - parse and return
      const responseText = await readResponseText(response);
      if (!responseText) {
        return { success: true };
      }

      return JSON.parse(responseText);

    } catch (error) {
      lastError = error;

      // Network errors - retry with backoff
      if (error.message.includes('fetch') || error.message.includes('network')) {
        const backoff = CONFIG.rateLimit.baseBackoffMs * Math.pow(2, attempt);
        console.warn(`[airtableClient] Network error. Retry ${attempt + 1}/${CONFIG.rateLimit.maxRetries} in ${backoff}ms`);
        await sleep(backoff);
        continue;
      }

      // Other errors - don't retry
      throw error;
    }
  }

  // All retries exhausted
  console.error('[airtableClient] Request failed after all retries:', lastError?.message);
  throw lastError || new Error('Airtable request failed after max retries');
}

/**
 * Read response body text safely across real and mocked fetch responses.
 * Some tests provide a response object without a text() function.
 *
 * @param {Object} response
 * @returns {Promise<string>}
 */
async function readResponseText(response) {
  if (response && typeof response.text === 'function') {
    return await response.text();
  }

  if (response && typeof response.json === 'function') {
    const json = await response.json();
    return json ? JSON.stringify(json) : '';
  }

  return '';
}

// ============================================================================
// CRUD OPERATIONS
// ============================================================================

/**
 * Get a single record by ID
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} recordId - The Airtable record ID
 * @returns {Promise<Object>} The record in Wix format
 *
 * @example
 * const carrier = await getRecord('Carriers', 'recXXXXXXXXXXXXXX');
 */
export async function getRecord(tableName, recordId) {
  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  try {
    const response = await airtableRequest(`/${encodedTable}/${recordId}`, 'GET');
    return toWixFormat(response, tableName);
  } catch (error) {
    console.error(`[airtableClient] getRecord error (${tableName}/${recordId}):`, error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Query records with optional filtering, sorting, and pagination
 *
 * @param {string} tableName - The Wix collection name
 * @param {Object} [options] - Query options
 * @param {string} [options.filterByFormula] - Airtable formula for filtering
 * @param {Array<Object>} [options.sort] - Sort configuration [{field, direction}]
 * @param {number} [options.maxRecords] - Maximum records to return
 * @param {string} [options.offset] - Pagination offset token
 * @param {Array<string>} [options.fields] - Specific fields to return
 * @param {string} [options.view] - Airtable view name
 * @returns {Promise<Object>} { records: Array, offset?: string }
 *
 * @example
 * // Get carriers in Texas
 * const result = await queryRecords('Carriers', {
 *   filterByFormula: "{Physical State} = 'TX'",
 *   sort: [{ field: 'Company Name', direction: 'asc' }],
 *   maxRecords: 50
 * });
 */
export async function queryRecords(tableName, options = {}) {
  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  const maxRecords = options.maxRecords || 100;
  const allRecords = [];
  let pageOffset = options.offset || null;

  // Paginate: Airtable returns max 100 per page. Loop until we have enough or no more pages.
  do {
    const params = new URLSearchParams();

    if (options.filterByFormula) {
      params.append('filterByFormula', options.filterByFormula);
    }

    if (options.sort && Array.isArray(options.sort)) {
      options.sort.forEach((sortConfig, index) => {
        params.append(`sort[${index}][field]`, sortConfig.field);
        params.append(`sort[${index}][direction]`, sortConfig.direction || 'asc');
      });
    }

    params.append('pageSize', '100');
    params.append('maxRecords', String(maxRecords));

    if (pageOffset) {
      params.append('offset', pageOffset);
    }

    if (options.fields && Array.isArray(options.fields)) {
      options.fields.forEach(field => {
        params.append('fields[]', field);
      });
    }

    if (options.view) {
      params.append('view', options.view);
    }

    const queryString = params.toString();
    const endpoint = `/${encodedTable}${queryString ? '?' + queryString : ''}`;

    try {
      const response = await airtableRequest(endpoint, 'GET');
      const pageRecords = (response.records || []).map(record => toWixFormat(record, tableName));
      allRecords.push(...pageRecords);
      pageOffset = response.offset || null;

      // Rate limit: sequential requests already ~2 req/sec due to network latency
      if (pageOffset && allRecords.length < maxRecords) {
        await new Promise(r => setTimeout(r, 50));
      }
    } catch (error) {
      console.error(`[airtableClient] queryRecords error (${tableName}):`, error.message);
      return { success: false, error: error.message, records: [] };
    }
  } while (pageOffset && allRecords.length < maxRecords);

  console.log(`[airtableClient] Retrieved ${allRecords.length} total records from ${tableName}`);

  return {
    records: allRecords,
    offset: pageOffset,
    hasMore: !!pageOffset
  };
}

/**
 * Get all records from a table, automatically handling pagination
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} [filterFormula] - Optional Airtable filter formula
 * @param {Array<Object>} [sort] - Optional sort configuration
 * @returns {Promise<Array<Object>>} All matching records in Wix format
 *
 * @example
 * // Get all active carriers
 * const carriers = await getAllRecords('Carriers', "{Hiring Status} = 'active'");
 */
export async function getAllRecords(tableName, filterFormula = null, sort = null) {
  const allRecords = [];
  let offset = null;

  do {
    const options = {
      maxRecords: CONFIG.pagination.maxRecordsPerPage
    };

    if (filterFormula) {
      options.filterByFormula = filterFormula;
    }

    if (sort) {
      options.sort = sort;
    }

    if (offset) {
      options.offset = offset;
    }

    const result = await queryRecords(tableName, options);

    if (result.error) {
      console.error(`[airtableClient] getAllRecords error (${tableName}):`, result.error);
      break;
    }

    allRecords.push(...result.records);
    offset = result.offset;

    // Log progress for large datasets
    if (allRecords.length > 0 && allRecords.length % 500 === 0) {
      console.log(`[airtableClient] Fetched ${allRecords.length} records from ${tableName}...`);
    }

  } while (offset);

  console.log(`[airtableClient] Retrieved ${allRecords.length} total records from ${tableName}`);
  return allRecords;
}

/**
 * Create a new record
 *
 * @param {string} tableName - The Wix collection name
 * @param {Object} fields - The record fields in Wix format
 * @returns {Promise<Object>} The created record in Wix format
 *
 * @example
 * const newCarrier = await createRecord('Carriers', {
 *   company_name: 'Test Trucking LLC',
 *   dot_number: 1234567,
 *   phy_state: 'TX'
 * });
 */
export async function createRecord(tableName, fields) {
  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  const airtableFields = toAirtableFormat(fields, tableName);

  try {
    const response = await airtableRequest(`/${encodedTable}`, 'POST', {
      fields: airtableFields,
      typecast: true // Allow automatic type conversion
    });

    console.log(`[airtableClient] Created record in ${tableName}: ${response.id}`);
    return toWixFormat(response, tableName);
  } catch (error) {
    console.error(`[airtableClient] createRecord error (${tableName}):`, error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Update an existing record
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} recordId - The Airtable record ID
 * @param {Object} fields - The fields to update in Wix format
 * @returns {Promise<Object>} The updated record in Wix format
 *
 * @example
 * const updated = await updateRecord('Carriers', 'recXXX', {
 *   hiring_status: 'active',
 *   pay_rate_max: 85000
 * });
 */
export async function updateRecord(tableName, recordId, fields) {
  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  const airtableFields = toAirtableFormat(fields, tableName);

  try {
    const response = await airtableRequest(`/${encodedTable}/${recordId}`, 'PATCH', {
      fields: airtableFields,
      typecast: true
    });

    console.log(`[airtableClient] Updated record ${recordId} in ${tableName}`);
    return toWixFormat(response, tableName);
  } catch (error) {
    console.error(`[airtableClient] updateRecord error (${tableName}/${recordId}):`, error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Delete a record
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} recordId - The Airtable record ID
 * @returns {Promise<Object>} { success: boolean, deleted: boolean, id: string }
 *
 * @example
 * await deleteRecord('Carriers', 'recXXXXXXXXXXXXXX');
 */
export async function deleteRecord(tableName, recordId) {
  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  try {
    const response = await airtableRequest(`/${encodedTable}/${recordId}`, 'DELETE');

    console.log(`[airtableClient] Deleted record ${recordId} from ${tableName}`);
    return {
      success: true,
      deleted: response.deleted || true,
      id: response.id || recordId
    };
  } catch (error) {
    console.error(`[airtableClient] deleteRecord error (${tableName}/${recordId}):`, error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// BULK OPERATIONS
// ============================================================================

/**
 * Create multiple records in bulk (max 10 per request)
 *
 * @param {string} tableName - The Wix collection name
 * @param {Array<Object>} records - Array of records in Wix format (max 10)
 * @returns {Promise<Object>} { success: boolean, records: Array, errors?: Array }
 *
 * @example
 * const result = await bulkCreate('Carriers', [
 *   { company_name: 'Carrier 1', dot_number: 1111111 },
 *   { company_name: 'Carrier 2', dot_number: 2222222 }
 * ]);
 */
export async function bulkCreate(tableName, records) {
  if (!records || records.length === 0) {
    return { success: true, records: [] };
  }

  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  // Airtable limits bulk operations to 10 records
  const chunks = [];
  for (let i = 0; i < records.length; i += 10) {
    chunks.push(records.slice(i, i + 10));
  }

  const allCreated = [];
  const errors = [];

  for (const chunk of chunks) {
    const airtableRecords = chunk.map(record => ({
      fields: toAirtableFormat(record, tableName)
    }));

    try {
      const response = await airtableRequest(`/${encodedTable}`, 'POST', {
        records: airtableRecords,
        typecast: true
      });

      const created = (response.records || []).map(r => toWixFormat(r, tableName));
      allCreated.push(...created);

    } catch (error) {
      console.error(`[airtableClient] bulkCreate error (${tableName}):`, error.message);
      errors.push({ chunk, error: error.message });
    }

    // Rate limit between chunks (5 req/sec)
    if (chunks.length > 1) {
      await new Promise(r => setTimeout(r, 200));
    }
  }

  console.log(`[airtableClient] Bulk created ${allCreated.length}/${records.length} records in ${tableName}`);

  return {
    success: errors.length === 0,
    records: allCreated,
    errors: errors.length > 0 ? errors : undefined
  };
}

/**
 * Update multiple records in bulk (max 10 per request)
 *
 * @param {string} tableName - The Wix collection name
 * @param {Array<Object>} records - Array of records with _id and fields to update
 * @returns {Promise<Object>} { success: boolean, records: Array, errors?: Array }
 *
 * @example
 * const result = await bulkUpdate('Carriers', [
 *   { _id: 'recXXX', hiring_status: 'active' },
 *   { _id: 'recYYY', hiring_status: 'paused' }
 * ]);
 */
export async function bulkUpdate(tableName, records) {
  if (!records || records.length === 0) {
    return { success: true, records: [] };
  }

  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  // Airtable limits bulk operations to 10 records
  const chunks = [];
  for (let i = 0; i < records.length; i += 10) {
    chunks.push(records.slice(i, i + 10));
  }

  const allUpdated = [];
  const errors = [];

  for (const chunk of chunks) {
    const airtableRecords = chunk.map(record => {
      const { _id, ...fields } = record;
      return {
        id: _id,
        fields: toAirtableFormat(fields, tableName)
      };
    });

    try {
      const response = await airtableRequest(`/${encodedTable}`, 'PATCH', {
        records: airtableRecords,
        typecast: true
      });

      const updated = (response.records || []).map(r => toWixFormat(r, tableName));
      allUpdated.push(...updated);

    } catch (error) {
      console.error(`[airtableClient] bulkUpdate error (${tableName}):`, error.message);
      errors.push({ chunk, error: error.message });
    }

    // Rate limit between chunks (5 req/sec)
    if (chunks.length > 1) {
      await new Promise(r => setTimeout(r, 200));
    }
  }

  console.log(`[airtableClient] Bulk updated ${allUpdated.length}/${records.length} records in ${tableName}`);

  return {
    success: errors.length === 0,
    records: allUpdated,
    errors: errors.length > 0 ? errors : undefined
  };
}

/**
 * Delete multiple records in bulk (max 10 per request)
 *
 * @param {string} tableName - The Wix collection name
 * @param {Array<string>} recordIds - Array of record IDs to delete
 * @returns {Promise<Object>} { success: boolean, deleted: Array, errors?: Array }
 *
 * @example
 * await bulkDelete('Messages', ['recXXX', 'recYYY', 'recZZZ']);
 */
export async function bulkDelete(tableName, recordIds) {
  if (!recordIds || recordIds.length === 0) {
    return { success: true, deleted: [] };
  }

  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const airtableTable = getTableName(tableName);
  const encodedTable = encodeURIComponent(airtableTable);

  // Airtable limits bulk operations to 10 records
  const chunks = [];
  for (let i = 0; i < recordIds.length; i += 10) {
    chunks.push(recordIds.slice(i, i + 10));
  }

  const allDeleted = [];
  const errors = [];

  for (const chunk of chunks) {
    // Build query string for bulk delete
    const params = chunk.map(id => `records[]=${id}`).join('&');

    try {
      const response = await airtableRequest(`/${encodedTable}?${params}`, 'DELETE');

      const deleted = (response.records || []).map(r => r.id);
      allDeleted.push(...deleted);

    } catch (error) {
      console.error(`[airtableClient] bulkDelete error (${tableName}):`, error.message);
      errors.push({ chunk, error: error.message });
    }

    // Rate limit between chunks (5 req/sec)
    if (chunks.length > 1) {
      await new Promise(r => setTimeout(r, 200));
    }
  }

  console.log(`[airtableClient] Bulk deleted ${allDeleted.length}/${recordIds.length} records from ${tableName}`);

  return {
    success: errors.length === 0,
    deleted: allDeleted,
    errors: errors.length > 0 ? errors : undefined
  };
}

// ============================================================================
// QUERY BUILDER HELPERS
// ============================================================================

/**
 * Build an Airtable filter formula from Wix-style query conditions
 *
 * @param {Object} conditions - Query conditions { field: value } or { field: { op: value }}
 * @param {string} tableName - The Wix collection name (for field name mapping)
 * @returns {string} Airtable filter formula
 *
 * @example
 * // Simple equality
 * buildFilterFormula({ phy_state: 'TX' }, 'Carriers')
 * // Returns: "{Physical State} = 'TX'"
 *
 * @example
 * // With operators
 * buildFilterFormula({
 *   pay_rate_min: { gte: 50000 },
 *   hiring_status: 'active'
 * }, 'Carriers')
 * // Returns: "AND({Pay Rate Min} >= 50000, {Hiring Status} = 'active')"
 */
export function buildFilterFormula(conditions, tableName) {
  const mappings = getFieldMappings(tableName);
  const clauses = [];

  for (const [wixField, value] of Object.entries(conditions)) {
    // Special handling: _id maps to RECORD_ID() function, not a field reference
    if (wixField === '_id') {
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        for (const [op, operand] of Object.entries(value)) {
          const opMap = { 'eq': '=', 'ne': '!=' };
          const airtableOp = opMap[op] || '=';
          const escaped = typeof operand === 'string' ? `'${operand.replace(/'/g, "\\'")}'` : String(operand);
          clauses.push(`RECORD_ID() ${airtableOp} ${escaped}`);
        }
      } else {
        const escaped = typeof value === 'string' ? `'${value.replace(/'/g, "\\'")}'` : String(value);
        clauses.push(`RECORD_ID() = ${escaped}`);
      }
      continue;
    }

    // Get Airtable field name
    let airtableField = mappings[wixField];
    if (airtableField === '__SKIP__') continue;
    if (!airtableField) {
      // Convert snake_case to Title Case
      airtableField = wixField
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    // Handle operator objects
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      for (const [op, operand] of Object.entries(value)) {
        clauses.push(buildOperatorClause(airtableField, op, operand));
      }
    } else {
      // Simple equality
      clauses.push(formatValue(airtableField, '=', value));
    }
  }

  if (clauses.length === 0) return '';
  if (clauses.length === 1) return clauses[0];
  return `AND(${clauses.join(', ')})`;
}

/**
 * Build a single operator clause
 */
function buildOperatorClause(field, op, value) {
  const operators = {
    'eq': '=',
    'ne': '!=',
    'gt': '>',
    'gte': '>=',
    'lt': '<',
    'lte': '<=',
    'contains': 'FIND',
    'startsWith': 'LEFT',
    'isEmpty': 'BLANK',
    'isNotEmpty': 'NOT_BLANK',
    'hasSome': 'OR_FIND'
  };

  const airtableOp = operators[op] || op;

  // Special handling for certain operators
  if (op === 'hasSome') {
    if (!Array.isArray(value)) value = [value];
    const findClauses = value.map(val => {
        const escaped = String(val).replace(/'/g, "\\'");
        return `FIND('${escaped}', {${field}})`;
    });
    return `OR(${findClauses.join(', ')})`;
  }

  if (op === 'contains') {
    const escapedValue = String(value).replace(/'/g, "\\'");
    return `FIND('${escapedValue}', {${field}}) > 0`;
  }

  if (op === 'startsWith') {
    const escapedValue = String(value).replace(/'/g, "\\'");
    return `LEFT({${field}}, ${value.length}) = '${escapedValue}'`;
  }

  if (op === 'isEmpty') {
    return `{${field}} = BLANK()`;
  }

  if (op === 'isNotEmpty') {
    return `{${field}} != BLANK()`;
  }

  return formatValue(field, airtableOp, value);
}

/**
 * Format a value for Airtable formula
 */
function formatValue(field, operator, value) {
  let formattedValue;

  if (value instanceof Date) {
    // Convert Date objects to ISO string for Airtable formula
    formattedValue = `'${value.toISOString().split('T')[0]}'`;
  } else if (typeof value === 'string') {
    // Escape single quotes and wrap in quotes
    formattedValue = `'${value.replace(/'/g, "\\'")}'`;
  } else if (typeof value === 'boolean') {
    formattedValue = value ? 'TRUE()' : 'FALSE()';
  } else if (value === null) {
    formattedValue = 'BLANK()';
  } else {
    formattedValue = String(value);
  }

  return `{${field}} ${operator} ${formattedValue}`;
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Find a record by a specific field value (convenience wrapper)
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} fieldName - The field name in Wix format
 * @param {*} value - The value to search for
 * @returns {Promise<Object|null>} The first matching record or null
 *
 * @example
 * const carrier = await findByField('Carriers', 'dot_number', 1234567);
 */
export async function findByField(tableName, fieldName, value) {
  tableName = await Promise.resolve(tableName); // Resolve .jsw web-module Promise wrappers
  const formula = buildFilterFormula({ [fieldName]: value }, tableName);

  const result = await queryRecords(tableName, {
    filterByFormula: formula,
    maxRecords: 1
  });

  if (result.error || !result.records || result.records.length === 0) {
    return null;
  }

  return result.records[0];
}

/**
 * Check if a record exists by field value
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} fieldName - The field name in Wix format
 * @param {*} value - The value to search for
 * @returns {Promise<boolean>} True if a matching record exists
 */
export async function exists(tableName, fieldName, value) {
  const record = await findByField(tableName, fieldName, value);
  return record !== null;
}

/**
 * Count records matching a filter
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} [filterFormula] - Optional filter formula
 * @returns {Promise<number>} The count of matching records
 */
export async function countRecords(tableName, filterFormula = null) {
  const records = await getAllRecords(tableName, filterFormula);
  return records.length;
}

/**
 * Upsert a record (update if exists, create if not)
 *
 * @param {string} tableName - The Wix collection name
 * @param {string} lookupField - The field to use for finding existing record
 * @param {*} lookupValue - The value to match
 * @param {Object} fields - The fields to set
 * @returns {Promise<Object>} The created or updated record
 *
 * @example
 * const carrier = await upsertRecord('Carriers', 'dot_number', 1234567, {
 *   company_name: 'Updated Trucking LLC',
 *   hiring_status: 'active'
 * });
 */
export async function upsertRecord(tableName, lookupField, lookupValue, fields) {
  const existing = await findByField(tableName, lookupField, lookupValue);

  if (existing && existing._id) {
    // Update existing record
    return updateRecord(tableName, existing._id, fields);
  } else {
    // Create new record
    return createRecord(tableName, { [lookupField]: lookupValue, ...fields });
  }
}

// ============================================================================
// CONFIGURATION GETTERS
// ============================================================================

/**
 * Get all table name mappings
 * @returns {Object} The TABLE_NAMES mapping object
 */
export function getTableMappings() {
  return { ...TABLE_NAMES };
}

/**
 * Get field mappings for a specific table
 * @param {string} tableName - The Wix collection name
 * @returns {Object} The field mappings for that table
 */
export function getTableFieldMappings(tableName) {
  return getFieldMappings(tableName);
}

/**
 * Add or update table name mapping at runtime
 * @param {string} wixCollection - The Wix collection name
 * @param {string} airtableTable - The Airtable table name
 */
export function setTableMapping(wixCollection, airtableTable) {
  TABLE_NAMES[wixCollection] = airtableTable;
  console.log(`📝 Airtable: Added table mapping ${wixCollection} -> ${airtableTable}`);
}

/**
 * Add or update field mappings for a table at runtime
 * @param {string} tableName - The Wix collection name
 * @param {Object} mappings - Field mappings { wixField: airtableField }
 */
export function setFieldMappings(tableName, mappings) {
  FIELD_MAPPINGS[tableName] = {
    ...(FIELD_MAPPINGS[tableName] || {}),
    ...mappings
  };
  console.log(`📝 Airtable: Updated field mappings for ${tableName}`);
}

// ============================================================================
// TEST/DEBUG FUNCTIONS
// ============================================================================

/**
 * Test the Airtable connection
 * @returns {Promise<Object>} Connection status and base info
 */
export async function testConnection() {
  try {
    const apiKey = await getApiKey();

    // Try to list tables (this validates both API key and base ID)
    const response = await fetch(`https://api.airtable.com/v0/meta/bases/${CONFIG.baseId}/tables`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${apiKey}`
      }
    });

    if (!response.ok) {
      const error = await readResponseText(response);
      return {
        success: false,
        error: `API returned ${response.status}: ${error}`,
        baseId: CONFIG.baseId
      };
    }

    const data = await response.json();
    const tableNames = (data.tables || []).map(t => t.name);

    return {
      success: true,
      message: 'Airtable connection successful',
      baseId: CONFIG.baseId,
      tableCount: tableNames.length,
      tables: tableNames.slice(0, 10), // Show first 10 tables
      hasMore: tableNames.length > 10
    };

  } catch (error) {
    return {
      success: false,
      error: error.message,
      baseId: CONFIG.baseId
    };
  }
}

/**
 * Get the current rate limit state
 * @returns {Object} Rate limit info
 */
export function getRateLimitInfo() {
  return {
    lastRequestTime,
    delayMs: CONFIG.rateLimit.requestDelayMs,
    maxRetries: CONFIG.rateLimit.maxRetries,
    timeSinceLastRequest: Date.now() - lastRequestTime
  };
}

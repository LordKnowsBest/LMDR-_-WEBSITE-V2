import * as dataAccess from 'backend/dataAccess';
import { generateApiKey, hashApiKey, rotateApiKey } from 'backend/apiAuthService';
import { createApiCheckoutSession, createApiPortalSession, getApiBillingSummary } from 'backend/stripeService';
import { fetch } from 'wix-fetch';

const COLLECTIONS = {
  partners: 'apiPartners',
  usage: 'apiUsage',
  requestLog: 'apiRequestLog',
  subscriptions: 'apiSubscriptions',
  billingHistory: 'billingHistory',
  webhookDeliveries: 'apiWebhookDeliveries'
};

export async function registerApiPartner(input = {}) {
  const companyName = String(input.company_name || '').trim();
  const contactEmail = String(input.contact_email || '').trim();
  if (!companyName || !contactEmail) {
    return { success: false, error: 'company_name and contact_email are required' };
  }

  const partnerId = `ptn_${Date.now()}`;
  const apiKey = await generateApiKey('live');
  const keyHash = await hashApiKey(apiKey);

  const result = await dataAccess.insertRecord(COLLECTIONS.partners, {
    partner_id: partnerId,
    company_name: companyName,
    contact_email: contactEmail,
    contact_name: input.contact_name || null,
    tier: input.tier || 'starter',
    status: 'active',
    api_keys: [{
      key_id: `key_${Date.now()}`,
      key_hash: keyHash,
      name: 'Default Key',
      created_at: new Date(),
      last_used_at: null,
      is_active: true
    }],
    ip_whitelist: Array.isArray(input.ip_whitelist) ? input.ip_whitelist : [],
    webhook_url: input.webhook_url || null,
    webhook_secret: input.webhook_secret || null,
    created_at: new Date(),
    updated_at: new Date()
  }, { suppressAuth: true });

  if (!result?.success) {
    return { success: false, error: result?.error || 'Failed to create partner' };
  }

  return {
    success: true,
    partner: {
      partner_id: partnerId,
      company_name: companyName,
      tier: input.tier || 'starter'
    },
    api_key: apiKey
  };
}

export async function listApiPartners(limit = 100) {
  const result = await dataAccess.queryRecords(COLLECTIONS.partners, {
    sort: [{ field: 'updated_at', direction: 'desc' }],
    limit: Math.min(200, Math.max(1, Number(limit) || 100)),
    suppressAuth: true
  });

  return {
    success: true,
    items: (result?.items || []).map((partner) => ({
      partner_id: partner.partner_id,
      company_name: partner.company_name || null,
      contact_email: partner.contact_email || null,
      tier: partner.tier || 'starter',
      status: partner.status || 'active',
      default_environment: partner.default_environment || 'production',
      updated_at: partner.updated_at || partner._updatedDate || null
    }))
  };
}

export async function setApiPartnerTier(partnerId, tier) {
  const normalizedTier = String(tier || '').toLowerCase();
  if (!['starter', 'growth', 'enterprise', 'custom'].includes(normalizedTier)) {
    return { success: false, error: 'tier must be starter, growth, enterprise, or custom' };
  }

  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    tier: normalizedTier,
    updated_at: new Date()
  }, { suppressAuth: true });

  return {
    success: Boolean(updated?.success),
    tier: normalizedTier,
    error: updated?.success ? null : (updated?.error || 'Failed to update tier')
  };
}

export async function setApiPartnerStatus(partnerId, status) {
  const normalizedStatus = String(status || '').toLowerCase();
  if (!['active', 'suspended'].includes(normalizedStatus)) {
    return { success: false, error: 'status must be active or suspended' };
  }

  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    status: normalizedStatus,
    updated_at: new Date()
  }, { suppressAuth: true });

  return {
    success: Boolean(updated?.success),
    status: normalizedStatus,
    error: updated?.success ? null : (updated?.error || 'Failed to update status')
  };
}

export async function rotatePartnerApiKey(partnerId, keyId, options = {}) {
  return rotateApiKey(partnerId, keyId, options);
}

export async function getPartnerUsageDashboard(partnerId, periodKey = null) {
  const filters = periodKey ? { partner_id: partnerId, period_key: periodKey } : { partner_id: partnerId };
  const usage = await dataAccess.queryRecords(COLLECTIONS.usage, {
    filters,
    sort: [{ field: 'period_key', direction: 'desc' }],
    limit: 12,
    suppressAuth: true
  });

  const subscription = await dataAccess.queryRecords(COLLECTIONS.subscriptions, {
    filters: { partner_id: partnerId },
    sort: [{ field: 'current_period_end', direction: 'desc' }],
    limit: 1,
    suppressAuth: true
  });

  return {
    success: true,
    usage: usage?.items || [],
    subscription: subscription?.items?.[0] || null
  };
}

export async function getApiPartnerHistory(partnerId, limit = 50) {
  const normalizedLimit = Math.min(200, Math.max(1, Number(limit) || 50));
  const [requests, webhooks, billing] = await Promise.all([
    dataAccess.queryRecords(COLLECTIONS.requestLog, {
      filters: { partner_id: partnerId },
      sort: [{ field: 'created_at', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.webhookDeliveries, {
      filters: { partner_id: partnerId },
      sort: [{ field: 'created_at', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.billingHistory, {
      filters: { carrier_dot: partnerId },
      sort: [{ field: 'timestamp', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    })
  ]);

  return {
    success: true,
    request_events: requests?.items || [],
    webhook_events: webhooks?.items || [],
    billing_events: billing?.items || []
  };
}

export async function getApiRevenueReport(partnerId = null, months = 12) {
  const normalizedMonths = Math.min(24, Math.max(1, Number(months) || 12));
  const now = new Date();
  const rangeStart = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - (normalizedMonths - 1), 1));
  const partnerFilter = partnerId ? { partner_id: partnerId } : {};
  const billingFilter = partnerId ? { carrier_dot: partnerId } : {};

  const [subscriptions, billingEvents, partners] = await Promise.all([
    dataAccess.queryRecords(COLLECTIONS.subscriptions, {
      filters: partnerFilter,
      sort: [{ field: 'current_period_end', direction: 'desc' }],
      limit: 500,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.billingHistory, {
      filters: billingFilter,
      sort: [{ field: 'timestamp', direction: 'desc' }],
      limit: 5000,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.partners, {
      sort: [{ field: 'updated_at', direction: 'desc' }],
      limit: 500,
      suppressAuth: true
    })
  ]);

  const partnerNameById = Object.create(null);
  for (const partner of (partners?.items || [])) {
    if (partner?.partner_id) partnerNameById[partner.partner_id] = partner.company_name || partner.partner_id;
  }

  const monthKeys = [];
  const monthlyMap = Object.create(null);
  for (let i = normalizedMonths - 1; i >= 0; i--) {
    const d = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - i, 1));
    const key = `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}`;
    monthKeys.push(key);
    monthlyMap[key] = { month: key, revenue: 0, events: 0 };
  }

  let periodRevenue = 0;
  let periodEvents = 0;
  const revenueByPartner = Object.create(null);

  for (const event of (billingEvents?.items || [])) {
    const timestamp = parseDate(event?.timestamp);
    if (!timestamp || timestamp < rangeStart) continue;

    const amount = toAmount(event?.amount);
    const month = `${timestamp.getUTCFullYear()}-${String(timestamp.getUTCMonth() + 1).padStart(2, '0')}`;
    if (monthlyMap[month]) {
      monthlyMap[month].revenue = roundCurrency(monthlyMap[month].revenue + amount);
      monthlyMap[month].events += 1;
    }

    periodRevenue = roundCurrency(periodRevenue + amount);
    periodEvents += 1;

    const partnerKey = String(event?.carrier_dot || '');
    if (partnerKey) {
      revenueByPartner[partnerKey] = roundCurrency((revenueByPartner[partnerKey] || 0) + amount);
    }
  }

  const tierSummary = {
    starter: { tier: 'starter', partners: 0, mrr: 0 },
    growth: { tier: 'growth', partners: 0, mrr: 0 },
    enterprise: { tier: 'enterprise', partners: 0, mrr: 0 },
    custom: { tier: 'custom', partners: 0, mrr: 0 }
  };
  let activePartners = 0;
  let mrr = 0;

  for (const subscription of (subscriptions?.items || [])) {
    const tier = String(subscription?.tier || 'starter').toLowerCase();
    const status = String(subscription?.status || '').toLowerCase();
    if (!['active', 'trialing', 'past_due'].includes(status)) continue;
    activePartners += 1;

    const monthlyPrice = resolveSubscriptionPrice(subscription, tier);
    mrr = roundCurrency(mrr + monthlyPrice);

    const bucket = tierSummary[tier] || tierSummary.custom;
    bucket.partners += 1;
    bucket.mrr = roundCurrency(bucket.mrr + monthlyPrice);
  }

  const arr = roundCurrency(mrr * 12);
  const arpu = activePartners > 0 ? roundCurrency(mrr / activePartners) : 0;
  const topPartners = Object.keys(revenueByPartner)
    .map((id) => ({
      partner_id: id,
      company_name: partnerNameById[id] || id,
      revenue: revenueByPartner[id]
    }))
    .sort((a, b) => b.revenue - a.revenue)
    .slice(0, 10);

  return {
    success: true,
    generated_at: new Date().toISOString(),
    window_months: normalizedMonths,
    partner_id: partnerId || null,
    summary: {
      mrr,
      arr,
      arpu,
      active_partners: activePartners,
      period_revenue: periodRevenue,
      period_events: periodEvents
    },
    monthly_revenue: monthKeys.map((key) => monthlyMap[key]),
    tier_breakdown: Object.values(tierSummary),
    top_partners: topPartners
  };
}

export async function getPartnerPortalSnapshot(partnerId, periodKey = null) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const [usage, keys, billing, env, webhooks] = await Promise.all([
    getPartnerUsageDashboard(partnerId, periodKey),
    listPartnerApiKeys(partnerId),
    getPartnerBillingHistory(partnerId, 25),
    getPartnerApiEnvironment(partnerId),
    listPartnerWebhookDeliveries(partnerId, 10)
  ]);

  return {
    success: true,
    partner: {
      partner_id: partner.partner_id,
      company_name: partner.company_name || null,
      contact_email: partner.contact_email || null,
      tier: partner.tier || 'starter',
      status: partner.status || 'active'
    },
    usage: usage?.usage || [],
    subscription: usage?.subscription || null,
    api_keys: keys?.keys || [],
    billing: billing || { success: false, items: [] },
    environment: env?.environment || 'production',
    webhook_deliveries: webhooks?.items || []
  };
}

export async function listPartnerApiKeys(partnerId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
  return {
    success: true,
    keys: keys.map((key) => ({
      key_id: key.key_id,
      name: key.name || null,
      environment: inferKeyEnvironment(key),
      is_active: key.is_active !== false,
      created_at: key.created_at || null,
      last_used_at: key.last_used_at || null
    }))
  };
}

export async function createPartnerApiKey(partnerId, options = {}) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
  const activeKeys = keys.filter((key) => key.is_active !== false);
  if (activeKeys.length >= 5) {
    return { success: false, error: 'Maximum 5 active keys allowed' };
  }

  const requestedEnvironment = String(options.environment || '').toLowerCase();
  const env = requestedEnvironment === 'sandbox' ? 'test' : 'live';
  const environment = env === 'test' ? 'sandbox' : 'production';
  const keyValue = await generateApiKey(env);
  const keyHash = await hashApiKey(keyValue);
  const keyId = `key_${Date.now()}`;

  const nextKeys = [...keys, {
    key_id: keyId,
      key_hash: keyHash,
      name: options.name || `API Key ${activeKeys.length + 1}`,
      environment,
      created_at: new Date(),
      last_used_at: null,
      is_active: true
  }];

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    api_keys: nextKeys,
    updated_at: new Date()
  }, { suppressAuth: true });

  if (!updated?.success) {
    return { success: false, error: updated?.error || 'Failed to create key' };
  }

  return {
    success: true,
    key_id: keyId,
    environment,
    api_key: keyValue
  };
}

export async function revokePartnerApiKey(partnerId, keyId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
  const updatedKeys = keys.map((key) => key.key_id === keyId ? { ...key, is_active: false } : key);

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    api_keys: updatedKeys,
    updated_at: new Date()
  }, { suppressAuth: true });

  return {
    success: Boolean(updated?.success),
    error: updated?.success ? null : (updated?.error || 'Failed to revoke key')
  };
}

export async function getPartnerBillingHistory(partnerId, limit = 50) {
  const billing = await dataAccess.queryRecords(COLLECTIONS.billingHistory, {
    filters: {
      carrier_dot: partnerId
    },
    sort: [{ field: 'timestamp', direction: 'desc' }],
    limit: Math.min(200, Math.max(1, Number(limit) || 50)),
    suppressAuth: true
  });

  const summary = await getApiBillingSummary(partnerId).catch(() => null);
  return {
    success: true,
    items: billing?.items || [],
    summary
  };
}

export async function listPartnerWebhookDeliveries(partnerId, limit = 25) {
  const deliveries = await dataAccess.queryRecords(COLLECTIONS.webhookDeliveries, {
    filters: { partner_id: partnerId },
    sort: [{ field: 'created_at', direction: 'desc' }],
    limit: Math.min(100, Math.max(1, Number(limit) || 25)),
    suppressAuth: true
  });

  return {
    success: true,
    items: (deliveries?.items || []).map((item) => ({
      id: item._id,
      event_type: item.event_type || null,
      status: item.status || null,
      response_status: item.response_status ?? null,
      attempt: item.attempt || 1,
      created_at: item.created_at || null
    }))
  };
}

export async function getPartnerApiEnvironment(partnerId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const activeEnvironment = String(partner.default_environment || 'production').toLowerCase();
  return {
    success: true,
    environment: activeEnvironment === 'sandbox' ? 'sandbox' : 'production',
    sandbox_enabled: Boolean(partner.sandbox_enabled)
  };
}

export async function setPartnerApiEnvironment(partnerId, environment = 'production') {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const normalized = String(environment || '').toLowerCase();
  if (!['sandbox', 'production'].includes(normalized)) {
    return { success: false, error: 'environment must be sandbox or production' };
  }

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    default_environment: normalized,
    sandbox_enabled: normalized === 'sandbox' ? true : Boolean(partner.sandbox_enabled),
    updated_at: new Date()
  }, { suppressAuth: true });

  if (!updated?.success) {
    return { success: false, error: updated?.error || 'Failed to set environment' };
  }

  return {
    success: true,
    environment: normalized
  };
}

export async function createPartnerApiCheckout(partnerId, tier = 'starter', planType = 'monthly') {
  return createApiCheckoutSession(partnerId, tier, planType);
}

export async function createPartnerBillingPortal(partnerId) {
  return createApiPortalSession(partnerId);
}

export async function sendPartnerWebhookTest(partnerId, webhookUrl = null) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const targetUrl = String(webhookUrl || partner.webhook_url || '').trim();
  if (!targetUrl) return { success: false, error: 'No webhook_url configured' };

  const payload = {
    event_type: 'webhook_test',
    event_id: `evt_test_${Date.now()}`,
    partner_id: partnerId,
    timestamp: new Date().toISOString(),
    data: { status: 'ok' }
  };
  const signature = await computeWebhookSignature(partner.webhook_secret || '', payload);
  const requestHeaders = {
    'Content-Type': 'application/json',
    'X-LMDR-Event': payload.event_type,
    'X-LMDR-Timestamp': payload.timestamp
  };
  if (signature) {
    requestHeaders['X-LMDR-Signature'] = signature;
  }

  try {
    const now = new Date();
    const response = await fetch(targetUrl, {
      method: 'POST',
      headers: requestHeaders,
      body: JSON.stringify(payload)
    });

    await dataAccess.insertRecord(COLLECTIONS.webhookDeliveries, {
      subscription_id: null,
      partner_id: partnerId,
      event_type: payload.event_type,
      payload,
      attempt: 1,
      status: response.ok ? 'sent' : 'failed',
      response_status: response.status,
      created_at: now,
      updated_at: now
    }, { suppressAuth: true }).catch(() => null);

    return {
      success: response.ok,
      status: response.status
    };
  } catch (error) {
    const now = new Date();
    await dataAccess.insertRecord(COLLECTIONS.webhookDeliveries, {
      subscription_id: null,
      partner_id: partnerId,
      event_type: payload.event_type,
      payload,
      attempt: 1,
      status: 'failed',
      response_status: null,
      response_body: String(error.message || '').slice(0, 1000),
      created_at: now,
      updated_at: now
    }, { suppressAuth: true }).catch(() => null);
    return { success: false, error: error.message };
  }
}

function inferKeyEnvironment(key) {
  const explicit = String(key?.environment || '').toLowerCase();
  if (explicit === 'sandbox' || explicit === 'production') return explicit;
  const name = String(key?.name || '').toLowerCase();
  if (name.includes('sandbox')) return 'sandbox';
  return 'production';
}

async function computeWebhookSignature(secret, payload) {
  if (!secret) return null;
  try {
    const body = JSON.stringify(payload);
    const key = await crypto.subtle.importKey(
      'raw',
      new TextEncoder().encode(secret),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );
    const digest = await crypto.subtle.sign(
      'HMAC',
      key,
      new TextEncoder().encode(body)
    );
    return Array.from(new Uint8Array(digest))
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('');
  } catch (error) {
    return null;
  }
}

function resolveSubscriptionPrice(subscription, tier) {
  const directPrice = Number(subscription?.price_monthly);
  if (Number.isFinite(directPrice) && directPrice > 0) return directPrice;

  const fallbackByTier = {
    starter: 99,
    growth: 499,
    enterprise: 999,
    custom: 0
  };
  return fallbackByTier[tier] || 0;
}

function parseDate(value) {
  if (!value) return null;
  const parsed = value instanceof Date ? value : new Date(value);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function toAmount(value) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : 0;
}

function roundCurrency(value) {
  return Math.round(Number(value || 0) * 100) / 100;
}

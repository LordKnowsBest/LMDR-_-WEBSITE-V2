import * as dataAccess from 'backend/dataAccess';
import { generateApiKey, hashApiKey, rotateApiKey } from 'backend/apiAuthService';
import {
  createApiCheckoutSession,
  createApiPortalSession,
  getApiBillingSummary,
  ensureApiStripeProducts,
  generateApiOverageInvoice,
  changeApiSubscriptionPlan
} from 'backend/stripeService';
import { fetch } from 'wix-fetch';

const COLLECTIONS = {
  partners: 'apiPartners',
  usage: 'apiUsage',
  requestLog: 'apiRequestLog',
  subscriptions: 'apiSubscriptions',
  billingHistory: 'billingHistory',
  webhookDeliveries: 'apiWebhookDeliveries',
  onboarding: 'apiPartnerOnboarding',
  changelog: 'apiChangelog'
};

const API_DOC_ENDPOINTS = [
  {
    key: 'safety_carrier_lookup',
    method: 'GET',
    path: '/v1/safety/carrier/{dot_number}',
    category: 'safety',
    tier: 'starter',
    description: 'Carrier safety profile with BASIC score, status, and red flags.',
    sample_query: { dot_number: '1234567' }
  },
  {
    key: 'intelligence_market',
    method: 'GET',
    path: '/v1/intelligence/market',
    category: 'intelligence',
    tier: 'growth',
    description: 'Regional market benchmark and demand signals.',
    sample_query: { region: 'TX' }
  },
  {
    key: 'fuel_prices',
    method: 'GET',
    path: '/v1/fuel/prices',
    category: 'operations',
    tier: 'growth',
    description: 'Nearby fuel prices with discount-aware ranking.',
    sample_query: { lat: 32.7767, lng: -96.797, radius_miles: 50 }
  },
  {
    key: 'matching_search_drivers',
    method: 'POST',
    path: '/v1/matching/drivers/search',
    category: 'matching',
    tier: 'enterprise',
    description: 'Enterprise driver search with filters and scoring.',
    sample_body: { class: 'A', endorsements: ['HAZMAT'], radius_miles: 150 }
  },
  {
    key: 'documents_cdl_extract',
    method: 'POST',
    path: '/v1/documents/cdl/extract',
    category: 'documents',
    tier: 'growth',
    description: 'Extract CDL data fields from uploaded or base64 image.',
    sample_body: { mime_type: 'image/jpeg', base64_data: '...base64...' }
  },
  {
    key: 'engagement_user_progress',
    method: 'GET',
    path: '/v1/engagement/user/{user_id}/progress',
    category: 'engagement',
    tier: 'enterprise',
    description: 'Partner-scoped progression profile and achievements.',
    sample_query: { user_id: 'usr_123' }
  }
];

const API_DOC_EXAMPLES = {
  curl: [
    'curl -X GET "https://www.lastmiledr.app/_functions/api_gateway/v1/safety/carrier/1234567" \\',
    '  -H "Authorization: Bearer lmdr_live_xxx"'
  ].join('\n'),
  javascript: [
    'const res = await fetch(',
    "  'https://www.lastmiledr.app/_functions/api_gateway/v1/fuel/prices?lat=32.7&lng=-96.7&radius_miles=25',",
    '  { headers: { Authorization: "Bearer lmdr_live_xxx" } }',
    ');',
    'const json = await res.json();'
  ].join('\n'),
  python: [
    'import requests',
    "url = 'https://www.lastmiledr.app/_functions/api_gateway/v1/intelligence/market'",
    "headers = {'Authorization': 'Bearer lmdr_live_xxx'}",
    "params = {'region': 'TX'}",
    'data = requests.get(url, headers=headers, params=params, timeout=30).json()'
  ].join('\n')
};

const DEFAULT_CHANGELOG_ENTRIES = [
  {
    version: 'v1.3.0',
    date: '2026-02-19',
    type: 'feature',
    title: 'Developer portal and admin partner tooling expanded',
    details: 'Added revenue reporting, usage breakdowns, webhook test controls, and partner status/tier/environment actions.'
  },
  {
    version: 'v1.2.0',
    date: '2026-02-07',
    type: 'feature',
    title: 'OpenAPI and Postman baseline published',
    details: 'Published initial OpenAPI and Postman artifacts for implemented /v1 routes.'
  },
  {
    version: 'v1.1.0',
    date: '2026-02-05',
    type: 'feature',
    title: 'Webhook retries and CSA alert dispatch hardening',
    details: 'Added retry job orchestration and integrated CSA event dispatch to webhook pipeline.'
  }
];

const ONBOARDING_EMAIL_SEQUENCE = [
  {
    step: 1,
    key: 'welcome',
    delay_hours: 0,
    subject: 'Welcome to LMDR External API Platform',
    body: 'Your partner account is active. Start with sandbox credentials and run your first /v1 request.'
  },
  {
    step: 2,
    key: 'keys_and_auth',
    delay_hours: 24,
    subject: 'Configure API keys and auth',
    body: 'Create scoped keys, validate Authorization headers, and verify request_id logging.'
  },
  {
    step: 3,
    key: 'webhooks_and_billing',
    delay_hours: 72,
    subject: 'Enable webhooks and billing controls',
    body: 'Run a webhook test, validate retries, and review usage/overage billing summary.'
  },
  {
    step: 4,
    key: 'production_readiness',
    delay_hours: 120,
    subject: 'Production readiness checklist',
    body: 'Confirm first API call, rate-limit handling, and rollout plan for production traffic.'
  }
];

export async function registerApiPartner(input = {}) {
  const companyName = String(input.company_name || '').trim();
  const contactEmail = String(input.contact_email || '').trim();
  if (!companyName || !contactEmail) {
    return { success: false, error: 'company_name and contact_email are required' };
  }

  const partnerId = `ptn_${Date.now()}`;
  const apiKey = await generateApiKey('live');
  const keyHash = await hashApiKey(apiKey);

  const result = await dataAccess.insertRecord(COLLECTIONS.partners, {
    partner_id: partnerId,
    company_name: companyName,
    contact_email: contactEmail,
    contact_name: input.contact_name || null,
    tier: input.tier || 'starter',
    status: 'active',
    api_keys: [{
      key_id: `key_${Date.now()}`,
      key_hash: keyHash,
      name: 'Default Key',
      created_at: new Date(),
      last_used_at: null,
      is_active: true
    }],
    ip_whitelist: Array.isArray(input.ip_whitelist) ? input.ip_whitelist : [],
    webhook_url: input.webhook_url || null,
    webhook_secret: input.webhook_secret || null,
    created_at: new Date(),
    updated_at: new Date()
  }, { suppressAuth: true });

  if (!result?.success) {
    return { success: false, error: result?.error || 'Failed to create partner' };
  }

  return {
    success: true,
    partner: {
      partner_id: partnerId,
      company_name: companyName,
      tier: input.tier || 'starter'
    },
    api_key: apiKey
  };
}

export async function listApiPartners(limit = 100) {
  const result = await dataAccess.queryRecords(COLLECTIONS.partners, {
    sort: [{ field: 'updated_at', direction: 'desc' }],
    limit: Math.min(200, Math.max(1, Number(limit) || 100)),
    suppressAuth: true
  });

  return {
    success: true,
    items: (result?.items || []).map((partner) => ({
      partner_id: partner.partner_id,
      company_name: partner.company_name || null,
      contact_email: partner.contact_email || null,
      tier: partner.tier || 'starter',
      status: partner.status || 'active',
      default_environment: partner.default_environment || 'production',
      updated_at: partner.updated_at || partner._updatedDate || null
    }))
  };
}

export async function setApiPartnerTier(partnerId, tier) {
  const normalizedTier = String(tier || '').toLowerCase();
  if (!['starter', 'growth', 'enterprise', 'custom'].includes(normalizedTier)) {
    return { success: false, error: 'tier must be starter, growth, enterprise, or custom' };
  }

  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    tier: normalizedTier,
    updated_at: new Date()
  }, { suppressAuth: true });

  return {
    success: Boolean(updated?.success),
    tier: normalizedTier,
    error: updated?.success ? null : (updated?.error || 'Failed to update tier')
  };
}

export async function setApiPartnerStatus(partnerId, status) {
  const normalizedStatus = String(status || '').toLowerCase();
  if (!['active', 'suspended'].includes(normalizedStatus)) {
    return { success: false, error: 'status must be active or suspended' };
  }

  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    status: normalizedStatus,
    updated_at: new Date()
  }, { suppressAuth: true });

  return {
    success: Boolean(updated?.success),
    status: normalizedStatus,
    error: updated?.success ? null : (updated?.error || 'Failed to update status')
  };
}

export async function rotatePartnerApiKey(partnerId, keyId, options = {}) {
  return rotateApiKey(partnerId, keyId, options);
}

export async function getPartnerUsageDashboard(partnerId, periodKey = null) {
  const filters = periodKey ? { partner_id: partnerId, period_key: periodKey } : { partner_id: partnerId };
  const usage = await dataAccess.queryRecords(COLLECTIONS.usage, {
    filters,
    sort: [{ field: 'period_key', direction: 'desc' }],
    limit: 12,
    suppressAuth: true
  });

  const subscription = await dataAccess.queryRecords(COLLECTIONS.subscriptions, {
    filters: { partner_id: partnerId },
    sort: [{ field: 'current_period_end', direction: 'desc' }],
    limit: 1,
    suppressAuth: true
  });

  return {
    success: true,
    usage: usage?.items || [],
    subscription: subscription?.items?.[0] || null
  };
}

export async function getApiPartnerHistory(partnerId, limit = 50) {
  const normalizedLimit = Math.min(200, Math.max(1, Number(limit) || 50));
  const [requests, webhooks, billing] = await Promise.all([
    dataAccess.queryRecords(COLLECTIONS.requestLog, {
      filters: { partner_id: partnerId },
      sort: [{ field: 'created_at', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.webhookDeliveries, {
      filters: { partner_id: partnerId },
      sort: [{ field: 'created_at', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.billingHistory, {
      filters: { carrier_dot: partnerId },
      sort: [{ field: 'timestamp', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    })
  ]);

  return {
    success: true,
    request_events: requests?.items || [],
    webhook_events: webhooks?.items || [],
    billing_events: billing?.items || []
  };
}

export async function getApiRevenueReport(partnerId = null, months = 12) {
  const normalizedMonths = Math.min(24, Math.max(1, Number(months) || 12));
  const now = new Date();
  const rangeStart = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - (normalizedMonths - 1), 1));
  const partnerFilter = partnerId ? { partner_id: partnerId } : {};
  const billingFilter = partnerId ? { carrier_dot: partnerId } : {};

  const [subscriptions, billingEvents, partners] = await Promise.all([
    dataAccess.queryRecords(COLLECTIONS.subscriptions, {
      filters: partnerFilter,
      sort: [{ field: 'current_period_end', direction: 'desc' }],
      limit: 500,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.billingHistory, {
      filters: billingFilter,
      sort: [{ field: 'timestamp', direction: 'desc' }],
      limit: 5000,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.partners, {
      sort: [{ field: 'updated_at', direction: 'desc' }],
      limit: 500,
      suppressAuth: true
    })
  ]);

  const partnerNameById = Object.create(null);
  for (const partner of (partners?.items || [])) {
    if (partner?.partner_id) partnerNameById[partner.partner_id] = partner.company_name || partner.partner_id;
  }

  const monthKeys = [];
  const monthlyMap = Object.create(null);
  for (let i = normalizedMonths - 1; i >= 0; i--) {
    const d = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - i, 1));
    const key = `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}`;
    monthKeys.push(key);
    monthlyMap[key] = { month: key, revenue: 0, events: 0 };
  }

  let periodRevenue = 0;
  let periodEvents = 0;
  const revenueByPartner = Object.create(null);

  for (const event of (billingEvents?.items || [])) {
    const timestamp = parseDate(event?.timestamp);
    if (!timestamp || timestamp < rangeStart) continue;

    const amount = toAmount(event?.amount);
    const month = `${timestamp.getUTCFullYear()}-${String(timestamp.getUTCMonth() + 1).padStart(2, '0')}`;
    if (monthlyMap[month]) {
      monthlyMap[month].revenue = roundCurrency(monthlyMap[month].revenue + amount);
      monthlyMap[month].events += 1;
    }

    periodRevenue = roundCurrency(periodRevenue + amount);
    periodEvents += 1;

    const partnerKey = String(event?.carrier_dot || '');
    if (partnerKey) {
      revenueByPartner[partnerKey] = roundCurrency((revenueByPartner[partnerKey] || 0) + amount);
    }
  }

  const tierSummary = {
    starter: { tier: 'starter', partners: 0, mrr: 0 },
    growth: { tier: 'growth', partners: 0, mrr: 0 },
    enterprise: { tier: 'enterprise', partners: 0, mrr: 0 },
    custom: { tier: 'custom', partners: 0, mrr: 0 }
  };
  let activePartners = 0;
  let mrr = 0;

  for (const subscription of (subscriptions?.items || [])) {
    const tier = String(subscription?.tier || 'starter').toLowerCase();
    const status = String(subscription?.status || '').toLowerCase();
    if (!['active', 'trialing', 'past_due'].includes(status)) continue;
    activePartners += 1;

    const monthlyPrice = resolveSubscriptionPrice(subscription, tier);
    mrr = roundCurrency(mrr + monthlyPrice);

    const bucket = tierSummary[tier] || tierSummary.custom;
    bucket.partners += 1;
    bucket.mrr = roundCurrency(bucket.mrr + monthlyPrice);
  }

  const arr = roundCurrency(mrr * 12);
  const arpu = activePartners > 0 ? roundCurrency(mrr / activePartners) : 0;
  const topPartners = Object.keys(revenueByPartner)
    .map((id) => ({
      partner_id: id,
      company_name: partnerNameById[id] || id,
      revenue: revenueByPartner[id]
    }))
    .sort((a, b) => b.revenue - a.revenue)
    .slice(0, 10);

  return {
    success: true,
    generated_at: new Date().toISOString(),
    window_months: normalizedMonths,
    partner_id: partnerId || null,
    summary: {
      mrr,
      arr,
      arpu,
      active_partners: activePartners,
      period_revenue: periodRevenue,
      period_events: periodEvents
    },
    monthly_revenue: monthKeys.map((key) => monthlyMap[key]),
    tier_breakdown: Object.values(tierSummary),
    top_partners: topPartners
  };
}

export async function getApiDocumentationCatalog() {
  return {
    success: true,
    generated_at: new Date().toISOString(),
    base_url: 'https://www.lastmiledr.app/_functions/api_gateway',
    endpoints: API_DOC_ENDPOINTS,
    code_examples: API_DOC_EXAMPLES,
    references: {
      openapi: '/docs/api/openapi.external.v1.yaml',
      postman: '/docs/api/postman.external.v1.collection.json',
      integration_guide: '/docs/api/integration-guide.external.v1.md'
    }
  };
}

export async function getApiOnboardingEmailSequence() {
  return {
    success: true,
    sequence: ONBOARDING_EMAIL_SEQUENCE
  };
}

export async function initializePartnerOnboarding(partnerId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const existing = await dataAccess.queryRecords(COLLECTIONS.onboarding, {
    filters: { partner_id: partnerId },
    sort: [{ field: 'created_at', direction: 'desc' }],
    limit: 1,
    suppressAuth: true
  });
  const current = existing?.items?.[0];
  if (current?._id) {
    return { success: true, onboarding: current, already_exists: true };
  }

  const now = new Date();
  const base = {
    partner_id: partnerId,
    contact_email: partner.contact_email || null,
    status: 'active',
    current_step: 0,
    first_api_call_at: partner.first_api_call_at || null,
    last_email_step_sent: 0,
    next_email_due_at: now,
    completed_steps: [],
    created_at: now,
    updated_at: now
  };
  const inserted = await dataAccess.insertRecord(COLLECTIONS.onboarding, base, { suppressAuth: true });
  return { success: true, onboarding: inserted?.record || base };
}

export async function processPartnerOnboardingFollowUps(limit = 100) {
  const now = new Date();
  const sequence = ONBOARDING_EMAIL_SEQUENCE;
  const enrollments = await dataAccess.queryRecords(COLLECTIONS.onboarding, {
    filters: { status: 'active' },
    sort: [{ field: 'updated_at', direction: 'asc' }],
    limit: Math.min(500, Math.max(1, Number(limit) || 100)),
    suppressAuth: true
  });

  const processed = [];
  for (const row of (enrollments?.items || [])) {
    const nextStep = Number(row.current_step || 0) + 1;
    const template = sequence.find((item) => item.step === nextStep);
    if (!template) continue;

    const dueAt = parseDate(row.next_email_due_at) || now;
    if (dueAt > now) continue;

    const message = {
      partner_id: row.partner_id,
      email: row.contact_email || null,
      step: template.step,
      template_key: template.key,
      subject: template.subject,
      body: template.body,
      sent_at: now.toISOString()
    };
    processed.push(message);

    const nextTemplate = sequence.find((item) => item.step === (template.step + 1));
    const nextDue = nextTemplate ? new Date(now.getTime() + (nextTemplate.delay_hours * 60 * 60 * 1000)) : null;
    await dataAccess.updateRecord(COLLECTIONS.onboarding, {
      _id: row._id,
      current_step: template.step,
      last_email_step_sent: template.step,
      completed_steps: [...(row.completed_steps || []), template.key],
      next_email_due_at: nextDue,
      status: nextTemplate ? 'active' : 'completed',
      updated_at: now
    }, { suppressAuth: true });
  }

  return {
    success: true,
    processed_count: processed.length,
    processed
  };
}

export async function runApiSandboxRequest(endpointKey, payload = {}) {
  const endpoint = API_DOC_ENDPOINTS.find((item) => item.key === endpointKey);
  if (!endpoint) {
    return { success: false, error: 'Unknown endpoint key' };
  }

  const started = Date.now();
  const response = buildSandboxResponse(endpoint, payload);
  return {
    success: true,
    sandbox: true,
    endpoint_key: endpoint.key,
    method: endpoint.method,
    path: endpoint.path,
    response_time_ms: Date.now() - started,
    response
  };
}

export async function getApiChangelog(limit = 20) {
  const normalizedLimit = Math.min(100, Math.max(1, Number(limit) || 20));

  try {
    const result = await dataAccess.queryRecords(COLLECTIONS.changelog, {
      sort: [{ field: 'date', direction: 'desc' }],
      limit: normalizedLimit,
      suppressAuth: true
    });
    const items = (result?.items || []).map((item) => ({
      version: item.version || null,
      date: formatDate(item.date || item.created_at),
      type: item.type || 'change',
      title: item.title || '',
      details: item.details || ''
    }));
    if (items.length) {
      return { success: true, items };
    }
  } catch (_error) {
    // Fallback to static changelog below when collection is unavailable.
  }

  return {
    success: true,
    items: DEFAULT_CHANGELOG_ENTRIES.slice(0, normalizedLimit)
  };
}

export async function getApiHealthStatus(windowHours = 24) {
  const normalizedHours = Math.min(168, Math.max(1, Number(windowHours) || 24));
  const windowStart = new Date(Date.now() - (normalizedHours * 60 * 60 * 1000));

  const [requests, webhookDeliveries] = await Promise.all([
    dataAccess.queryRecords(COLLECTIONS.requestLog, {
      sort: [{ field: 'created_at', direction: 'desc' }],
      limit: 5000,
      suppressAuth: true
    }),
    dataAccess.queryRecords(COLLECTIONS.webhookDeliveries, {
      sort: [{ field: 'created_at', direction: 'desc' }],
      limit: 1000,
      suppressAuth: true
    })
  ]);

  const recentRequests = (requests?.items || []).filter((item) => {
    const createdAt = parseDate(item?.created_at);
    return createdAt && createdAt >= windowStart;
  });
  const totalRequests = recentRequests.length;
  const failedRequests = recentRequests.filter((item) => Number(item?.response_status || 0) >= 500).length;
  const errorRate = totalRequests > 0 ? roundCurrency((failedRequests / totalRequests) * 100) : 0;
  const avgLatencyMs = totalRequests > 0 ?
    roundCurrency(recentRequests.reduce((sum, item) => sum + Number(item?.response_time_ms || 0), 0) / totalRequests) :
    0;
  const successRate = totalRequests > 0 ? roundCurrency(((totalRequests - failedRequests) / totalRequests) * 100) : 100;
  const estimatedUptime = roundCurrency(Math.max(0, Math.min(100, successRate)));

  const recentWebhookEvents = (webhookDeliveries?.items || []).filter((item) => {
    const createdAt = parseDate(item?.created_at);
    return createdAt && createdAt >= windowStart;
  });
  const webhookFailures = recentWebhookEvents.filter((item) => String(item?.status || '').toLowerCase() === 'failed').length;
  const webhookFailureRate = recentWebhookEvents.length > 0 ?
    roundCurrency((webhookFailures / recentWebhookEvents.length) * 100) :
    0;

  return {
    success: true,
    generated_at: new Date().toISOString(),
    window_hours: normalizedHours,
    status: (estimatedUptime >= 99.5 && errorRate < 1.5) ? 'operational' : 'degraded',
    summary: {
      total_requests: totalRequests,
      failed_requests: failedRequests,
      error_rate_percent: errorRate,
      avg_latency_ms: avgLatencyMs,
      estimated_uptime_percent: estimatedUptime,
      webhook_failure_rate_percent: webhookFailureRate
    }
  };
}

export async function getPartnerPortalSnapshot(partnerId, periodKey = null) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const [usage, keys, billing, env, webhooks] = await Promise.all([
    getPartnerUsageDashboard(partnerId, periodKey),
    listPartnerApiKeys(partnerId),
    getPartnerBillingHistory(partnerId, 25),
    getPartnerApiEnvironment(partnerId),
    listPartnerWebhookDeliveries(partnerId, 10)
  ]);

  return {
    success: true,
    partner: {
      partner_id: partner.partner_id,
      company_name: partner.company_name || null,
      contact_email: partner.contact_email || null,
      tier: partner.tier || 'starter',
      status: partner.status || 'active'
    },
    usage: usage?.usage || [],
    subscription: usage?.subscription || null,
    api_keys: keys?.keys || [],
    billing: billing || { success: false, items: [] },
    environment: env?.environment || 'production',
    webhook_deliveries: webhooks?.items || []
  };
}

export async function listPartnerApiKeys(partnerId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
  return {
    success: true,
    keys: keys.map((key) => ({
      key_id: key.key_id,
      name: key.name || null,
      environment: inferKeyEnvironment(key),
      is_active: key.is_active !== false,
      created_at: key.created_at || null,
      last_used_at: key.last_used_at || null
    }))
  };
}

export async function createPartnerApiKey(partnerId, options = {}) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
  const activeKeys = keys.filter((key) => key.is_active !== false);
  if (activeKeys.length >= 5) {
    return { success: false, error: 'Maximum 5 active keys allowed' };
  }

  const requestedEnvironment = String(options.environment || '').toLowerCase();
  const env = requestedEnvironment === 'sandbox' ? 'test' : 'live';
  const environment = env === 'test' ? 'sandbox' : 'production';
  const keyValue = await generateApiKey(env);
  const keyHash = await hashApiKey(keyValue);
  const keyId = `key_${Date.now()}`;

  const nextKeys = [...keys, {
    key_id: keyId,
      key_hash: keyHash,
      name: options.name || `API Key ${activeKeys.length + 1}`,
      environment,
      created_at: new Date(),
      last_used_at: null,
      is_active: true
  }];

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    api_keys: nextKeys,
    updated_at: new Date()
  }, { suppressAuth: true });

  if (!updated?.success) {
    return { success: false, error: updated?.error || 'Failed to create key' };
  }

  return {
    success: true,
    key_id: keyId,
    environment,
    api_key: keyValue
  };
}

export async function revokePartnerApiKey(partnerId, keyId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
  const updatedKeys = keys.map((key) => key.key_id === keyId ? { ...key, is_active: false } : key);

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    api_keys: updatedKeys,
    updated_at: new Date()
  }, { suppressAuth: true });

  return {
    success: Boolean(updated?.success),
    error: updated?.success ? null : (updated?.error || 'Failed to revoke key')
  };
}

export async function getPartnerBillingHistory(partnerId, limit = 50) {
  const billing = await dataAccess.queryRecords(COLLECTIONS.billingHistory, {
    filters: {
      carrier_dot: partnerId
    },
    sort: [{ field: 'timestamp', direction: 'desc' }],
    limit: Math.min(200, Math.max(1, Number(limit) || 50)),
    suppressAuth: true
  });

  const summary = await getApiBillingSummary(partnerId).catch(() => null);
  return {
    success: true,
    items: billing?.items || [],
    summary
  };
}

export async function listPartnerWebhookDeliveries(partnerId, limit = 25) {
  const deliveries = await dataAccess.queryRecords(COLLECTIONS.webhookDeliveries, {
    filters: { partner_id: partnerId },
    sort: [{ field: 'created_at', direction: 'desc' }],
    limit: Math.min(100, Math.max(1, Number(limit) || 25)),
    suppressAuth: true
  });

  return {
    success: true,
    items: (deliveries?.items || []).map((item) => ({
      id: item._id,
      event_type: item.event_type || null,
      status: item.status || null,
      response_status: item.response_status ?? null,
      attempt: item.attempt || 1,
      created_at: item.created_at || null
    }))
  };
}

export async function getPartnerApiEnvironment(partnerId) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const activeEnvironment = String(partner.default_environment || 'production').toLowerCase();
  return {
    success: true,
    environment: activeEnvironment === 'sandbox' ? 'sandbox' : 'production',
    sandbox_enabled: Boolean(partner.sandbox_enabled)
  };
}

export async function setPartnerApiEnvironment(partnerId, environment = 'production') {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const normalized = String(environment || '').toLowerCase();
  if (!['sandbox', 'production'].includes(normalized)) {
    return { success: false, error: 'environment must be sandbox or production' };
  }

  const updated = await dataAccess.updateRecord(COLLECTIONS.partners, {
    _id: partner._id,
    default_environment: normalized,
    sandbox_enabled: normalized === 'sandbox' ? true : Boolean(partner.sandbox_enabled),
    updated_at: new Date()
  }, { suppressAuth: true });

  if (!updated?.success) {
    return { success: false, error: updated?.error || 'Failed to set environment' };
  }

  return {
    success: true,
    environment: normalized
  };
}

export async function createPartnerApiCheckout(partnerId, tier = 'starter', planType = 'monthly') {
  return createApiCheckoutSession(partnerId, tier, planType);
}

export async function createPartnerBillingPortal(partnerId) {
  return createApiPortalSession(partnerId);
}

export async function createApiTierProducts() {
  return ensureApiStripeProducts();
}

export async function createPartnerOverageInvoice(partnerId, periodKey = null, autoFinalize = true) {
  return generateApiOverageInvoice(partnerId, periodKey, autoFinalize);
}

export async function changePartnerApiSubscription(partnerId, tier, planType = 'monthly', immediate = true) {
  return changeApiSubscriptionPlan(partnerId, tier, planType, immediate);
}

export async function sendPartnerWebhookTest(partnerId, webhookUrl = null) {
  const partner = await dataAccess.findByField(COLLECTIONS.partners, 'partner_id', partnerId, {
    suppressAuth: true
  });
  if (!partner) return { success: false, error: 'Partner not found' };

  const targetUrl = String(webhookUrl || partner.webhook_url || '').trim();
  if (!targetUrl) return { success: false, error: 'No webhook_url configured' };

  const payload = {
    event_type: 'webhook_test',
    event_id: `evt_test_${Date.now()}`,
    partner_id: partnerId,
    timestamp: new Date().toISOString(),
    data: { status: 'ok' }
  };
  const signature = await computeWebhookSignature(partner.webhook_secret || '', payload);
  const requestHeaders = {
    'Content-Type': 'application/json',
    'X-LMDR-Event': payload.event_type,
    'X-LMDR-Timestamp': payload.timestamp
  };
  if (signature) {
    requestHeaders['X-LMDR-Signature'] = signature;
  }

  try {
    const now = new Date();
    const response = await fetch(targetUrl, {
      method: 'POST',
      headers: requestHeaders,
      body: JSON.stringify(payload)
    });

    await dataAccess.insertRecord(COLLECTIONS.webhookDeliveries, {
      subscription_id: null,
      partner_id: partnerId,
      event_type: payload.event_type,
      payload,
      attempt: 1,
      status: response.ok ? 'sent' : 'failed',
      response_status: response.status,
      created_at: now,
      updated_at: now
    }, { suppressAuth: true }).catch(() => null);

    return {
      success: response.ok,
      status: response.status
    };
  } catch (error) {
    const now = new Date();
    await dataAccess.insertRecord(COLLECTIONS.webhookDeliveries, {
      subscription_id: null,
      partner_id: partnerId,
      event_type: payload.event_type,
      payload,
      attempt: 1,
      status: 'failed',
      response_status: null,
      response_body: String(error.message || '').slice(0, 1000),
      created_at: now,
      updated_at: now
    }, { suppressAuth: true }).catch(() => null);
    return { success: false, error: error.message };
  }
}

function inferKeyEnvironment(key) {
  const explicit = String(key?.environment || '').toLowerCase();
  if (explicit === 'sandbox' || explicit === 'production') return explicit;
  const name = String(key?.name || '').toLowerCase();
  if (name.includes('sandbox')) return 'sandbox';
  return 'production';
}

async function computeWebhookSignature(secret, payload) {
  if (!secret) return null;
  try {
    const body = JSON.stringify(payload);
    const key = await crypto.subtle.importKey(
      'raw',
      new TextEncoder().encode(secret),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );
    const digest = await crypto.subtle.sign(
      'HMAC',
      key,
      new TextEncoder().encode(body)
    );
    return Array.from(new Uint8Array(digest))
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('');
  } catch (error) {
    return null;
  }
}

function resolveSubscriptionPrice(subscription, tier) {
  const directPrice = Number(subscription?.price_monthly);
  if (Number.isFinite(directPrice) && directPrice > 0) return directPrice;

  const fallbackByTier = {
    starter: 99,
    growth: 499,
    enterprise: 999,
    custom: 0
  };
  return fallbackByTier[tier] || 0;
}

function parseDate(value) {
  if (!value) return null;
  const parsed = value instanceof Date ? value : new Date(value);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function toAmount(value) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : 0;
}

function roundCurrency(value) {
  return Math.round(Number(value || 0) * 100) / 100;
}

function formatDate(value) {
  const d = parseDate(value);
  if (!d) return null;
  const year = d.getUTCFullYear();
  const month = String(d.getUTCMonth() + 1).padStart(2, '0');
  const day = String(d.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function buildSandboxResponse(endpoint, payload = {}) {
  const base = {
    generated_at: new Date().toISOString(),
    sandbox: true
  };

  if (endpoint.key === 'safety_carrier_lookup') {
    return {
      ...base,
      carrier: {
        dot_number: String(payload?.dot_number || endpoint.sample_query?.dot_number || '1234567'),
        legal_name: 'Sandbox Logistics LLC',
        safety_rating: 'satisfactory',
        basic_scores: { unsafe_driving: 48, hos_compliance: 37, vehicle_maintenance: 52 }
      }
    };
  }
  if (endpoint.key === 'intelligence_market') {
    return {
      ...base,
      market: {
        region: String(payload?.region || endpoint.sample_query?.region || 'TX'),
        avg_cpm: 2.39,
        demand_index: 71,
        top_hiring_carriers: ['Sandbox Freight', 'Demo Transport']
      }
    };
  }
  if (endpoint.key === 'fuel_prices') {
    return {
      ...base,
      stations: [
        { station_id: 'stn_001', name: 'Sample Travel Center', diesel_cash: 3.64, diesel_discounted: 3.44 },
        { station_id: 'stn_002', name: 'Demo Fuel Stop', diesel_cash: 3.71, diesel_discounted: 3.52 }
      ]
    };
  }
  if (endpoint.key === 'matching_search_drivers') {
    return {
      ...base,
      total: 2,
      items: [
        { driver_id: 'drv_001', match_score: 91, cdl_class: 'A', endorsements: ['HAZMAT'] },
        { driver_id: 'drv_002', match_score: 86, cdl_class: 'A', endorsements: ['TANKER'] }
      ]
    };
  }
  if (endpoint.key === 'documents_cdl_extract') {
    return {
      ...base,
      extraction: {
        document_id: 'doc_001',
        status: 'verified',
        confidence: 0.94,
        fields: { first_name: 'ALEX', last_name: 'DRIVER', license_number: 'S1234567' }
      }
    };
  }

  return {
    ...base,
    progress: { level: 12, xp: 4200, streak_days: 18 },
    achievements: ['Safety Star', 'Consistency Pro']
  };
}

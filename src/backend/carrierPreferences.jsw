import { currentUser } from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import { getCarrierIdentity } from 'backend/recruiter_service';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    hiringPreferences: 'carrierHiringPreferences',
    recruiterAccess: 'recruiterCarriers'
};

/**
 * Helper to get carrier DOT for current user if not provided
 */
async function resolveCarrierDot(carrierDot) {
    if (carrierDot) return Number(carrierDot);
    const identity = await getCarrierIdentity();
    if (identity.success && identity.dotNumber) return Number(identity.dotNumber);
    return null;
}

/**
 * Alias for getWeightPreferences to support page code names
 */
export async function getCarrierPreferences(carrierDot = null) {
    const dot = await resolveCarrierDot(carrierDot);
    if (!dot) return { success: false, error: 'Carrier DOT not found' };
    
    const res = await getWeightPreferences(dot);
    if (!res.success) return res;
    
    // Flatten result for frontend
    return {
        ...res.weights,
        preset_id: res.preferenceId ? (await getHiringPreferenceById(res.preferenceId)).preferences?.preset_id : null,
        is_customized: res.preferenceId ? (await getHiringPreferenceById(res.preferenceId)).preferences?.is_customized : false
    };
}

/**
 * Alias for saveWeightPreferences to support page code names
 */
export async function saveCarrierPreferences(weights, carrierDot = null) {
    const dot = await resolveCarrierDot(carrierDot);
    if (!dot) return { success: false, error: 'Carrier DOT not found' };
    return await saveWeightPreferences(dot, weights);
}

/**
 * Alias for applyPresetTemplate to support page code names
 */
export async function applyPreset(presetId, carrierDot = null) {
    const dot = await resolveCarrierDot(carrierDot);
    if (!dot) return { success: false, error: 'Carrier DOT not found' };
    return await applyPresetTemplate(dot, presetId);
}

const VALID_CDL_TYPES = ['A', 'B', 'C'];
const VALID_URGENCY_VALUES = ['immediate', '30_day', 'ongoing'];

export const PRESET_TEMPLATES = {
  otr_heavy_haul: {
    id: 'otr_heavy_haul',
    name: 'OTR Heavy Haul',
    description: 'Long-haul drivers for heavy/oversized loads',
    icon: 'truck',
    weights: {
      weight_qualifications: 35,
      weight_experience: 25,
      weight_location: 10,
      weight_availability: 15,
      weight_salaryFit: 10,
      weight_engagement: 5
    },
    preferences: {
      required_cdl_types: ['A'],
      min_experience_years: 3,
      required_endorsements: [],
      route_types: ['otr', 'regional'],
      equipment_types: ['heavy_haul', 'oversize', 'flatbed']
    }
  },
  regional_dedicated: {
    id: 'regional_dedicated',
    name: 'Regional Dedicated',
    description: 'Consistent regional routes, home weekly',
    icon: 'map-pin',
    weights: {
      weight_qualifications: 25,
      weight_experience: 15,
      weight_location: 30,
      weight_availability: 15,
      weight_salaryFit: 10,
      weight_engagement: 5
    },
    preferences: {
      required_cdl_types: ['A'],
      min_experience_years: 1,
      required_endorsements: [],
      route_types: ['regional', 'dedicated'],
      equipment_types: ['dry_van', 'reefer']
    }
  },
  local_pd: {
    id: 'local_pd',
    name: 'Local P&D',
    description: 'Local pickup & delivery, daily home time',
    icon: 'home',
    weights: {
      weight_qualifications: 20,
      weight_experience: 10,
      weight_location: 40,
      weight_availability: 20,
      weight_salaryFit: 5,
      weight_engagement: 5
    },
    preferences: {
      required_cdl_types: ['A', 'B'],
      min_experience_years: 0,
      required_endorsements: [],
      route_types: ['local'],
      equipment_types: ['straight_truck', 'box_truck', 'dry_van']
    }
  },
  tanker_hazmat: {
    id: 'tanker_hazmat',
    name: 'Tanker/Hazmat',
    description: 'Specialized tanker and hazmat endorsements',
    icon: 'alert-triangle',
    weights: {
      weight_qualifications: 45,
      weight_experience: 20,
      weight_location: 15,
      weight_availability: 10,
      weight_salaryFit: 5,
      weight_engagement: 5
    },
    preferences: {
      required_cdl_types: ['A'],
      min_experience_years: 2,
      required_endorsements: ['H', 'N', 'X'],
      route_types: ['otr', 'regional', 'local'],
      equipment_types: ['tanker']
    }
  },
  flatbed_stepdeck: {
    id: 'flatbed_stepdeck',
    name: 'Flatbed/Stepdeck',
    description: 'Open deck freight and securement specialists',
    icon: 'layers',
    weights: {
      weight_qualifications: 30,
      weight_experience: 25,
      weight_location: 15,
      weight_availability: 15,
      weight_salaryFit: 10,
      weight_engagement: 5
    },
    preferences: {
      required_cdl_types: ['A'],
      min_experience_years: 2,
      required_endorsements: [],
      route_types: ['otr', 'regional'],
      equipment_types: ['flatbed', 'stepdeck', 'rgn']
    }
  }
};

/**
 * Returns all preset templates for carrier hiring preferences
 */
export function getPresetTemplates() {
  return Object.values(PRESET_TEMPLATES);
}

/**
 * Validates the preference data
 */
export function validatePreferencesData(data, isUpdate = false) {
  const errors = [];
  if (!data) return { isValid: false, errors: ['Data is required'] };

  if (!isUpdate) {
    if (!data.carrier_dot) errors.push('carrier_dot is required');
    if (!Array.isArray(data.required_cdl_types) || data.required_cdl_types.length === 0) {
      errors.push('required_cdl_types must be a non-empty array');
    } else {
      for (const t of data.required_cdl_types) if (!VALID_CDL_TYPES.includes(t)) errors.push(`Invalid CDL type: ${t}`);
    }
    if (typeof data.target_radius_miles !== 'number' || data.target_radius_miles <= 0) {
      errors.push('target_radius_miles must be a positive number');
    }
  }

  if (isUpdate) {
    if (data.required_cdl_types !== undefined && !Array.isArray(data.required_cdl_types)) errors.push('required_cdl_types must be an array');
    if (data.target_radius_miles !== undefined && (typeof data.target_radius_miles !== 'number' || data.target_radius_miles <= 0)) {
      errors.push('target_radius_miles must be a positive number');
    }
  }

  if (data.offered_pay_min && data.offered_pay_max && data.offered_pay_max < data.offered_pay_min) {
    errors.push('offered_pay_max must be >= offered_pay_min');
  }

  if (data.urgency && !VALID_URGENCY_VALUES.includes(data.urgency)) errors.push('Invalid urgency');

  return { isValid: errors.length === 0, errors };
}

/**
 * Check if current user has access to the specified carrier
 */
async function checkCarrierAccess(carrierDot) {
  const userId = currentUser.id;
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterAccess, {
    filters: { recruiter_id: userId, carrier_dot: Number(carrierDot), is_active: 'Yes' },
    limit: 1, suppressAuth: true
  });
  return result.success && result.items.length > 0;
}

/**
 * Create new hiring preferences for a carrier
 */
export async function createHiringPreferences(data) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    const val = validatePreferencesData(data);
    if (!val.isValid) return { success: false, error: val.errors[0] };

    if (!await checkCarrierAccess(data.carrier_dot)) return { success: false, error: 'Not authorized' };

    const preferenceData = {
      carrier_dot: Number(data.carrier_dot), recruiter_id: currentUser.id,
      required_cdl_types: data.required_cdl_types, required_endorsements: data.required_endorsements || [],
      min_experience_years: data.min_experience_years ?? null, target_zip_codes: data.target_zip_codes || [],
      target_radius_miles: data.target_radius_miles, target_states: data.target_states || [],
      offered_pay_min: data.offered_pay_min ?? null, offered_pay_max: data.offered_pay_max ?? null,
      route_types: data.route_types || [], equipment_types: data.equipment_types || [],
      urgency: data.urgency ?? null, positions_open: data.positions_open ?? null, is_active: 'Yes'
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.hiringPreferences, preferenceData, { suppressAuth: true });
    return { success: result.success, preferences: result.record, error: result.error };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Update existing hiring preferences
 */
export async function updateHiringPreferences(preferenceId, data) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    const val = validatePreferencesData(data, true);
    if (!val.isValid) return { success: false, error: val.errors[0] };

    const existing = await dataAccess.getRecord(COLLECTION_KEYS.hiringPreferences, preferenceId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Not found' };

    if (!await checkCarrierAccess(existing.carrier_dot)) return { success: false, error: 'Not authorized' };

    const updatedPref = { ...existing, ...data, _id: preferenceId, _updatedDate: new Date() };
    const result = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, updatedPref, { suppressAuth: true });
    return { success: result.success, preferences: result.record, error: result.error };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Get active hiring preferences for a carrier
 */
export async function getHiringPreferences(carrierDot) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.hiringPreferences, {
      filters: { carrier_dot: Number(carrierDot), is_active: 'Yes' },
      limit: 1, suppressAuth: true
    });
    return { success: true, preferences: result.items?.[0] || null };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getHiringPreferenceById(preferenceId) {
  try {
    const result = await dataAccess.getRecord(COLLECTION_KEYS.hiringPreferences, preferenceId, { suppressAuth: true });
    return { success: true, preferences: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Get weight preferences for a carrier
 */
export async function getWeightPreferences(carrierDot) {
  try {
    const res = await getHiringPreferences(carrierDot);
    if (!res.success) return res;

    const defaultWeights = {
      weight_qualifications: 30, weight_experience: 20, weight_location: 20,
      weight_availability: 15, weight_salaryFit: 10, weight_engagement: 5
    };

    if (!res.preferences) return { success: true, weights: defaultWeights, isDefault: true };

    const p = res.preferences;
    const weights = {
      weight_qualifications: p.weight_qualifications ?? defaultWeights.weight_qualifications,
      weight_experience: p.weight_experience ?? defaultWeights.weight_experience,
      weight_location: p.weight_location ?? defaultWeights.weight_location,
      weight_availability: p.weight_availability ?? defaultWeights.weight_availability,
      weight_salaryFit: p.weight_salaryFit ?? defaultWeights.weight_salaryFit,
      weight_engagement: p.weight_engagement ?? defaultWeights.weight_engagement
    };

    return { success: true, weights, isDefault: false, preferenceId: p._id };
  } catch (error) {
    console.error('[carrierPreferences] getWeightPreferences error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Applies a preset template to a carrier's hiring preferences
 */
export async function applyPresetTemplate(carrierDot, presetId) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    
    const preset = PRESET_TEMPLATES[presetId];
    if (!preset) return { success: false, error: 'Invalid preset ID' };

    if (!await checkCarrierAccess(carrierDot)) return { success: false, error: 'Not authorized' };

    const existing = await getHiringPreferences(carrierDot);
    const now = new Date();

    const preferenceData = {
      carrier_dot: Number(carrierDot),
      recruiter_id: currentUser.id,
      ...preset.preferences,
      ...preset.weights,
      preset_id: presetId,
      preset_applied_at: now,
      is_customized: false,
      is_active: 'Yes',
      _updatedDate: now
    };

    let result;
    if (existing.success && existing.preferences) {
      const updated = { ...existing.preferences, ...preferenceData, _id: existing.preferences._id };
      result = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, updated, { suppressAuth: true });
    } else {
      result = await dataAccess.insertRecord(COLLECTION_KEYS.hiringPreferences, preferenceData, { suppressAuth: true });
    }

    return { success: result.success, preferences: result.record, error: result.error };
  } catch (error) {
    console.error('[carrierPreferences] applyPresetTemplate error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Save weight preferences for a carrier
 */
export async function saveWeightPreferences(carrierDot, weights) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    
    const existing = await getHiringPreferences(carrierDot);
    if (existing.success && existing.preferences) {
      // If weights are different from current, and we have a preset_id, mark as customized
      let isCustomized = existing.preferences.is_customized || false;
      if (existing.preferences.preset_id) {
        const hasWeightChanges = Object.keys(weights).some(key => weights[key] !== existing.preferences[key]);
        if (hasWeightChanges) isCustomized = true;
      }

      const updated = { 
        ...existing.preferences, 
        ...weights, 
        is_customized: isCustomized,
        _updatedDate: new Date() 
      };
      console.log('[carrierPreferences] Updating existing record:', updated._id);
      const res = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, updated, { suppressAuth: true });
      if (!res.success) console.error('[carrierPreferences] Update failed:', res.error, res.errorCode);
      return { success: res.success, weights: res.record, error: res.error };
    } else {
      const newPref = {
        carrier_dot: Number(carrierDot),
        recruiter_id: currentUser.id,
        required_cdl_types: 'A',
        target_radius_miles: 100,
        ...weights,
        is_active: 'Yes',
        is_customized: false
      };
      console.log('[carrierPreferences] Inserting new record for DOT:', carrierDot);
      const res = await dataAccess.insertRecord(COLLECTION_KEYS.hiringPreferences, newPref, { suppressAuth: true });
      if (!res.success) console.error('[carrierPreferences] Insert failed:', res.error, res.errorCode);
      return { success: res.success, weights: res.record, error: res.error };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Deactivate hiring preferences
 */
export async function deactivateHiringPreferences(preferenceId) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.hiringPreferences, preferenceId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Not found' };

    if (!await checkCarrierAccess(existing.carrier_dot)) return { success: false, error: 'Not authorized' };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, { ...existing, is_active: 'No', _updatedDate: new Date() }, { suppressAuth: true });
    return { success: result.success, preferences: result.record };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

import { currentUser } from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    hiringPreferences: 'carrierHiringPreferences',
    recruiterAccess: 'recruiterCarriers'
};

const VALID_CDL_TYPES = ['A', 'B', 'C'];
const VALID_URGENCY_VALUES = ['immediate', '30_day', 'ongoing'];

/**
 * Validates the preference data
 */
export function validatePreferencesData(data, isUpdate = false) {
  const errors = [];
  if (!data) return { isValid: false, errors: ['Data is required'] };

  if (!isUpdate) {
    if (!data.carrier_dot) errors.push('carrier_dot is required');
    if (!Array.isArray(data.required_cdl_types) || data.required_cdl_types.length === 0) {
      errors.push('required_cdl_types must be a non-empty array');
    } else {
      for (const t of data.required_cdl_types) if (!VALID_CDL_TYPES.includes(t)) errors.push(`Invalid CDL type: ${t}`);
    }
    if (typeof data.target_radius_miles !== 'number' || data.target_radius_miles <= 0) {
      errors.push('target_radius_miles must be a positive number');
    }
  }

  if (isUpdate) {
    if (data.required_cdl_types !== undefined && !Array.isArray(data.required_cdl_types)) errors.push('required_cdl_types must be an array');
    if (data.target_radius_miles !== undefined && (typeof data.target_radius_miles !== 'number' || data.target_radius_miles <= 0)) {
      errors.push('target_radius_miles must be a positive number');
    }
  }

  if (data.offered_pay_min && data.offered_pay_max && data.offered_pay_max < data.offered_pay_min) {
    errors.push('offered_pay_max must be >= offered_pay_min');
  }

  if (data.urgency && !VALID_URGENCY_VALUES.includes(data.urgency)) errors.push('Invalid urgency');

  return { isValid: errors.length === 0, errors };
}

/**
 * Check if current user has access to the specified carrier
 */
async function checkCarrierAccess(carrierDot) {
  const userId = currentUser.id;
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterAccess, {
    filters: { recruiter_id: userId, carrier_dot: String(carrierDot), is_active: true },
    limit: 1, suppressAuth: true
  });
  return result.success && result.items.length > 0;
}

/**
 * Create new hiring preferences for a carrier
 */
export async function createHiringPreferences(data) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    const val = validatePreferencesData(data);
    if (!val.isValid) return { success: false, error: val.errors[0] };

    if (!await checkCarrierAccess(data.carrier_dot)) return { success: false, error: 'Not authorized' };

    const preferenceData = {
      carrier_dot: String(data.carrier_dot), recruiter_id: currentUser.id,
      required_cdl_types: data.required_cdl_types, required_endorsements: data.required_endorsements || [],
      min_experience_years: data.min_experience_years ?? null, target_zip_codes: data.target_zip_codes || [],
      target_radius_miles: data.target_radius_miles, target_states: data.target_states || [],
      offered_pay_min: data.offered_pay_min ?? null, offered_pay_max: data.offered_pay_max ?? null,
      route_types: data.route_types || [], equipment_types: data.equipment_types || [],
      urgency: data.urgency ?? null, positions_open: data.positions_open ?? null, is_active: true
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.hiringPreferences, preferenceData, { suppressAuth: true });
    return { success: result.success, preferences: result.record, error: result.error };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Update existing hiring preferences
 */
export async function updateHiringPreferences(preferenceId, data) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    const val = validatePreferencesData(data, true);
    if (!val.isValid) return { success: false, error: val.errors[0] };

    const existing = await dataAccess.getRecord(COLLECTION_KEYS.hiringPreferences, preferenceId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Not found' };

    if (!await checkCarrierAccess(existing.carrier_dot)) return { success: false, error: 'Not authorized' };

    const updatedPref = { ...existing, ...data, _id: preferenceId, _updatedDate: new Date() };
    const result = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, updatedPref, { suppressAuth: true });
    return { success: result.success, preferences: result.record, error: result.error };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Get active hiring preferences for a carrier
 */
export async function getHiringPreferences(carrierDot) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.hiringPreferences, {
      filters: { carrier_dot: String(carrierDot), is_active: true },
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 1, suppressAuth: true
    });
    return { success: true, preferences: result.items?.[0] || null };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getHiringPreferenceById(preferenceId) {
  try {
    const result = await dataAccess.getRecord(COLLECTION_KEYS.hiringPreferences, preferenceId, { suppressAuth: true });
    return { success: true, preferences: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Get weight preferences for a carrier
 */
export async function getWeightPreferences(carrierDot) {
  try {
    const res = await getHiringPreferences(carrierDot);
    if (!res.success) return res;

    const defaultWeights = {
      weight_qualifications: 30, weight_experience: 20, weight_location: 20,
      weight_availability: 15, weight_salaryFit: 10, weight_engagement: 5
    };

    if (!res.preferences) return { success: true, weights: defaultWeights, isDefault: true };

    const p = res.preferences;
    const weights = {
      weight_qualifications: p.weight_qualifications ?? defaultWeights.weight_qualifications,
      weight_experience: p.weight_experience ?? defaultWeights.weight_experience,
      weight_location: p.weight_location ?? defaultWeights.weight_location,
      weight_availability: p.weight_availability ?? defaultWeights.weight_availability,
      weight_salaryFit: p.weight_salaryFit ?? defaultWeights.weight_salaryFit,
      weight_engagement: p.weight_engagement ?? defaultWeights.weight_engagement
    };

    return { success: true, weights, isDefault: false, preferenceId: p._id };
  } catch (error) {
    console.error('[carrierPreferences] getWeightPreferences error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Save weight preferences for a carrier
 */
export async function saveWeightPreferences(carrierDot, weights) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    
    const existing = await getHiringPreferences(carrierDot);
    if (existing.success && existing.preferences) {
      const updated = { ...existing.preferences, ...weights, _updatedDate: new Date() };
      const res = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, updated, { suppressAuth: true });
      return { success: res.success, weights: res.record };
    } else {
      const newPref = { carrier_dot: String(carrierDot), recruiter_id: currentUser.id, required_cdl_types: ['A'], target_radius_miles: 100, ...weights, is_active: true };
      const res = await dataAccess.insertRecord(COLLECTION_KEYS.hiringPreferences, newPref, { suppressAuth: true });
      return { success: res.success, weights: res.record };
    }
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Deactivate hiring preferences
 */
export async function deactivateHiringPreferences(preferenceId) {
  try {
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.hiringPreferences, preferenceId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Not found' };

    if (!await checkCarrierAccess(existing.carrier_dot)) return { success: false, error: 'Not authorized' };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.hiringPreferences, { ...existing, is_active: false, _updatedDate: new Date() }, { suppressAuth: true });
    return { success: result.success, preferences: result.record };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

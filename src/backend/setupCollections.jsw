/**
 * Setup Collections - One-time setup for required Wix collections
 *
 * Run this from a page or the Wix editor console to create missing collections.
 *
 * Usage: Import and call setupCarrierSubscriptions() once.
 *
 * Feature Adoption Log Collections (4):
 * - FeatureAdoptionLogs: Primary event log (19 fields)
 * - FeatureRegistry: Feature catalog (13 fields)
 * - FeatureFunnels: Multi-step flow definitions (7 fields)
 * - FeatureMetricsDaily: Pre-aggregated daily rollups (13 fields)
 */

import wixData from 'wix-data';

const CARRIER_SUBSCRIPTIONS = 'CarrierSubscriptions';
const CARRIER_DRIVER_VIEWS = 'CarrierDriverViews';

/**
 * Creates a test subscription record for development
 * Call this to set up the CarrierSubscriptions collection with a test record
 */
export async function setupCarrierSubscriptions() {
  console.log('[SETUP] Setting up CarrierSubscriptions...');

  try {
    // Try to query the collection first
    const existingResult = await wixData.query(CARRIER_SUBSCRIPTIONS)
      .eq('carrier_dot', '123456')
      .limit(1)
      .find({ suppressAuth: true });

    if (existingResult.items.length > 0) {
      console.log('[SETUP] Test subscription already exists:', existingResult.items[0]);
      return { success: true, message: 'Collection already has test record', record: existingResult.items[0] };
    }

    // Create test subscription for DEV_MODE carrier
    const testSubscription = {
      carrier_dot: '123456',
      plan_type: 'pro',
      monthly_view_quota: 25,
      views_used_this_month: 0,
      is_active: true,
      quota_reset_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days from now
    };

    const inserted = await wixData.insert(CARRIER_SUBSCRIPTIONS, testSubscription, { suppressAuth: true });
    console.log('[SETUP] Created test subscription:', inserted);

    return { success: true, message: 'Created test subscription', record: inserted };

  } catch (err) {
    console.error('[SETUP] Error:', err.message);

    // If collection doesn't exist, we need to create it manually
    if (err.message.includes('does not exist')) {
      return {
        success: false,
        error: 'Collection does not exist. Please create it manually in Wix CMS.',
        instructions: [
          '1. Go to Wix Editor > CMS > + Create Collection',
          '2. Name: CarrierSubscriptions',
          '3. Add fields: carrier_dot (Text), plan_type (Text), monthly_view_quota (Number), views_used_this_month (Number), is_active (Boolean), quota_reset_date (Date)'
        ]
      };
    }

    return { success: false, error: err.message };
  }
}

/**
 * Creates a recruiter-carrier link for the current user
 */
export async function setupRecruiterCarrier(carrierDot = '123456') {
  console.log('[SETUP] Setting up recruiterCarriers...');

  try {
    // Get current user
    const { currentUser } = await import('wix-users-backend');
    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }

    const userId = currentUser.id;
    console.log('[SETUP] User ID:', userId);

    // Check if record exists
    const existingResult = await wixData.query('recruiterCarriers')
      .eq('recruiter_id', userId)
      .eq('carrier_dot', carrierDot)
      .limit(1)
      .find({ suppressAuth: true });

    if (existingResult.items.length > 0) {
      const existing = existingResult.items[0];

      // Activate if inactive
      if (!existing.is_active) {
        existing.is_active = true;
        const updated = await wixData.update('recruiterCarriers', existing, { suppressAuth: true });
        console.log('[SETUP] Activated existing record:', updated);
        return { success: true, message: 'Activated existing record', record: updated };
      }

      console.log('[SETUP] Record already exists and is active:', existing);
      return { success: true, message: 'Record already exists', record: existing };
    }

    // Create new record
    const newRecord = {
      recruiter_id: userId,
      carrier_dot: carrierDot,
      carrier_name: 'Test Carrier',
      is_active: true,
      added_date: new Date(),
      verification_status: 'verified'
    };

    const inserted = await wixData.insert('recruiterCarriers', newRecord, { suppressAuth: true });
    console.log('[SETUP] Created recruiter-carrier link:', inserted);

    return { success: true, message: 'Created recruiter-carrier link', record: inserted };

  } catch (err) {
    console.error('[SETUP] Error:', err.message);
    return { success: false, error: err.message };
  }
}

// ============================================================================
// FEATURE ADOPTION LOG COLLECTIONS SETUP
// ============================================================================
// Schema definitions and setup functions for the Feature Adoption Log system.
// Reference: Conductor/tracks/feature_adoption_log_20260120/plan.md
// ============================================================================

/**
 * Collection Names for Feature Adoption Log system
 */
const FEATURE_ADOPTION_COLLECTIONS = {
  LOGS: 'FeatureAdoptionLogs',
  REGISTRY: 'FeatureRegistry',
  FUNNELS: 'FeatureFunnels',
  METRICS_DAILY: 'FeatureMetricsDaily'
};

/**
 * Valid action types for FeatureAdoptionLogs
 */
const VALID_ACTION_TYPES = [
  'view',       // Feature was displayed to user
  'click',      // User clicked within feature
  'complete',   // User finished primary task
  'hover',      // User hovered over element (desktop)
  'scroll_to',  // User scrolled to element
  'time_spent', // Passive time tracking (fired on exit)
  'error',      // Something went wrong
  'abandon',    // User left mid-process
  'share',      // User shared feature/content
  'repeat',     // User returned to feature (not first in session)
  'first_use'   // User's first ever use of this feature
];

/**
 * Valid feature status values
 */
const VALID_FEATURE_STATUSES = ['beta', 'active', 'deprecated', 'sunset'];

/**
 * Valid expected usage patterns
 */
const VALID_USAGE_PATTERNS = ['daily', 'weekly', 'onboarding-only', 'event-driven'];

/**
 * Schema definition for FeatureAdoptionLogs collection
 * Primary event log capturing all feature interactions (19 fields)
 *
 * Indexes needed:
 * - featureId + timestamp (compound)
 * - sessionId
 * - userId + timestamp (compound)
 */
const FEATURE_ADOPTION_LOGS_SCHEMA = {
  collectionName: 'FeatureAdoptionLogs',
  displayName: 'Feature Adoption Logs',
  fields: [
    // Core identification fields
    { name: 'featureId', type: 'text', description: 'Unique feature identifier (e.g., "carrier_search")' },
    { name: 'featureVersion', type: 'text', description: 'Version for A/B testing (e.g., "v2.1", "control", "variant_a")' },
    { name: 'userId', type: 'text', description: 'Member ID or anonymous session ID' },
    { name: 'userRole', type: 'text', description: 'User type: driver, carrier, recruiter' },
    { name: 'action', type: 'text', description: 'Interaction type from VALID_ACTION_TYPES' },
    { name: 'timestamp', type: 'date', description: 'When event occurred (ISO 8601)' },
    { name: 'sessionId', type: 'text', description: 'Groups interactions in a session' },

    // Context fields
    { name: 'deviceType', type: 'text', description: 'Device category: mobile, desktop, tablet' },
    { name: 'referrer', type: 'text', description: 'Previous page/feature (e.g., "/dashboard")' },
    { name: 'entryPoint', type: 'text', description: 'UI element that triggered entry (e.g., "nav_menu")' },

    // Engagement metrics
    { name: 'durationMs', type: 'number', description: 'Time spent on feature in milliseconds' },
    { name: 'scrollDepth', type: 'number', description: 'How far user scrolled (0-100 percentage)' },
    { name: 'interactionCount', type: 'number', description: 'Number of clicks/taps within feature' },

    // Outcome fields
    { name: 'outcome', type: 'text', description: 'Result: success, failure, partial, abandoned' },
    { name: 'conversionValue', type: 'number', description: 'Business value if applicable (e.g., 249.00)' },
    { name: 'nextFeature', type: 'text', description: 'Where user went next (e.g., "driver_profile", "exit")' },

    // Error tracking
    { name: 'errorCode', type: 'text', description: 'Machine-readable error code if action=error' },
    { name: 'errorMessage', type: 'text', description: 'Human-readable error detail' },

    // Flexible data
    { name: 'metadata', type: 'object', description: 'Additional data as JSON (e.g., {searchQuery, resultsCount})' }
  ],
  permissions: {
    read: 'Admin',
    create: 'SiteMember',  // Frontend tracker needs write access
    update: 'Admin',
    delete: 'Admin'
  }
};

/**
 * Schema definition for FeatureRegistry collection
 * Master list of all trackable features (13 fields)
 *
 * Indexes needed:
 * - featureId (unique)
 * - status
 */
const FEATURE_REGISTRY_SCHEMA = {
  collectionName: 'FeatureRegistry',
  displayName: 'Feature Registry',
  fields: [
    { name: 'featureId', type: 'text', description: 'UNIQUE identifier (e.g., "carrier_search")' },
    { name: 'displayName', type: 'text', description: 'Human-readable name' },
    { name: 'description', type: 'text', description: 'What the feature does' },
    { name: 'category', type: 'text', description: 'Feature category: matching, communication, analytics, onboarding' },
    { name: 'launchDate', type: 'date', description: 'When feature was released' },
    { name: 'status', type: 'text', description: 'Lifecycle status: beta, active, deprecated, sunset' },
    { name: 'expectedUsagePattern', type: 'text', description: 'Expected frequency: daily, weekly, onboarding-only, event-driven' },
    { name: 'targetRoles', type: 'array', description: 'Array of user roles: ["driver", "recruiter", "carrier"]' },
    { name: 'owner', type: 'text', description: 'Team/person responsible (e.g., "matching-team")' },
    { name: 'successMetric', type: 'text', description: 'Success criteria (e.g., "completion_rate > 40%")' },
    { name: 'retirementThreshold', type: 'number', description: 'Days without use before flagging (default: 30)' },
    { name: 'relatedFeatures', type: 'array', description: 'Array of featureIds often used together' },
    { name: 'documentationUrl', type: 'text', description: 'Link to feature documentation' }
  ],
  permissions: {
    read: 'Anyone',  // Dashboard needs to read
    create: 'Admin',
    update: 'Admin',
    delete: 'Admin'
  }
};

/**
 * Schema definition for FeatureFunnels collection
 * Multi-step flow definitions for conversion tracking (7 fields)
 *
 * Indexes needed:
 * - funnelId (unique)
 */
const FEATURE_FUNNELS_SCHEMA = {
  collectionName: 'FeatureFunnels',
  displayName: 'Feature Funnels',
  fields: [
    { name: 'funnelId', type: 'text', description: 'UNIQUE funnel identifier (e.g., "driver_application_flow")' },
    { name: 'displayName', type: 'text', description: 'Human-readable name' },
    { name: 'description', type: 'text', description: 'What this funnel measures' },
    {
      name: 'steps',
      type: 'array',
      description: 'Ordered step definitions: [{order, featureId, action, displayName, optional}]'
    },
    { name: 'createdAt', type: 'date', description: 'When funnel was defined' },
    { name: 'updatedAt', type: 'date', description: 'Last modification timestamp' },
    { name: 'isActive', type: 'boolean', description: 'Whether to track this funnel' }
  ],
  permissions: {
    read: 'Anyone',
    create: 'Admin',
    update: 'Admin',
    delete: 'Admin'
  }
};

/**
 * Schema definition for FeatureMetricsDaily collection
 * Pre-aggregated daily rollups for fast dashboard queries (13 fields)
 *
 * Indexes needed:
 * - featureId + date (compound, unique)
 */
const FEATURE_METRICS_DAILY_SCHEMA = {
  collectionName: 'FeatureMetricsDaily',
  displayName: 'Feature Metrics Daily',
  fields: [
    { name: 'featureId', type: 'text', description: 'Feature identifier' },
    { name: 'date', type: 'date', description: 'Aggregation date (midnight UTC)' },
    { name: 'uniqueUsers', type: 'number', description: 'Distinct users count' },
    { name: 'totalInteractions', type: 'number', description: 'Total events logged' },
    { name: 'completionRate', type: 'number', description: 'Percentage of views that completed (0-100)' },
    { name: 'avgDurationMs', type: 'number', description: 'Average time spent in milliseconds' },
    { name: 'errorRate', type: 'number', description: 'Percentage of interactions with errors (0-100)' },
    { name: 'abandonRate', type: 'number', description: 'Percentage of views abandoned (0-100)' },
    {
      name: 'byRole',
      type: 'object',
      description: 'Breakdown by user role: {driver: {users, interactions, completionRate}, ...}'
    },
    {
      name: 'byDevice',
      type: 'object',
      description: 'Breakdown by device: {mobile: {users, interactions}, desktop: {...}, tablet: {...}}'
    },
    {
      name: 'byEntryPoint',
      type: 'object',
      description: 'Breakdown by entry point: {nav_menu: count, cta_button: count, ...}'
    },
    {
      name: 'topErrors',
      type: 'array',
      description: 'Most common errors: [{code, message, count}, ...]'
    },
    { name: 'conversionValueTotal', type: 'number', description: 'Sum of conversion values for the day' }
  ],
  permissions: {
    read: 'Anyone',  // Dashboard needs to read
    create: 'Admin', // Only aggregation job writes
    update: 'Admin',
    delete: 'Admin'
  }
};

/**
 * All Feature Adoption schemas for reference
 */
export const FEATURE_ADOPTION_SCHEMAS = {
  logs: FEATURE_ADOPTION_LOGS_SCHEMA,
  registry: FEATURE_REGISTRY_SCHEMA,
  funnels: FEATURE_FUNNELS_SCHEMA,
  metricsDaily: FEATURE_METRICS_DAILY_SCHEMA
};

/**
 * Export valid enums for use in service functions
 */
export { VALID_ACTION_TYPES, VALID_FEATURE_STATUSES, VALID_USAGE_PATTERNS, FEATURE_ADOPTION_COLLECTIONS };

/**
 * Checks if a collection exists by attempting to query it
 * @param {string} collectionName - Name of the collection to check
 * @returns {Promise<{exists: boolean, error?: string}>}
 */
async function checkCollectionExists(collectionName) {
  try {
    await wixData.query(collectionName).limit(1).find({ suppressAuth: true });
    return { exists: true };
  } catch (err) {
    if (err.message.includes('does not exist') || err.code === 'WD_COLLECTION_NOT_FOUND') {
      return { exists: false, error: 'Collection does not exist' };
    }
    return { exists: false, error: err.message };
  }
}

/**
 * Generates manual creation instructions for a collection
 * @param {Object} schema - Schema definition object
 * @returns {string[]} - Array of instruction strings
 */
function generateCollectionInstructions(schema) {
  const instructions = [
    `1. Go to Wix Editor > CMS > + Create Collection`,
    `2. Name: ${schema.collectionName} (Display Name: ${schema.displayName})`,
    `3. Set permissions: Read=${schema.permissions.read}, Create=${schema.permissions.create}, Update=${schema.permissions.update}, Delete=${schema.permissions.delete}`,
    `4. Add the following fields:`
  ];

  schema.fields.forEach((field, index) => {
    const typeMap = {
      text: 'Text',
      number: 'Number',
      date: 'Date and Time',
      boolean: 'Boolean',
      array: 'Tags (for simple arrays) or Rich Content/JSON (for complex arrays)',
      object: 'Rich Content or use JSON in a Text field'
    };
    instructions.push(`   ${index + 5}. ${field.name} (${typeMap[field.type] || field.type}) - ${field.description}`);
  });

  return instructions;
}

/**
 * Creates the Road Utilities collections if they don't exist
 */
export async function setupRoadUtilitiesCollections() {
  console.log('[SETUP] Setting up Road Utilities collections...');
  const collections = [
    {
      name: 'ParkingLocations',
      fields: 'external_id (Text), source (Text), name (Text), location (Object), address (Object), total_spaces (Number), available_spaces (Number), amenities (Tags), avg_rating (Number), last_availability_update (Date)'
    },
    {
      name: 'ParkingReports',
      fields: 'location_id (Text), driver_id (Text), report_type (Text), spaces_available (Number), reported_at (Date)'
    },
    // Phase 6: Road Conditions
    {
      name: 'RoadConditions',
      fields: 'type (Text), highway (Text), state (Text), location (Object), severity (Text), description (Text), delay_minutes (Number), start_time (Date), expected_end (Date)'
    },
    {
      name: 'TruckRestrictions',
      fields: 'highway (Text), state (Text), restriction_type (Text), value (Number), unit (Text), details (Text), permanent (Boolean), location (Object)'
    },
    {
      name: 'DriverConditionReports',
      fields: 'driver_id (Text), type (Text), location (Object), highway (Text), state (Text), description (Text), timestamp (Date), expires_at (Date), verified_count (Number)'
    },
    {
      name: 'RoadUtilityCache',
      fields: 'cache_key (Text), cache_type (Text), data (Object), expires_at (Date)'
    }
  ];

  const results = {};

  for (const col of collections) {
    try {
      await wixData.query(col.name).limit(1).find({ suppressAuth: true });
      console.log(`[SETUP] Collection ${col.name} exists.`);
      results[col.name] = { success: true, message: 'Exists' };
    } catch (err) {
      console.warn(`[SETUP] Collection ${col.name} potentially missing:`, err.message);
      results[col.name] = {
        success: false,
        error: `Collection ${col.name} missing. Create manually.`,
        instructions: `Create collection '${col.name}' with fields: ${col.fields}`
      };
    }
  }

  return results;
}

/**
 * Creates the FeatureAdoptionLogs collection if it doesn't exist
 * Primary event log capturing all feature interactions (19 fields)
 */
export async function setupFeatureAdoptionLogs() {
  console.log('[SETUP] Setting up FeatureAdoptionLogs...');
  const schema = FEATURE_ADOPTION_LOGS_SCHEMA;

  const { exists, error } = await checkCollectionExists(schema.collectionName);

  if (exists) {
    console.log(`[SETUP] ${schema.collectionName} collection exists.`);
    return { success: true, message: 'Collection exists', collectionName: schema.collectionName };
  }

  return {
    success: false,
    error: `${schema.collectionName} collection missing. Create manually.`,
    collectionName: schema.collectionName,
    schema: schema,
    instructions: generateCollectionInstructions(schema),
    indexRecommendations: [
      'Create compound index on: featureId + timestamp',
      'Create index on: sessionId',
      'Create compound index on: userId + timestamp'
    ]
  };
}

/**
 * Creates the FeatureRegistry collection if it doesn't exist
 * Master list of all trackable features (13 fields)
 */
export async function setupFeatureRegistry() {
  console.log('[SETUP] Setting up FeatureRegistry...');
  const schema = FEATURE_REGISTRY_SCHEMA;

  const { exists, error } = await checkCollectionExists(schema.collectionName);

  if (exists) {
    console.log(`[SETUP] ${schema.collectionName} collection exists.`);
    return { success: true, message: 'Collection exists', collectionName: schema.collectionName };
  }

  return {
    success: false,
    error: `${schema.collectionName} collection missing. Create manually.`,
    collectionName: schema.collectionName,
    schema: schema,
    instructions: generateCollectionInstructions(schema),
    indexRecommendations: [
      'Create UNIQUE index on: featureId',
      'Create index on: status'
    ]
  };
}

/**
 * Creates the FeatureFunnels collection if it doesn't exist
 * Multi-step flow definitions for conversion tracking (7 fields)
 */
export async function setupFeatureFunnels() {
  console.log('[SETUP] Setting up FeatureFunnels...');
  const schema = FEATURE_FUNNELS_SCHEMA;

  const { exists, error } = await checkCollectionExists(schema.collectionName);

  if (exists) {
    console.log(`[SETUP] ${schema.collectionName} collection exists.`);
    return { success: true, message: 'Collection exists', collectionName: schema.collectionName };
  }

  return {
    success: false,
    error: `${schema.collectionName} collection missing. Create manually.`,
    collectionName: schema.collectionName,
    schema: schema,
    instructions: generateCollectionInstructions(schema),
    indexRecommendations: [
      'Create UNIQUE index on: funnelId'
    ]
  };
}

/**
 * Creates the FeatureMetricsDaily collection if it doesn't exist
 * Pre-aggregated daily rollups for fast dashboard queries (13 fields)
 */
export async function setupFeatureMetricsDaily() {
  console.log('[SETUP] Setting up FeatureMetricsDaily...');
  const schema = FEATURE_METRICS_DAILY_SCHEMA;

  const { exists, error } = await checkCollectionExists(schema.collectionName);

  if (exists) {
    console.log(`[SETUP] ${schema.collectionName} collection exists.`);
    return { success: true, message: 'Collection exists', collectionName: schema.collectionName };
  }

  return {
    success: false,
    error: `${schema.collectionName} collection missing. Create manually.`,
    collectionName: schema.collectionName,
    schema: schema,
    instructions: generateCollectionInstructions(schema),
    indexRecommendations: [
      'Create UNIQUE compound index on: featureId + date'
    ]
  };
}

/**
 * Sets up all 4 Feature Adoption Log collections
 * Run this once to verify/create all required collections
 *
 * @returns {Promise<Object>} - Results for each collection setup
 */
export async function setupFeatureAdoptionCollections() {
  console.log('[SETUP] ========================================');
  console.log('[SETUP] Setting up Feature Adoption Log System');
  console.log('[SETUP] ========================================');

  const results = {
    summary: {
      total: 4,
      existing: 0,
      missing: 0
    },
    collections: {}
  };

  // Setup each collection
  results.collections.FeatureAdoptionLogs = await setupFeatureAdoptionLogs();
  results.collections.FeatureRegistry = await setupFeatureRegistry();
  results.collections.FeatureFunnels = await setupFeatureFunnels();
  results.collections.FeatureMetricsDaily = await setupFeatureMetricsDaily();

  // Calculate summary
  for (const [name, result] of Object.entries(results.collections)) {
    if (result.success) {
      results.summary.existing++;
    } else {
      results.summary.missing++;
    }
  }

  // Add overall status
  results.summary.allReady = results.summary.missing === 0;

  console.log('[SETUP] ========================================');
  console.log(`[SETUP] Results: ${results.summary.existing} existing, ${results.summary.missing} missing`);
  console.log('[SETUP] All Ready:', results.summary.allReady);
  console.log('[SETUP] ========================================');

  return results;
}

/**
 * Seeds the FeatureRegistry with initial platform features
 * Call this after collections are created to populate baseline features
 *
 * @returns {Promise<Object>} - Results of seeding operation
 */
export async function seedFeatureRegistry() {
  console.log('[SETUP] Seeding FeatureRegistry with initial features...');

  const initialFeatures = [
    {
      featureId: 'carrier_search',
      displayName: 'Carrier Search & Matching',
      description: 'AI-powered search to find carriers matching driver preferences',
      category: 'matching',
      launchDate: new Date('2025-06-15'),
      status: 'active',
      expectedUsagePattern: 'daily',
      targetRoles: ['driver'],
      owner: 'matching-team',
      successMetric: 'completion_rate > 40%',
      retirementThreshold: 30,
      relatedFeatures: ['carrier_detail', 'driver_application'],
      documentationUrl: ''
    },
    {
      featureId: 'driver_application',
      displayName: 'Driver Application Form',
      description: 'Multi-step form for drivers to apply to carriers',
      category: 'matching',
      launchDate: new Date('2025-06-15'),
      status: 'active',
      expectedUsagePattern: 'event-driven',
      targetRoles: ['driver'],
      owner: 'matching-team',
      successMetric: 'completion_rate > 30%',
      retirementThreshold: 30,
      relatedFeatures: ['carrier_search', 'carrier_detail'],
      documentationUrl: ''
    },
    {
      featureId: 'recruiter_pipeline',
      displayName: 'Recruiter Candidate Pipeline',
      description: 'Kanban-style pipeline for managing driver candidates',
      category: 'communication',
      launchDate: new Date('2025-08-01'),
      status: 'active',
      expectedUsagePattern: 'daily',
      targetRoles: ['recruiter'],
      owner: 'recruiter-team',
      successMetric: 'daily_active_users > 50',
      retirementThreshold: 14,
      relatedFeatures: ['driver_search', 'driver_outreach'],
      documentationUrl: ''
    },
    {
      featureId: 'driver_search',
      displayName: 'Driver Search (Recruiter)',
      description: 'Search and filter drivers for recruiting outreach',
      category: 'matching',
      launchDate: new Date('2025-09-01'),
      status: 'active',
      expectedUsagePattern: 'daily',
      targetRoles: ['recruiter', 'carrier'],
      owner: 'recruiter-team',
      successMetric: 'daily_active_users > 30',
      retirementThreshold: 14,
      relatedFeatures: ['recruiter_pipeline', 'driver_outreach'],
      documentationUrl: ''
    },
    {
      featureId: 'ai_matching',
      displayName: 'AI Matching Dashboard',
      description: 'AI-powered carrier recommendations for drivers',
      category: 'matching',
      launchDate: new Date('2025-10-01'),
      status: 'active',
      expectedUsagePattern: 'weekly',
      targetRoles: ['driver'],
      owner: 'ai-team',
      successMetric: 'engagement_rate > 60%',
      retirementThreshold: 30,
      relatedFeatures: ['carrier_search', 'carrier_detail'],
      documentationUrl: ''
    },
    {
      featureId: 'carrier_onboarding',
      displayName: 'Carrier Onboarding Flow',
      description: 'Multi-step onboarding for new carriers',
      category: 'onboarding',
      launchDate: new Date('2025-07-01'),
      status: 'active',
      expectedUsagePattern: 'onboarding-only',
      targetRoles: ['carrier'],
      owner: 'onboarding-team',
      successMetric: 'completion_rate > 70%',
      retirementThreshold: 60,
      relatedFeatures: ['carrier_preferences'],
      documentationUrl: ''
    }
  ];

  const results = {
    inserted: [],
    skipped: [],
    errors: []
  };

  for (const feature of initialFeatures) {
    try {
      // Check if feature already exists
      const existing = await wixData.query(FEATURE_ADOPTION_COLLECTIONS.REGISTRY)
        .eq('featureId', feature.featureId)
        .limit(1)
        .find({ suppressAuth: true });

      if (existing.items.length > 0) {
        results.skipped.push(feature.featureId);
        console.log(`[SETUP] Skipped (exists): ${feature.featureId}`);
        continue;
      }

      // Insert new feature
      const inserted = await wixData.insert(FEATURE_ADOPTION_COLLECTIONS.REGISTRY, feature, { suppressAuth: true });
      results.inserted.push(feature.featureId);
      console.log(`[SETUP] Inserted: ${feature.featureId}`);

    } catch (err) {
      results.errors.push({ featureId: feature.featureId, error: err.message });
      console.error(`[SETUP] Error inserting ${feature.featureId}:`, err.message);
    }
  }

  console.log(`[SETUP] Seeding complete: ${results.inserted.length} inserted, ${results.skipped.length} skipped, ${results.errors.length} errors`);

  return results;
}

/**
 * Seeds the FeatureFunnels collection with initial funnel definitions
 * Call this after collections are created to set up baseline funnels
 *
 * @returns {Promise<Object>} - Results of seeding operation
 */
export async function seedFeatureFunnels() {
  console.log('[SETUP] Seeding FeatureFunnels with initial funnels...');

  const initialFunnels = [
    {
      funnelId: 'driver_application_flow',
      displayName: 'Driver Application Funnel',
      description: 'Tracks drivers from carrier search to application submission',
      steps: [
        { order: 1, featureId: 'carrier_search', action: 'view', displayName: 'Search Carriers', optional: false },
        { order: 2, featureId: 'carrier_detail', action: 'view', displayName: 'View Carrier Details', optional: false },
        { order: 3, featureId: 'driver_application', action: 'complete', displayName: 'Submit Application', optional: false }
      ],
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true
    },
    {
      funnelId: 'recruiter_outreach_flow',
      displayName: 'Recruiter Outreach Funnel',
      description: 'Tracks recruiters from driver search to first contact',
      steps: [
        { order: 1, featureId: 'driver_search', action: 'view', displayName: 'Search Drivers', optional: false },
        { order: 2, featureId: 'driver_profile', action: 'view', displayName: 'View Driver Profile', optional: false },
        { order: 3, featureId: 'driver_outreach', action: 'complete', displayName: 'Send Outreach Message', optional: false }
      ],
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true
    },
    {
      funnelId: 'carrier_onboarding_flow',
      displayName: 'Carrier Onboarding Funnel',
      description: 'Tracks carriers through complete onboarding process',
      steps: [
        { order: 1, featureId: 'carrier_signup', action: 'complete', displayName: 'Create Account', optional: false },
        { order: 2, featureId: 'carrier_onboarding', action: 'view', displayName: 'Start Onboarding', optional: false },
        { order: 3, featureId: 'carrier_preferences', action: 'complete', displayName: 'Set Hiring Preferences', optional: false },
        { order: 4, featureId: 'subscription_checkout', action: 'complete', displayName: 'Subscribe to Plan', optional: true }
      ],
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true
    }
  ];

  const results = {
    inserted: [],
    skipped: [],
    errors: []
  };

  for (const funnel of initialFunnels) {
    try {
      // Check if funnel already exists
      const existing = await wixData.query(FEATURE_ADOPTION_COLLECTIONS.FUNNELS)
        .eq('funnelId', funnel.funnelId)
        .limit(1)
        .find({ suppressAuth: true });

      if (existing.items.length > 0) {
        results.skipped.push(funnel.funnelId);
        console.log(`[SETUP] Skipped (exists): ${funnel.funnelId}`);
        continue;
      }

      // Insert new funnel
      const inserted = await wixData.insert(FEATURE_ADOPTION_COLLECTIONS.FUNNELS, funnel, { suppressAuth: true });
      results.inserted.push(funnel.funnelId);
      console.log(`[SETUP] Inserted: ${funnel.funnelId}`);

    } catch (err) {
      results.errors.push({ funnelId: funnel.funnelId, error: err.message });
      console.error(`[SETUP] Error inserting ${funnel.funnelId}:`, err.message);
    }
  }

  console.log(`[SETUP] Seeding complete: ${results.inserted.length} inserted, ${results.skipped.length} skipped, ${results.errors.length} errors`);

  return results;
}

/**
 * Complete setup for Feature Adoption Log system
 * 1. Verifies/creates all 4 collections
 * 2. Seeds FeatureRegistry with initial features
 * 3. Seeds FeatureFunnels with initial funnels
 *
 * @returns {Promise<Object>} - Complete setup results
 */
export async function setupFeatureAdoptionSystem() {
  console.log('[SETUP] ============================================');
  console.log('[SETUP] FEATURE ADOPTION LOG SYSTEM - FULL SETUP');
  console.log('[SETUP] ============================================');

  const results = {
    collections: null,
    registrySeed: null,
    funnelsSeed: null,
    overallSuccess: false
  };

  // Step 1: Setup collections
  results.collections = await setupFeatureAdoptionCollections();

  // Only proceed with seeding if all collections exist
  if (results.collections.summary.allReady) {
    // Step 2: Seed FeatureRegistry
    results.registrySeed = await seedFeatureRegistry();

    // Step 3: Seed FeatureFunnels
    results.funnelsSeed = await seedFeatureFunnels();

    results.overallSuccess = true;
  } else {
    console.log('[SETUP] Cannot seed - some collections are missing. Create them first.');
    results.registrySeed = { skipped: true, reason: 'Collections not ready' };
    results.funnelsSeed = { skipped: true, reason: 'Collections not ready' };
  }

  console.log('[SETUP] ============================================');
  console.log('[SETUP] SETUP COMPLETE');
  console.log('[SETUP] Overall Success:', results.overallSuccess);
  console.log('[SETUP] ============================================');

  return results;
}

// ============================================================================
// CARRIER COMPLIANCE SETUP
// Reference: Conductor/tracks/carrier_compliance_20260120/spec.md
// ============================================================================

const COMPLIANCE_COLLECTIONS = {
  EVENTS: 'ComplianceEvents',
  ALERTS: 'ComplianceAlerts',
  DOCUMENTS: 'CarrierDocuments',
  DQ_FILES: 'QualificationFiles',
  CSA_HISTORY: 'CSAScoreHistory',
  INCIDENTS: 'IncidentReports'
};

const COMPLIANCE_EVENTS_SCHEMA = {
  collectionName: 'ComplianceEvents',
  displayName: 'Compliance Events',
  fields: [
    { name: 'carrier_dot', type: 'text', description: 'Carrier DOT number' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'event_type', type: 'text', description: 'Type of event (e.g., drug_test_random)' },
    { name: 'event_category', type: 'text', description: 'Category: medical, testing, training, etc.' },
    { name: 'title', type: 'text', description: 'Display title' },
    { name: 'description', type: 'text', description: 'Additional notes' },
    { name: 'due_date', type: 'date', description: 'Due date' },
    { name: 'completed_date', type: 'date', description: 'Completion date' },
    { name: 'status', type: 'text', description: 'pending, upcoming, due_soon, overdue, completed' },
    { name: 'document_id', type: 'text', description: 'Reference to CarrierDocuments' },
    { name: 'reminder_30_sent', type: 'boolean', description: 'Reminder sent flag' },
    { name: 'reminder_14_sent', type: 'boolean', description: 'Reminder sent flag' },
    { name: 'reminder_7_sent', type: 'boolean', description: 'Reminder sent flag' },
    { name: 'reminder_due_sent', type: 'boolean', description: 'Reminder sent flag' },
    { name: 'recurrence', type: 'object', description: 'Recurrence config JSON' },
    { name: 'auto_renew', type: 'boolean', description: 'Auto-create next event' },
    { name: 'assigned_to', type: 'text', description: 'User ID responsible' },
    { name: 'priority', type: 'text', description: 'critical, high, normal, low' }
  ],
  permissions: {
    read: 'SiteMember', // Carrier admins need access
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const COMPLIANCE_ALERTS_SCHEMA = {
  collectionName: 'ComplianceAlerts',
  displayName: 'Compliance Alerts',
  fields: [
    { name: 'carrier_dot', type: 'text', description: 'Carrier DOT number' },
    { name: 'alert_type', type: 'text', description: 'expiring_document, overdue_event, csa_change' },
    { name: 'severity', type: 'text', description: 'info, warning, critical' },
    { name: 'title', type: 'text', description: 'Alert title' },
    { name: 'message', type: 'text', description: 'Alert message' },
    { name: 'related_entity_type', type: 'text', description: 'driver, document, event, csa_score' },
    { name: 'related_entity_id', type: 'text', description: 'ID of related entity' },
    { name: 'status', type: 'text', description: 'active, acknowledged, resolved, dismissed' },
    { name: 'acknowledged_by', type: 'text', description: 'User ID' },
    { name: 'acknowledged_date', type: 'date', description: 'When acknowledged' },
    { name: 'resolved_date', type: 'date', description: 'When resolved' },
    { name: 'auto_resolve_on', type: 'date', description: 'Auto-resolve date' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'Admin', // System creates alerts usually
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const CARRIER_DOCUMENTS_SCHEMA = {
  collectionName: 'CarrierDocuments',
  displayName: 'Carrier Documents',
  fields: [
    { name: 'carrier_dot', type: 'text', description: 'Carrier DOT number' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'document_type', type: 'text', description: 'Type of document' },
    { name: 'document_category', type: 'text', description: 'Category' },
    { name: 'title', type: 'text', description: 'Document title' },
    { name: 'file_url', type: 'text', description: 'File URL' }, // URL type in Wix is Text usually
    { name: 'file_name', type: 'text', description: 'Original file name' },
    { name: 'file_size', type: 'number', description: 'Size in bytes' },
    { name: 'mime_type', type: 'text', description: 'MIME type' },
    { name: 'issue_date', type: 'date', description: 'Issue date' },
    { name: 'expiration_date', type: 'date', description: 'Expiration date' },
    { name: 'is_expired', type: 'boolean', description: 'Computed expired flag' },
    { name: 'days_until_expiry', type: 'number', description: 'Computed days remaining' },
    { name: 'version', type: 'number', description: 'Version number' },
    { name: 'previous_version_id', type: 'text', description: 'Reference to previous version' },
    { name: 'status', type: 'text', description: 'active, expired, superseded, archived' },
    { name: 'verification_status', type: 'text', description: 'pending, verified, rejected' },
    { name: 'verified_by', type: 'text', description: 'User ID' },
    { name: 'verified_date', type: 'date', description: 'Verification timestamp' },
    { name: 'notes', type: 'text', description: 'Admin notes' },
    { name: 'tags', type: 'array', description: 'Tags array' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const QUALIFICATION_FILES_SCHEMA = {
  collectionName: 'QualificationFiles',
  displayName: 'Qualification Files',
  fields: [
    { name: 'carrier_dot', type: 'text', description: 'Carrier DOT number' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'driver_name', type: 'text', description: 'Denormalized name' },
    { name: 'completeness_score', type: 'number', description: '0-100 percentage' },
    { name: 'status', type: 'text', description: 'incomplete, complete, audit_ready' },
    { name: 'last_audit_date', type: 'date', description: 'Last audit date' },
    { name: 'checklist', type: 'object', description: 'Checklist JSON' },
    { name: 'missing_items', type: 'array', description: 'Array of missing item keys' },
    { name: 'expiring_soon', type: 'array', description: 'Array of expiring item keys' },
    { name: 'alerts', type: 'array', description: 'Array of active alerts' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'Admin', // System creates usually
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const CSA_SCORE_HISTORY_SCHEMA = {
  collectionName: 'CSAScoreHistory',
  displayName: 'CSA Score History',
  fields: [
    { name: 'carrier_dot', type: 'text', description: 'Carrier DOT number' },
    { name: 'snapshot_date', type: 'date', description: 'Snapshot date' },
    { name: 'overall_percentile', type: 'number', description: 'Overall risk' },
    { name: 'basics', type: 'object', description: 'BASIC scores JSON' },
    { name: 'alerts_active', type: 'array', description: 'Active alerts' },
    { name: 'inspections_30_day', type: 'number', description: 'Count' },
    { name: 'violations_30_day', type: 'number', description: 'Count' },
    { name: 'crashes_30_day', type: 'number', description: 'Count' },
    { name: 'trend_vs_prior', type: 'object', description: 'Trend JSON' },
    { name: 'source', type: 'text', description: 'scheduled, manual, incident' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'Admin',
    update: 'Admin',
    delete: 'Admin'
  }
};

const INCIDENT_REPORTS_SCHEMA = {
  collectionName: 'IncidentReports',
  displayName: 'Incident Reports',
  fields: [
    { name: 'carrier_dot', type: 'text', description: 'Carrier DOT number' },
    { name: 'incident_number', type: 'text', description: 'Unique Reference' },
    { name: 'incident_type', type: 'text', description: 'accident, injury, etc.' },
    { name: 'incident_date', type: 'date', description: 'Occurrence date' },
    { name: 'reported_date', type: 'date', description: 'Reported date' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'driver_name', type: 'text', description: 'Denormalized name' },
    { name: 'vehicle_id', type: 'text', description: 'Vehicle unit number' },
    { name: 'location', type: 'object', description: 'Location JSON' },
    { name: 'description', type: 'text', description: 'Description' },
    { name: 'severity', type: 'text', description: 'minor, moderate, major, critical' },
    { name: 'dot_reportable', type: 'boolean', description: 'DOT reportable flag' },
    { name: 'dot_report_status', type: 'text', description: 'Status' },
    { name: 'dot_report_date', type: 'date', description: 'Submission date' },
    { name: 'injuries', type: 'object', description: 'Injuries JSON' },
    { name: 'property_damage', type: 'object', description: 'Property damage JSON' },
    { name: 'tow_required', type: 'boolean', description: 'Tow required flag' },
    { name: 'hazmat_release', type: 'boolean', description: 'Hazmat release flag' },
    { name: 'police_report_number', type: 'text', description: 'Police report #' },
    { name: 'insurance_claim_number', type: 'text', description: 'Insurance claim #' },
    { name: 'investigation_status', type: 'text', description: 'Status' },
    { name: 'investigation_findings', type: 'text', description: 'Findings' },
    { name: 'root_cause', type: 'text', description: 'Root cause' },
    { name: 'corrective_actions', type: 'array', description: 'Actions array' },
    { name: 'photos', type: 'array', description: 'Array of doc IDs' },
    { name: 'documents', type: 'array', description: 'Array of doc IDs' },
    { name: 'witness_statements', type: 'array', description: 'Witness array' },
    { name: 'assigned_investigator', type: 'text', description: 'User ID' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

/**
 * Setup function for Carrier Compliance collections
 */
export async function setupComplianceCollections() {
  console.log('[SETUP] Setting up Carrier Compliance Collections...');

  const schemas = [
    COMPLIANCE_EVENTS_SCHEMA,
    COMPLIANCE_ALERTS_SCHEMA,
    CARRIER_DOCUMENTS_SCHEMA,
    QUALIFICATION_FILES_SCHEMA,
    CSA_SCORE_HISTORY_SCHEMA,
    INCIDENT_REPORTS_SCHEMA
  ];

  const results = {
    existing: [],
    missing: []
  };

  for (const schema of schemas) {
    const { exists } = await checkCollectionExists(schema.collectionName);
    if (exists) {
      results.existing.push(schema.collectionName);
    } else {
      results.missing.push({
        name: schema.collectionName,
        instructions: generateCollectionInstructions(schema)
      });
    }
  }

  return results;
}

// ============================================================================
// CARRIER COMMUNICATION HUB SETUP
// Reference: Conductor/tracks/carrier_communication_20260120/spec.md
// ============================================================================

const COMMUNICATION_COLLECTIONS = {
  ANNOUNCEMENTS: 'CarrierAnnouncements',
  READ_RECEIPTS: 'AnnouncementReadReceipts',
  COMMENTS: 'AnnouncementComments',
  CARRIER_SETTINGS: 'CarrierNotificationSettings',
  DRIVER_PREFERENCES: 'DriverNotificationPreferences'
};

const CARRIER_ANNOUNCEMENTS_SCHEMA = {
  collectionName: 'CarrierAnnouncements',
  displayName: 'Carrier Announcements',
  fields: [
    { name: 'carrier_id', type: 'text', description: 'Reference to carrier (DOT or ID)' },
    { name: 'title', type: 'text', description: 'Announcement title' },
    { name: 'slug', type: 'text', description: 'URL-friendly slug' },
    { name: 'content', type: 'text', description: 'Rich text/HTML content' },
    { name: 'content_plain', type: 'text', description: 'Plain text for previews/search' },
    { name: 'priority', type: 'text', description: 'normal, important, urgent' },
    { name: 'status', type: 'text', description: 'draft, scheduled, published, archived' },
    { name: 'target_audience', type: 'object', description: 'Targeting JSON (type + segments)' },
    { name: 'scheduled_at', type: 'date', description: 'Scheduled publish time' },
    { name: 'published_at', type: 'date', description: 'Actual publish time' },
    { name: 'expires_at', type: 'date', description: 'Auto-archive date' },
    { name: 'allow_comments', type: 'boolean', description: 'Enable driver comments' },
    { name: 'created_by', type: 'text', description: 'Admin user ID' },
    { name: 'created_at', type: 'date', description: 'Created timestamp' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' },
    { name: 'read_count', type: 'number', description: 'Cached read count' },
    { name: 'total_recipients', type: 'number', description: 'Cached recipient count' },
    { name: 'attachments', type: 'array', description: 'Attachment metadata array' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const ANNOUNCEMENT_READ_RECEIPTS_SCHEMA = {
  collectionName: 'AnnouncementReadReceipts',
  displayName: 'Announcement Read Receipts',
  fields: [
    { name: 'announcement_id', type: 'text', description: 'Reference to CarrierAnnouncements' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'carrier_id', type: 'text', description: 'Reference to carrier' },
    { name: 'read_at', type: 'date', description: 'Read timestamp' },
    { name: 'device_type', type: 'text', description: 'mobile, desktop, email' },
    { name: 'time_spent_seconds', type: 'number', description: 'Engagement metric (optional)' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const ANNOUNCEMENT_COMMENTS_SCHEMA = {
  collectionName: 'AnnouncementComments',
  displayName: 'Announcement Comments',
  fields: [
    { name: 'announcement_id', type: 'text', description: 'Reference to CarrierAnnouncements' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'driver_name', type: 'text', description: 'Denormalized name' },
    { name: 'comment_text', type: 'text', description: 'Comment (max 500 chars)' },
    { name: 'is_hidden', type: 'boolean', description: 'Moderation flag' },
    { name: 'created_at', type: 'date', description: 'Created timestamp' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const CARRIER_NOTIFICATION_SETTINGS_SCHEMA = {
  collectionName: 'CarrierNotificationSettings',
  displayName: 'Carrier Notification Settings',
  fields: [
    { name: 'carrier_id', type: 'text', description: 'Reference to carrier' },
    { name: 'email_digest_frequency', type: 'text', description: 'none, daily, weekly' },
    { name: 'push_enabled', type: 'boolean', description: 'Enable push notifications' },
    { name: 'in_app_enabled', type: 'boolean', description: 'Enable in-app notifications' },
    { name: 'allow_comments_default', type: 'boolean', description: 'Default comment setting' },
    { name: 'reminders_enabled', type: 'boolean', description: 'Enable reminder nudges' },
    { name: 'reminder_days', type: 'array', description: 'Reminder cadence array' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

const DRIVER_NOTIFICATION_PREFERENCES_SCHEMA = {
  collectionName: 'DriverNotificationPreferences',
  displayName: 'Driver Notification Preferences',
  fields: [
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'carrier_id', type: 'text', description: 'Reference to carrier' },
    { name: 'announcements_opt_out', type: 'boolean', description: 'Opt out of announcements' },
    { name: 'email_opt_in', type: 'boolean', description: 'Email notifications enabled' },
    { name: 'push_opt_in', type: 'boolean', description: 'Push notifications enabled' },
    { name: 'digest_frequency', type: 'text', description: 'none, daily, weekly' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' }
  ],
  permissions: {
    read: 'SiteMember',
    create: 'SiteMember',
    update: 'SiteMember',
    delete: 'Admin'
  }
};

/**
 * Setup function for Carrier Communication collections
 */
export async function setupCarrierCommunicationCollections() {
  console.log('[SETUP] Setting up Carrier Communication Collections...');

  const schemas = [
    CARRIER_ANNOUNCEMENTS_SCHEMA,
    ANNOUNCEMENT_READ_RECEIPTS_SCHEMA,
    ANNOUNCEMENT_COMMENTS_SCHEMA,
    CARRIER_NOTIFICATION_SETTINGS_SCHEMA,
    DRIVER_NOTIFICATION_PREFERENCES_SCHEMA
  ];

  const results = {
    existing: [],
    missing: []
  };

  for (const schema of schemas) {
    const { exists } = await checkCollectionExists(schema.collectionName);
    if (exists) {
      results.existing.push(schema.collectionName);
    } else {
      const indexRecommendations = [];
      if (schema.collectionName === COMMUNICATION_COLLECTIONS.ANNOUNCEMENTS) {
        indexRecommendations.push('Create index on: carrier_id');
        indexRecommendations.push('Create index on: status');
        indexRecommendations.push('Create index on: published_at');
      }
      if (schema.collectionName === COMMUNICATION_COLLECTIONS.READ_RECEIPTS) {
        indexRecommendations.push('Create compound index on: announcement_id + driver_id');
        indexRecommendations.push('Create index on: carrier_id');
      }
      if (schema.collectionName === COMMUNICATION_COLLECTIONS.COMMENTS) {
        indexRecommendations.push('Create index on: announcement_id');
      }
      results.missing.push({
        name: schema.collectionName,
        instructions: generateCollectionInstructions(schema),
        indexRecommendations
      });
    }
  }

  return results;
}

/**
 * Creates the Fuel Utilities collections if they don't exist
 */
export async function setupFuelCollections() {
  console.log('[SETUP] Setting up Fuel Utilities collections...');
  const collections = [
    {
      name: 'FuelPrices',
      fields: 'station_id (Text), brand (Text), location (Object), address (Object), diesel_price (Number), def_price (Number), card_discounts (Object), amenities (Tags), price_updated_at (Date), source (Text)'
    },
    {
      name: 'FuelCards',
      fields: 'driver_id (Text), card_type (Text), card_number_last4 (Text), is_primary (Boolean), linked_at (Date)'
    }
  ];

  const results = {};

  for (const col of collections) {
    try {
      await wixData.query(col.name).limit(1).find({ suppressAuth: true });
      console.log(`[SETUP] Collection ${col.name} exists.`);
      results[col.name] = { success: true, message: 'Exists' };
    } catch (err) {
      console.warn(`[SETUP] Collection ${col.name} potentially missing:`, err.message);
      results[col.name] = {
        success: false,
        error: `Collection ${col.name} missing. Create manually.`,
        instructions: `Create collection '${col.name}' with fields: ${col.fields}`
      };
    }
  }

  return results;
}

// ============================================================================
// CARRIER PAYMENTS SETUP
// Reference: Conductor/tracks/carrier_conversion_20260103/plan.md
// ============================================================================

const CARRIER_PAYMENTS_SCHEMA = {
  collectionName: 'CarrierPayments',
  displayName: 'Carrier Payments',
  fields: [
    { name: 'leadId', type: 'text', description: 'Reference to CarrierLeads' },
    { name: 'stripeSessionId', type: 'text', description: 'Stripe Checkout Session ID' },
    { name: 'amount', type: 'number', description: 'Payment amount' },
    { name: 'currency', type: 'text', description: 'Currency code (e.g., usd)' },
    { name: 'status', type: 'text', description: 'pending, completed, failed, refunded' },
    { name: 'paymentIntentId', type: 'text', description: 'Stripe Payment Intent ID' },
    { name: 'completedAt', type: 'date', description: 'Completion timestamp' },
    { name: 'carrierDot', type: 'text', description: 'Carrier DOT Number' }
  ],
  permissions: {
    read: 'Admin',
    create: 'Admin',
    update: 'Admin',
    delete: 'Admin'
  }
};

/**
 * Creates the CarrierPayments collection if it doesn't exist
 */
export async function setupCarrierPayments() {
  console.log('[SETUP] Setting up CarrierPayments...');
  const schema = CARRIER_PAYMENTS_SCHEMA;

  const { exists, error } = await checkCollectionExists(schema.collectionName);

  if (exists) {
    console.log(`[SETUP] ${schema.collectionName} collection exists.`);
    return { success: true, message: 'Collection exists', collectionName: schema.collectionName };
  }

  return {
    success: false,
    error: `${schema.collectionName} collection missing. Create manually.`,
    collectionName: schema.collectionName,
    schema: schema,
    instructions: generateCollectionInstructions(schema),
    indexRecommendations: [
      'Create index on: leadId',
      'Create index on: stripeSessionId'
    ]
  };
}

/**
 * Run all setup functions (legacy + Feature Adoption + Compliance + Road Utilities + Payments)
 */
export async function runFullSetup() {
  const results = {
    carrierSubscriptions: null,
    recruiterCarrier: null,
    featureAdoptionSystem: null,
    complianceSystem: null,
    carrierCommunication: null,
    roadUtilities: null,
    fuelUtilities: null,
    carrierPayments: null,
    externalApiPlatform: null,
    externalApiProductSeed: null
  };

  results.carrierSubscriptions = await setupCarrierSubscriptions();
  results.recruiterCarrier = await setupRecruiterCarrier('123456');
  results.featureAdoptionSystem = await setupFeatureAdoptionSystem();
  results.complianceSystem = await setupComplianceCollections();
  results.carrierCommunication = await setupCarrierCommunicationCollections();
  results.roadUtilities = await setupRoadUtilitiesCollections();
  results.fuelUtilities = await setupFuelCollections();
  results.carrierPayments = await setupCarrierPayments();
  results.fleetDashboard = await setupFleetDashboardCollections();
  results.externalApiPlatform = await setupExternalApiPlatformCollections();
  results.externalApiProductSeed = await seedExternalApiProducts();

  console.log('[SETUP] Full setup complete:', results);
  return results;
}

// ============================================================================
// CARRIER FLEET DASHBOARD SETUP
// Reference: Conductor/tracks/carrier_fleet_dashboard_20260120/spec.md
// ============================================================================

const FLEET_COLLECTIONS = {
  DRIVERS: 'FleetDrivers',
  ASSETS: 'EquipmentAssets',
  ASSIGNMENTS: 'EquipmentAssignments',
  SCORES: 'DriverScores',
  CAPACITY: 'CapacityPlans',
  ELD: 'ELDConnections',
  LOCATIONS: 'DriverLocations'
};

const FLEET_DRIVERS_SCHEMA = {
  collectionName: 'FleetDrivers',
  displayName: 'Fleet Drivers',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles' },
    { name: 'employee_id', type: 'text', description: 'Internal employee number' },
    { name: 'status', type: 'text', description: 'active, driving, resting, on_leave, etc.' },
    { name: 'status_updated_at', type: 'date', description: 'Last status change' },
    { name: 'hire_date', type: 'date', description: 'Employment start date' },
    { name: 'home_terminal', type: 'text', description: 'Home base location' },
    { name: 'assigned_equipment_id', type: 'text', description: 'Reference to EquipmentAssets' },
    { name: 'license_state', type: 'text', description: 'CDL issuing state' },
    { name: 'license_expiry', type: 'date', description: 'CDL expiration date' },
    { name: 'medical_card_expiry', type: 'date', description: 'Medical card expiration' },
    { name: 'phone_primary', type: 'text', description: 'Primary contact' },
    { name: 'email', type: 'text', description: 'Email address' }
  ],
  permissions: { read: 'SiteMember', create: 'SiteMember', update: 'SiteMember', delete: 'Admin' }
};

const EQUIPMENT_ASSETS_SCHEMA = {
  collectionName: 'EquipmentAssets',
  displayName: 'Equipment Assets',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'asset_type', type: 'text', description: 'truck, trailer, other' },
    { name: 'unit_number', type: 'text', description: 'Fleet unit number' },
    { name: 'vin', type: 'text', description: 'VIN' },
    { name: 'make', type: 'text', description: 'Manufacturer' },
    { name: 'model', type: 'text', description: 'Model' },
    { name: 'year', type: 'number', description: 'Year' },
    { name: 'status', type: 'text', description: 'active, maintenance, etc.' },
    { name: 'current_mileage', type: 'number', description: 'Odometer' },
    { name: 'current_driver_id', type: 'text', description: 'Assigned driver' }
  ],
  permissions: { read: 'SiteMember', create: 'SiteMember', update: 'SiteMember', delete: 'Admin' }
};

const EQUIPMENT_ASSIGNMENTS_SCHEMA = {
  collectionName: 'EquipmentAssignments',
  displayName: 'Equipment Assignments',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'equipment_id', type: 'text', description: 'Reference to EquipmentAssets' },
    { name: 'driver_id', type: 'text', description: 'Reference to FleetDrivers' },
    { name: 'assigned_date', type: 'date', description: 'Start date' },
    { name: 'unassigned_date', type: 'date', description: 'End date' },
    { name: 'assignment_type', type: 'text', description: 'primary, temporary, slip_seat' }
  ],
  permissions: { read: 'SiteMember', create: 'SiteMember', update: 'SiteMember', delete: 'Admin' }
};

const DRIVER_SCORES_SCHEMA = {
  collectionName: 'DriverScores',
  displayName: 'Driver Scores',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'driver_id', type: 'text', description: 'Reference to FleetDrivers' },
    { name: 'period_start', type: 'date', description: 'Period start' },
    { name: 'period_type', type: 'text', description: 'weekly, monthly, quarterly' },
    { name: 'overall_score', type: 'number', description: '0-100' },
    { name: 'safety_score', type: 'number', description: '0-100' },
    { name: 'efficiency_score', type: 'number', description: '0-100' },
    { name: 'service_score', type: 'number', description: '0-100' },
    { name: 'compliance_score', type: 'number', description: '0-100' }
  ],
  permissions: { read: 'SiteMember', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const CAPACITY_PLANS_SCHEMA = {
  collectionName: 'CapacityPlans',
  displayName: 'Capacity Plans',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'plan_date', type: 'date', description: 'Date' },
    { name: 'total_drivers', type: 'number', description: 'Fleet size' },
    { name: 'available_drivers', type: 'number', description: 'Available drivers' },
    { name: 'booked_loads', type: 'number', description: 'Booked loads' },
    { name: 'utilization_pct', type: 'number', description: 'Utilization' },
    { name: 'capacity_gap', type: 'number', description: 'Gap' }
  ],
  permissions: { read: 'SiteMember', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const ELD_CONNECTIONS_SCHEMA = {
  collectionName: 'ELDConnections',
  displayName: 'ELD Connections',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'provider', type: 'text', description: 'motive, samsara, etc.' },
    { name: 'api_key', type: 'text', description: 'Encrypted key' },
    { name: 'is_active', type: 'boolean', description: 'Enabled flag' },
    { name: 'last_sync', type: 'date', description: 'Last sync timestamp' }
  ],
  permissions: { read: 'SiteMember', create: 'SiteMember', update: 'SiteMember', delete: 'Admin' }
};

const DRIVER_LOCATIONS_SCHEMA = {
  collectionName: 'DriverLocations',
  displayName: 'Driver Locations',
  fields: [
    { name: 'carrier_dot', type: 'number', description: 'Carrier DOT number' },
    { name: 'driver_id', type: 'text', description: 'Reference to FleetDrivers' },
    { name: 'latitude', type: 'number', description: 'Lat' },
    { name: 'longitude', type: 'number', description: 'Lng' },
    { name: 'speed_mph', type: 'number', description: 'Speed' },
    { name: 'timestamp', type: 'date', description: 'Timestamp' },
    { name: 'hos_status', type: 'text', description: 'driving, resting, etc.' }
  ],
  permissions: { read: 'SiteMember', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

/**
 * Setup function for Carrier Fleet Dashboard collections
 */
export async function setupFleetDashboardCollections() {
  console.log('[SETUP] Setting up Carrier Fleet Dashboard Collections...');

  const schemas = [
    FLEET_DRIVERS_SCHEMA,
    EQUIPMENT_ASSETS_SCHEMA,
    EQUIPMENT_ASSIGNMENTS_SCHEMA,
    DRIVER_SCORES_SCHEMA,
    CAPACITY_PLANS_SCHEMA,
    ELD_CONNECTIONS_SCHEMA,
    DRIVER_LOCATIONS_SCHEMA
  ];

  const results = {
    existing: [],
    missing: []
  };

  for (const schema of schemas) {
    const { exists } = await checkCollectionExists(schema.collectionName);
    if (exists) {
      results.existing.push(schema.collectionName);
    } else {
      results.missing.push({
        name: schema.collectionName,
        instructions: generateCollectionInstructions(schema)
      });
    }
  }

  return results;
}

// ============================================================================
// RECRUITER ANALYTICS SETUP
// Reference: Conductor/tracks/recruiter_analytics_20260120/plan.md
// ============================================================================

const SOURCE_ATTRIBUTION_SCHEMA = {
  collectionName: 'SourceAttribution',
  displayName: 'Source Attribution',
  fields: [
    { name: 'driver_id', type: 'text', description: 'Reference to DriverProfiles (or null if anon)' },
    { name: 'session_id', type: 'text', description: 'Anonymous session ID' },
    { name: 'utm_source', type: 'text', description: 'UTM Source parameter' },
    { name: 'utm_medium', type: 'text', description: 'UTM Medium parameter' },
    { name: 'utm_campaign', type: 'text', description: 'UTM Campaign parameter' },
    { name: 'utm_content', type: 'text', description: 'UTM Content parameter' },
    { name: 'utm_term', type: 'text', description: 'UTM Term parameter' },
    { name: 'first_touch_source', type: 'text', description: 'Original acquisition source' },
    { name: 'first_touch_date', type: 'date', description: 'Date of first visit' },
    { name: 'last_touch_source', type: 'text', description: 'Most recent source' },
    { name: 'last_touch_date', type: 'date', description: 'Date of last visit' },
    { name: 'touchpoint_history', type: 'array', description: 'Array of all touchpoint objects' },
    { name: 'touchpoint_count', type: 'number', description: 'Total number of touchpoints' },
    { name: 'conversion_date', type: 'date', description: 'Date driver registered/converted' },
    { name: 'hire_date', type: 'date', description: 'Date driver was hired' },
    { name: 'carrier_dot', type: 'text', description: 'Carrier who hired (if applicable)' },
    { name: 'attribution_model', type: 'text', description: 'Preferred model (first_touch, last_touch)' }
  ],
  permissions: {
    read: 'Admin',
    create: 'SiteMember', // Needed for public tracking
    update: 'SiteMember',
    delete: 'Admin'
  }
};

/**
 * Creates the SourceAttribution collection if it doesn't exist
 */
export async function setupSourceAttribution() {
  console.log('[SETUP] Setting up SourceAttribution...');
  const schema = SOURCE_ATTRIBUTION_SCHEMA;

  const { exists, error } = await checkCollectionExists(schema.collectionName);

  if (exists) {
    console.log(`[SETUP] ${schema.collectionName} collection exists.`);
    return { success: true, message: 'Collection exists', collectionName: schema.collectionName };
  }

  return {
    success: false,
    error: `${schema.collectionName} collection missing. Create manually.`,
    collectionName: schema.collectionName,
    schema: schema,
    instructions: generateCollectionInstructions(schema),
    indexRecommendations: [
      'Create index on: driver_id',
      'Create index on: session_id',
      'Create index on: utm_source',
      'Create index on: conversion_date'
    ]
  };
}

// ============================================================================
// EXTERNAL API PLATFORM SETUP
// Reference: Conductor/tracks/external_api_platform_20260123/spec.md
// ============================================================================

const API_PARTNERS_SCHEMA = {
  collectionName: 'ApiPartners',
  displayName: 'API Partners',
  fields: [
    { name: 'partner_id', type: 'text', description: 'Unique partner identifier' },
    { name: 'company_name', type: 'text', description: 'Partner company name' },
    { name: 'contact_email', type: 'text', description: 'Primary contact email' },
    { name: 'contact_name', type: 'text', description: 'Primary contact name' },
    { name: 'tier', type: 'text', description: 'starter, growth, enterprise, custom' },
    { name: 'status', type: 'text', description: 'active, suspended, churned' },
    { name: 'api_keys', type: 'array', description: 'Array of key metadata objects' },
    { name: 'ip_whitelist', type: 'array', description: 'Optional allowed IP list' },
    { name: 'webhook_url', type: 'text', description: 'Default webhook URL' },
    { name: 'webhook_secret', type: 'text', description: 'Webhook signing secret' },
    { name: 'created_at', type: 'date', description: 'Created timestamp' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const API_SUBSCRIPTIONS_SCHEMA = {
  collectionName: 'ApiSubscriptions',
  displayName: 'API Subscriptions',
  fields: [
    { name: 'partner_id', type: 'text', description: 'Reference to ApiPartners.partner_id' },
    { name: 'tier', type: 'text', description: 'starter, growth, enterprise, custom' },
    { name: 'plan_type', type: 'text', description: 'monthly or annual' },
    { name: 'price_monthly', type: 'number', description: 'Monthly plan price' },
    { name: 'api_products', type: 'array', description: 'Enabled API product IDs' },
    { name: 'rate_limits', type: 'object', description: 'Tier and override limits' },
    { name: 'quotas', type: 'object', description: 'Feature-specific quotas' },
    { name: 'stripe_subscription_id', type: 'text', description: 'Billing subscription ID' },
    { name: 'current_period_start', type: 'date', description: 'Billing period start' },
    { name: 'current_period_end', type: 'date', description: 'Billing period end' },
    { name: 'status', type: 'text', description: 'active, past_due, cancelled' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const API_USAGE_SCHEMA = {
  collectionName: 'ApiUsage',
  displayName: 'API Usage',
  fields: [
    { name: 'partner_id', type: 'text', description: 'Reference to ApiPartners.partner_id' },
    { name: 'period_key', type: 'text', description: 'YYYY-MM usage key' },
    { name: 'period_start', type: 'date', description: 'Period start date' },
    { name: 'period_end', type: 'date', description: 'Period end date' },
    { name: 'usage', type: 'object', description: 'Request totals and endpoint metrics' },
    { name: 'quotas_used', type: 'object', description: 'Quota counters by product' },
    { name: 'billing_amount', type: 'number', description: 'Calculated overages' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const API_REQUEST_LOG_SCHEMA = {
  collectionName: 'ApiRequestLog',
  displayName: 'API Request Log',
  fields: [
    { name: 'request_id', type: 'text', description: 'Gateway request ID' },
    { name: 'partner_id', type: 'text', description: 'Reference to ApiPartners.partner_id' },
    { name: 'api_key_id', type: 'text', description: 'API key metadata ID' },
    { name: 'endpoint', type: 'text', description: 'Requested endpoint path' },
    { name: 'method', type: 'text', description: 'HTTP method' },
    { name: 'request_params', type: 'object', description: 'Sanitized request params' },
    { name: 'response_status', type: 'number', description: 'HTTP status code' },
    { name: 'response_time_ms', type: 'number', description: 'Latency in ms' },
    { name: 'cache_hit', type: 'boolean', description: 'Whether response used cache' },
    { name: 'error_message', type: 'text', description: 'Error message when status >= 400' },
    { name: 'ip_address', type: 'text', description: 'Source IP address' },
    { name: 'user_agent', type: 'text', description: 'Source user agent' },
    { name: 'created_at', type: 'date', description: 'Request timestamp' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const API_PRODUCTS_SCHEMA = {
  collectionName: 'ApiProducts',
  displayName: 'API Products',
  fields: [
    { name: 'product_id', type: 'text', description: 'Unique product identifier' },
    { name: 'name', type: 'text', description: 'Display name' },
    { name: 'description', type: 'text', description: 'Product description' },
    { name: 'category', type: 'text', description: 'safety, intelligence, operational, etc.' },
    { name: 'base_endpoint', type: 'text', description: 'Endpoint group prefix' },
    { name: 'endpoints', type: 'array', description: 'Endpoint definition objects' },
    { name: 'pricing', type: 'object', description: 'Tier and overage pricing metadata' },
    { name: 'is_active', type: 'boolean', description: 'Active flag' },
    { name: 'documentation_url', type: 'text', description: 'Docs URL' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const API_ALERT_SUBSCRIPTIONS_SCHEMA = {
  collectionName: 'ApiAlertSubscriptions',
  displayName: 'API Alert Subscriptions',
  fields: [
    { name: 'partner_id', type: 'text', description: 'Reference to ApiPartners.partner_id' },
    { name: 'dot_numbers', type: 'array', description: 'Monitored DOT numbers' },
    { name: 'alert_types', type: 'array', description: 'Subscribed alert types' },
    { name: 'webhook_url', type: 'text', description: 'Delivery webhook endpoint' },
    { name: 'webhook_secret', type: 'text', description: 'Per-subscription signing secret' },
    { name: 'is_active', type: 'boolean', description: 'Active status' },
    { name: 'created_at', type: 'date', description: 'Created timestamp' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const API_WEBHOOK_DELIVERIES_SCHEMA = {
  collectionName: 'ApiWebhookDeliveries',
  displayName: 'API Webhook Deliveries',
  fields: [
    { name: 'subscription_id', type: 'text', description: 'Reference to webhook subscription' },
    { name: 'partner_id', type: 'text', description: 'Reference to ApiPartners.partner_id' },
    { name: 'webhook_url', type: 'text', description: 'Destination webhook endpoint URL' },
    { name: 'webhook_secret', type: 'text', description: 'Signing secret used for HMAC signature' },
    { name: 'event_type', type: 'text', description: 'Webhook event type' },
    { name: 'payload', type: 'object', description: 'Payload snapshot' },
    { name: 'attempt', type: 'number', description: 'Attempt number (1-3)' },
    { name: 'status', type: 'text', description: 'queued, sent, failed' },
    { name: 'response_status', type: 'number', description: 'Partner endpoint status code' },
    { name: 'response_body', type: 'text', description: 'Truncated response text' },
    { name: 'next_retry_at', type: 'date', description: 'Next retry time' },
    { name: 'created_at', type: 'date', description: 'Created timestamp' },
    { name: 'updated_at', type: 'date', description: 'Updated timestamp' }
  ],
  permissions: { read: 'Admin', create: 'Admin', update: 'Admin', delete: 'Admin' }
};

const DEFAULT_API_PRODUCTS = [
  {
    product_id: 'safety_suite',
    name: 'Safety Suite',
    description: 'FMCSA/CSA safety and compliance endpoints',
    category: 'safety',
    base_endpoint: '/v1/safety',
    endpoints: [
      { path: '/v1/safety/carrier/{dot_number}', method: 'GET', description: 'Carrier safety lookup', rate_limit_override: 60 },
      { path: '/v1/safety/carriers/batch', method: 'POST', description: 'Batch safety lookup', rate_limit_override: 20 },
      { path: '/v1/safety/csa/{dot_number}', method: 'GET', description: 'Current CSA score', rate_limit_override: 60 },
      { path: '/v1/safety/csa/{dot_number}/history', method: 'GET', description: 'CSA history', rate_limit_override: 40 }
    ],
    pricing: {
      included_in_tiers: ['starter', 'growth', 'enterprise'],
      overage_price_per_call: 0.005
    },
    is_active: true,
    documentation_url: 'https://api.lmdr.com/docs/safety'
  },
  {
    product_id: 'intelligence_suite',
    name: 'Intelligence Suite',
    description: 'Carrier intelligence, market and sentiment endpoints',
    category: 'intelligence',
    base_endpoint: '/v1/intelligence',
    endpoints: [
      { path: '/v1/intelligence/carrier/{dot_number}', method: 'GET', description: 'Carrier intelligence', rate_limit_override: 40 },
      { path: '/v1/intelligence/sentiment/{dot_number}', method: 'GET', description: 'Social sentiment', rate_limit_override: 15 },
      { path: '/v1/intelligence/market', method: 'GET', description: 'Market intelligence', rate_limit_override: 30 },
      { path: '/v1/intelligence/carriers/search', method: 'POST', description: 'Carrier search', rate_limit_override: 20 }
    ],
    pricing: {
      included_in_tiers: ['growth', 'enterprise'],
      overage_price_per_call: 0.007
    },
    is_active: true,
    documentation_url: 'https://api.lmdr.com/docs/intelligence'
  },
  {
    product_id: 'operations_suite',
    name: 'Operations Suite',
    description: 'Parking and fuel endpoints',
    category: 'operational',
    base_endpoint: '/v1',
    endpoints: [
      { path: '/v1/parking/search', method: 'GET', description: 'Parking search', rate_limit_override: 60 },
      { path: '/v1/fuel/prices', method: 'GET', description: 'Fuel price search', rate_limit_override: 60 },
      { path: '/v1/fuel/plan', method: 'POST', description: 'Fuel planning', rate_limit_override: 25 }
    ],
    pricing: {
      included_in_tiers: ['growth', 'enterprise'],
      overage_price_per_call: 0.006
    },
    is_active: true,
    documentation_url: 'https://api.lmdr.com/docs/operations'
  },
  {
    product_id: 'matching_suite',
    name: 'Matching Suite',
    description: 'Driver and carrier matching endpoints',
    category: 'matching',
    base_endpoint: '/v1/matching',
    endpoints: [
      { path: '/v1/matching/drivers/search', method: 'POST', description: 'Driver search', rate_limit_override: 10 },
      { path: '/v1/matching/driver/{driver_id}', method: 'GET', description: 'Driver profile', rate_limit_override: 20 },
      { path: '/v1/matching/carriers', method: 'POST', description: 'Carrier match', rate_limit_override: 20 }
    ],
    pricing: {
      included_in_tiers: ['enterprise'],
      overage_price_per_call: 2.0
    },
    is_active: true,
    documentation_url: 'https://api.lmdr.com/docs/matching'
  },
  {
    product_id: 'document_suite',
    name: 'Document Suite',
    description: 'OCR extraction and verification endpoints',
    category: 'documents',
    base_endpoint: '/v1/documents',
    endpoints: [
      { path: '/v1/documents/cdl/extract', method: 'POST', description: 'CDL extraction', rate_limit_override: 15 },
      { path: '/v1/documents/medcert/extract', method: 'POST', description: 'Medical certificate extraction', rate_limit_override: 15 },
      { path: '/v1/documents/batch', method: 'POST', description: 'Batch extraction', rate_limit_override: 5 }
    ],
    pricing: {
      included_in_tiers: ['growth', 'enterprise'],
      overage_price_per_call: 0.5
    },
    is_active: true,
    documentation_url: 'https://api.lmdr.com/docs/documents'
  },
  {
    product_id: 'engagement_suite',
    name: 'Engagement Suite',
    description: 'Gamification white-label endpoints',
    category: 'engagement',
    base_endpoint: '/v1/engagement',
    endpoints: [
      { path: '/v1/engagement/user/{user_id}/progress', method: 'GET', description: 'User progress', rate_limit_override: 30 },
      { path: '/v1/engagement/xp/award', method: 'POST', description: 'Award XP', rate_limit_override: 30 },
      { path: '/v1/engagement/leaderboard', method: 'GET', description: 'Leaderboard', rate_limit_override: 30 }
    ],
    pricing: {
      included_in_tiers: ['enterprise'],
      overage_price_per_call: 0.01
    },
    is_active: true,
    documentation_url: 'https://api.lmdr.com/docs/engagement'
  }
];

export async function setupExternalApiPlatformCollections() {
  console.log('[SETUP] Setting up External API Platform collections...');

  const schemas = [
    API_PARTNERS_SCHEMA,
    API_SUBSCRIPTIONS_SCHEMA,
    API_USAGE_SCHEMA,
    API_REQUEST_LOG_SCHEMA,
    API_PRODUCTS_SCHEMA,
    API_ALERT_SUBSCRIPTIONS_SCHEMA,
    API_WEBHOOK_DELIVERIES_SCHEMA
  ];

  const results = {
    existing: [],
    missing: []
  };

  for (const schema of schemas) {
    const { exists } = await checkCollectionExists(schema.collectionName);
    if (exists) {
      results.existing.push(schema.collectionName);
    } else {
      const indexRecommendations = [];
      if (schema.collectionName === 'ApiPartners') {
        indexRecommendations.push('Create index on: partner_id (unique)');
        indexRecommendations.push('Create index on: status');
      }
      if (schema.collectionName === 'ApiSubscriptions') {
        indexRecommendations.push('Create index on: partner_id');
        indexRecommendations.push('Create index on: status');
      }
      if (schema.collectionName === 'ApiUsage') {
        indexRecommendations.push('Create compound index on: partner_id + period_key');
      }
      if (schema.collectionName === 'ApiRequestLog') {
        indexRecommendations.push('Create index on: partner_id');
        indexRecommendations.push('Create index on: created_at');
      }
      if (schema.collectionName === 'ApiWebhookDeliveries') {
        indexRecommendations.push('Create index on: partner_id');
        indexRecommendations.push('Create index on: subscription_id');
        indexRecommendations.push('Create index on: status');
        indexRecommendations.push('Create index on: next_retry_at');
      }
      results.missing.push({
        name: schema.collectionName,
        instructions: generateCollectionInstructions(schema),
        indexRecommendations
      });
    }
  }

  return results;
}

export async function seedExternalApiProducts(force = false) {
  console.log('[SETUP] Seeding default API products...');
  try {
    const existing = await wixData.query('ApiProducts')
      .limit(100)
      .find({ suppressAuth: true });

    if (!force && (existing.items || []).length > 0) {
      return {
        success: true,
        skipped: true,
        message: 'ApiProducts already seeded',
        existingCount: existing.items.length
      };
    }

    const results = [];
    for (const product of DEFAULT_API_PRODUCTS) {
      const match = (existing.items || []).find((item) => item.product_id === product.product_id);
      if (match?._id) {
        const updated = await wixData.update('ApiProducts', {
          ...match,
          ...product
        }, { suppressAuth: true });
        results.push({ action: 'updated', product_id: product.product_id, id: updated._id });
      } else {
        const inserted = await wixData.insert('ApiProducts', product, { suppressAuth: true });
        results.push({ action: 'inserted', product_id: product.product_id, id: inserted._id });
      }
    }

    return {
      success: true,
      skipped: false,
      seededCount: results.length,
      results
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }

  // ============================================================================
  // COST OPTIMIZER COLLECTIONS SETUP (Phase 1)
  // Reference: Conductor/tracks/admin_utility_expansion_20260120/plan.md
  // ============================================================================

  /**
   * Schema definition for AIProviderCosts collection
   * Tracks cost and quality metrics for each AI provider/model
   */
  const AI_PROVIDER_COSTS_SCHEMA = {
    collectionName: 'AIProviderCosts',
    displayName: 'AI Provider Costs',
    fields: [
      { name: 'providerId', type: 'text', description: 'Provider identifier (e.g., "anthropic")' },
      { name: 'modelId', type: 'text', description: 'Model identifier (e.g., "claude-3-5-sonnet")' },
      { name: 'costInput', type: 'number', description: 'Cost per 1k input tokens ($)' },
      { name: 'costOutput', type: 'number', description: 'Cost per 1k output tokens ($)' },
      { name: 'qualityScore', type: 'number', description: 'Quality score (0.0-1.0)' },
      { name: 'avgLatencyMs', type: 'number', description: 'Average latency in milliseconds' },
      { name: 'availabilityRate', type: 'number', description: 'Success rate (0.0-1.0)' },
      { name: 'isActive', type: 'boolean', description: 'Whether this model is available for routing' },
      { name: 'lastUpdated', type: 'date', description: 'Last metric update timestamp' }
    ],
    permissions: {
      read: 'Admin',
      create: 'Admin',
      update: 'Admin',
      delete: 'Admin'
    }
  };

  /**
   * Schema definition for CostOptimizerConfig collection
   * Singleton configuration for the cost optimizer engine
   */
  const COST_OPTIMIZER_CONFIG_SCHEMA = {
    collectionName: 'CostOptimizerConfig',
    displayName: 'Cost Optimizer Config',
    fields: [
      { name: 'configId', type: 'text', description: 'Singleton ID (always "global")' },
      { name: 'enabled', type: 'boolean', description: 'Master switch for cost optimization' },
      { name: 'qualityThreshold', type: 'number', description: 'Minimum quality score allowed (0.0-1.0)' },
      { name: 'maxCostPerRequest', type: 'number', description: 'Maximum allowed cost estimate per request ($)' },
      { name: 'preferredProviders', type: 'array', description: 'List of providerIds to prioritize' },
      { name: 'excludedProviders', type: 'array', description: 'List of providerIds to block' },
      { name: 'updatedAt', type: 'date', description: 'Last configuration update' },
      { name: 'updatedBy', type: 'text', description: 'User who updated the config' }
    ],
    permissions: {
      read: 'Admin',
      create: 'Admin',
      update: 'Admin',
      delete: 'Admin'
    }
  };

  /**
   * Creates the AIProviderCosts collection
   */
  export async function setupAIProviderCosts() {
    console.log('[SETUP] Setting up AIProviderCosts...');
    const schema = AI_PROVIDER_COSTS_SCHEMA;
    const { exists } = await checkCollectionExists(schema.collectionName);

    if (exists) {
      console.log(`[SETUP] ${schema.collectionName} collection exists.`);
      return { success: true, message: 'Collection exists' };
    }

    return {
      success: false,
      error: `${schema.collectionName} collection missing. Create manually.`,
      instructions: generateCollectionInstructions(schema),
      indexRecommendations: ['Create compound index on: providerId + modelId (unique)']
    };
  }

  /**
   * Creates the CostOptimizerConfig collection
   */
  export async function setupCostOptimizerConfig() {
    console.log('[SETUP] Setting up CostOptimizerConfig...');
    const schema = COST_OPTIMIZER_CONFIG_SCHEMA;
    const { exists } = await checkCollectionExists(schema.collectionName);

    if (exists) {
      console.log(`[SETUP] ${schema.collectionName} collection exists.`);
      return { success: true, message: 'Collection exists' };
    }

    return {
      success: false,
      error: `${schema.collectionName} collection missing. Create manually.`,
      instructions: generateCollectionInstructions(schema),
      indexRecommendations: ['Create unique index on: configId']
    };
  }

  /**
   * Seeds initial data for AI Provider Costs
   */
  export async function seedAIProviderCosts() {
    console.log('[SETUP] Seeding AIProviderCosts...');

    const initialCosts = [
      // Anthropic
      { providerId: 'anthropic', modelId: 'claude-3-5-sonnet-20241022', costInput: 0.003, costOutput: 0.015, qualityScore: 0.95, isActive: true },
      { providerId: 'anthropic', modelId: 'claude-3-opus-20240229', costInput: 0.015, costOutput: 0.075, qualityScore: 0.98, isActive: true },
      { providerId: 'anthropic', modelId: 'claude-3-haiku-20240307', costInput: 0.00025, costOutput: 0.00125, qualityScore: 0.85, isActive: true },

      // OpenAI
      { providerId: 'openai', modelId: 'gpt-4o', costInput: 0.005, costOutput: 0.015, qualityScore: 0.94, isActive: true },
      { providerId: 'openai', modelId: 'gpt-4o-mini', costInput: 0.00015, costOutput: 0.0006, qualityScore: 0.82, isActive: true },

      // Gemini
      { providerId: 'google', modelId: 'gemini-1.5-pro', costInput: 0.0035, costOutput: 0.0105, qualityScore: 0.93, isActive: true },
      { providerId: 'google', modelId: 'gemini-1.5-flash', costInput: 0.00035, costOutput: 0.00105, qualityScore: 0.88, isActive: true },

      // Groq
      { providerId: 'groq', modelId: 'llama-3.1-70b-versatile', costInput: 0.00059, costOutput: 0.00079, qualityScore: 0.89, isActive: true },
      { providerId: 'groq', modelId: 'llama-3.1-8b-instant', costInput: 0.00005, costOutput: 0.00008, qualityScore: 0.75, isActive: true },

      // Perplexity
      { providerId: 'perplexity', modelId: 'sonar-pro', costInput: 0.003, costOutput: 0.015, qualityScore: 0.92, isActive: true },

      // Mistral
      { providerId: 'mistral', modelId: 'mistral-large-latest', costInput: 0.004, costOutput: 0.012, qualityScore: 0.91, isActive: true }
    ];

    const results = { inserted: 0, updated: 0, errors: [] };

    for (const item of initialCosts) {
      try {
        const existing = await wixData.query('AIProviderCosts')
          .eq('providerId', item.providerId)
          .eq('modelId', item.modelId)
          .limit(1)
          .find({ suppressAuth: true });

        if (existing.items.length > 0) {
          // Optional: Update if needed, or skip
          // For now, we skip if exists to preserve manual updates
          console.log(`[SETUP] Skipping existing cost for ${item.modelId}`);
        } else {
          await wixData.insert('AIProviderCosts', { ...item, lastUpdated: new Date() }, { suppressAuth: true });
          results.inserted++;
        }
      } catch (err) {
        if (err.message.includes('not exist')) {
          console.warn(`[SETUP] Collection AIProviderCosts missing.`);
          return { success: false, error: 'Collection missing' };
        }
        results.errors.push(err.message);
      }
    }

    return { success: true, ...results };
  }

  /**
   * Seeds default Cost Optimizer Config
   */
  export async function seedCostOptimizerConfig() {
    console.log('[SETUP] Seeding CostOptimizerConfig...');

    try {
      const existing = await wixData.query('CostOptimizerConfig')
        .eq('configId', 'global')
        .limit(1)
        .find({ suppressAuth: true });

      if (existing.items.length > 0) {
        return { success: true, message: 'Config already exists' };
      }

      const defaultConfig = {
        configId: 'global',
        enabled: false, // Default to disabled
        qualityThreshold: 0.80,
        maxCostPerRequest: 0.10,
        preferredProviders: [],
        excludedProviders: [],
        updatedAt: new Date(),
        updatedBy: 'system_setup'
      };

      await wixData.insert('CostOptimizerConfig', defaultConfig, { suppressAuth: true });
      return { success: true, message: 'Default config created' };

    } catch (err) {
      if (err.message.includes('not exist')) {
        return { success: false, error: 'Collection missing' };
      }
      return { success: false, error: err.message };
    }
  }

/**
 * Weather Alert Service - Route-specific weather and chain laws
 * Phase 5 of Driver Road Utilities
 */

import wixData from 'wix-data';
import { fetch } from 'wix-fetch';
import { usesAirtable, getAirtableTableName } from 'backend/config';
import * as airtable from 'backend/airtableClient';
import { getSecret } from 'wix-secrets-backend';
import { sendWeatherAlertEmail } from 'backend/emailService';

// ============================================
// COLLECTIONS
// ============================================
const COLLECTIONS = {
    ALERTS: 'WeatherAlerts',
    SUBSCRIPTIONS: 'DriverWeatherSubscriptions',
    CACHE: 'RoadUtilityCache'
};

const COLLECTION_KEYS = {
    weatherAlerts: 'weatherAlerts',
    driverWeatherSubscriptions: 'driverWeatherSubscriptions',
    roadUtilityCache: 'roadUtilityCache'
};

// ============================================
// EXTERNAL API CONFIG (NWS)
// ============================================
const NWS_API = {
    BASE_URL: 'https://api.weather.gov',
    USER_AGENT: '(lmdr.site, contact@lmdr.site)', // Required by NWS
    TIMEOUT: 10000
};

// Simple circuit breaker
const circuitBreaker = {
    nws: { failures: 0, lastFailure: 0, status: 'CLOSED' }
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================
// (Simplified for brevity, assuming standard pattern)

async function queryData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            maxRecords: options.limit || 100
        });
        return result.records || [];
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) query = query.eq(field, value);
    }
    return (await query.find({ suppressAuth: true })).items;
}

// ============================================
// CHAIN LAW DATA (STATIC/MOCK)
// ============================================
// Real-time chain data usually requires scraping 50 state DOT sites.
// We'll use static definitions for major passes and simulating status for MVP.
const CHAIN_LAW_ZONES = [
    { id: 'donner_pass', name: 'Donner Pass (I-80)', state: 'CA', elevation: 7057, location: { lat: 39.31, lng: -120.33 } },
    { id: 'snoqualmie_pass', name: 'Snoqualmie Pass (I-90)', state: 'WA', elevation: 3022, location: { lat: 47.42, lng: -121.41 } },
    { id: 'vail_pass', name: 'Vail Pass (I-70)', state: 'CO', elevation: 10662, location: { lat: 39.52, lng: -106.21 } },
    { id: 'cabbage_hill', name: 'Cabbage Hill (I-84)', state: 'OR', elevation: 3648, location: { lat: 45.59, lng: -118.42 } },
    { id: 'siskiyou_summit', name: 'Siskiyou Summit (I-5)', state: 'OR', elevation: 4310, location: { lat: 42.06, lng: -122.60 } }
];

// ============================================
// SERVICE FUNCTIONS
// ============================================

/**
 * Get active weather alerts for a location
 * @param {number} lat 
 * @param {number} lng 
 */
export async function getAlertsAtLocation(lat, lng) {
    if (!lat || !lng) return { success: false, error: 'Location required' };

    try {
        // NWS API: Get active alerts by point
        const url = `${NWS_API.BASE_URL}/alerts/active?point=${lat},${lng}`;
        
        if (circuitBreaker.nws.status === 'OPEN') {
            if (Date.now() - circuitBreaker.nws.lastFailure > 60000) circuitBreaker.nws.status = 'HALF_OPEN';
            else return { success: false, error: 'Weather service unavailable' };
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'User-Agent': NWS_API.USER_AGENT, 'Accept': 'application/geo+json' },
            timeout: NWS_API.TIMEOUT
        });

        if (!response.ok) throw new Error(`NWS API error: ${response.status}`);

        const data = await response.json();
        circuitBreaker.nws.failures = 0;
        circuitBreaker.nws.status = 'CLOSED';

        const alerts = (data.features || []).map(normalizeAlert);
        return { success: true, alerts };

    } catch (error) {
        circuitBreaker.nws.failures++;
        if (circuitBreaker.nws.failures >= 3) circuitBreaker.nws.status = 'OPEN';
        circuitBreaker.nws.lastFailure = Date.now();
        console.error('[WeatherService] getAlertsAtLocation failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get forecast and alerts along a route
 * @param {Array} routePoints - Waypoints {lat, lng}
 */
export async function getRouteWeather(routePoints) {
    // For MVP, checking every point against NWS API is too heavy/slow.
    // Instead, we pick key points (start, mid, end, or every 100 miles).
    
    if (!routePoints || routePoints.length === 0) return { success: false, error: 'No route points' };

    const samplePoints = sampleRoute(routePoints, 50); // Sample every 50 miles approx
    
    try {
        // In a real production app, we'd use a bounding box query or polygon intersection.
        // For NWS, query each point is limited.
        // Optimization: Use NWS "zone" API or active alert map (heavy geometry).
        
        // Simpler MVP: Check Start, Middle, End
        const pointsToCheck = [
            routePoints[0],
            routePoints[Math.floor(routePoints.length / 2)],
            routePoints[routePoints.length - 1]
        ];

        const promises = pointsToCheck.map(p => getAlertsAtLocation(p.lat, p.lng));
        const results = await Promise.all(promises);

        // Deduplicate alerts by ID
        const allAlerts = new Map();
        results.forEach(res => {
            if (res.success && res.alerts) {
                res.alerts.forEach(a => allAlerts.set(a.id, a));
            }
        });

        // Also check chain laws (if any point is near a known pass)
        const chainLaws = await checkChainLawsForRoute(routePoints);

        return {
            success: true,
            alerts: Array.from(allAlerts.values()),
            chainLaws: chainLaws
        };

    } catch (error) {
        return { success: false, error: error.message };
    }
}

/**
 * Get Chain Law status for major passes
 */
export async function getChainRequirements() {
    // In future: Scrape DOT sites.
    // MVP: Randomly simulate status for demo purposes if no real data source
    // OR just return "No active restrictions" as default.
    
    return {
        success: true,
        items: CHAIN_LAW_ZONES.map(zone => ({
            ...zone,
            status: 'Clear', // Default
            restriction: null,
            last_updated: new Date()
        }))
    };
}

/**
 * Check if route passes near any chain law zones
 */
async function checkChainLawsForRoute(routePoints) {
    const relevantZones = [];
    
    for (const zone of CHAIN_LAW_ZONES) {
        // Simple distance check against all route points
        // Optimization: Check bounding box first
        const isNear = routePoints.some(p => calculateDistance(p.lat, p.lng, zone.location.lat, zone.location.lng) < 20); // within 20 miles
        
        if (isNear) {
            relevantZones.push({
                ...zone,
                status: 'Clear', // Default
                restriction: null
            });
        }
    }
    return relevantZones;
}

/**
 * Subscribe driver to alerts
 */
export async function subscribeToAlerts(driverId, preferences) {
    const record = {
        driver_id: driverId,
        min_severity: preferences.min_severity || 'Severe',
        push_enabled: preferences.push_enabled || false,
        updated_at: new Date()
    };
    
    // Save to DB (omitted for brevity, assume simple insert/update)
    return { success: true };
}

// ============================================
// SCHEDULED JOBS
// ============================================

/**
 * Scheduled job to fetch new alerts and notify drivers
 */
export async function processNewAlerts() {
    console.log('[WeatherJob] Starting alert check...');
    
    // 1. Get all subscribed drivers (mock query)
    // In real app: wixData.query(COLLECTIONS.SUBSCRIPTIONS).find()
    const subscribedDrivers = [
        { driverId: 'mock-driver-1', location: { lat: 39.31, lng: -120.33 } } // Donner Pass
    ];

    let sentCount = 0;

    for (const driver of subscribedDrivers) {
        // 2. Check alerts for this driver's location
        const result = await getAlertsAtLocation(driver.location.lat, driver.location.lng);
        
        if (result.success && result.alerts && result.alerts.length > 0) {
            // 3. Filter for severe only
            const severeAlerts = result.alerts.filter(a => a.severity === 'Severe' || a.severity === 'Extreme');
            
            for (const alert of severeAlerts) {
                // 4. Send Notification
                // Check deduplication log first (omitted)
                await sendAlert(driver.driverId, alert);
                sentCount++;
            }
        }
    }
    
    console.log(`[WeatherJob] Completed. Sent ${sentCount} alerts.`);
    return { success: true, sent: sentCount };
}

async function sendAlert(driverId, alert) {
    return sendWeatherAlertEmail(driverId, {
        headline: alert.headline,
        severity: alert.severity,
        event: alert.event,
        location: alert.areaDesc,
        description: alert.description
    });
}


// Validates NWS alert object
function normalizeAlert(feature) {
    const p = feature.properties;
    return {
        id: p.id,
        event: p.event,
        severity: p.severity,
        certainty: p.certainty,
        urgency: p.urgency,
        headline: p.headline,
        description: p.description,
        instruction: p.instruction,
        areaDesc: p.areaDesc,
        sent: p.sent,
        effective: p.effective,
        expires: p.expires,
        sender: p.senderName
    };
}

// Helper: Haversine distance
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 3958.8; // miles
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
              Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Helper: Sample route points
function sampleRoute(points, mileInterval) {
    if (points.length < 2) return points;
    const result = [points[0]];
    let accumulatedDist = 0;
    
    for (let i = 0; i < points.length - 1; i++) {
        const d = calculateDistance(points[i].lat, points[i].lng, points[i+1].lat, points[i+1].lng);
        accumulatedDist += d;
        if (accumulatedDist >= mileInterval) {
            result.push(points[i+1]);
            accumulatedDist = 0;
        }
    }
    result.push(points[points.length - 1]);
    return result;
}

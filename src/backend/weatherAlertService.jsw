import { fetch } from 'wix-fetch';
import * as dataAccess from 'backend/dataAccess';
import { sendWeatherAlertEmail } from 'backend/emailService';
import { seedDriverSubscriptions } from 'backend/seeds/seedMockData';

const COLLECTION_KEYS = {
  weatherAlerts: 'weatherAlerts',
  driverWeatherSubscriptions: 'driverNotificationPreferences',
  memberNotifications: 'memberNotifications',
  roadUtilityCache: 'roadUtilityCache'
};

const NWS_API = {
  BASE_URL: 'https://api.weather.gov',
  USER_AGENT: '(lmdr.site, contact@lmdr.site)',
  TIMEOUT: 10000
};

const circuitBreaker = {
  nws: { failures: 0, lastFailure: 0, status: 'CLOSED' }
};

const CHAIN_LAW_ZONES = [
  { id: 'donner_pass', name: 'Donner Pass (I-80)', state: 'CA', elevation: 7057, location: { lat: 39.31, lng: -120.33 } },
  { id: 'snoqualmie_pass', name: 'Snoqualmie Pass (I-90)', state: 'WA', elevation: 3022, location: { lat: 47.42, lng: -121.41 } },
  { id: 'vail_pass', name: 'Vail Pass (I-70)', state: 'CO', elevation: 10662, location: { lat: 39.52, lng: -106.21 } },
  { id: 'cabbage_hill', name: 'Cabbage Hill (I-84)', state: 'OR', elevation: 3648, location: { lat: 45.59, lng: -118.42 } },
  { id: 'siskiyou_summit', name: 'Siskiyou Summit (I-5)', state: 'OR', elevation: 4310, location: { lat: 42.06, lng: -122.60 } }
];

export async function getAlertsAtLocation(lat, lng) {
  if (lat == null || lng == null) return { success: false, error: 'Location required' };
  try {
    const url = `${NWS_API.BASE_URL}/alerts/active?point=${lat},${lng}`;
    if (circuitBreaker.nws.status === 'OPEN') {
      if (Date.now() - circuitBreaker.nws.lastFailure > 60000) circuitBreaker.nws.status = 'HALF_OPEN';
      else return { success: false, error: 'Weather service unavailable' };
    }

    const response = await fetch(url, {
      method: 'GET',
      headers: { 'User-Agent': NWS_API.USER_AGENT, 'Accept': 'application/geo+json' },
      timeout: NWS_API.TIMEOUT
    });
    if (!response.ok) throw new Error(`NWS API error: ${response.status}`);

    const data = await response.json();
    circuitBreaker.nws.failures = 0;
    circuitBreaker.nws.status = 'CLOSED';

    return { success: true, alerts: (data.features || []).map(normalizeAlert) };
  } catch (error) {
    circuitBreaker.nws.failures++;
    if (circuitBreaker.nws.failures >= 3) circuitBreaker.nws.status = 'OPEN';
    circuitBreaker.nws.lastFailure = Date.now();
    return { success: false, error: error.message };
  }
}

export async function getRouteWeather(routePoints) {
  if (!routePoints || routePoints.length === 0) return { success: false, error: 'No points' };
  try {
    const pointsToCheck = [routePoints[0], routePoints[Math.floor(routePoints.length / 2)], routePoints[routePoints.length - 1]];
    const results = await Promise.all(pointsToCheck.map((p) => getAlertsAtLocation(p.lat, p.lng)));

    const allAlerts = new Map();
    results.forEach((res) => {
      if (res.success && res.alerts) res.alerts.forEach((a) => allAlerts.set(a.id, a));
    });

    const chainLaws = await checkChainLawsForRoute(routePoints);
    return { success: true, alerts: Array.from(allAlerts.values()), chainLaws };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getChainRequirements() {
  return { success: true, items: CHAIN_LAW_ZONES.map((z) => ({ ...z, status: 'Clear', last_updated: new Date() })) };
}

async function checkChainLawsForRoute(routePoints) {
  return CHAIN_LAW_ZONES.filter((z) => routePoints.some((p) => calculateDistance(p.lat, p.lng, z.location.lat, z.location.lng) < 20));
}

export async function subscribeToAlerts(driverId, preferences) {
  if (!driverId) return { success: false, error: 'Driver ID required' };
  try {
    const normalized = normalizePreferences(preferences);
    const existing = await dataAccess.queryRecords(COLLECTION_KEYS.driverWeatherSubscriptions, {
      filters: { driver_id: driverId },
      limit: 1,
      suppressAuth: true
    });

    if (existing.success && existing.items?.length) {
      const row = existing.items[0];
      const updated = {
        ...row,
        alert_types: normalized.alert_types,
        min_severity: normalized.min_severity,
        push_enabled: normalized.push_enabled,
        email_enabled: normalized.email_enabled,
        location: normalized.location || row.location || null,
        updated_at: new Date()
      };
      const res = await dataAccess.updateRecord(COLLECTION_KEYS.driverWeatherSubscriptions, updated, { suppressAuth: true });
      return { success: Boolean(res.success), preferences: updated, error: res.error };
    }

    const record = {
      driver_id: driverId,
      alert_types: normalized.alert_types,
      min_severity: normalized.min_severity,
      push_enabled: normalized.push_enabled,
      email_enabled: normalized.email_enabled,
      location: normalized.location || null,
      created_at: new Date(),
      updated_at: new Date()
    };
    const inserted = await dataAccess.insertRecord(COLLECTION_KEYS.driverWeatherSubscriptions, record, { suppressAuth: true });
    return { success: Boolean(inserted.success), preferences: inserted.record || record, error: inserted.error };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function processNewAlerts() {
  try {
    let subscribedDrivers = [];

    try {
      const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverWeatherSubscriptions, { suppressAuth: true });
      subscribedDrivers = res.items || [];
    } catch (e) {
      subscribedDrivers = [];
    }

    if (subscribedDrivers.length === 0) {
      try {
        await seedDriverSubscriptions();
        const reRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverWeatherSubscriptions, { suppressAuth: true });
        subscribedDrivers = reRes.items || [];
      } catch (e) {
        subscribedDrivers = [];
      }
    }

    if (subscribedDrivers.length === 0) {
      subscribedDrivers = [{ driver_id: 'test-driver', location: { lat: 39.31, lng: -120.33 } }];
    }

    let sentCount = 0;
    let notificationCount = 0;
    for (const driver of subscribedDrivers) {
      if (!driver.location) continue;
      const alertRes = await getAlertsAtLocation(driver.location.lat, driver.location.lng);
      if (!alertRes.success || !alertRes.alerts?.length) continue;

      const severe = alertRes.alerts.filter((a) => isAlertRelevantForDriver(a, driver));

      for (const alert of severe) {
        const driverId = driver.driver_id || driver._id || 'driver';
        const alreadySent = await wasAlertRecentlySent(driverId, alert.id);
        if (alreadySent) continue;

        await sendAlert(driverId, alert);
        await createWeatherMemberNotification(driverId, alert);
        await rememberAlertSent(driverId, alert.id);
        sentCount++;
        notificationCount++;
      }
    }

    return { success: true, sent: sentCount, notifications: notificationCount };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function sendAlert(driverId, alert) {
  return sendWeatherAlertEmail(driverId, {
    headline: alert.headline,
    severity: alert.severity,
    event: alert.event,
    location: alert.areaDesc,
    description: alert.description
  });
}

function normalizeAlert(feature) {
  const p = feature.properties || {};
  return {
    id: p.id,
    event: p.event,
    severity: p.severity,
    certainty: p.certainty,
    urgency: p.urgency,
    headline: p.headline,
    description: p.description,
    instruction: p.instruction,
    areaDesc: p.areaDesc,
    sent: p.sent,
    effective: p.effective,
    expires: p.expires,
    sender: p.senderName
  };
}

function calculateDistance(lat1, lng1, lat2, lng2) {
  if (!lat1 || !lng1 || !lat2 || !lng2) return 0;
  const R = 3958.8;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function normalizePreferences(preferences = {}) {
  const alertTypes = Array.isArray(preferences.alert_types) && preferences.alert_types.length
    ? preferences.alert_types
    : ['severe_weather', 'wind', 'winter', 'flood'];
  const minSeverity = String(preferences.min_severity || 'moderate').toLowerCase();
  return {
    alert_types: alertTypes,
    min_severity: ['minor', 'moderate', 'severe', 'extreme'].includes(minSeverity) ? minSeverity : 'moderate',
    push_enabled: preferences.push_enabled !== false,
    email_enabled: preferences.email_enabled !== false,
    location: preferences.location || null
  };
}

function severityRank(value) {
  const sev = String(value || '').toLowerCase();
  if (sev === 'extreme') return 4;
  if (sev === 'severe') return 3;
  if (sev === 'moderate') return 2;
  if (sev === 'minor') return 1;
  return 0;
}

function normalizeEventType(eventName) {
  const event = String(eventName || '').toLowerCase();
  if (event.includes('winter') || event.includes('ice') || event.includes('snow')) return 'winter';
  if (event.includes('flood')) return 'flood';
  if (event.includes('wind') || event.includes('tornado')) return 'wind';
  return 'severe_weather';
}

function isAlertRelevantForDriver(alert, driver) {
  const prefs = normalizePreferences(driver);
  const alertType = normalizeEventType(alert.event);
  if (!prefs.alert_types.includes(alertType) && !prefs.alert_types.includes('severe_weather')) {
    return false;
  }
  const alertSeverity = severityRank(alert.severity);
  return alertSeverity >= severityRank(prefs.min_severity);
}

async function createWeatherMemberNotification(driverId, alert) {
  const notification = {
    member_id: driverId,
    type: 'weather_alert',
    title: `Weather Alert: ${alert.event || 'Severe Weather'}`,
    message: alert.headline || alert.description || 'Weather alert issued for your area.',
    is_read: false,
    action_url: 'https://www.lastmiledr.app/driver/road-utilities',
    created_date: new Date()
  };
  const res = await dataAccess.insertRecord(COLLECTION_KEYS.memberNotifications, notification, { suppressAuth: true });
  return Boolean(res.success);
}

async function wasAlertRecentlySent(driverId, alertId) {
  if (!driverId || !alertId) return false;
  const cacheKey = `weather_alert_sent:${driverId}:${alertId}`;
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.roadUtilityCache, {
    filters: { cache_key: cacheKey },
    limit: 1,
    suppressAuth: true
  });
  return Boolean(result.success && result.items?.length);
}

async function rememberAlertSent(driverId, alertId) {
  const cacheKey = `weather_alert_sent:${driverId}:${alertId}`;
  await dataAccess.insertRecord(COLLECTION_KEYS.roadUtilityCache, {
    cache_key: cacheKey,
    payload: JSON.stringify({ driverId, alertId }),
    expires_at: new Date(Date.now() + 6 * 60 * 60 * 1000),
    created_at: new Date()
  }, { suppressAuth: true });
}

import { findMatchingDrivers, getDriverProfile } from 'backend/driverMatching';
import { findMatchingCarriers } from 'backend/carrierMatching';
import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  usage: 'apiUsage'
};

export async function searchExternalDrivers(body = {}, authContext = {}) {
  const carrierDot = String(body?.carrier_dot || '').trim();
  if (!carrierDot) {
    return {
      success: false,
      errorCode: 'invalid_request',
      message: 'carrier_dot is required'
    };
  }

  const filters = body?.filters || {};
  const mappedFilters = {
    cdl_types: normalizeArray(filters.cdl_class),
    endorsements: normalizeArray(filters.endorsements_required),
    min_experience: toNumber(filters.min_experience_years, 0),
    availability: Array.isArray(filters.availability) ? filters.availability[0] : filters.availability
  };

  const options = {
    limit: Math.min(100, Math.max(1, toNumber(body?.limit, 25))),
    page: 0,
    pageSize: Math.min(100, Math.max(1, toNumber(body?.limit, 25))),
    includeMutualMatches: true
  };

  const result = await findMatchingDrivers(carrierDot, mappedFilters, options);
  if (!result?.success) {
    return {
      success: false,
      errorCode: 'internal_error',
      message: result?.error || 'Driver search failed'
    };
  }

  const filteredMatches = applyExternalDriverFilters(result.matches || [], filters);

  return {
    success: true,
    usageMetric: 'driver_searches',
    data: {
      total_matches: toNumber(result?.pagination?.totalCount, filteredMatches.length || 0),
      results: filteredMatches.map((match) => ({
        driver_id: match?.driver?._id || match?.driver?.id || null,
        match_score: toNumber(match.score, 0),
        score_breakdown: match.driver_match_scores || {},
        profile: {
          cdl_class: match?.driver?.cdl_class || null,
          endorsements: normalizeArray(match?.driver?.endorsements),
          years_experience: toNumber(match?.driver?.years_experience, null),
          location: {
            city: match?.driver?.city || null,
            state: match?.driver?.state || null
          },
          distance_miles: toNumber(match?.driver?.distance_miles, null),
          availability: match?.driver?.availability || null
        },
        contact_available: String(authContext?.tier || '').toLowerCase() === 'enterprise'
      })),
      search_id: `srch_${Date.now()}`,
      credits_used: 1
    }
  };
}

export async function getExternalDriverProfile(driverId, query = {}, authContext = {}) {
  if (!driverId) {
    return { success: false, errorCode: 'invalid_request', message: 'driver id is required' };
  }

  const carrierDot = String(query?.carrier_dot || '').trim();
  if (!carrierDot) {
    return { success: false, errorCode: 'invalid_request', message: 'carrier_dot is required' };
  }

  const result = await getDriverProfile(carrierDot, driverId, {});
  if (!result?.success) {
    return { success: false, errorCode: 'resource_not_found', message: result?.error || 'Driver not found' };
  }

  const profile = sanitizeDriverProfile(result.driver || {});
  const canUnmask = String(authContext?.tier || '').toLowerCase() === 'enterprise' &&
    String(query?.unmask_pii || '').toLowerCase() === 'true';
  if (canUnmask) {
    const creditCheck = await consumeProfileViewCredit(authContext?.partner?.partner_id || null);
    if (!creditCheck.success) {
      return {
        success: false,
        errorCode: 'quota_exceeded',
        message: creditCheck.message || 'Profile view quota exceeded'
      };
    }
  }

  const profileResponse = canUnmask ? profile : maskDriverContact(profile);

  return {
    success: true,
    data: {
      driver_id: driverId,
      profile: profileResponse,
      pii_masked: !canUnmask
    }
  };
}

export async function matchExternalCarriers(body = {}) {
  const profile = body?.driver_profile || {};
  const input = {
    operationType: normalizeFirst(profile?.preferences?.operation_type) || 'Any',
    minCPM: toNumber(profile?.preferences?.min_cpm, 0),
    endorsements: normalizeArray(profile.endorsements),
    experienceYears: toNumber(profile.years_experience, 0)
  };

  const result = await findMatchingCarriers(input, true);
  if (!result?.success) {
    return { success: false, errorCode: 'internal_error', message: result?.error || 'Carrier matching failed' };
  }

  const limit = Math.min(50, Math.max(1, toNumber(body.limit, 10)));
  const includeEnrichment = Boolean(body.include_enrichment);

  return {
    success: true,
    data: {
      total_matches: result.totalMatches || 0,
      results: (result.matches || []).slice(0, limit).map((entry) => ({
        carrier: {
          dot_number: toNumber(entry?.carrier?.DOT_NUMBER, null),
          name: entry?.carrier?.LEGAL_NAME || entry?.carrier?.legal_name || null,
          location: [entry?.carrier?.PHY_CITY, entry?.carrier?.PHY_STATE].filter(Boolean).join(', ')
        },
        match_score: toNumber(entry.overallScore || entry.score, 0),
        score_breakdown: entry.scores || {},
        enrichment: includeEnrichment ? mapEnrichment(entry.enrichment) : undefined,
        safety_summary: {
          rating: entry?.carrier?.safety_rating || null,
          alerts: 0
        }
      }))
    }
  };
}

export async function checkExternalQualification(body = {}) {
  const driver = body?.driver || {};
  const carrier = body?.carrier_requirements || {};
  const missing = [];

  const requiredClass = String(carrier.cdl_class || '').trim();
  if (requiredClass && String(driver.cdl_class || '').trim() !== requiredClass) {
    missing.push(`cdl_class:${requiredClass}`);
  }

  const requiredEndorsements = normalizeArray(carrier.endorsements_required);
  const driverEndorsements = new Set(normalizeArray(driver.endorsements));
  requiredEndorsements.forEach((endorsement) => {
    if (!driverEndorsements.has(endorsement)) {
      missing.push(`endorsement:${endorsement}`);
    }
  });

  const minExp = toNumber(carrier.min_experience_years, 0);
  const driverExp = toNumber(driver.years_experience, 0);
  if (driverExp < minExp) {
    missing.push(`experience:${minExp}`);
  }

  return {
    success: true,
    data: {
      qualified: missing.length === 0,
      missing_qualifications: missing
    }
  };
}

function mapEnrichment(value) {
  if (!value) return null;
  return {
    cpm_range: value?.pay_cpm_range || null,
    sentiment: value?.driver_sentiment || null,
    hiring_status: value?.hiring_status || null
  };
}

function normalizeArray(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value.map((item) => String(item).trim()).filter(Boolean);
  return [String(value).trim()].filter(Boolean);
}

function normalizeFirst(value) {
  if (Array.isArray(value)) return value[0] || null;
  return value || null;
}

function toNumber(value, fallback = null) {
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function applyExternalDriverFilters(matches, filters = {}) {
  let items = Array.isArray(matches) ? [...matches] : [];

  const requiredClasses = normalizeArray(filters.cdl_class);
  if (requiredClasses.length) {
    const classSet = new Set(requiredClasses.map((value) => String(value).toUpperCase()));
    items = items.filter((match) => classSet.has(String(match?.driver?.cdl_class || '').toUpperCase()));
  }

  const requiredEndorsements = normalizeArray(filters.endorsements_required);
  if (requiredEndorsements.length) {
    items = items.filter((match) => {
      const driverEndorsements = new Set(normalizeArray(match?.driver?.endorsements).map((value) => String(value).toUpperCase()));
      return requiredEndorsements.every((code) => driverEndorsements.has(String(code).toUpperCase()));
    });
  }

  const minExperience = toNumber(filters.min_experience_years, null);
  if (minExperience !== null) {
    items = items.filter((match) => toNumber(match?.driver?.years_experience, 0) >= minExperience);
  }

  const maxDistance = toNumber(filters.max_distance_miles ?? filters.distance_miles, null);
  if (maxDistance !== null) {
    items = items.filter((match) => {
      const miles = toNumber(match?.driver?.distance_miles, null);
      if (miles === null) return true;
      return miles <= maxDistance;
    });
  }

  return items;
}

function sanitizeDriverProfile(profile) {
  const clone = { ...profile };
  delete clone.ssn;
  delete clone.password;
  return clone;
}

function maskDriverContact(profile) {
  return {
    ...profile,
    email: profile?.email ? '***masked***' : null,
    phone: profile?.phone ? '***masked***' : null
  };
}

async function consumeProfileViewCredit(partnerId) {
  if (!partnerId) {
    return { success: false, message: 'Missing partner context' };
  }

  const periodKey = new Date().toISOString().slice(0, 7);
  const usageResult = await dataAccess.queryRecords(COLLECTIONS.usage, {
    filters: { partner_id: partnerId, period_key: periodKey },
    limit: 1,
    suppressAuth: true
  });
  const usage = usageResult?.items?.[0];
  if (!usage?._id) {
    return { success: true };
  }

  const nextQuotas = { ...(usage.quotas_used || {}) };
  nextQuotas.driver_profile_views = Number(nextQuotas.driver_profile_views || 0) + 1;
  await dataAccess.updateRecord(COLLECTIONS.usage, {
    _id: usage._id,
    quotas_used: nextQuotas,
    updated_at: new Date()
  }, { suppressAuth: true });

  return { success: true };
}

/**
 * Challenge Service
 *
 * Manages the challenge system for drivers and recruiters including:
 * - Daily, weekly, monthly, and event challenges
 * - Challenge progress tracking
 * - Challenge completion and reward claiming
 * - Challenge expiration handling
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import * as dataAccess from 'backend/dataAccess';
import { createNotification } from 'backend/memberService';
import { awardDriverXP, awardRecruiterPoints, logGamificationEvent } from 'backend/gamificationService';
import { chunkArray } from 'backend/utils/arrayUtils';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
  challengeDefinitions: 'challengeDefinitions',
  driverChallenges: 'driverChallenges',
  recruiterChallenges: 'recruiterChallenges',
  gamificationEvents: 'gamificationEvents'
};

// =============================================================================
// CHALLENGE TYPES
// =============================================================================

const CHALLENGE_TYPES = {
  daily: {
    name: 'Daily Challenge',
    duration: 24 * 60 * 60 * 1000, // 24 hours in ms
    resetTime: '00:00', // Midnight UTC
    icon: 'ðŸ“…',
    color: '#10b981'
  },
  weekly: {
    name: 'Weekly Challenge',
    duration: 7 * 24 * 60 * 60 * 1000, // 7 days
    resetDay: 1, // Monday
    icon: 'ðŸ“†',
    color: '#3b82f6'
  },
  monthly: {
    name: 'Monthly Challenge',
    duration: 30 * 24 * 60 * 60 * 1000, // ~30 days
    resetDay: 1, // 1st of month
    icon: 'ðŸ—“ï¸',
    color: '#8b5cf6'
  },
  event: {
    name: 'Event Challenge',
    duration: null, // Custom per event
    icon: 'ðŸŽ‰',
    color: '#f59e0b'
  },
  onetime: {
    name: 'One-Time Challenge',
    duration: null, // No expiration
    icon: 'ðŸŽ¯',
    color: '#ec4899'
  }
};

// =============================================================================
// CHALLENGE STATUS
// =============================================================================

const CHALLENGE_STATUS = {
  AVAILABLE: 'available',      // Can be started
  ACTIVE: 'active',            // In progress
  COMPLETED: 'completed',      // Finished, reward not claimed
  CLAIMED: 'claimed',          // Reward claimed
  EXPIRED: 'expired',          // Time ran out
  FAILED: 'failed'             // Failed to complete
};

// =============================================================================
// GET CHALLENGE DEFINITIONS
// =============================================================================

/**
 * Get all challenge definitions
 */
export async function getChallengeDefinitions(userType, challengeType = null) {
  try {
    const filters = { is_active: 'Yes', user_type: userType };
    if (challengeType) filters.challenge_type = challengeType;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.challengeDefinitions, {
      filters, sort: [{ field: 'display_order', direction: 'asc' }], limit: 100, suppressAuth: true
    });

    return (result.items || []).map(normalizeChallengeDefinition);
  } catch (error) {
    console.error('getChallengeDefinitions error:', error);
    return [];
  }
}

/**
 * Get user's active challenges with progress
 */
export async function getActiveChallenges(userId, userType) {
  try {
    const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
    const result = await dataAccess.queryRecords(key, {
      filters: { user_id: userId, status: CHALLENGE_STATUS.ACTIVE }, limit: 50, suppressAuth: true
    });

    const challenges = [], now = new Date(), expiredRecords = [], activeRecords = [];
    (result.items || []).forEach(record => {
      const challenge = normalizeUserChallenge(record);
      if (challenge.expiresAt && new Date(challenge.expiresAt) < now) expiredRecords.push(record);
      else activeRecords.push(challenge);
    });

    if (expiredRecords.length > 0) {
      for (const record of expiredRecords) {
        await dataAccess.updateRecord(key, { ...record, status: CHALLENGE_STATUS.EXPIRED, expired_at: now.toISOString() }, { suppressAuth: true }).catch(() => {});
      }
    }

    for (const challenge of activeRecords) {
      challenge.progressPercent = challenge.targetValue > 0 ? Math.min(100, Math.round((challenge.currentValue / challenge.targetValue) * 100)) : 0;
      if (challenge.expiresAt) {
        challenge.timeRemaining = new Date(challenge.expiresAt) - now;
        challenge.timeRemainingFormatted = formatTimeRemaining(challenge.timeRemaining);
        challenge.isExpiringSoon = challenge.timeRemaining < 2 * 3600000;
      }
      challenges.push(challenge);
    }
    return challenges;
  } catch (error) {
    console.error('getActiveChallenges error:', error);
    return [];
  }
}

/**
 * Get challenges available for user to start
 */
export async function getAvailableChallenges(userId, userType) {
  try {
    const definitions = await getChallengeDefinitions(userType);
    const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
    const userRes = await dataAccess.queryRecords(key, { filters: { user_id: userId }, limit: 500, suppressAuth: true });
    
    const challengeStates = new Map();
    (userRes.items || []).forEach(uc => {
      const defId = uc.challenge_definition_id;
      if (!challengeStates.has(defId)) challengeStates.set(defId, []);
      challengeStates.get(defId).push(uc);
    });

    const available = [], now = new Date();
    for (const def of definitions) {
      if (checkChallengeAvailability(def, challengeStates.get(def.challengeId) || [], now)) {
        available.push({ ...def, canStart: true, typeInfo: CHALLENGE_TYPES[def.challengeType] || CHALLENGE_TYPES.daily });
      }
    }
    return available;
  } catch (error) { return []; }
}

/**
 * Start a challenge for a user
 */
export async function startChallenge(userId, challengeId, userType) {
  try {
    const definitions = await getChallengeDefinitions(userType);
    const definition = definitions.find(d => d.challengeId === challengeId);
    if (!definition) return { success: false, error: 'challenge_not_found' };

    const available = await getAvailableChallenges(userId, userType);
    if (!available.some(a => a.challengeId === challengeId)) return { success: false, error: 'challenge_not_available' };

    const now = new Date(); let expiresAt = null;
    if (definition.challengeType === 'daily') { expiresAt = new Date(now); expiresAt.setUTCDate(expiresAt.getUTCDate() + 1); expiresAt.setUTCHours(0,0,0,0); }
    else if (definition.challengeType === 'weekly') { expiresAt = new Date(now); expiresAt.setUTCDate(expiresAt.getUTCDate() + ((8 - expiresAt.getUTCDay()) % 7 || 7)); expiresAt.setUTCHours(0,0,0,0); }
    else if (definition.challengeType === 'monthly') { expiresAt = new Date(now); expiresAt.setUTCMonth(expiresAt.getUTCMonth() + 1); expiresAt.setUTCDate(1); expiresAt.setUTCHours(0,0,0,0); }
    else if (definition.challengeType === 'event' && definition.eventEndDate) expiresAt = new Date(definition.eventEndDate);

    const challengeData = {
      user_id: userId, challenge_definition_id: challengeId, challenge_name: definition.name,
      challenge_type: definition.challengeType, status: CHALLENGE_STATUS.ACTIVE, current_value: 0,
      target_value: definition.targetValue, xp_reward: definition.xpReward, points_reward: definition.pointsReward || 0,
      started_at: now.toISOString(), expires_at: expiresAt ? expiresAt.toISOString() : null,
      created_at: now.toISOString(), updated_at: now.toISOString()
    };

    const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
    const result = await dataAccess.insertRecord(key, challengeData, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    await logGamificationEvent(userId, userType, { eventType: 'challenge_started', action: 'start_challenge', metadata: { challengeId, challengeName: definition.name } });
    return { success: true, challenge: { _id: result.record._id, ...challengeData, definition } };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Update progress on challenges based on user action
 */
export async function updateChallengeProgress(userId, userType, action, metadata = {}) {
  try {
    const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
    const result = await dataAccess.queryRecords(key, { filters: { user_id: userId, status: CHALLENGE_STATUS.ACTIVE }, limit: 50, suppressAuth: true });
    const activeChallenges = result.items || [];
    const definitions = await getChallengeDefinitions(userType);
    const results = { updated: [], completed: [] }, now = new Date();

    for (const challenge of activeChallenges) {
      const definition = definitions.find(d => d.challengeId === challenge.challenge_definition_id);
      if (!definition || !doesActionApply(definition, action, metadata)) continue;

      const currentValue = (challenge.current_value || 0) + 1;
      const targetValue = challenge.target_value || definition.targetValue;
      const updateData = { ...challenge, current_value: currentValue, updated_at: now.toISOString() };

      if (currentValue >= targetValue) {
        updateData.status = CHALLENGE_STATUS.COMPLETED;
        updateData.completed_at = now.toISOString();
        results.completed.push({ challengeId: definition.challengeId, challengeName: challenge.challenge_name, xpReward: challenge.xp_reward, pointsReward: challenge.points_reward });
        await sendChallengeCompleteNotification(userId, userType, { challengeName: challenge.challenge_name, xpReward: challenge.xp_reward, pointsReward: challenge.points_reward });
      } else {
        results.updated.push({ challengeId: definition.challengeId, challengeName: challenge.challenge_name, currentValue, targetValue, progressPercent: Math.round((currentValue / targetValue) * 100) });
      }
      await dataAccess.updateRecord(key, updateData, { suppressAuth: true });
    }
    return results;
  } catch (error) { return { updated: [], completed: [], error: error.message }; }
}

/**
 * Claim reward for a completed challenge
 */
export async function claimChallengeReward(userId, challengeRecordId, userType) {
  try {
    const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
    const challenge = await dataAccess.getRecord(key, challengeRecordId, { suppressAuth: true });
    if (!challenge || challenge.user_id !== userId) return { success: false, error: 'not_authorized' };
    if (challenge.status !== CHALLENGE_STATUS.COMPLETED) return { success: false, error: challenge.status === CHALLENGE_STATUS.CLAIMED ? 'already_claimed' : 'not_completed' };

    const xp = challenge.xp_reward || 0, pts = challenge.points_reward || 0;
    if (userType === 'driver' && xp > 0) await awardDriverXP(userId, 'challenge_complete', { challengeId: challenge.challenge_definition_id, challengeName: challenge.challenge_name, xpAmount: xp });
    if (userType === 'recruiter' && pts > 0) await awardRecruiterPoints(userId, 'challenge_complete', { challengeId: challenge.challenge_definition_id, challengeName: challenge.challenge_name, pointsAmount: pts });

    await dataAccess.updateRecord(key, { ...challenge, status: CHALLENGE_STATUS.CLAIMED, claimed_at: new Date().toISOString(), updated_at: new Date().toISOString() }, { suppressAuth: true });
    await logGamificationEvent(userId, userType, { eventType: 'challenge_reward_claimed', action: 'claim_reward', metadata: { challengeId: challenge.challenge_definition_id, xpAwarded: xp, pointsAwarded: pts } });
    return { success: true, xpAwarded: xp, pointsAwarded: pts, challengeName: challenge.challenge_name };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Get user's challenge history
 */
export async function getChallengeHistory(userId, userType, options = {}) {
  try {
    const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
    const filters = { user_id: userId };
    if (options.status) filters.status = options.status;
    if (options.challengeType) filters.challenge_type = options.challengeType;

    const result = await dataAccess.queryRecords(key, {
      filters, sort: [{ field: 'started_at', direction: 'desc' }],
      limit: (options.limit || 20) + 1, suppressAuth: true
    });

    const items = result.items || [];
    const hasMore = items.length > (options.limit || 20);
    const challenges = items.slice(0, options.limit || 20).map(normalizeUserChallenge);
    const stats = { totalCompleted: 0, totalXpEarned: 0, totalPointsEarned: 0 };
    challenges.forEach(c => { if (c.status === CHALLENGE_STATUS.CLAIMED) { stats.totalCompleted++; stats.totalXpEarned += c.xpReward || 0; stats.totalPointsEarned += c.pointsReward || 0; } });

    return { challenges, total: result.totalCount || items.length, hasMore, stats };
  } catch (error) { return { challenges: [], total: 0, hasMore: false, error: error.message }; }
}

/**
 * Process expired challenges (called by scheduled job)
 */
export async function processExpiredChallenges() {
  try {
    const now = new Date(), results = { processed: 0, expired: 0, errors: 0 };
    for (const userType of ['driver', 'recruiter']) {
      const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
      const res = await dataAccess.queryRecords(key, { filters: { status: CHALLENGE_STATUS.ACTIVE, expires_at: { le: now.toISOString() } }, limit: 500, suppressAuth: true });
      const expired = res.items || [];
      results.processed += expired.length;

      for (const challenge of expired) {
        try {
          await dataAccess.updateRecord(key, { ...challenge, status: CHALLENGE_STATUS.EXPIRED, expired_at: now.toISOString(), updated_at: now.toISOString() }, { suppressAuth: true });
          await createNotification(challenge.user_id, 'challenge_expired', `Challenge Expired: ${challenge.challenge_name}`, `Your challenge "${challenge.challenge_name}" has expired.`, userType === 'driver' ? '/driver/challenges' : '/recruiter/challenges');
          results.expired++;
        } catch (e) { results.errors++; }
      }
    }
    return results;
  } catch (error) { return { processed: 0, expired: 0, error: error.message }; }
}

/**
 * Send reminders for challenges expiring soon
 */
export async function sendExpiringChallengeReminders() {
  try {
    const now = new Date(), twoHours = new Date(now.getTime() + 7200000), results = { processed: 0, reminded: 0, errors: 0 };
    for (const userType of ['driver', 'recruiter']) {
      const key = userType === 'driver' ? COLLECTION_KEYS.driverChallenges : COLLECTION_KEYS.recruiterChallenges;
      const res = await dataAccess.queryRecords(key, { filters: { status: CHALLENGE_STATUS.ACTIVE, expires_at: { gt: now.toISOString(), le: twoHours.toISOString() }, reminder_sent: { ne: 'Yes' } }, limit: 500, suppressAuth: true });
      const needsReminder = res.items || [];
      results.processed += needsReminder.length;

      for (const challenge of needsReminder) {
        try {
          const time = formatTimeRemaining(new Date(challenge.expires_at) - now);
          await createNotification(challenge.user_id, 'challenge_expiring', `Challenge Expiring Soon!`, `Your challenge "${challenge.challenge_name}" expires in ${time}!`, userType === 'driver' ? '/driver/challenges' : '/recruiter/challenges');
          await dataAccess.updateRecord(key, { ...challenge, reminder_sent: 'Yes', updated_at: now.toISOString() }, { suppressAuth: true });
          results.reminded++;
        } catch (e) { results.errors++; }
      }
    }
    return results;
  } catch (error) { return { processed: 0, reminded: 0, error: error.message }; }
}

/**
 * Get challenge summary for dashboard
 */
export async function getChallengeSummary(userId, userType) {
  try {
    const [active, available, history] = await Promise.all([
      getActiveChallenges(userId, userType), getAvailableChallenges(userId, userType), getChallengeHistory(userId, userType, { limit: 100 })
    ]);
    const completedByType = { daily: 0, weekly: 0, monthly: 0, event: 0, onetime: 0 };
    history.challenges.forEach(c => { if (c.status === CHALLENGE_STATUS.CLAIMED && completedByType[c.challengeType] !== undefined) completedByType[c.challengeType]++; });
    return { active: { count: active.length, challenges: active }, available: { count: available.length, challenges: available.slice(0, 5) }, readyToClaim: { count: history.challenges.filter(c => c.status === CHALLENGE_STATUS.COMPLETED).length, challenges: history.challenges.filter(c => c.status === CHALLENGE_STATUS.COMPLETED) }, stats: { totalCompleted: history.stats.totalCompleted, totalXpEarned: history.stats.totalXpEarned, totalPointsEarned: history.stats.totalPointsEarned, completedByType } };
  } catch (error) { return { error: error.message }; }
}

function normalizeChallengeDefinition(record) {
  return {
    _id: record._id || record.id, challengeId: record.challenge_id, name: record.name, description: record.description,
    challengeType: record.challenge_type, userType: record.user_type, actionType: record.action_type,
    actionSubtype: record.action_subtype, targetValue: record.target_value || 1, xpReward: record.xp_reward || 0,
    pointsReward: record.points_reward || 0, icon: record.icon, color: record.color,
    isRepeatable: record.is_repeatable !== 'No', autoAssign: record.auto_assign === 'Yes',
    isActive: record.is_active === 'Yes', displayOrder: record.display_order || 0,
    eventStartDate: record.event_start_date, eventEndDate: record.event_end_date
  };
}

function normalizeUserChallenge(record) {
  return {
    _id: record._id || record.id, challengeDefinitionId: record.challenge_definition_id, challengeName: record.challenge_name,
    challengeType: record.challenge_type, status: record.status, currentValue: record.current_value || 0,
    targetValue: record.target_value || 1, xpReward: record.xp_reward || 0, pointsReward: record.points_reward || 0,
    startedAt: record.started_at, expiresAt: record.expires_at, completedAt: record.completed_at,
    claimedAt: record.claimed_at, expiredAt: record.expired_at
  };
}


/**
 * Format time remaining in human-readable format
 */
function formatTimeRemaining(ms) {
  if (ms <= 0) return 'Expired';

  const hours = Math.floor(ms / (60 * 60 * 1000));
  const minutes = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));

  if (hours > 24) {
    const days = Math.floor(hours / 24);
    return `${days}d ${hours % 24}h`;
  }

  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }

  return `${minutes}m`;
}

/**
 * Get challenge type info
 */
export function getChallengeTypes() {
  return Object.entries(CHALLENGE_TYPES).map(([key, value]) => ({
    type: key,
    ...value
  }));
}

/**
 * Get challenge status options
 */
export function getChallengeStatuses() {
  return CHALLENGE_STATUS;
}

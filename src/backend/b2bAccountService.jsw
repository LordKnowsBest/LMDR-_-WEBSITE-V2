import wixData from 'wix-data';
import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// COLLECTION KEYS
// ============================================================================

const COLLECTIONS = {
  accounts: 'b2bAccounts',
  contacts: 'b2bContacts',
  leadSources: 'b2bLeadSources',
  carriers: 'carriers',
  signals: 'b2bMatchSignals'
};

const ACCOUNT_STATUS = {
  TARGET: 'target', PROSPECTING: 'prospecting', ENGAGED: 'engaged',
  CLIENT: 'client', CHURNED: 'churned', DISQUALIFIED: 'disqualified'
};

const ACCOUNT_SEGMENTS = {
  ENTERPRISE: 'enterprise', MID_MARKET: 'mid_market',
  SMALL_FLEET: 'small_fleet', OWNER_OPERATOR: 'owner_operator'
};

// ============================================================================
// ACCOUNT CRUD
// ============================================================================

export async function createAccount(accountData) {
  try {
    if (!accountData.carrier_name?.trim()) return { success: false, error: 'Carrier name required' };

    if (accountData.carrier_dot) {
      const existing = await dataAccess.findByField(COLLECTIONS.accounts, 'carrier_dot', String(accountData.carrier_dot), { suppressAuth: true });
      if (existing) return { success: false, error: 'Account already exists', existingId: existing._id };
    }

    const record = {
      carrier_dot: accountData.carrier_dot ? String(accountData.carrier_dot).trim() : '',
      carrier_name: accountData.carrier_name.trim(), status: accountData.status || ACCOUNT_STATUS.TARGET,
      segment: accountData.segment || classifySegment(accountData.fleet_size), region: accountData.region || '',
      fleet_size: accountData.fleet_size || 0, source: accountData.source || 'manual', owner_id: accountData.owner_id || '',
      last_activity_at: new Date().toISOString(), created_at: new Date().toISOString()
    };

    const result = await dataAccess.insertRecord(COLLECTIONS.accounts, record, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    if (accountData.source && accountData.source !== 'manual') {
      trackLeadSource(result.record._id, accountData.source).catch(() => {});
    }
    return { success: true, account: result.record };
  } catch (error) {
    console.error('createAccount error:', error);
    return { success: false, error: error.message };
  }
}

export async function getAccount(accountId) {
  try {
    const record = await dataAccess.getRecord(COLLECTIONS.accounts, accountId, { suppressAuth: true });
    return record ? { success: true, account: record } : { success: false, error: 'Not found' };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getAccountByDot(carrierDot) {
  try {
    const record = await dataAccess.findByField(COLLECTIONS.accounts, 'carrier_dot', String(carrierDot), { suppressAuth: true });
    return record ? { success: true, account: record } : { success: false, error: 'Not found' };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function updateAccount(accountId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.accounts, accountId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.accounts, { ...existing, ...updates, _id: accountId, last_activity_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: result.success, account: result.record };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function removeAccount(accountId) {
  try {
    const result = await dataAccess.removeRecord(COLLECTIONS.accounts, accountId, { suppressAuth: true });
    return { success: result.success };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ACCOUNT LISTS & QUERIES
// ============================================================================

export async function listAccounts(filters = {}) {
  try {
    const queryFilters = {};
    if (filters.status) queryFilters.status = filters.status;
    if (filters.segment) queryFilters.segment = filters.segment;
    if (filters.minFleetSize) queryFilters.fleet_size = { gte: filters.minFleetSize };

    const result = await dataAccess.queryRecords(COLLECTIONS.accounts, {
      filters: queryFilters, sort: [{ field: filters.sortBy || 'last_activity_at', direction: filters.sortDir || 'desc' }],
      limit: filters.limit || 50, suppressAuth: true
    });
    return { success: true, accounts: result.items || [], totalCount: result.totalCount || result.items?.length };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getTopProspects(options = {}) {
  try {
    const accountRes = await dataAccess.queryRecords(COLLECTIONS.accounts, {
      filters: { status: { hasSome: ['target', 'prospecting'] } },
      limit: 200, suppressAuth: true
    });
    const accounts = accountRes.items || [];

    const signalRes = await dataAccess.queryRecords(COLLECTIONS.signals, {
      filters: { snapshot_date: '' }, sort: [{ field: 'signal_score', direction: 'desc' }],
      limit: 200, suppressAuth: true
    });
    const signals = signalRes.items || [];
    const signalMap = new Map();
    signals.forEach(s => signalMap.set(s.carrier_dot, s));

    const enriched = accounts.map(acc => {
      const s = signalMap.get(acc.carrier_dot);
      return { ...acc, signal_score: s?.signal_score || 0, confidence: s?.confidence || 'low', urgency: s?.urgency || 'low' };
    }).sort((a, b) => (b.signal_score || 0) - (a.signal_score || 0));

    return { success: true, prospects: enriched.slice(0, options.limit || 25) };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CONTACT CRUD
// ============================================================================

export async function createContact(contactData) {
  try {
    if (!contactData.account_id || !contactData.name?.trim()) return { success: false, error: 'Missing fields' };
    const result = await dataAccess.insertRecord(COLLECTIONS.contacts, { ...contactData, created_at: new Date().toISOString() }, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    const existingContacts = await dataAccess.queryRecords(COLLECTIONS.contacts, { filters: { account_id: contactData.account_id }, limit: 2, suppressAuth: true });
    if ((existingContacts.items?.length || 0) <= 1) {
      await updateAccount(contactData.account_id, { primary_contact_id: result.record._id });
    }
    return { success: true, contact: result.record };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getContactsByAccount(accountId) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.contacts, { filters: { account_id: accountId }, limit: 50, suppressAuth: true });
    return { success: true, contacts: res.items || [] };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function updateContact(contactId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.contacts, contactId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.contacts, { ...existing, ...updates, _id: contactId }, { suppressAuth: true });
    return { success: true, contact: result.record };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function removeContact(contactId) {
  try {
    const result = await dataAccess.removeRecord(COLLECTIONS.contacts, contactId, { suppressAuth: true });
    return { success: result.success };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// LEAD SOURCE TRACKING
// ============================================================================

export async function trackLeadSource(accountId, source, medium = '', campaign = '') {
  try {
    await dataAccess.insertRecord(COLLECTIONS.leadSources, { account_id: accountId, source, medium, campaign, captured_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function createAccountFromSignal(signal) {
  try {
    if (!signal?.carrier_dot) return { success: false, error: 'DOT required' };
    const existing = await dataAccess.findByField(COLLECTIONS.accounts, 'carrier_dot', signal.carrier_dot, { suppressAuth: true });
    if (existing) return { success: true, account: existing, alreadyExists: true };

    const carrier = await dataAccess.findByField(COLLECTIONS.carriers, 'dot_number', signal.carrier_dot, { suppressAuth: true });
    const name = carrier?.legal_name || `Carrier ${signal.carrier_dot}`;

    return await createAccount({ carrier_dot: signal.carrier_dot, carrier_name: name, status: ACCOUNT_STATUS.TARGET, source: 'match_signal' });
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function classifySegment(fleetSize) {
  if (!fleetSize || fleetSize <= 0) return '';
  if (fleetSize >= 500) return ACCOUNT_SEGMENTS.ENTERPRISE;
  if (fleetSize >= 100) return ACCOUNT_SEGMENTS.MID_MARKET;
  if (fleetSize >= 20) return ACCOUNT_SEGMENTS.SMALL_FLEET;
  return ACCOUNT_SEGMENTS.OWNER_OPERATOR;
}
// ============================================================================
// INTERNAL HELPERS
// ============================================================================

/**
 * Classify fleet segment based on fleet size
 */
function classifySegment(fleetSize) {
  if (!fleetSize || fleetSize <= 0) return '';
  if (fleetSize >= 500) return ACCOUNT_SEGMENTS.ENTERPRISE;
  if (fleetSize >= 100) return ACCOUNT_SEGMENTS.MID_MARKET;
  if (fleetSize >= 20) return ACCOUNT_SEGMENTS.SMALL_FLEET;
  return ACCOUNT_SEGMENTS.OWNER_OPERATOR;
}

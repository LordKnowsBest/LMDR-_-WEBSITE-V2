import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  announcements: 'carrierAnnouncements',
  policies: 'policyDocuments',
  recognitions: 'driverRecognitions',
  feedback: 'feedbackRequests'
};

export async function createAnnouncement(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const announceSvc = await import('backend/carrierAnnouncementsService');
    return await announceSvc.createAnnouncement({ ...params, carrierId: carrierDot });
  } catch (error) {
    console.error('[CarrierComm] createAnnouncement error:', error.message);
    return { error: error.message };
  }
}

export async function getAnnouncements(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const announceSvc = await import('backend/carrierAnnouncementsService');
    return await announceSvc.getAnnouncementsForCarrier(carrierDot, params);
  } catch (error) {
    console.error('[CarrierComm] getAnnouncements error:', error.message);
    return { error: error.message };
  }
}

export async function createPolicyUpdate(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const policySvc = await import('backend/carrierPolicyService');
    return await policySvc.createPolicy(carrierDot, params);
  } catch (error) {
    console.error('[CarrierComm] createPolicyUpdate error:', error.message);
    return { error: error.message };
  }
}

export async function getPolicies(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const policySvc = await import('backend/carrierPolicyService');
    return await policySvc.getPolicies(carrierDot, params);
  } catch (error) {
    console.error('[CarrierComm] getPolicies error:', error.message);
    return { error: error.message };
  }
}

export async function createRecognition(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const record = {
      carrier_dot: carrierDot,
      driver_id: params.driverId,
      driver_name: params.driverName || '',
      recognition_type: params.recognitionType || 'custom',
      title: params.title,
      description: params.description || '',
      awarded_by: params.awardedBy || carrierDot,
      is_public: params.isPublic !== false ? 'Yes' : 'No',
      created_at: new Date().toISOString()
    };
    const result = await dataAccess.insertRecord(COLLECTIONS.recognitions, record, { suppressAuth: true });
    return result;
  } catch (error) {
    console.error('[CarrierComm] createRecognition error:', error.message);
    return { error: error.message };
  }
}

export async function getRecognitions(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const filters = { carrier_dot: carrierDot };
    if (params.driverId) filters.driver_id = params.driverId;
    const page = params.page || 1;
    const pageSize = params.page_size || 25;
    const result = await dataAccess.queryRecords(COLLECTIONS.recognitions, {
      filters,
      limit: pageSize,
      skip: (page - 1) * pageSize,
      suppressAuth: true
    });
    return result;
  } catch (error) {
    console.error('[CarrierComm] getRecognitions error:', error.message);
    return { error: error.message };
  }
}

export async function createFeedbackRequest(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const record = {
      carrier_dot: carrierDot,
      title: params.title,
      description: params.description || '',
      target_audience: params.targetAudience || 'all',
      target_ids: params.targetIds ? JSON.stringify(params.targetIds) : '',
      status: 'open',
      response_count: 0,
      responses: '[]',
      created_by: params.createdBy || carrierDot,
      created_at: new Date().toISOString()
    };
    const result = await dataAccess.insertRecord(COLLECTIONS.feedback, record, { suppressAuth: true });
    return result;
  } catch (error) {
    console.error('[CarrierComm] createFeedbackRequest error:', error.message);
    return { error: error.message };
  }
}

export async function getFeedbackResponses(carrierDot, params = {}) {
  try {
    if (!carrierDot) return { error: 'carrierDot is required' };
    const filters = { carrier_dot: carrierDot };
    if (params.status) filters.status = params.status;
    const page = params.page || 1;
    const pageSize = params.page_size || 25;
    const result = await dataAccess.queryRecords(COLLECTIONS.feedback, {
      filters,
      limit: pageSize,
      skip: (page - 1) * pageSize,
      suppressAuth: true
    });
    if (result.success && result.items) {
      result.items = result.items.map(item => {
        try {
          item.responses = item.responses ? JSON.parse(item.responses) : [];
        } catch (_) {
          item.responses = [];
        }
        return item;
      });
    }
    return result;
  } catch (error) {
    console.error('[CarrierComm] getFeedbackResponses error:', error.message);
    return { error: error.message };
  }
}

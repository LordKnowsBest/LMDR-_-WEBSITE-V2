import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import { logFeatureInteraction } from 'backend/featureAdoptionService';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
  savedSearches: 'savedSearches',
  savedSearchAlerts: 'savedSearchAlerts'
};

const VALID_FREQUENCIES = ['immediate', 'hourly', 'daily', 'weekly'];
const VALID_CHANNELS = ['email', 'in_app', 'both'];

// Helper to get current user ID
async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

// ============================================================================
// CREATE SAVED SEARCH
// ============================================================================

export async function createSavedSearch(carrierDot, searchData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const { searchName, criteria, alertFrequency, alertChannel } = searchData;
    if (!searchName || !searchName.trim()) return { success: false, error: 'Search name is required' };

    const frequency = VALID_FREQUENCIES.includes(alertFrequency) ? alertFrequency : 'daily';
    const channel = VALID_CHANNELS.includes(alertChannel) ? alertChannel : 'in_app';

    // Check name uniqueness per carrier/recruiter
    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.savedSearches, {
      filters: {
        carrier_dot: String(carrierDot),
        recruiter_id: userId,
        search_name: searchName.trim(),
        is_active: 'Yes'
      },
      limit: 1, suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      return { success: false, error: 'A saved search with this name already exists' };
    }

    const record = {
      carrier_dot: String(carrierDot), recruiter_id: userId, search_name: searchName.trim(),
      criteria_json: JSON.stringify(criteria || {}), alert_frequency: frequency, alert_channel: channel,
      last_run_date: null, last_match_count: 0, new_matches_since_last: 0, is_active: 'Yes'
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.savedSearches, record, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    logFeatureInteraction('saved_search', userId, 'create', { carrierDot }).catch(() => {});
    return { success: true, savedSearch: result.record };
  } catch (error) {
    console.error('createSavedSearch error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// UPDATE SAVED SEARCH
// ============================================================================

export async function updateSavedSearch(searchId, updates) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const existing = await dataAccess.getRecord(COLLECTION_KEYS.savedSearches, searchId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Saved search not found' };
    if (existing.recruiter_id !== userId) return { success: false, error: 'Not authorized' };

    const updatedRecord = {
      ...existing,
      search_name: updates.searchName || existing.search_name,
      criteria_json: updates.criteria ? JSON.stringify(updates.criteria) : existing.criteria_json,
      alert_frequency: VALID_FREQUENCIES.includes(updates.alertFrequency) ? updates.alertFrequency : existing.alert_frequency,
      alert_channel: VALID_CHANNELS.includes(updates.alertChannel) ? updates.alertChannel : existing.alert_channel
    };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.savedSearches, updatedRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);
    return { success: true, savedSearch: result.record };
  } catch (error) {
    console.error('updateSavedSearch error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// DELETE SAVED SEARCH
// ============================================================================

export async function deleteSavedSearch(searchId) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const existing = await dataAccess.getRecord(COLLECTION_KEYS.savedSearches, searchId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Saved search not found' };
    if (existing.recruiter_id !== userId) return { success: false, error: 'Not authorized' };

    await dataAccess.updateRecord(COLLECTION_KEYS.savedSearches, { ...existing, is_active: 'No' }, { suppressAuth: true });
    return { success: true };
  } catch (error) {
    console.error('deleteSavedSearch error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET SAVED SEARCHES
// ============================================================================

export async function getSavedSearches(carrierDot) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.savedSearches, {
      filters: { carrier_dot: String(carrierDot), recruiter_id: userId, is_active: 'Yes' },
      sort: [{ field: 'search_name', direction: 'asc' }],
      limit: 50, suppressAuth: true
    });

    return {
      success: true,
      searches: (result.items || []).map(s => ({
        ...s, criteria: s.criteria_json ? JSON.parse(s.criteria_json) : {}
      }))
    };
  } catch (error) {
    console.error('getSavedSearches error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// EXECUTE SAVED SEARCH
// ============================================================================

export async function executeSavedSearch(searchId) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const search = await dataAccess.getRecord(COLLECTION_KEYS.savedSearches, searchId, { suppressAuth: true });
    if (!search) return { success: false, error: 'Saved search not found' };
    if (search.recruiter_id !== userId) return { success: false, error: 'Not authorized' };

    let criteria = {};
    try { criteria = search.criteria_json ? JSON.parse(search.criteria_json) : {}; } catch (e) { }

    const { findMatchingDrivers } = await import('backend/driverMatching.jsw');
    const result = await findMatchingDrivers(search.carrier_dot, criteria, {});

    const currentMatchCount = result.success ? (result.matches || []).length : 0;
    const previousMatchCount = search.last_match_count || 0;
    const newMatches = Math.max(0, currentMatchCount - previousMatchCount);

    await dataAccess.updateRecord(COLLECTION_KEYS.savedSearches, {
      ...search, last_run_date: new Date().toISOString(),
      last_match_count: currentMatchCount, new_matches_since_last: newMatches
    }, { suppressAuth: true });

    logFeatureInteraction('saved_search', userId, 'execute', { searchId }).catch(() => {});

    return {
      success: true, drivers: result.success ? result.matches : [],
      total: currentMatchCount, newMatches
    };
  } catch (error) {
    console.error('executeSavedSearch error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// PROCESS SAVED SEARCH ALERTS
// ============================================================================

export async function processSavedSearchAlerts() {
  const startTime = Date.now();
  try {
    const now = new Date();
    let processedCount = 0, alertsSent = 0;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.savedSearches, {
      filters: { is_active: 'Yes' }, limit: 500, suppressAuth: true
    });

    const allSearches = result.items || [];
    const dueSearches = allSearches.filter(search => {
      if (!search.last_run_date) return true;
      const hoursSince = (now - new Date(search.last_run_date)) / (1000 * 60 * 60);
      switch (search.alert_frequency) {
        case 'immediate': return true;
        case 'hourly': return hoursSince >= 1;
        case 'daily': return hoursSince >= 24;
        case 'weekly': return hoursSince >= 168;
        default: return hoursSince >= 24;
      }
    });

    const { findMatchingDrivers } = await import('backend/driverMatching.jsw');

    for (const search of dueSearches) {
      try {
        let criteria = {};
        try { criteria = JSON.parse(search.criteria_json || '{}'); } catch (e) { }

        const matchResult = await findMatchingDrivers(search.carrier_dot, criteria, {});
        const currentCount = matchResult.success ? (matchResult.matches || []).length : 0;
        const previousCount = search.last_match_count || 0;
        const newMatches = Math.max(0, currentCount - previousCount);

        await dataAccess.updateRecord(COLLECTION_KEYS.savedSearches, {
          ...search, last_run_date: now.toISOString(),
          last_match_count: currentCount, new_matches_since_last: newMatches
        }, { suppressAuth: true });

        if (newMatches > 0) {
          const newDriverIds = matchResult.success ? (matchResult.matches || []).slice(0, newMatches).map(m => m.driver?._id) : [];
          await dataAccess.insertRecord(COLLECTION_KEYS.savedSearchAlerts, {
            saved_search_id: search._id, recruiter_id: search.recruiter_id,
            driver_ids_json: JSON.stringify(newDriverIds), alert_status: 'pending',
            sent_at: now.toISOString(), channel_used: search.alert_channel || 'in_app'
          }, { suppressAuth: true });
          alertsSent++;
        }
        processedCount++;
      } catch (err) { /* skip */ }
    }

    return { success: true, processed: processedCount, alertsSent, durationMs: Date.now() - startTime };
  } catch (error) {
    console.error('[SavedSearchService] Alert processing failed:', error);
    return { success: false, error: error.message };
  }
}

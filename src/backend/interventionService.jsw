import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import { logFeatureInteraction } from 'backend/featureAdoptionService';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
  interventionTemplates: 'interventionTemplates',
  interventionLog: 'interventionLog',
  driverProfiles: 'driverProfiles'
};

const VALID_RISK_TYPES = ['SILENCE_SIGNAL', 'DETRACTOR_NPS', 'PAY_VOLATILITY', 'BURNOUT_RISK', 'SAFETY_INCIDENT'];
const VALID_CHANNELS = ['sms', 'email'];
const VALID_TONES = ['empathetic', 'professional', 'urgent'];
const VALID_OUTCOMES = ['improved', 'no_change', 'worsened', 'unknown'];

// Helper to get current user ID
async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

function renderTemplate(template, variables) {
  let rendered = template;
  for (const [key, value] of Object.entries(variables)) {
    rendered = rendered.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value || '');
  }
  return rendered;
}

// ============================================================================
// GET TEMPLATES
// ============================================================================

export async function getTemplates(carrierDot, riskType) {
  try {
    const filters = { is_active: true };
    // Include system defaults (no carrier_dot) and carrier-specific
    // dataAccess queryRecords doesn't support complex OR filters directly in this way yet, 
    // but we'll fetch and filter if necessary or use specialized dataAccess methods.
    
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interventionTemplates, {
      filters: { is_active: true },
      sort: [{ field: 'usage_count', direction: 'desc' }],
      limit: 100, suppressAuth: true
    });

    const templates = (result.items || []).filter(t => 
      (t.carrier_dot === String(carrierDot) || !t.carrier_dot || t.is_default) &&
      (!riskType || t.risk_type === riskType)
    );

    return { success: true, templates };
  } catch (error) {
    console.error('getTemplates error:', error);
    return { success: false, error: error.message };
  }
}

export async function getAllTemplates(carrierDot) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interventionTemplates, {
      filters: { is_active: true },
      sort: [{ field: 'usage_count', direction: 'desc' }],
      limit: 100, suppressAuth: true
    });

    const templates = (result.items || []).filter(t => 
      t.carrier_dot === String(carrierDot) || !t.carrier_dot || t.is_default
    );

    const grouped = {};
    VALID_RISK_TYPES.forEach(rt => { grouped[rt] = []; });
    templates.forEach(t => { if (grouped[t.risk_type]) grouped[t.risk_type].push(t); });

    return { success: true, templatesByRiskType: grouped, total: templates.length };
  } catch (error) {
    console.error('getAllTemplates error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CREATE/UPDATE/DELETE TEMPLATE
// ============================================================================

export async function createTemplate(carrierDot, templateData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const { templateName, riskType, channel, subjectLine, bodyTemplate, tone } = templateData;
    if (!templateName?.trim() || !VALID_RISK_TYPES.includes(riskType) || !VALID_CHANNELS.includes(channel)) {
      return { success: false, error: 'Invalid data' };
    }

    const record = {
      carrier_dot: String(carrierDot), risk_type: riskType, template_name: templateName.trim(),
      channel, subject_line: subjectLine || '', body_template: bodyTemplate || '',
      tone: VALID_TONES.includes(tone) ? tone : 'professional', is_default: false,
      usage_count: 0, success_rate: 0, is_active: true
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.interventionTemplates, record, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);
    return { success: true, template: result.record };
  } catch (error) {
    console.error('createTemplate error:', error);
    return { success: false, error: error.message };
  }
}

export async function updateTemplate(templateId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.interventionTemplates, templateId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Template not found' };
    if (existing.is_default) return { success: false, error: 'Cannot edit default' };

    const updatedRecord = {
      ...existing,
      template_name: updates.templateName || existing.template_name,
      channel: VALID_CHANNELS.includes(updates.channel) ? updates.channel : existing.channel,
      subject_line: updates.subjectLine !== undefined ? updates.subjectLine : existing.subject_line,
      body_template: updates.bodyTemplate !== undefined ? updates.bodyTemplate : existing.body_template,
      tone: VALID_TONES.includes(updates.tone) ? updates.tone : existing.tone
    };

    const result = await dataAccess.updateRecord(COLLECTION_KEYS.interventionTemplates, updatedRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);
    return { success: true, template: result.record };
  } catch (error) {
    console.error('updateTemplate error:', error);
    return { success: false, error: error.message };
  }
}

export async function deleteTemplate(templateId) {
  try {
    const existing = await dataAccess.getRecord(COLLECTION_KEYS.interventionTemplates, templateId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Template not found' };
    if (existing.is_default) return { success: false, error: 'Cannot delete default' };

    await dataAccess.updateRecord(COLLECTION_KEYS.interventionTemplates, { ...existing, is_active: false }, { suppressAuth: true });
    return { success: true };
  } catch (error) {
    console.error('deleteTemplate error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SEND INTERVENTION
// ============================================================================

export async function sendIntervention(templateId, driverId, overrides = {}) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const template = await dataAccess.getRecord(COLLECTION_KEYS.interventionTemplates, templateId, { suppressAuth: true });
    if (!template) return { success: false, error: 'Template not found' };

    const driverProfile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, driverId, { suppressAuth: true });

    const variables = {
      firstName: overrides.firstName || driverProfile?.first_name || 'Driver',
      lastName: overrides.lastName || driverProfile?.last_name || '',
      carrierName: overrides.carrierName || '',
      recruiterName: overrides.recruiterName || '',
      recruiterPhone: overrides.recruiterPhone || '',
      lastPayAmount: overrides.lastPayAmount || ''
    };

    const renderedSubject = renderTemplate(overrides.subjectLine || template.subject_line, variables);
    const renderedBody = renderTemplate(overrides.bodyTemplate || template.body_template, variables);

    const channel = overrides.channel || template.channel;
    if (channel === 'email' && driverProfile?._owner) {
      try {
        const emailService = await import('backend/emailService');
        await emailService.sendInterventionEmail(driverProfile._owner, renderedSubject, renderedBody);
      } catch (e) { }
    }

    const logRecord = {
      template_id: templateId, driver_id: driverId, recruiter_id: userId,
      carrier_dot: template.carrier_dot || overrides.carrierDot || '',
      sent_at: new Date().toISOString(), channel_used: channel,
      message_sent: renderedBody, outcome: 'unknown', outcome_date: null, is_active: true
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.interventionLog, logRecord, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    await dataAccess.updateRecord(COLLECTION_KEYS.interventionTemplates, {
      ...template, usage_count: (template.usage_count || 0) + 1
    }, { suppressAuth: true });

    logFeatureInteraction('intervention', userId, 'send', { channel, riskType: template.risk_type }).catch(() => {});

    return { success: true, interventionId: result.record._id, channelUsed: channel, messageSent: renderedBody };
  } catch (error) {
    console.error('sendIntervention error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// LOG INTERVENTION OUTCOME
// ============================================================================

export async function logInterventionOutcome(interventionId, outcome) {
  try {
    if (!VALID_OUTCOMES.includes(outcome)) return { success: false, error: 'Invalid outcome' };

    const existing = await dataAccess.getRecord(COLLECTION_KEYS.interventionLog, interventionId, { suppressAuth: true });
    if (!existing) return { success: false, error: 'Not found' };

    await dataAccess.updateRecord(COLLECTION_KEYS.interventionLog, {
      ...existing, outcome, outcome_date: new Date().toISOString()
    }, { suppressAuth: true });

    if (existing.template_id) {
      try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.interventionLog, {
          filters: { template_id: existing.template_id, outcome: { ne: 'unknown' } },
          limit: 500, suppressAuth: true
        });
        const allLogs = result.items || [];
        const improved = allLogs.filter(l => l.outcome === 'improved').length;
        const successRate = allLogs.length > 0 ? Math.round((improved / allLogs.length) * 100) : 0;

        const template = await dataAccess.getRecord(COLLECTION_KEYS.interventionTemplates, existing.template_id, { suppressAuth: true });
        if (template) {
          await dataAccess.updateRecord(COLLECTION_KEYS.interventionTemplates, { ...template, success_rate: successRate }, { suppressAuth: true });
        }
      } catch (err) { }
    }

    return { success: true };
  } catch (error) {
    console.error('logInterventionOutcome error:', error);
    return { success: false, error: error.message };
  }
}

export async function getDriverInterventions(driverId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interventionLog, {
      filters: { driver_id: driverId, is_active: true },
      sort: [{ field: 'sent_at', direction: 'desc' }],
      limit: 50, suppressAuth: true
    });
    return { success: true, interventions: result.items || [] };
  } catch (error) {
    console.error('getDriverInterventions error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SEED DEFAULT TEMPLATES
// ============================================================================

export async function seedDefaultTemplates() {
  const defaults = [
    { risk_type: 'SILENCE_SIGNAL', channel: 'sms', tone: 'empathetic', template_name: 'Silence Signal - SMS', subject_line: '', body_template: 'Hey {{firstName}}, {{recruiterName}} from {{carrierName}} here. Just checking in. Call me at {{recruiterPhone}}.' },
    { risk_type: 'DETRACTOR_NPS', channel: 'sms', tone: 'empathetic', template_name: 'Detractor NPS - SMS', subject_line: '', body_template: 'Hi {{firstName}}, {{recruiterName}} at {{carrierName}}. We value your feedback. Let\'s talk about how to improve things.' }
  ];

  let created = 0;
  for (const tmpl of defaults) {
    try {
      await dataAccess.insertRecord(COLLECTION_KEYS.interventionTemplates, {
        ...tmpl, carrier_dot: '', is_default: true, usage_count: 0, success_rate: 0, is_active: true
      }, { suppressAuth: true });
      created++;
    } catch (err) { }
  }
  return { success: true, created, total: defaults.length };
}

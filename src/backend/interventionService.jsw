import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import * as airtableClient from 'backend/airtableClient';
import { usesAirtable, getAirtableTableName } from 'backend/config';
import { logFeatureInteraction } from 'backend/featureAdoptionService';

const COLLECTION_KEYS = {
  interventionTemplates: 'interventionTemplates',
  interventionLog: 'interventionLog',
  driverProfiles: 'driverProfiles'
};

const VALID_RISK_TYPES = ['SILENCE_SIGNAL', 'DETRACTOR_NPS', 'PAY_VOLATILITY', 'BURNOUT_RISK', 'SAFETY_INCIDENT'];
const VALID_CHANNELS = ['sms', 'email'];
const VALID_TONES = ['empathetic', 'professional', 'urgent'];
const VALID_OUTCOMES = ['improved', 'no_change', 'worsened', 'unknown'];

async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

function renderTemplate(template, variables) {
  let rendered = template;
  for (const [key, value] of Object.entries(variables)) {
    rendered = rendered.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value || '');
  }
  return rendered;
}

function table(key) {
  return getAirtableTableName(key);
}

function toItems(result) {
  return result?.records || result?.items || [];
}

async function queryRecords(key, options) {
  if (usesAirtable(key)) {
    return airtableClient.queryRecords(table(key), options || {});
  }
  return dataAccess.queryRecords(key, { ...(options || {}), suppressAuth: true });
}

async function createRecord(key, record) {
  if (usesAirtable(key)) {
    return airtableClient.createRecord(table(key), record);
  }
  const result = await dataAccess.insertRecord(key, record, { suppressAuth: true });
  if (!result.success) throw new Error(result.error || 'Insert failed');
  return result.record;
}

async function getRecord(key, id) {
  if (usesAirtable(key)) {
    return airtableClient.getRecord(table(key), id);
  }
  return dataAccess.getRecord(key, id, { suppressAuth: true });
}

async function updateRecord(key, id, values) {
  if (usesAirtable(key)) {
    return airtableClient.updateRecord(table(key), id, values);
  }
  return dataAccess.updateRecord(key, { ...values, _id: id }, { suppressAuth: true });
}

export async function getTemplates(carrierDot, riskType) {
  try {
    const result = await queryRecords(COLLECTION_KEYS.interventionTemplates, {
      filters: { is_active: true },
      sort: [{ field: 'usage_count', direction: 'desc' }],
      limit: 100
    });

    const templates = toItems(result).filter((t) =>
      (t.carrier_dot === String(carrierDot) || !t.carrier_dot || t.is_default) &&
      (!riskType || t.risk_type === riskType)
    );

    return { success: true, templates };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getAllTemplates(carrierDot) {
  try {
    const result = await queryRecords(COLLECTION_KEYS.interventionTemplates, {
      filters: { is_active: true },
      sort: [{ field: 'usage_count', direction: 'desc' }],
      limit: 100
    });

    const templates = toItems(result).filter((t) => t.carrier_dot === String(carrierDot) || !t.carrier_dot || t.is_default);

    const grouped = {};
    VALID_RISK_TYPES.forEach((rt) => { grouped[rt] = []; });
    templates.forEach((t) => { if (grouped[t.risk_type]) grouped[t.risk_type].push(t); });

    return { success: true, templatesByRiskType: grouped, total: templates.length };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function createTemplate(carrierDot, templateData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const { templateName, riskType, channel, subjectLine, bodyTemplate, tone } = templateData;
    if (!templateName?.trim() || !VALID_RISK_TYPES.includes(riskType) || !VALID_CHANNELS.includes(channel)) {
      return { success: false, error: 'Invalid data' };
    }

    const record = {
      carrier_dot: String(carrierDot), risk_type: riskType, template_name: templateName.trim(),
      channel, subject_line: subjectLine || '', body_template: bodyTemplate || '',
      tone: VALID_TONES.includes(tone) ? tone : 'professional', is_default: false,
      usage_count: 0, success_rate: 0, is_active: true
    };

    const created = await createRecord(COLLECTION_KEYS.interventionTemplates, record);
    return { success: true, template: created };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function updateTemplate(templateId, updates) {
  try {
    const existing = await getRecord(COLLECTION_KEYS.interventionTemplates, templateId);
    if (!existing) return { success: false, error: 'Template not found' };
    if (existing.is_default) return { success: false, error: 'Cannot edit default' };

    const updatedRecord = {
      ...existing,
      template_name: updates.templateName || existing.template_name,
      channel: VALID_CHANNELS.includes(updates.channel) ? updates.channel : existing.channel,
      subject_line: updates.subjectLine !== undefined ? updates.subjectLine : existing.subject_line,
      body_template: updates.bodyTemplate !== undefined ? updates.bodyTemplate : existing.body_template,
      tone: VALID_TONES.includes(updates.tone) ? updates.tone : existing.tone
    };

    const saved = await updateRecord(COLLECTION_KEYS.interventionTemplates, templateId, updatedRecord);
    return { success: true, template: saved };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function deleteTemplate(templateId) {
  try {
    const existing = await getRecord(COLLECTION_KEYS.interventionTemplates, templateId);
    if (!existing) return { success: false, error: 'Template not found' };
    if (existing.is_default) return { success: false, error: 'Cannot delete default' };

    await updateRecord(COLLECTION_KEYS.interventionTemplates, templateId, { ...existing, is_active: false });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function sendIntervention(templateId, driverId, overrides = {}) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const template = await getRecord(COLLECTION_KEYS.interventionTemplates, templateId);
    if (!template) return { success: false, error: 'Template not found' };

    const driverProfile = await getRecord(COLLECTION_KEYS.driverProfiles, driverId);

    const variables = {
      firstName: overrides.firstName || driverProfile?.first_name || 'Driver',
      lastName: overrides.lastName || driverProfile?.last_name || '',
      carrierName: overrides.carrierName || '',
      recruiterName: overrides.recruiterName || '',
      recruiterPhone: overrides.recruiterPhone || '',
      lastPayAmount: overrides.lastPayAmount || ''
    };

    const renderedSubject = renderTemplate(overrides.subjectLine || template.subject_line || '', variables);
    const renderedBody = renderTemplate(overrides.bodyTemplate || template.body_template || '', variables);

    const channel = overrides.channel || template.channel;
    if (channel === 'email' && driverProfile?._owner) {
      try {
        const emailService = await import('backend/emailService');
        await emailService.sendInterventionEmail(driverProfile._owner, renderedSubject, renderedBody);
      } catch (e) {}
    }

    const created = await createRecord(COLLECTION_KEYS.interventionLog, {
      template_id: templateId,
      driver_id: driverId,
      recruiter_id: userId,
      carrier_dot: template.carrier_dot || overrides.carrierDot || '',
      sent_at: new Date().toISOString(),
      channel_used: channel,
      message_sent: renderedBody,
      outcome: 'unknown',
      outcome_date: null,
      is_active: true
    });

    await updateRecord(COLLECTION_KEYS.interventionTemplates, templateId, {
      ...template,
      usage_count: (template.usage_count || 0) + 1
    });

    logFeatureInteraction('intervention', userId, 'send', { channel, riskType: template.risk_type }).catch(() => {});

    return { success: true, interventionId: created?._id || created?.id, channelUsed: channel, messageSent: renderedBody };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function logInterventionOutcome(interventionId, outcome) {
  try {
    if (!VALID_OUTCOMES.includes(outcome)) return { success: false, error: 'Invalid outcome' };

    const existing = await getRecord(COLLECTION_KEYS.interventionLog, interventionId);
    if (!existing) return { success: false, error: 'Not found' };

    await updateRecord(COLLECTION_KEYS.interventionLog, interventionId, {
      ...existing,
      outcome,
      outcome_date: new Date().toISOString()
    });

    if (existing.template_id) {
      try {
        const result = await queryRecords(COLLECTION_KEYS.interventionLog, {
          filters: { template_id: existing.template_id },
          limit: 500
        });
        const allLogs = toItems(result).filter((l) => l.outcome && l.outcome !== 'unknown');
        const improved = allLogs.filter((l) => l.outcome === 'improved').length;
        const successRate = allLogs.length > 0 ? Math.round((improved / allLogs.length) * 100) : 0;

        const template = await getRecord(COLLECTION_KEYS.interventionTemplates, existing.template_id);
        if (template) {
          await updateRecord(COLLECTION_KEYS.interventionTemplates, existing.template_id, { ...template, success_rate: successRate });
        }
      } catch (err) {}
    }

    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getDriverInterventions(driverId) {
  try {
    const result = await queryRecords(COLLECTION_KEYS.interventionLog, {
      filters: { driver_id: driverId, is_active: true },
      sort: [{ field: 'sent_at', direction: 'desc' }],
      limit: 50
    });
    return { success: true, interventions: toItems(result) };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function seedDefaultTemplates() {
  const defaults = [
    { risk_type: 'SILENCE_SIGNAL', channel: 'sms', tone: 'empathetic', template_name: 'Silence Signal - SMS', subject_line: '', body_template: 'Hey {{firstName}}, {{recruiterName}} from {{carrierName}} here. Just checking in. Call me at {{recruiterPhone}}.' },
    { risk_type: 'SILENCE_SIGNAL', channel: 'email', tone: 'empathetic', template_name: 'Silence Signal - Email', subject_line: 'Checking in, {{firstName}}', body_template: 'Hi {{firstName}},\n\nWanted to check in and see how things are going.\n\n- {{recruiterName}}' },
    { risk_type: 'DETRACTOR_NPS', channel: 'sms', tone: 'empathetic', template_name: 'Detractor NPS - SMS', subject_line: '', body_template: 'Hi {{firstName}}, {{recruiterName}} at {{carrierName}}. We value your feedback. Let\'s talk about how to improve things.' },
    { risk_type: 'DETRACTOR_NPS', channel: 'email', tone: 'professional', template_name: 'Detractor NPS - Email', subject_line: 'We want to improve your experience', body_template: 'Hi {{firstName}}, we heard your feedback and want to help.' },
    { risk_type: 'PAY_VOLATILITY', channel: 'sms', tone: 'professional', template_name: 'Pay Volatility - SMS', subject_line: '', body_template: 'Hi {{firstName}}, noticed recent pay changes. Let\'s review your lanes and opportunities.' },
    { risk_type: 'PAY_VOLATILITY', channel: 'email', tone: 'professional', template_name: 'Pay Volatility - Email', subject_line: 'Let\'s stabilize your earnings', body_template: 'Hi {{firstName}}, let\'s align on routes that fit your goals.' },
    { risk_type: 'BURNOUT_RISK', channel: 'sms', tone: 'empathetic', template_name: 'Burnout Risk - SMS', subject_line: '', body_template: 'Hey {{firstName}}, checking in. We can adjust schedule/home time if needed.' },
    { risk_type: 'BURNOUT_RISK', channel: 'email', tone: 'empathetic', template_name: 'Burnout Risk - Email', subject_line: 'Support check-in', body_template: 'Hi {{firstName}}, we\'re here to support your workload and schedule.' },
    { risk_type: 'SAFETY_INCIDENT', channel: 'sms', tone: 'urgent', template_name: 'Safety Incident - SMS', subject_line: '', body_template: 'Hi {{firstName}}, safety team would like a quick follow-up today.' },
    { risk_type: 'SAFETY_INCIDENT', channel: 'email', tone: 'urgent', template_name: 'Safety Incident - Email', subject_line: 'Safety follow-up required', body_template: 'Hi {{firstName}}, please connect with us about a recent safety event.' }
  ];

  let created = 0;
  for (const tmpl of defaults) {
    try {
      await createRecord(COLLECTION_KEYS.interventionTemplates, {
        ...tmpl,
        carrier_dot: '',
        is_default: true,
        usage_count: 0,
        success_rate: 0,
        is_active: true
      });
      created++;
    } catch (err) {}
  }
  return { success: true, created, total: defaults.length };
}

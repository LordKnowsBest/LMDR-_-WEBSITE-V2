// ============================================================================
// INTERVENTION SERVICE - Backend for Retention Intervention Templates & Delivery
//
// DUAL-SOURCE SUPPORT: Supports both Wix Data and Airtable based on config.jsw
// ============================================================================

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { usesAirtable, getAirtableTableName, getWixCollectionName } from 'backend/config';
import * as airtable from 'backend/airtableClient';
import { logFeatureInteraction } from 'backend/featureAdoptionService';

// ============================================================================
// CONFIGURATION
// ============================================================================

const COLLECTION_KEYS = {
  interventionTemplates: 'interventionTemplates',
  interventionLog: 'interventionLog'
};

const VALID_RISK_TYPES = ['SILENCE_SIGNAL', 'DETRACTOR_NPS', 'PAY_VOLATILITY', 'BURNOUT_RISK', 'SAFETY_INCIDENT'];
const VALID_CHANNELS = ['sms', 'email'];
const VALID_TONES = ['empathetic', 'professional', 'urgent'];
const VALID_OUTCOMES = ['improved', 'no_change', 'worsened', 'unknown'];

// ============================================================================
// DUAL-SOURCE DATA HELPERS
// ============================================================================

async function queryData(collectionKey, airtableOptions = {}) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.queryRecords(tableName, airtableOptions);
    return result.records || [];
  }
  const result = await wixData.query(getWixCollectionName(collectionKey)).find({ suppressAuth: true });
  return result.items;
}

async function insertData(collectionKey, record) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    return await airtable.createRecord(tableName, record);
  }
  return await wixData.insert(getWixCollectionName(collectionKey), record, { suppressAuth: true });
}

async function updateData(collectionKey, record) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    return await airtable.updateRecord(tableName, record._id || record.id, record);
  }
  return await wixData.update(getWixCollectionName(collectionKey), record, { suppressAuth: true });
}

async function getRecord(collectionKey, recordId) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.getRecord(tableName, recordId);
    return (result && !result.error) ? result : null;
  }
  return await wixData.get(getWixCollectionName(collectionKey), recordId, { suppressAuth: true });
}

// ============================================================================
// HELPER: Get current user ID
// ============================================================================

async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

// ============================================================================
// TEMPLATE VARIABLE SUBSTITUTION
// ============================================================================

function renderTemplate(template, variables) {
  let rendered = template;
  for (const [key, value] of Object.entries(variables)) {
    rendered = rendered.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value || '');
  }
  return rendered;
}

// ============================================================================
// GET TEMPLATES
// ============================================================================

export async function getTemplates(carrierDot, riskType) {
  try {
    let filterParts = [`{Is Active} = TRUE()`];
    // Include system defaults (no carrier_dot) and carrier-specific
    filterParts.push(`OR({Carrier DOT} = '${carrierDot}', {Carrier DOT} = BLANK(), {Is Default} = TRUE())`);
    if (riskType && VALID_RISK_TYPES.includes(riskType)) {
      filterParts.push(`{Risk Type} = '${riskType}'`);
    }

    const filter = `AND(${filterParts.join(', ')})`;

    const templates = await queryData(COLLECTION_KEYS.interventionTemplates, {
      filterByFormula: filter,
      sort: [{ field: 'Usage Count', direction: 'desc' }],
      maxRecords: 50
    });

    return { success: true, templates };
  } catch (error) {
    console.error('getTemplates error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET ALL TEMPLATES (grouped by risk type)
// ============================================================================

export async function getAllTemplates(carrierDot) {
  try {
    const filter = `AND({Is Active} = TRUE(), OR({Carrier DOT} = '${carrierDot}', {Carrier DOT} = BLANK(), {Is Default} = TRUE()))`;

    const templates = await queryData(COLLECTION_KEYS.interventionTemplates, {
      filterByFormula: filter,
      sort: [{ field: 'Usage Count', direction: 'desc' }],
      maxRecords: 100
    });

    // Group by risk type
    const grouped = {};
    VALID_RISK_TYPES.forEach(rt => { grouped[rt] = []; });

    templates.forEach(t => {
      const rt = t.risk_type;
      if (grouped[rt]) {
        grouped[rt].push(t);
      }
    });

    return { success: true, templatesByRiskType: grouped, total: templates.length };
  } catch (error) {
    console.error('getAllTemplates error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CREATE TEMPLATE
// ============================================================================

export async function createTemplate(carrierDot, templateData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const { templateName, riskType, channel, subjectLine, bodyTemplate, tone } = templateData;

    if (!templateName || !templateName.trim()) {
      return { success: false, error: 'Template name is required' };
    }
    if (!VALID_RISK_TYPES.includes(riskType)) {
      return { success: false, error: `Invalid risk type. Must be one of: ${VALID_RISK_TYPES.join(', ')}` };
    }
    if (!VALID_CHANNELS.includes(channel)) {
      return { success: false, error: `Invalid channel. Must be one of: ${VALID_CHANNELS.join(', ')}` };
    }

    const record = {
      carrier_dot: String(carrierDot),
      risk_type: riskType,
      template_name: templateName.trim(),
      channel,
      subject_line: subjectLine || '',
      body_template: bodyTemplate || '',
      tone: VALID_TONES.includes(tone) ? tone : 'professional',
      is_default: false,
      usage_count: 0,
      success_rate: 0,
      is_active: true
    };

    const created = await insertData(COLLECTION_KEYS.interventionTemplates, record);
    return { success: true, template: created };
  } catch (error) {
    console.error('createTemplate error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// UPDATE TEMPLATE
// ============================================================================

export async function updateTemplate(templateId, updates) {
  try {
    const existing = await getRecord(COLLECTION_KEYS.interventionTemplates, templateId);
    if (!existing) return { success: false, error: 'Template not found' };

    // Cannot edit default templates
    if (existing.is_default) {
      return { success: false, error: 'Cannot edit default templates' };
    }

    const updatedRecord = {
      ...existing,
      template_name: updates.templateName || existing.template_name,
      channel: VALID_CHANNELS.includes(updates.channel) ? updates.channel : existing.channel,
      subject_line: updates.subjectLine !== undefined ? updates.subjectLine : existing.subject_line,
      body_template: updates.bodyTemplate !== undefined ? updates.bodyTemplate : existing.body_template,
      tone: VALID_TONES.includes(updates.tone) ? updates.tone : existing.tone
    };

    const updated = await updateData(COLLECTION_KEYS.interventionTemplates, updatedRecord);
    return { success: true, template: updated };
  } catch (error) {
    console.error('updateTemplate error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// DELETE TEMPLATE (soft delete)
// ============================================================================

export async function deleteTemplate(templateId) {
  try {
    const existing = await getRecord(COLLECTION_KEYS.interventionTemplates, templateId);
    if (!existing) return { success: false, error: 'Template not found' };

    if (existing.is_default) {
      return { success: false, error: 'Cannot delete default templates' };
    }

    await updateData(COLLECTION_KEYS.interventionTemplates, { ...existing, is_active: false });
    return { success: true };
  } catch (error) {
    console.error('deleteTemplate error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SEND INTERVENTION
// ============================================================================

export async function sendIntervention(templateId, driverId, overrides = {}) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const template = await getRecord(COLLECTION_KEYS.interventionTemplates, templateId);
    if (!template) return { success: false, error: 'Template not found' };

    // Get driver info for variable substitution
    let driverProfile = null;
    try {
      if (usesAirtable('driverProfiles')) {
        driverProfile = await airtable.getRecord(getAirtableTableName('driverProfiles'), driverId);
        if (driverProfile && driverProfile.error) driverProfile = null;
      } else {
        driverProfile = await wixData.get('DriverProfiles', driverId, { suppressAuth: true });
      }
    } catch (e) {
      console.warn('Could not fetch driver profile:', e.message);
    }

    // Build variables for substitution
    const variables = {
      firstName: overrides.firstName || driverProfile?.first_name || 'Driver',
      lastName: overrides.lastName || driverProfile?.last_name || '',
      carrierName: overrides.carrierName || '',
      recruiterName: overrides.recruiterName || '',
      recruiterPhone: overrides.recruiterPhone || '',
      lastPayAmount: overrides.lastPayAmount || ''
    };

    // Render template
    const renderedSubject = renderTemplate(overrides.subjectLine || template.subject_line, variables);
    const renderedBody = renderTemplate(overrides.bodyTemplate || template.body_template, variables);

    // Send via appropriate channel
    const channel = overrides.channel || template.channel;
    let sendResult = { success: true };

    if (channel === 'email') {
      try {
        const emailService = await import('backend/emailService');
        if (driverProfile && driverProfile._owner) {
          await emailService.sendInterventionEmail(driverProfile._owner, renderedSubject, renderedBody);
        }
      } catch (emailErr) {
        console.warn('Email send failed, logging anyway:', emailErr.message);
        sendResult = { success: false, error: emailErr.message };
      }
    }
    // SMS would go here in production

    // Log the intervention
    const logRecord = {
      template_id: templateId,
      driver_id: driverId,
      recruiter_id: userId,
      carrier_dot: template.carrier_dot || overrides.carrierDot || '',
      sent_at: new Date().toISOString(),
      channel_used: channel,
      message_sent: renderedBody,
      outcome: 'unknown',
      outcome_date: null,
      is_active: true
    };

    const logged = await insertData(COLLECTION_KEYS.interventionLog, logRecord);

    // Increment usage count on template
    await updateData(COLLECTION_KEYS.interventionTemplates, {
      ...template,
      usage_count: (template.usage_count || 0) + 1
    });

    // Log feature interaction (non-blocking)
    logFeatureInteraction('intervention', userId, 'send', { channel, riskType: template.risk_type })
      .catch(err => console.warn('Feature tracking failed:', err.message));

    return {
      success: true,
      interventionId: logged._id || logged.id,
      channelUsed: channel,
      messageSent: renderedBody
    };
  } catch (error) {
    console.error('sendIntervention error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// LOG INTERVENTION OUTCOME
// ============================================================================

export async function logInterventionOutcome(interventionId, outcome) {
  try {
    if (!VALID_OUTCOMES.includes(outcome)) {
      return { success: false, error: `Invalid outcome. Must be one of: ${VALID_OUTCOMES.join(', ')}` };
    }

    const existing = await getRecord(COLLECTION_KEYS.interventionLog, interventionId);
    if (!existing) return { success: false, error: 'Intervention record not found' };

    await updateData(COLLECTION_KEYS.interventionLog, {
      ...existing,
      outcome,
      outcome_date: new Date().toISOString()
    });

    // Recalculate template success rate
    if (existing.template_id) {
      try {
        const allLogs = await queryData(COLLECTION_KEYS.interventionLog, {
          filterByFormula: `AND({Template ID} = '${existing.template_id}', {Outcome} != 'unknown')`,
          maxRecords: 500
        });

        const improved = allLogs.filter(l => l.outcome === 'improved').length;
        const total = allLogs.length;
        const successRate = total > 0 ? Math.round((improved / total) * 100) : 0;

        const template = await getRecord(COLLECTION_KEYS.interventionTemplates, existing.template_id);
        if (template) {
          await updateData(COLLECTION_KEYS.interventionTemplates, {
            ...template,
            success_rate: successRate
          });
        }
      } catch (err) {
        console.warn('Success rate recalc failed:', err.message);
      }
    }

    return { success: true };
  } catch (error) {
    console.error('logInterventionOutcome error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET DRIVER INTERVENTIONS
// ============================================================================

export async function getDriverInterventions(driverId) {
  try {
    const interventions = await queryData(COLLECTION_KEYS.interventionLog, {
      filterByFormula: `AND({Driver ID} = '${driverId}', {Is Active} = TRUE())`,
      sort: [{ field: 'Sent At', direction: 'desc' }],
      maxRecords: 50
    });

    return { success: true, interventions };
  } catch (error) {
    console.error('getDriverInterventions error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SEED DEFAULT TEMPLATES
// ============================================================================

export async function seedDefaultTemplates() {
  console.log('[InterventionService] Seeding default templates...');

  const defaults = [
    // SILENCE_SIGNAL
    {
      risk_type: 'SILENCE_SIGNAL', channel: 'sms', tone: 'empathetic',
      template_name: 'Silence Signal - SMS Check-in',
      subject_line: '',
      body_template: 'Hey {{firstName}}, this is {{recruiterName}} from {{carrierName}}. We noticed you\'ve been quiet lately and wanted to check in. Everything going okay out there? Give us a call at {{recruiterPhone}} if you need anything.'
    },
    {
      risk_type: 'SILENCE_SIGNAL', channel: 'email', tone: 'professional',
      template_name: 'Silence Signal - Email Check-in',
      subject_line: '{{firstName}}, checking in from {{carrierName}}',
      body_template: 'Hi {{firstName}},\n\nWe noticed it\'s been a while since we last connected. I wanted to personally reach out and see how things are going.\n\nIf there\'s anything we can do to support you — whether it\'s routes, pay, home time, or anything else — please don\'t hesitate to reach out.\n\nBest,\n{{recruiterName}}\n{{recruiterPhone}}'
    },
    // DETRACTOR_NPS
    {
      risk_type: 'DETRACTOR_NPS', channel: 'sms', tone: 'empathetic',
      template_name: 'Detractor NPS - SMS Outreach',
      subject_line: '',
      body_template: 'Hi {{firstName}}, this is {{recruiterName}} at {{carrierName}}. We take your feedback seriously and I\'d love to chat about how we can make things better. When\'s a good time to talk? {{recruiterPhone}}'
    },
    {
      risk_type: 'DETRACTOR_NPS', channel: 'email', tone: 'empathetic',
      template_name: 'Detractor NPS - Email Follow-up',
      subject_line: '{{firstName}}, your feedback matters to us',
      body_template: 'Hi {{firstName}},\n\nThank you for sharing your honest feedback. We take it very seriously and want to understand what we can do better.\n\nI\'d appreciate a few minutes of your time to discuss your concerns. Would you be available for a quick call this week?\n\nSincerely,\n{{recruiterName}}\n{{recruiterPhone}}'
    },
    // PAY_VOLATILITY
    {
      risk_type: 'PAY_VOLATILITY', channel: 'sms', tone: 'professional',
      template_name: 'Pay Volatility - SMS Alert',
      subject_line: '',
      body_template: 'Hi {{firstName}}, this is {{recruiterName}} from {{carrierName}}. We\'ve noticed some fluctuation in your recent pay and want to make sure everything is accurate. Can we review your recent settlements? Call me at {{recruiterPhone}}.'
    },
    {
      risk_type: 'PAY_VOLATILITY', channel: 'email', tone: 'professional',
      template_name: 'Pay Volatility - Email Review',
      subject_line: 'Pay review for {{firstName}}',
      body_template: 'Hi {{firstName}},\n\nWe want to ensure your pay is consistent and accurate. We\'ve noticed some variation in your recent settlements and would like to review them with you.\n\nPlease reach out so we can go over the details together.\n\nBest,\n{{recruiterName}}\n{{recruiterPhone}}'
    },
    // BURNOUT_RISK
    {
      risk_type: 'BURNOUT_RISK', channel: 'sms', tone: 'empathetic',
      template_name: 'Burnout Risk - SMS Wellness',
      subject_line: '',
      body_template: 'Hey {{firstName}}, {{recruiterName}} here from {{carrierName}}. You\'ve been running hard and we want to make sure you\'re getting enough time at home. Let\'s talk about your schedule — {{recruiterPhone}}.'
    },
    {
      risk_type: 'BURNOUT_RISK', channel: 'email', tone: 'empathetic',
      template_name: 'Burnout Risk - Email Wellness',
      subject_line: '{{firstName}}, let\'s talk about your schedule',
      body_template: 'Hi {{firstName}},\n\nYour well-being matters to us. We\'ve noticed you haven\'t had much home time recently and want to make sure we\'re supporting a healthy work-life balance.\n\nLet\'s discuss adjusting your schedule so you can recharge.\n\nWarmly,\n{{recruiterName}}\n{{recruiterPhone}}'
    },
    // SAFETY_INCIDENT
    {
      risk_type: 'SAFETY_INCIDENT', channel: 'sms', tone: 'urgent',
      template_name: 'Safety Incident - SMS Follow-up',
      subject_line: '',
      body_template: 'Hi {{firstName}}, {{recruiterName}} from {{carrierName}}. We want to check on you following a recent safety report. Your safety is our #1 priority. Please call me at {{recruiterPhone}}.'
    },
    {
      risk_type: 'SAFETY_INCIDENT', channel: 'email', tone: 'urgent',
      template_name: 'Safety Incident - Email Follow-up',
      subject_line: 'Important: Safety follow-up for {{firstName}}',
      body_template: 'Hi {{firstName}},\n\nYour safety is our top priority. Following a recent safety report, we\'d like to schedule a brief review to ensure you have everything you need to stay safe on the road.\n\nPlease reach out at your earliest convenience.\n\nRegards,\n{{recruiterName}}\n{{recruiterPhone}}'
    }
  ];

  let created = 0;
  for (const tmpl of defaults) {
    try {
      await insertData(COLLECTION_KEYS.interventionTemplates, {
        ...tmpl,
        carrier_dot: '',
        is_default: true,
        usage_count: 0,
        success_rate: 0,
        is_active: true
      });
      created++;
    } catch (err) {
      console.warn(`Failed to seed template "${tmpl.template_name}":`, err.message);
    }
  }

  console.log(`[InterventionService] Seeded ${created}/${defaults.length} default templates`);
  return { success: true, created, total: defaults.length };
}

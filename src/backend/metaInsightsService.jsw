import * as dataAccess from 'backend/dataAccess';
import { consumeRequestBudget, executeWithRetryAndCircuit, readWithCache } from 'backend/metaReliabilityService';

const COLLECTIONS = {
  campaignMirror: 'metaCampaignMirror',
  adSetMirror: 'metaAdSetMirror',
  adMirror: 'metaAdMirror',
  creativeMirror: 'metaCreativeMirror',
  insightsDaily: 'metaInsightsDaily',
  insightsIntraday: 'metaInsightsIntraday',
  asyncReportJobs: 'metaAsyncReportJobs'
};

function nowIso() {
  return new Date().toISOString();
}

function makeId(prefix) {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function buildTimeRange(params = {}) {
  const dateRange = params.dateRange || {};
  const end = dateRange.end || params.end || nowIso();
  const start = dateRange.start || params.start || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
  return { start, end };
}

function normalizeInsightRow(row = {}) {
  return {
    spend: Number(row.spend || 0),
    impressions: Number(row.impressions || 0),
    reach: Number(row.reach || 0),
    clicks: Number(row.clicks || 0),
    results: Number(row.results || row.conversions || 0),
    frequency: Number(row.frequency || 0),
    cpl: Number(row.cpl || 0),
    cpc: Number(row.cpc || 0)
  };
}

function mergeInsightTotals(rows = []) {
  const totals = {
    spend: 0,
    impressions: 0,
    reach: 0,
    clicks: 0,
    results: 0,
    frequency: 0,
    cpl: 0,
    cpc: 0
  };

  for (const row of rows) {
    const parsed = normalizeInsightRow(row);
    totals.spend += parsed.spend;
    totals.impressions += parsed.impressions;
    totals.reach += parsed.reach;
    totals.clicks += parsed.clicks;
    totals.results += parsed.results;
  }

  totals.frequency = totals.reach > 0 ? Number((totals.impressions / totals.reach).toFixed(2)) : 0;
  totals.cpl = totals.results > 0 ? Number((totals.spend / totals.results).toFixed(2)) : 0;
  totals.cpc = totals.clicks > 0 ? Number((totals.spend / totals.clicks).toFixed(2)) : 0;
  return totals;
}

async function listInsights(filters = {}, limit = 500, intraday = false) {
  const collection = intraday ? COLLECTIONS.insightsIntraday : COLLECTIONS.insightsDaily;
  const budget = await consumeRequestBudget(`meta_insights.read.${collection}`, {
    limitPerMinute: 180
  });
  if (!budget.allowed) {
    return { success: false, error: budget.error || 'Insights budget exceeded', items: [] };
  }

  const result = await executeWithRetryAndCircuit(
    `meta_insights.query.${collection}`,
    () => dataAccess.queryRecords(collection, {
      filters,
      sort: [{ field: 'timestamp', direction: 'desc' }],
      limit,
      suppressAuth: true
    }),
    {
      context: {
        payload: { collection, filters, limit }
      }
    }
  );

  if (!result.success) {
    return { success: false, error: result.error || 'Failed to query insights', items: [] };
  }
  return { success: true, items: result.items || [] };
}

async function getMirrorEntityIds(entityType, params = {}) {
  const carrierDot = params.carrierDot || '';
  const cacheKey = `meta_mirror_ids:${entityType}:${carrierDot || 'all'}`;
  try {
    return await readWithCache(cacheKey, async () => {
      if (entityType === 'campaign') {
        const rows = await dataAccess.queryRecords(COLLECTIONS.campaignMirror, {
          filters: carrierDot ? { carrierDot } : {},
          limit: 200,
          suppressAuth: true
        });
        if (!rows.success) {
          throw new Error(rows.error || 'Failed to load campaign mirror IDs');
        }
        return (rows.items || []).map(r => r.campaign_id).filter(Boolean);
      }
      if (entityType === 'ad_set') {
        const rows = await dataAccess.queryRecords(COLLECTIONS.adSetMirror, {
          filters: carrierDot ? { carrierDot } : {},
          limit: 400,
          suppressAuth: true
        });
        if (!rows.success) {
          throw new Error(rows.error || 'Failed to load ad set mirror IDs');
        }
        return (rows.items || []).map(r => r.ad_set_id).filter(Boolean);
      }
      const rows = await dataAccess.queryRecords(COLLECTIONS.adMirror, {
        filters: carrierDot ? { carrierDot } : {},
        limit: 600,
        suppressAuth: true
      });
      if (!rows.success) {
        throw new Error(rows.error || 'Failed to load ad mirror IDs');
      }
      return (rows.items || []).map(r => r.ad_id).filter(Boolean);
    }, 90 * 1000);
  } catch (error) {
    return [];
  }
}

async function getInsightsForEntity(entityType, params = {}, options = {}) {
  const ids = params.ids && Array.isArray(params.ids) ? params.ids : await getMirrorEntityIds(entityType, params);
  const range = buildTimeRange(params);
  const intraday = Boolean(options.intraday);
  const rows = [];

  for (const id of ids) {
    const filters = {
      entity_type: entityType,
      entity_id: id,
      timestamp: { gte: range.start, lte: range.end }
    };
    const result = await listInsights(filters, 500, intraday);
    if (!result.success) {
      return {
        success: false,
        entityType,
        timeRange: range,
        ids,
        rows,
        totals: mergeInsightTotals(rows),
        failedEntityId: id,
        error: result.error || 'Failed to query insights'
      };
    }
    rows.push(...result.items);
  }

  return {
    success: true,
    entityType,
    timeRange: range,
    ids,
    rows,
    totals: mergeInsightTotals(rows)
  };
}

function buildBreakdown(rows = [], breakdownBy = 'placement') {
  const grouped = {};
  for (const row of rows) {
    const key = row[breakdownBy] || 'unknown';
    if (!grouped[key]) {
      grouped[key] = {
        key,
        spend: 0,
        impressions: 0,
        reach: 0,
        clicks: 0,
        results: 0
      };
    }
    const parsed = normalizeInsightRow(row);
    grouped[key].spend += parsed.spend;
    grouped[key].impressions += parsed.impressions;
    grouped[key].reach += parsed.reach;
    grouped[key].clicks += parsed.clicks;
    grouped[key].results += parsed.results;
  }
  return Object.values(grouped).map(item => ({
    ...item,
    cpl: item.results > 0 ? Number((item.spend / item.results).toFixed(2)) : 0,
    cpc: item.clicks > 0 ? Number((item.spend / item.clicks).toFixed(2)) : 0
  }));
}

export async function getInsightsCampaignLevel(recruiterId, params = {}) {
  return getInsightsForEntity('campaign', params, { intraday: false, recruiterId });
}

export async function getInsightsAdSetLevel(recruiterId, params = {}) {
  return getInsightsForEntity('ad_set', params, { intraday: false, recruiterId });
}

export async function getInsightsAdLevel(recruiterId, params = {}) {
  return getInsightsForEntity('ad', params, { intraday: false, recruiterId });
}

export async function getInsightsWithBreakdowns(recruiterId, params = {}) {
  const entityType = params.entityType || 'campaign';
  const breakdownBy = params.breakdownBy || 'placement';
  const result = await getInsightsForEntity(entityType, params, { intraday: true, recruiterId });
  if (!result.success) return result;

  return {
    ...result,
    breakdownBy,
    breakdown: buildBreakdown(result.rows, breakdownBy)
  };
}

export async function createAsyncReportJob(recruiterId, params = {}) {
  const payload = {
    job_id: params.jobId || makeId('meta_report'),
    recruiter_id: recruiterId || '',
    report_scope: params.reportScope || 'campaign',
    status: 'queued',
    format: params.format || 'json',
    date_range: buildTimeRange(params),
    breakdown_by: params.breakdownBy || '',
    requested_at: nowIso(),
    updated_at: nowIso()
  };

  const insert = await dataAccess.insertRecord(COLLECTIONS.asyncReportJobs, payload, { suppressAuth: true });
  if (!insert.success) {
    return { success: false, error: insert.error || 'Failed to create async report job' };
  }
  return { success: true, job: insert.record || payload };
}

async function getAsyncJobById(jobId) {
  const query = await dataAccess.queryRecords(COLLECTIONS.asyncReportJobs, {
    filters: { job_id: jobId },
    limit: 1,
    suppressAuth: true
  });
  return query.success && query.items.length > 0 ? query.items[0] : null;
}

export async function getAsyncReportStatus(recruiterId, params = {}) {
  const jobId = params.jobId || '';
  if (!jobId) return { success: false, error: 'Missing required field: jobId' };
  const job = await getAsyncJobById(jobId);
  if (!job) return { success: false, error: `Async report job not found: ${jobId}` };

  return {
    success: true,
    job: {
      jobId: job.job_id,
      status: job.status || 'queued',
      rowCount: Number(job.row_count || 0),
      requestedAt: job.requested_at || null,
      completedAt: job.completed_at || null,
      downloadUrl: job.download_url || ''
    }
  };
}

export async function downloadReport(recruiterId, params = {}) {
  const jobId = params.jobId || '';
  if (!jobId) return { success: false, error: 'Missing required field: jobId' };
  const job = await getAsyncJobById(jobId);
  if (!job) return { success: false, error: `Async report job not found: ${jobId}` };
  if (job.status !== 'completed') {
    return { success: false, error: `Report is not ready (status: ${job.status || 'queued'})` };
  }

  let payload = [];
  try {
    payload = JSON.parse(job.report_payload || '[]');
  } catch (error) {
    payload = [];
  }

  return {
    success: true,
    jobId,
    format: job.format || 'json',
    rows: payload,
    rowCount: Number(job.row_count || payload.length || 0),
    downloadUrl: job.download_url || ''
  };
}

export async function getCreativePerformance(recruiterId, params = {}) {
  const creatives = await dataAccess.queryRecords(COLLECTIONS.creativeMirror, {
    filters: params.campaignId ? { campaign_id: params.campaignId } : {},
    limit: 400,
    suppressAuth: true
  });

  if (!creatives.success) {
    return { success: false, error: creatives.error || 'Failed to query creatives', items: [] };
  }

  const range = buildTimeRange(params);
  const items = [];
  for (const creative of creatives.items || []) {
    const insights = await dataAccess.queryRecords(COLLECTIONS.insightsIntraday, {
      filters: {
        creative_id: creative.creative_id,
        timestamp: { gte: range.start, lte: range.end }
      },
      limit: 200,
      suppressAuth: true
    });
    const rows = insights.success ? (insights.items || []) : [];
    items.push({
      creativeId: creative.creative_id,
      creativeName: creative.name || '',
      headline: creative.headline || '',
      totals: mergeInsightTotals(rows)
    });
  }
  return { success: true, timeRange: range, items };
}

export async function getPlacementPerformance(recruiterId, params = {}) {
  const result = await getInsightsWithBreakdowns(recruiterId, { ...params, breakdownBy: 'placement', entityType: 'campaign' });
  if (!result.success) return result;
  return { success: true, timeRange: result.timeRange, breakdown: result.breakdown };
}

export async function getFrequencyFatigueAlerts(recruiterId, params = {}) {
  const result = await getInsightsForEntity('campaign', params, { intraday: true });
  if (!result.success) return result;

  const threshold = Number(params.frequencyThreshold || 2.8);
  const alerts = result.rows
    .map(row => ({
      entityId: row.entity_id || '',
      campaignId: row.campaign_id || row.entity_id || '',
      placement: row.placement || 'unknown',
      frequency: Number(row.frequency || 0),
      spend: Number(row.spend || 0),
      timestamp: row.timestamp || ''
    }))
    .filter(item => item.frequency >= threshold)
    .sort((a, b) => b.frequency - a.frequency);

  return {
    success: true,
    threshold,
    alerts,
    totalAlerts: alerts.length
  };
}

export async function suggestBudgetReallocation(recruiterId, params = {}) {
  const insights = await getInsightsCampaignLevel(recruiterId, params);
  if (!insights.success) return insights;

  const byCampaign = {};
  for (const row of insights.rows) {
    const campaignId = row.entity_id || row.campaign_id || 'unknown';
    if (!byCampaign[campaignId]) byCampaign[campaignId] = [];
    byCampaign[campaignId].push(row);
  }

  const suggestions = Object.entries(byCampaign).map(([campaignId, rows]) => {
    const totals = mergeInsightTotals(rows);
    const action = totals.cpl > 120 ? 'decrease' : (totals.cpl > 0 && totals.cpl < 60 ? 'increase' : 'hold');
    const deltaPct = action === 'increase' ? 15 : (action === 'decrease' ? -20 : 0);
    return {
      campaignId,
      currentCpl: totals.cpl,
      spend: totals.spend,
      results: totals.results,
      recommendation: action,
      budgetDeltaPct: deltaPct,
      rationale: action === 'hold' ? 'Performance is within expected CPL band' : `CPL trend indicates ${action} budget`
    };
  });

  return { success: true, suggestions };
}

export async function suggestCreativeRotation(recruiterId, params = {}) {
  const creatives = await getCreativePerformance(recruiterId, params);
  if (!creatives.success) return creatives;
  const suggestions = creatives.items
    .map(item => ({
      creativeId: item.creativeId,
      creativeName: item.creativeName,
      cpl: item.totals.cpl,
      ctr: item.totals.impressions > 0 ? Number(((item.totals.clicks / item.totals.impressions) * 100).toFixed(2)) : 0
    }))
    .filter(item => item.cpl > 90 || item.ctr < 0.8)
    .map(item => ({
      ...item,
      recommendation: 'rotate',
      rationale: item.cpl > 90 ? 'High CPL relative to cohort' : 'Low CTR indicates fatigue'
    }));
  return { success: true, suggestions };
}

export async function suggestAudienceNarrowing(recruiterId, params = {}) {
  const placement = await getPlacementPerformance(recruiterId, params);
  if (!placement.success) return placement;
  const suggestions = placement.breakdown
    .filter(item => item.spend > 0)
    .map(item => ({
      placement: item.key,
      cpl: item.cpl,
      recommendation: item.cpl > 100 ? 'narrow_audience' : 'keep',
      rationale: item.cpl > 100 ? 'Placement-level CPL is above threshold' : 'Placement operating in expected range'
    }));
  return { success: true, suggestions };
}

export async function processPendingMetaAsyncReports() {
  const budget = await consumeRequestBudget('meta_async_reports.poll', {
    limitPerMinute: 18
  });
  if (!budget.allowed) {
    return { success: false, error: budget.error || 'Async report poll budget exceeded', processed: 0 };
  }

  const jobs = await executeWithRetryAndCircuit(
    'meta_async_reports.query_queued',
    () => dataAccess.queryRecords(COLLECTIONS.asyncReportJobs, {
      filters: { status: 'queued' },
      sort: [{ field: 'requested_at', direction: 'asc' }],
      limit: budget.remainingPct <= 25 ? 8 : 25,
      suppressAuth: true
    }),
    { context: { payload: { status: 'queued' } } }
  );
  if (!jobs.success) {
    return { success: false, error: jobs.error || 'Failed to query pending async reports', processed: 0 };
  }

  let processed = 0;
  for (const job of jobs.items || []) {
    if (budget.remainingPct <= 10) {
      await sleep(1200);
    } else if (budget.remainingPct <= 25) {
      await sleep(350);
    }

    const statusUpdate = await dataAccess.updateRecord(COLLECTIONS.asyncReportJobs, {
      ...job,
      status: 'processing',
      started_at: nowIso(),
      updated_at: nowIso()
    }, { suppressAuth: true });
    if (!statusUpdate.success) {
      continue;
    }

    let rows = [];
    const scope = job.report_scope || 'campaign';
    if (scope === 'ad_set') {
      const result = await getInsightsAdSetLevel(job.recruiter_id || '', job.date_range || {});
      if (!result.success) {
        await dataAccess.updateRecord(COLLECTIONS.asyncReportJobs, {
          ...statusUpdate.record,
          status: 'failed',
          completed_at: nowIso(),
          row_count: 0,
          error_message: result.error || 'Failed to load ad set insights',
          updated_at: nowIso()
        }, { suppressAuth: true });
        continue;
      }
      rows = result.rows || [];
    } else if (scope === 'ad') {
      const result = await getInsightsAdLevel(job.recruiter_id || '', job.date_range || {});
      if (!result.success) {
        await dataAccess.updateRecord(COLLECTIONS.asyncReportJobs, {
          ...statusUpdate.record,
          status: 'failed',
          completed_at: nowIso(),
          row_count: 0,
          error_message: result.error || 'Failed to load ad insights',
          updated_at: nowIso()
        }, { suppressAuth: true });
        continue;
      }
      rows = result.rows || [];
    } else {
      const result = await getInsightsCampaignLevel(job.recruiter_id || '', job.date_range || {});
      if (!result.success) {
        await dataAccess.updateRecord(COLLECTIONS.asyncReportJobs, {
          ...statusUpdate.record,
          status: 'failed',
          completed_at: nowIso(),
          row_count: 0,
          error_message: result.error || 'Failed to load campaign insights',
          updated_at: nowIso()
        }, { suppressAuth: true });
        continue;
      }
      rows = result.rows || [];
    }

    await dataAccess.updateRecord(COLLECTIONS.asyncReportJobs, {
      ...statusUpdate.record,
      status: 'completed',
      completed_at: nowIso(),
      row_count: rows.length,
      report_payload: JSON.stringify(rows),
      download_url: `https://www.lastmiledr.app/api/meta/reports/${job.job_id}`,
      updated_at: nowIso()
    }, { suppressAuth: true });

    processed++;
  }

  return { success: true, processed };
}

export async function syncMetaInsightsSnapshot() {
  const campaigns = await dataAccess.queryRecords(COLLECTIONS.campaignMirror, {
    filters: {},
    limit: 300,
    suppressAuth: true
  });
  if (!campaigns.success) {
    return { success: false, error: campaigns.error || 'Failed to load campaign mirror for snapshot sync' };
  }

  let dailyUpserts = 0;
  let intradayInserts = 0;
  for (const campaign of campaigns.items || []) {
    const baseSpend = Number(campaign.daily_budget || campaign.dailyBudget || 0);
    const spend = baseSpend > 0 ? baseSpend : 150;
    const impressions = Math.round(spend * 115);
    const reach = Math.round(impressions * 0.72);
    const clicks = Math.round(impressions * 0.015);
    const results = Math.max(1, Math.round(clicks * 0.08));
    const insightKey = `${campaign.campaign_id || 'campaign'}_${new Date().toISOString().slice(0, 10)}`;

    const daily = await dataAccess.upsertRecord(
      COLLECTIONS.insightsDaily,
      'insight_key',
      insightKey,
      {
        insight_key: insightKey,
        entity_type: 'campaign',
        entity_id: campaign.campaign_id || '',
        campaign_id: campaign.campaign_id || '',
        spend,
        impressions,
        reach,
        clicks,
        results,
        cpl: Number((spend / results).toFixed(2)),
        cpc: Number((spend / clicks).toFixed(2)),
        frequency: Number((impressions / Math.max(reach, 1)).toFixed(2)),
        timestamp: nowIso(),
        date: new Date().toISOString().slice(0, 10),
        updated_at: nowIso()
      },
      { suppressAuth: true }
    );
    if (daily.success) dailyUpserts++;

    const intraday = await dataAccess.insertRecord(COLLECTIONS.insightsIntraday, {
      entity_type: 'campaign',
      entity_id: campaign.campaign_id || '',
      campaign_id: campaign.campaign_id || '',
      placement: 'facebook_feed',
      spend: Number((spend * 0.6).toFixed(2)),
      impressions: Math.round(impressions * 0.62),
      reach: Math.round(reach * 0.63),
      clicks: Math.round(clicks * 0.58),
      results: Math.max(1, Math.round(results * 0.56)),
      frequency: Number(((impressions * 0.62) / Math.max(Math.round(reach * 0.63), 1)).toFixed(2)),
      timestamp: nowIso(),
      created_at: nowIso()
    }, { suppressAuth: true });
    if (intraday.success) intradayInserts++;
  }

  return {
    success: true,
    campaignsScanned: (campaigns.items || []).length,
    dailyUpserts,
    intradayInserts
  };
}

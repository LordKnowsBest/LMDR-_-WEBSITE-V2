import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';
import * as dataAccess from 'backend/dataAccess';
import { seedFuelPrices, seedFuelTrends } from 'backend/seeds/seedMockData';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    fuelPrices: 'fuelPrices',
    fuelCards: 'fuelCards',
    roadUtilityCache: 'roadUtilityCache',
    fuelPriceTrends: 'fuelPriceTrends'
};

// Local Haversine formula
function calculateDistance(lat1, lng1, lat2, lng2) {
    if (!lat1 || !lng1 || !lat2 || !lng2) return 0;
    const R = 3958.8; // Earth's radius in miles
    const toRad = (v) => (v * Math.PI) / 180;
    const dLat = toRad(lat2 - lat1); const dLon = toRad(lng2 - lng1);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

const FUEL_CARD_DISCOUNTS = {
    comdata: { base: 0.05, premium: 0.08 }, efs: { base: 0.04, premium: 0.07 }, tcheck: { base: 0.03, premium: 0.06 },
    fleetone: { base: 0.04, premium: 0.065 }, wex: { base: 0.035, premium: 0.055 }
};

export async function searchFuelPrices(lat, lng, radius = 50, options = {}) {
    const cacheKey = `fuel:${lat.toFixed(2)}:${lng.toFixed(2)}:${radius}:${options.cardType || 'none'}`;
    try {
        const cacheRes = await dataAccess.queryRecords(COLLECTION_KEYS.roadUtilityCache, {
            filters: { cache_key: cacheKey, expires_at: { gt: new Date() } }, limit: 1, suppressAuth: true
        });
        if (cacheRes.items?.length) return { success: true, items: cacheRes.items[0].data, fromCache: true };

        const dbRes = await dataAccess.queryRecords(COLLECTION_KEYS.fuelPrices, { limit: 1000, suppressAuth: true });
        let items = dbRes.items || [];
        if (!items.length) {
            await seedFuelPrices(lat, lng, radius);
            const reRes = await dataAccess.queryRecords(COLLECTION_KEYS.fuelPrices, { limit: 1000, suppressAuth: true });
            items = reRes.items || [];
        }

        const nearby = items.map(s => {
            const d = calculateDistance(parseFloat(lat), parseFloat(lng), parseFloat(s.location?.lat), parseFloat(s.location?.lng));
            return { ...s, distance_miles: parseFloat(d.toFixed(2)) };
        }).filter(s => s.distance_miles <= radius);

        const processed = nearby.map(s => {
            let disc = 0;
            if (options.cardType && s.card_discounts?.[options.cardType]) disc = s.card_discounts[options.cardType];
            else if (options.cardType && FUEL_CARD_DISCOUNTS[options.cardType]) disc = FUEL_CARD_DISCOUNTS[options.cardType].base;
            const effective = parseFloat(((s.diesel_price || 3.50) - disc).toFixed(3));
            return { ...s, retail_price: s.diesel_price || 3.50, discount_applied: disc, effective_price: effective, savings_per_gallon: disc, savings_per_fill: parseFloat((disc * 150).toFixed(2)) };
        });

        processed.sort((a, b) => a.effective_price - b.effective_price);
        const final = processed.slice(0, 25);
        const expiry = new Date(); expiry.setMinutes(expiry.getMinutes() + 15);
        await dataAccess.insertRecord(COLLECTION_KEYS.roadUtilityCache, { cache_key: cacheKey, cache_type: 'fuel', data: final, expires_at: expiry }, { suppressAuth: true }).catch(()=>{});

        return { success: true, items: final };
    } catch (e) { return { success: false, error: e.message }; }
}

export async function getFuelAlongRoute(routePoints, options = {}) {
    if (!Array.isArray(routePoints) || routePoints.length < 2) return { success: false, error: 'Invalid' };
    try {
        const all = []; const seen = new Set();
        const max = options.maxStops || 5;
        const step = Math.max(1, Math.floor(routePoints.length / max));
        for (let i = 0; i < routePoints.length; i += step) {
            const res = await searchFuelPrices(routePoints[i].lat, routePoints[i].lng, 25, { cardType: options.cardType });
            if (res.success) {
                res.items.slice(0, 3).forEach(s => {
                    if (!seen.has(s._id)) { s.route_mile = i * 10; all.push(s); seen.add(s._id); }
                });
            }
        }
        return { success: true, items: all.sort((a, b) => a.effective_price - b.effective_price) };
    } catch (e) { return { success: false, error: e.message }; }
}

export async function calculateFuelSavings(driverId, tripDetails) {
    const { gallonsNeeded: g, currentPrice: p = 3.50, cardType = 'none' } = tripDetails;
    if (!g || g <= 0) return { success: false, error: 'Invalid gallons' };
    try {
        let best = null;
        if (tripDetails.routePoints?.length >= 2) {
            const res = await getFuelAlongRoute(tripDetails.routePoints, { cardType });
            if (res.success && res.items.length) best = res.items[0];
        } else if (tripDetails.lat && tripDetails.lng) {
            const res = await searchFuelPrices(tripDetails.lat, tripDetails.lng, 50, { cardType });
            if (res.success && res.items.length) best = res.items[0];
        }
        const bestPrice = best ? best.effective_price : p;
        return { success: true, calculation: { gallons: g, currentPrice: p, totalSavings: parseFloat(((p - bestPrice) * g).toFixed(2)), cheapestPrice: bestPrice } };
    } catch (e) { return { success: false, error: e.message }; }
}

export async function linkFuelCard(driverId, cardInfo) {
    const { cardType, last4 } = cardInfo;
    const existing = await dataAccess.queryRecords(COLLECTION_KEYS.fuelCards, { filters: { driver_id: driverId, card_type: cardType, card_number_last4: last4 }, limit: 1, suppressAuth: true });
    if (existing.items?.length) return { success: false, error: 'Already linked' };

    const count = await dataAccess.countRecords(COLLECTION_KEYS.fuelCards, { driver_id: driverId });
    if (count >= 5) return { success: false, error: 'Limit reached' };

    const res = await dataAccess.insertRecord(COLLECTION_KEYS.fuelCards, { driver_id: driverId, card_type: cardType, card_number_last4: last4, nickname: cardInfo.nickname || `${cardType.toUpperCase()} ****${last4}`, is_primary: count === 0, linked_at: new Date() }, { suppressAuth: true });
    return { success: res.success, card: res.record };
}

export async function getDriverFuelCards(driverId) {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.fuelCards, { filters: { driver_id: driverId }, sort: [{ field: 'is_primary', direction: 'desc' }], limit: 10, suppressAuth: true });
    return { success: true, cards: res.items || [] };
}

export async function unlinkFuelCard(driverId, cardId) {
    const card = await dataAccess.getRecord(COLLECTION_KEYS.fuelCards, cardId, { suppressAuth: true });
    if (!card || card.driver_id !== driverId) return { success: false, error: 'Denied' };
    await dataAccess.removeRecord(COLLECTION_KEYS.fuelCards, cardId, { suppressAuth: true });
    return { success: true };
}

// ============================================================================
// AGENT-FACING EXPORTS (Phase 1 Agentic Buildout)
// ============================================================================

/**
 * Find diesel prices near a location. Agent-facing wrapper around searchFuelPrices.
 * @param {Object} location - { latitude, longitude, city, state }
 * @param {Object} filters - { radius_miles, max_results, sort_by }
 * @returns {{ items: Array, totalCount: number } | { error: string }}
 */
export async function findDieselPrices(location = {}, filters = {}) {
    try {
        const lat = Number(location.latitude);
        const lng = Number(location.longitude);
        const radius = Math.min(Number(filters.radius_miles) || 50, 150);
        const maxResults = Math.min(Number(filters.max_results) || 20, 50);

        if (isNaN(lat) || isNaN(lng)) {
            // Fallback: query by state if no coordinates
            if (location.state) {
                const res = await dataAccess.queryRecords(COLLECTION_KEYS.fuelPrices, {
                    filters: { state: location.state },
                    limit: maxResults,
                    suppressAuth: true
                });
                return { items: res.items || [], totalCount: (res.items || []).length };
            }
            return { error: 'latitude/longitude or state is required' };
        }

        const result = await searchFuelPrices(lat, lng, radius, {});
        if (!result.success) return { error: result.error };

        const sortBy = filters.sort_by || 'price';
        let items = result.items || [];

        if (sortBy === 'distance') {
            items.sort((a, b) => (a.distance_miles || Infinity) - (b.distance_miles || Infinity));
        }
        // Default already sorted by price from searchFuelPrices

        return { items: items.slice(0, maxResults), totalCount: Math.min(items.length, maxResults) };
    } catch (error) {
        console.error('[FuelService] findDieselPrices error:', error.message);
        return { error: error.message };
    }
}

/**
 * Estimate fuel cost for a planned trip.
 * @param {string} origin - Origin city/state (e.g. "Memphis, TN")
 * @param {string} destination - Destination city/state
 * @param {Object} truckConfig - { truck_mpg, tank_capacity_gallons, current_fuel_level_gallons }
 * @returns {{ estimatedCost: number, estimatedGallons: number, avgPricePerGallon: number } | { error: string }}
 */
export async function calculateTripFuelCost(origin, destination, truckConfig = {}) {
    try {
        if (!origin) return { error: 'origin is required' };
        if (!destination) return { error: 'destination is required' };

        const mpg = Number(truckConfig.truck_mpg) || 6.5;

        // Extract state codes
        const originState = extractStateCode(origin);
        const destState = extractStateCode(destination);
        const uniqueStates = [...new Set([originState, destState].filter(Boolean))];

        let totalPrice = 0;
        let priceCount = 0;

        for (const st of uniqueStates) {
            const priceResult = await dataAccess.queryRecords(COLLECTION_KEYS.fuelPrices, {
                filters: { state: st },
                limit: 50,
                suppressAuth: true
            });
            const prices = (priceResult.items || []).map(p => Number(p.diesel_price)).filter(p => p > 0);
            if (prices.length > 0) {
                totalPrice += prices.reduce((a, b) => a + b, 0);
                priceCount += prices.length;
            }
        }

        const avgPricePerGallon = priceCount > 0 ? Math.round((totalPrice / priceCount) * 100) / 100 : 3.85;
        const estimatedMiles = 500;
        const estimatedGallons = Math.round((estimatedMiles / mpg) * 10) / 10;
        const estimatedCost = Math.round(estimatedGallons * avgPricePerGallon * 100) / 100;

        return {
            estimatedCost,
            estimatedGallons,
            avgPricePerGallon,
            estimatedMiles,
            mpg,
            note: 'Distance is estimated. Use with route planner for accurate mileage.'
        };
    } catch (error) {
        console.error('[FuelService] calculateTripFuelCost error:', error.message);
        return { error: error.message };
    }
}

function extractStateCode(cityState) {
    if (!cityState || typeof cityState !== 'string') return '';
    const parts = cityState.split(',');
    if (parts.length >= 2) return parts[parts.length - 1].trim().substring(0, 2).toUpperCase();
    return cityState.trim().substring(0, 2).toUpperCase();
}

export async function getFuelPriceTrends(state, days = 30) {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.fuelPriceTrends, { filters: { state }, sort: [{ field: 'date', direction: 'desc' }], limit: days, suppressAuth: true });
    let trends = res.items || [];
    if (!trends.length) {
        await seedFuelTrends(state);
        const re = await dataAccess.queryRecords(COLLECTION_KEYS.fuelPriceTrends, { filters: { state }, sort: [{ field: 'date', direction: 'desc' }], limit: days, suppressAuth: true });
        trends = re.items || [];
    }
    return { success: true, state, trends: trends.sort((a,b) => new Date(a.date) - new Date(b.date)) };
}

/**
 * Fuel Service - Help drivers find cheapest diesel and calculate savings
 *
 * Features:
 * - Search diesel prices near location with fuel card discounts
 * - Route-based fuel planning
 * - Savings calculator
 * - Fuel card management
 * - Regional price trends
 */

import wixData from 'wix-data';
import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';
import { calculateDistance } from 'backend/locationService';

const COLLECTIONS = {
    PRICES: 'FuelPrices',
    CARDS: 'FuelCards',
    CACHE: 'RoadUtilityCache'
};

// Fuel card discount rates (cents per gallon)
const FUEL_CARD_DISCOUNTS = {
    comdata: { base: 0.05, premium: 0.08 },
    efs: { base: 0.04, premium: 0.07 },
    tcheck: { base: 0.03, premium: 0.06 },
    fleetone: { base: 0.04, premium: 0.065 },
    wex: { base: 0.035, premium: 0.055 }
};

// Cache TTL in minutes
const CACHE_TTL_MINUTES = 15;

/**
 * Search for diesel prices near location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} radius - Search radius in miles (default 50)
 * @param {Object} options - { cardType, amenities, minRating }
 */
export async function searchFuelPrices(lat, lng, radius = 50, options = {}) {
    const cacheKey = `fuel:${lat.toFixed(2)}:${lng.toFixed(2)}:${radius}:${options.cardType || 'none'}`;

    try {
        // 1. Check cache first
        const cached = await wixData.query(COLLECTIONS.CACHE)
            .eq('cache_key', cacheKey)
            .gt('expires_at', new Date())
            .limit(1)
            .find({ suppressAuth: true });

        if (cached.items.length > 0) {
            console.log('[FuelService] Cache hit for:', cacheKey);
            return { success: true, items: cached.items[0].data, fromCache: true };
        }

        // 2. Query local database (populated by scheduled job from GasBuddy/OPIS)
        const results = await wixData.query(COLLECTIONS.PRICES)
            .limit(1000)
            .find({ suppressAuth: true });

        let items = results.items || [];

        // If no local data, generate mock data for demo purposes
        if (items.length === 0) {
            items = generateMockFuelData(lat, lng, radius);
        }

        // 3. Filter by radius and calculate distance
        const nearbyStations = items.filter(station => {
            if (!station.location?.lat || !station.location?.lng) return false;
            const stationLat = parseFloat(station.location.lat);
            const stationLng = parseFloat(station.location.lng);
            if (isNaN(stationLat) || isNaN(stationLng)) return false;

            const distance = calculateDistance(
                parseFloat(lat),
                parseFloat(lng),
                stationLat,
                stationLng
            );

            // Defensive check for invalid distance
            if (typeof distance !== 'number' || isNaN(distance)) {
                console.warn('[FuelService] Invalid distance calculated:', { lat, lng, stationLat, stationLng, distance });
                return false;
            }

            station.distance_miles = parseFloat(distance.toFixed(2));
            return distance <= radius;
        });

        // 4. Apply fuel card discounts
        const processedStations = nearbyStations.map(station => {
            let discount = 0;
            let discountSource = 'none';

            // Check station-specific discounts first
            if (options.cardType && station.card_discounts && station.card_discounts[options.cardType]) {
                discount = station.card_discounts[options.cardType];
                discountSource = 'station';
            }
            // Fall back to standard card discount
            else if (options.cardType && FUEL_CARD_DISCOUNTS[options.cardType]) {
                discount = FUEL_CARD_DISCOUNTS[options.cardType].base;
                discountSource = 'standard';
            }

            const retailPrice = station.diesel_price || 3.50;
            const effectivePrice = parseFloat((retailPrice - discount).toFixed(3));

            return {
                ...station,
                retail_price: retailPrice,
                discount_applied: discount,
                discount_source: discountSource,
                effective_price: effectivePrice,
                savings_per_gallon: discount,
                savings_per_fill: parseFloat((discount * 150).toFixed(2)) // Assume 150 gal fill
            };
        });

        // 5. Filter by amenities if specified
        let finalItems = processedStations;
        if (options.amenities && Array.isArray(options.amenities) && options.amenities.length > 0) {
            finalItems = processedStations.filter(station =>
                options.amenities.every(amenity => station.amenities && station.amenities.includes(amenity))
            );
        }

        // 6. Sort by effective price (cheapest first)
        finalItems.sort((a, b) => a.effective_price - b.effective_price);

        // 7. Limit to top 25 results
        finalItems = finalItems.slice(0, 25);

        // 8. Store in cache
        const expiry = new Date();
        expiry.setMinutes(expiry.getMinutes() + CACHE_TTL_MINUTES);

        await wixData.insert(COLLECTIONS.CACHE, {
            cache_key: cacheKey,
            cache_type: 'fuel',
            data: finalItems,
            expires_at: expiry
        }, { suppressAuth: true }).catch(err => console.warn('[FuelService] Cache write failed:', err.message));

        return { success: true, items: finalItems };
    } catch (error) {
        console.error('[FuelService] searchFuelPrices failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Generate mock fuel data for demo/development
 */
function generateMockFuelData(centerLat, centerLng, radius) {
    const brands = ['Pilot', 'Flying J', 'Love\'s', 'TA', 'Petro', 'Sapp Bros', 'Kwik Trip', 'Casey\'s'];
    const mockStations = [];

    for (let i = 0; i < 15; i++) {
        const latOffset = (Math.random() - 0.5) * (radius / 35);
        const lngOffset = (Math.random() - 0.5) * (radius / 28);
        const basePrice = 3.20 + Math.random() * 0.80;

        mockStations.push({
            _id: `mock_fuel_${i}`,
            station_id: `MOCK${1000 + i}`,
            brand: brands[Math.floor(Math.random() * brands.length)],
            name: `${brands[Math.floor(Math.random() * brands.length)]} #${100 + i}`,
            location: {
                lat: centerLat + latOffset,
                lng: centerLng + lngOffset
            },
            address: {
                street: `${1000 + i * 100} Interstate Dr`,
                city: 'Memphis',
                state: 'TN',
                zip: '38118'
            },
            diesel_price: parseFloat(basePrice.toFixed(3)),
            def_price: parseFloat((2.50 + Math.random() * 0.50).toFixed(3)),
            card_discounts: {
                comdata: parseFloat((0.04 + Math.random() * 0.04).toFixed(3)),
                efs: parseFloat((0.03 + Math.random() * 0.04).toFixed(3)),
                tcheck: parseFloat((0.02 + Math.random() * 0.03).toFixed(3)),
                fleetone: parseFloat((0.03 + Math.random() * 0.035).toFixed(3))
            },
            amenities: getRandomAmenities(),
            has_def: Math.random() > 0.2,
            has_scales: Math.random() > 0.4,
            has_truck_wash: Math.random() > 0.6,
            price_updated_at: new Date(),
            source: 'mock'
        });
    }

    return mockStations;
}

function getRandomAmenities() {
    const allAmenities = ['shower', 'restaurant', 'wifi', 'scales', 'def', 'truck_wash', 'atm', 'laundry'];
    const count = 2 + Math.floor(Math.random() * 5);
    const shuffled = allAmenities.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
}

/**
 * Get fuel prices along a route
 * @param {Array} routePoints - Array of {lat, lng} waypoints
 * @param {Object} options - { cardType, maxStops }
 */
export async function getFuelAlongRoute(routePoints, options = {}) {
    if (!Array.isArray(routePoints) || routePoints.length < 2) {
        return { success: false, error: 'At least 2 route points required' };
    }

    try {
        const maxStops = options.maxStops || 5;
        const allStations = [];
        const seenIds = new Set();

        // Sample points along the route (every ~100 miles or so)
        const samplePoints = sampleRoutePoints(routePoints, maxStops);

        for (const point of samplePoints) {
            const result = await searchFuelPrices(point.lat, point.lng, 25, {
                cardType: options.cardType
            });

            if (result.success) {
                // Take top 3 from each waypoint
                const top3 = result.items.slice(0, 3);
                for (const station of top3) {
                    if (!seenIds.has(station._id)) {
                        station.route_mile = point.routeMile || 0;
                        allStations.push(station);
                        seenIds.add(station._id);
                    }
                }
            }
        }

        // Sort by effective price
        allStations.sort((a, b) => a.effective_price - b.effective_price);

        return {
            success: true,
            items: allStations,
            routeLength: routePoints.length,
            stopsFound: allStations.length
        };
    } catch (error) {
        console.error('[FuelService] getFuelAlongRoute failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Sample evenly spaced points along a route
 */
function sampleRoutePoints(routePoints, maxSamples) {
    if (routePoints.length <= maxSamples) return routePoints;

    const step = Math.floor(routePoints.length / maxSamples);
    const samples = [];

    for (let i = 0; i < routePoints.length; i += step) {
        samples.push({ ...routePoints[i], routeMile: i * 10 }); // Rough estimate
        if (samples.length >= maxSamples) break;
    }

    // Always include the last point
    if (samples[samples.length - 1] !== routePoints[routePoints.length - 1]) {
        samples.push(routePoints[routePoints.length - 1]);
    }

    return samples;
}

/**
 * Calculate potential fuel savings for a trip
 * @param {string} driverId - Driver ID
 * @param {Object} tripDetails - { gallonsNeeded, currentPrice, cardType, routePoints }
 */
export async function calculateFuelSavings(driverId, tripDetails) {
    if (!tripDetails.gallonsNeeded || tripDetails.gallonsNeeded <= 0) {
        return { success: false, error: 'gallonsNeeded is required and must be positive' };
    }

    try {
        const gallons = tripDetails.gallonsNeeded;
        const currentPrice = tripDetails.currentPrice || 3.50;
        const cardType = tripDetails.cardType || 'none';

        // If route provided, find cheapest along route
        let cheapestStation = null;
        if (tripDetails.routePoints && tripDetails.routePoints.length >= 2) {
            const routeResult = await getFuelAlongRoute(tripDetails.routePoints, { cardType });
            if (routeResult.success && routeResult.items.length > 0) {
                cheapestStation = routeResult.items[0];
            }
        } else if (tripDetails.lat && tripDetails.lng) {
            const searchResult = await searchFuelPrices(tripDetails.lat, tripDetails.lng, 50, { cardType });
            if (searchResult.success && searchResult.items.length > 0) {
                cheapestStation = searchResult.items[0];
            }
        }

        // Calculate savings
        const currentCost = gallons * currentPrice;
        const cheapestPrice = cheapestStation ? cheapestStation.effective_price : currentPrice;
        const cheapestCost = gallons * cheapestPrice;
        const savings = currentCost - cheapestCost;

        // Card discount savings
        let cardDiscount = 0;
        if (cardType !== 'none' && FUEL_CARD_DISCOUNTS[cardType]) {
            cardDiscount = FUEL_CARD_DISCOUNTS[cardType].base;
        }
        const cardSavings = gallons * cardDiscount;

        // Regional average comparison
        const stateAverage = await getStateAveragePrice(tripDetails.state || 'US');
        const vsAverageSavings = gallons * (stateAverage - cheapestPrice);

        return {
            success: true,
            calculation: {
                gallons,
                currentPrice,
                currentCost: parseFloat(currentCost.toFixed(2)),
                cheapestPrice,
                cheapestCost: parseFloat(cheapestCost.toFixed(2)),
                totalSavings: parseFloat(savings.toFixed(2)),
                cardSavings: parseFloat(cardSavings.toFixed(2)),
                vsAverageSavings: parseFloat(vsAverageSavings.toFixed(2)),
                stateAverage,
                cheapestStation: cheapestStation ? {
                    name: cheapestStation.name,
                    brand: cheapestStation.brand,
                    distance_miles: cheapestStation.distance_miles,
                    effective_price: cheapestStation.effective_price
                } : null
            }
        };
    } catch (error) {
        console.error('[FuelService] calculateFuelSavings failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get state average diesel price (mock for now)
 */
async function getStateAveragePrice(state) {
    // In production, this would query EIA or other data source
    const stateAverages = {
        'US': 3.75,
        'TX': 3.45, 'CA': 5.20, 'FL': 3.65, 'TN': 3.55,
        'GA': 3.60, 'NC': 3.58, 'OH': 3.70, 'PA': 4.10,
        'IL': 3.85, 'IN': 3.72, 'MO': 3.48, 'AR': 3.42
    };
    return stateAverages[state] || stateAverages['US'];
}

/**
 * Link a fuel card to a driver's profile
 * @param {string} driverId - Driver ID
 * @param {Object} cardInfo - { cardType, last4, nickname }
 */
export async function linkFuelCard(driverId, cardInfo) {
    if (!driverId) return { success: false, error: 'driverId is required' };
    if (!cardInfo.cardType) return { success: false, error: 'cardType is required' };
    if (!cardInfo.last4 || cardInfo.last4.length !== 4) {
        return { success: false, error: 'last4 must be exactly 4 digits' };
    }

    try {
        // Check if card already linked
        const existing = await wixData.query(COLLECTIONS.CARDS)
            .eq('driver_id', driverId)
            .eq('card_type', cardInfo.cardType)
            .eq('card_number_last4', cardInfo.last4)
            .limit(1)
            .find({ suppressAuth: true });

        if (existing.items.length > 0) {
            return { success: false, error: 'This card is already linked to your account' };
        }

        // Check max cards limit (5 per driver)
        const cardCount = await wixData.query(COLLECTIONS.CARDS)
            .eq('driver_id', driverId)
            .count({ suppressAuth: true });

        if (cardCount >= 5) {
            return { success: false, error: 'Maximum of 5 fuel cards allowed per driver' };
        }

        // Determine if this should be primary (first card = primary)
        const isPrimary = cardCount === 0;

        const record = {
            driver_id: driverId,
            card_type: cardInfo.cardType,
            card_number_last4: cardInfo.last4,
            nickname: cardInfo.nickname || `${cardInfo.cardType.toUpperCase()} ****${cardInfo.last4}`,
            is_primary: isPrimary,
            linked_at: new Date()
        };

        const result = await wixData.insert(COLLECTIONS.CARDS, record, { suppressAuth: true });

        return {
            success: true,
            card: {
                _id: result._id,
                cardType: result.card_type,
                last4: result.card_number_last4,
                nickname: result.nickname,
                isPrimary: result.is_primary
            }
        };
    } catch (error) {
        console.error('[FuelService] linkFuelCard failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get driver's linked fuel cards
 * @param {string} driverId - Driver ID
 */
export async function getDriverFuelCards(driverId) {
    if (!driverId) return { success: false, error: 'driverId is required' };

    try {
        const result = await wixData.query(COLLECTIONS.CARDS)
            .eq('driver_id', driverId)
            .descending('is_primary')
            .find({ suppressAuth: true });

        const cards = result.items.map(card => ({
            _id: card._id,
            cardType: card.card_type,
            last4: card.card_number_last4,
            nickname: card.nickname,
            isPrimary: card.is_primary,
            linkedAt: card.linked_at
        }));

        return { success: true, cards };
    } catch (error) {
        console.error('[FuelService] getDriverFuelCards failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Remove a linked fuel card
 * @param {string} driverId - Driver ID
 * @param {string} cardId - Card record ID
 */
export async function unlinkFuelCard(driverId, cardId) {
    if (!driverId || !cardId) {
        return { success: false, error: 'driverId and cardId are required' };
    }

    try {
        // Verify ownership
        const card = await wixData.get(COLLECTIONS.CARDS, cardId, { suppressAuth: true });
        if (!card || card.driver_id !== driverId) {
            return { success: false, error: 'Card not found or access denied' };
        }

        await wixData.remove(COLLECTIONS.CARDS, cardId, { suppressAuth: true });

        // If this was primary, make another card primary
        if (card.is_primary) {
            const remaining = await wixData.query(COLLECTIONS.CARDS)
                .eq('driver_id', driverId)
                .limit(1)
                .find({ suppressAuth: true });

            if (remaining.items.length > 0) {
                remaining.items[0].is_primary = true;
                await wixData.update(COLLECTIONS.CARDS, remaining.items[0], { suppressAuth: true });
            }
        }

        return { success: true, message: 'Card removed successfully' };
    } catch (error) {
        console.error('[FuelService] unlinkFuelCard failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get price trends for a state
 * @param {string} state - State abbreviation
 * @param {number} days - Number of days to look back (default 30)
 */
export async function getFuelPriceTrends(state, days = 30) {
    if (!state) return { success: false, error: 'state is required' };

    try {
        // In production, this would query historical data from EIA or cached API responses
        // For now, generate mock trend data
        const currentAvg = await getStateAveragePrice(state);
        const trends = [];

        for (let i = days; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);

            // Simulate price fluctuation
            const variation = (Math.random() - 0.5) * 0.15;
            const price = currentAvg + variation + (i * 0.002); // Slight downward trend

            trends.push({
                date: date.toISOString().split('T')[0],
                avgPrice: parseFloat(price.toFixed(3))
            });
        }

        // Calculate trend direction
        const firstWeekAvg = trends.slice(0, 7).reduce((sum, t) => sum + t.avgPrice, 0) / 7;
        const lastWeekAvg = trends.slice(-7).reduce((sum, t) => sum + t.avgPrice, 0) / 7;
        const trendChange = lastWeekAvg - firstWeekAvg;

        return {
            success: true,
            state,
            currentAverage: currentAvg,
            trendDirection: trendChange < -0.02 ? 'down' : trendChange > 0.02 ? 'up' : 'stable',
            trendAmount: parseFloat(Math.abs(trendChange).toFixed(3)),
            trends
        };
    } catch (error) {
        console.error('[FuelService] getFuelPriceTrends failed:', error);
        return { success: false, error: error.message };
    }
}
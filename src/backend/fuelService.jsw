/**
 * Fuel Service - Help drivers find cheapest diesel and calculate savings
 *
 * Features:
 * - Search diesel prices near location with fuel card discounts
 * - Route-based fuel planning
 * - Savings calculator
 * - Fuel card management
 * - Regional price trends
 */

import wixData from 'wix-data';
import { getSecret } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';
import { usesAirtable, getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// Collection keys for dual-source routing
const COLLECTION_KEYS = {
    fuelPrices: 'fuelPrices',
    fuelCards: 'fuelCards',
    roadUtilityCache: 'roadUtilityCache'
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

async function queryData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            sort: options.sort,
            maxRecords: options.limit || 100
        });
        return result.records || [];
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) {
            query = query.eq(field, value);
        }
    }
    if (options.gt) {
        for (const [field, value] of Object.entries(options.gt)) {
            query = query.gt(field, value);
        }
    }
    if (options.descending) {
        query = query.descending(options.descending);
    }
    if (options.limit) {
        query = query.limit(options.limit);
    }
    const result = await query.find({ suppressAuth: true });
    return result.items;
}

async function getRecord(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.getRecord(tableName, recordId);
    }
    return await wixData.get(wixCollectionName, recordId, { suppressAuth: true });
}

async function insertData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.createRecord(tableName, data);
    }
    return await wixData.insert(wixCollectionName, data, { suppressAuth: true });
}

async function updateData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.updateRecord(tableName, data._id || data.id, data);
    }
    return await wixData.update(wixCollectionName, data, { suppressAuth: true });
}

async function removeData(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.deleteRecord(tableName, recordId);
    }
    return await wixData.remove(wixCollectionName, recordId, { suppressAuth: true });
}

async function countData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            maxRecords: 1000
        });
        return (result.records || []).length;
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) {
            query = query.eq(field, value);
        }
    }
    return await query.count({ suppressAuth: true });
}

// Local Haversine formula - avoid async overhead from importing .jsw module
function calculateDistance(lat1, lng1, lat2, lng2) {
    if (!lat1 || !lng1 || !lat2 || !lng2) return 0;

    const R = 3958.8; // Earth's radius in miles
    const toRad = (value) => (value * Math.PI) / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lng2 - lng1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

const COLLECTIONS = {
    PRICES: 'FuelPrices',
    CARDS: 'FuelCards',
    CACHE: 'RoadUtilityCache'
};

// Fuel card discount rates (cents per gallon)
const FUEL_CARD_DISCOUNTS = {
    comdata: { base: 0.05, premium: 0.08 },
    efs: { base: 0.04, premium: 0.07 },
    tcheck: { base: 0.03, premium: 0.06 },
    fleetone: { base: 0.04, premium: 0.065 },
    wex: { base: 0.035, premium: 0.055 }
};

// Cache TTL in minutes
const CACHE_TTL_MINUTES = 15;

/**
 * Search for diesel prices near location
 * @param {number} lat - Latitude
 * @param {number} lng - Longitude
 * @param {number} radius - Search radius in miles (default 50)
 * @param {Object} options - { cardType, amenities, minRating }
 */
export async function searchFuelPrices(lat, lng, radius = 50, options = {}) {
    const cacheKey = `fuel:${lat.toFixed(2)}:${lng.toFixed(2)}:${radius}:${options.cardType || 'none'}`;

    try {
        // 1. Check cache first using dual-source routing
        let cachedItems = [];
        if (usesAirtable(COLLECTION_KEYS.roadUtilityCache)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.roadUtilityCache);
            const filter = `AND({Cache Key} = "${cacheKey}", {Expires At} > "${new Date().toISOString()}")`;
            const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
            if (result.records && result.records.length > 0) {
                cachedItems = [{ data: result.records[0].Data || result.records[0].data }];
            }
        } else {
            const cached = await wixData.query(COLLECTIONS.CACHE)
                .eq('cache_key', cacheKey)
                .gt('expires_at', new Date())
                .limit(1)
                .find({ suppressAuth: true });
            cachedItems = cached.items;
        }

        if (cachedItems.length > 0) {
            console.log('[FuelService] Cache hit for:', cacheKey);
            return { success: true, items: cachedItems[0].data, fromCache: true };
        }

        // 2. Query local database using dual-source routing
        let items = [];
        if (usesAirtable(COLLECTION_KEYS.fuelPrices)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.fuelPrices);
            const result = await airtable.queryRecords(tableName, { maxRecords: 1000 });
            items = (result.records || []).map(r => ({
                _id: r.id || r._id,
                station_id: r['Station Id'] || r.station_id,
                brand: r.Brand || r.brand,
                name: r.Name || r.name,
                location: r.Location || r.location,
                diesel_price: r['Diesel Price'] || r.diesel_price,
                def_price: r['Def Price'] || r.def_price,
                card_discounts: r['Card Discounts'] || r.card_discounts,
                amenities: r.Amenities || r.amenities,
                address: r.Address || r.address
            }));
        } else {
            const results = await wixData.query(COLLECTIONS.PRICES)
                .limit(1000)
                .find({ suppressAuth: true });
            items = results.items || [];
        }

        console.log('[FuelService] Database query returned:', items.length, 'items');

        // If no local data, generate mock data for demo purposes
        if (items.length === 0) {
            console.log('[FuelService] Generating mock data for location:', { lat, lng, radius });
            items = generateMockFuelData(lat, lng, radius);
            console.log('[FuelService] Generated', items.length, 'mock stations');
        }

        // 3. Filter by radius and calculate distance
        const nearbyStations = items.filter(station => {
            if (!station.location?.lat || !station.location?.lng) return false;
            const stationLat = parseFloat(station.location.lat);
            const stationLng = parseFloat(station.location.lng);
            if (isNaN(stationLat) || isNaN(stationLng)) return false;

            const distance = calculateDistance(
                parseFloat(lat),
                parseFloat(lng),
                stationLat,
                stationLng
            );

            // Defensive check for invalid distance
            if (typeof distance !== 'number' || isNaN(distance)) {
                console.warn('[FuelService] Invalid distance calculated:', { lat, lng, stationLat, stationLng, distance });
                return false;
            }

            station.distance_miles = parseFloat(distance.toFixed(2));
            return distance <= radius;
        });

        console.log('[FuelService] After radius filter:', nearbyStations.length, 'stations within', radius, 'miles');

        // 4. Apply fuel card discounts
        const processedStations = nearbyStations.map(station => {
            let discount = 0;
            let discountSource = 'none';

            // Check station-specific discounts first
            if (options.cardType && station.card_discounts && station.card_discounts[options.cardType]) {
                discount = station.card_discounts[options.cardType];
                discountSource = 'station';
            }
            // Fall back to standard card discount
            else if (options.cardType && FUEL_CARD_DISCOUNTS[options.cardType]) {
                discount = FUEL_CARD_DISCOUNTS[options.cardType].base;
                discountSource = 'standard';
            }

            const retailPrice = station.diesel_price || 3.50;
            const effectivePrice = parseFloat((retailPrice - discount).toFixed(3));

            return {
                ...station,
                retail_price: retailPrice,
                discount_applied: discount,
                discount_source: discountSource,
                effective_price: effectivePrice,
                savings_per_gallon: discount,
                savings_per_fill: parseFloat((discount * 150).toFixed(2)) // Assume 150 gal fill
            };
        });

        // 5. Filter by amenities if specified
        let finalItems = processedStations;
        if (options.amenities && Array.isArray(options.amenities) && options.amenities.length > 0) {
            finalItems = processedStations.filter(station =>
                options.amenities.every(amenity => station.amenities && station.amenities.includes(amenity))
            );
        }

        // 6. Sort by effective price (cheapest first)
        finalItems.sort((a, b) => a.effective_price - b.effective_price);

        // 7. Limit to top 25 results
        finalItems = finalItems.slice(0, 25);

        // 8. Store in cache using dual-source routing
        const expiry = new Date();
        expiry.setMinutes(expiry.getMinutes() + CACHE_TTL_MINUTES);

        const cacheRecord = {
            cache_key: cacheKey,
            cache_type: 'fuel',
            data: finalItems,
            expires_at: expiry
        };

        await insertData(COLLECTION_KEYS.roadUtilityCache, COLLECTIONS.CACHE, cacheRecord)
            .catch(err => console.warn('[FuelService] Cache write failed:', err.message));

        return { success: true, items: finalItems };
    } catch (error) {
        console.error('[FuelService] searchFuelPrices failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Generate mock fuel data for demo/development
 */
function generateMockFuelData(centerLat, centerLng, radius) {
    const brands = ['Pilot', 'Flying J', 'Love\'s', 'TA', 'Petro', 'Sapp Bros', 'Kwik Trip', 'Casey\'s'];
    const mockStations = [];

    for (let i = 0; i < 15; i++) {
        const latOffset = (Math.random() - 0.5) * (radius / 35);
        const lngOffset = (Math.random() - 0.5) * (radius / 28);
        const basePrice = 3.20 + Math.random() * 0.80;

        mockStations.push({
            _id: `mock_fuel_${i}`,
            station_id: `MOCK${1000 + i}`,
            brand: brands[Math.floor(Math.random() * brands.length)],
            name: `${brands[Math.floor(Math.random() * brands.length)]} #${100 + i}`,
            location: {
                lat: centerLat + latOffset,
                lng: centerLng + lngOffset
            },
            address: {
                street: `${1000 + i * 100} Interstate Dr`,
                city: 'Memphis',
                state: 'TN',
                zip: '38118'
            },
            diesel_price: parseFloat(basePrice.toFixed(3)),
            def_price: parseFloat((2.50 + Math.random() * 0.50).toFixed(3)),
            card_discounts: {
                comdata: parseFloat((0.04 + Math.random() * 0.04).toFixed(3)),
                efs: parseFloat((0.03 + Math.random() * 0.04).toFixed(3)),
                tcheck: parseFloat((0.02 + Math.random() * 0.03).toFixed(3)),
                fleetone: parseFloat((0.03 + Math.random() * 0.035).toFixed(3))
            },
            amenities: getRandomAmenities(),
            has_def: Math.random() > 0.2,
            has_scales: Math.random() > 0.4,
            has_truck_wash: Math.random() > 0.6,
            price_updated_at: new Date(),
            source: 'mock'
        });
    }

    return mockStations;
}

function getRandomAmenities() {
    const allAmenities = ['shower', 'restaurant', 'wifi', 'scales', 'def', 'truck_wash', 'atm', 'laundry'];
    const count = 2 + Math.floor(Math.random() * 5);
    const shuffled = allAmenities.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
}

/**
 * Get fuel prices along a route
 * @param {Array} routePoints - Array of {lat, lng} waypoints
 * @param {Object} options - { cardType, maxStops }
 */
export async function getFuelAlongRoute(routePoints, options = {}) {
    if (!Array.isArray(routePoints) || routePoints.length < 2) {
        return { success: false, error: 'At least 2 route points required' };
    }

    try {
        const maxStops = options.maxStops || 5;
        const allStations = [];
        const seenIds = new Set();

        // Sample points along the route (every ~100 miles or so)
        const samplePoints = sampleRoutePoints(routePoints, maxStops);

        for (const point of samplePoints) {
            const result = await searchFuelPrices(point.lat, point.lng, 25, {
                cardType: options.cardType
            });

            if (result.success) {
                // Take top 3 from each waypoint
                const top3 = result.items.slice(0, 3);
                for (const station of top3) {
                    if (!seenIds.has(station._id)) {
                        station.route_mile = point.routeMile || 0;
                        allStations.push(station);
                        seenIds.add(station._id);
                    }
                }
            }
        }

        // Sort by effective price
        allStations.sort((a, b) => a.effective_price - b.effective_price);

        return {
            success: true,
            items: allStations,
            routeLength: routePoints.length,
            stopsFound: allStations.length
        };
    } catch (error) {
        console.error('[FuelService] getFuelAlongRoute failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Sample evenly spaced points along a route
 */
function sampleRoutePoints(routePoints, maxSamples) {
    if (routePoints.length <= maxSamples) return routePoints;

    const step = Math.floor(routePoints.length / maxSamples);
    const samples = [];

    for (let i = 0; i < routePoints.length; i += step) {
        samples.push({ ...routePoints[i], routeMile: i * 10 }); // Rough estimate
        if (samples.length >= maxSamples) break;
    }

    // Always include the last point
    if (samples[samples.length - 1] !== routePoints[routePoints.length - 1]) {
        samples.push(routePoints[routePoints.length - 1]);
    }

    return samples;
}

/**
 * Calculate potential fuel savings for a trip
 * @param {string} driverId - Driver ID
 * @param {Object} tripDetails - { gallonsNeeded, currentPrice, cardType, routePoints }
 */
export async function calculateFuelSavings(driverId, tripDetails) {
    if (!tripDetails.gallonsNeeded || tripDetails.gallonsNeeded <= 0) {
        return { success: false, error: 'gallonsNeeded is required and must be positive' };
    }

    try {
        const gallons = tripDetails.gallonsNeeded;
        const currentPrice = tripDetails.currentPrice || 3.50;
        const cardType = tripDetails.cardType || 'none';

        // If route provided, find cheapest along route
        let cheapestStation = null;
        if (tripDetails.routePoints && tripDetails.routePoints.length >= 2) {
            const routeResult = await getFuelAlongRoute(tripDetails.routePoints, { cardType });
            if (routeResult.success && routeResult.items.length > 0) {
                cheapestStation = routeResult.items[0];
            }
        } else if (tripDetails.lat && tripDetails.lng) {
            const searchResult = await searchFuelPrices(tripDetails.lat, tripDetails.lng, 50, { cardType });
            if (searchResult.success && searchResult.items.length > 0) {
                cheapestStation = searchResult.items[0];
            }
        }

        // Calculate savings
        const currentCost = gallons * currentPrice;
        const cheapestPrice = cheapestStation ? cheapestStation.effective_price : currentPrice;
        const cheapestCost = gallons * cheapestPrice;
        const savings = currentCost - cheapestCost;

        // Card discount savings
        let cardDiscount = 0;
        if (cardType !== 'none' && FUEL_CARD_DISCOUNTS[cardType]) {
            cardDiscount = FUEL_CARD_DISCOUNTS[cardType].base;
        }
        const cardSavings = gallons * cardDiscount;

        // Regional average comparison
        const stateAverage = await getStateAveragePrice(tripDetails.state || 'US');
        const vsAverageSavings = gallons * (stateAverage - cheapestPrice);

        return {
            success: true,
            calculation: {
                gallons,
                currentPrice,
                currentCost: parseFloat(currentCost.toFixed(2)),
                cheapestPrice,
                cheapestCost: parseFloat(cheapestCost.toFixed(2)),
                totalSavings: parseFloat(savings.toFixed(2)),
                cardSavings: parseFloat(cardSavings.toFixed(2)),
                vsAverageSavings: parseFloat(vsAverageSavings.toFixed(2)),
                stateAverage,
                cheapestStation: cheapestStation ? {
                    name: cheapestStation.name,
                    brand: cheapestStation.brand,
                    distance_miles: cheapestStation.distance_miles,
                    effective_price: cheapestStation.effective_price
                } : null
            }
        };
    } catch (error) {
        console.error('[FuelService] calculateFuelSavings failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get state average diesel price (mock for now)
 */
async function getStateAveragePrice(state) {
    // In production, this would query EIA or other data source
    const stateAverages = {
        'US': 3.75,
        'TX': 3.45, 'CA': 5.20, 'FL': 3.65, 'TN': 3.55,
        'GA': 3.60, 'NC': 3.58, 'OH': 3.70, 'PA': 4.10,
        'IL': 3.85, 'IN': 3.72, 'MO': 3.48, 'AR': 3.42
    };
    return stateAverages[state] || stateAverages['US'];
}

/**
 * Link a fuel card to a driver's profile
 * @param {string} driverId - Driver ID
 * @param {Object} cardInfo - { cardType, last4, nickname }
 */
export async function linkFuelCard(driverId, cardInfo) {
    if (!driverId) return { success: false, error: 'driverId is required' };
    if (!cardInfo.cardType) return { success: false, error: 'cardType is required' };
    if (!cardInfo.last4 || cardInfo.last4.length !== 4) {
        return { success: false, error: 'last4 must be exactly 4 digits' };
    }

    try {
        // Check if card already linked using dual-source routing
        let existingCount = 0;
        if (usesAirtable(COLLECTION_KEYS.fuelCards)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.fuelCards);
            const filter = `AND({Driver Id} = "${driverId}", {Card Type} = "${cardInfo.cardType}", {Card Number Last4} = "${cardInfo.last4}")`;
            const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
            existingCount = (result.records || []).length;
        } else {
            const existing = await wixData.query(COLLECTIONS.CARDS)
                .eq('driver_id', driverId)
                .eq('card_type', cardInfo.cardType)
                .eq('card_number_last4', cardInfo.last4)
                .limit(1)
                .find({ suppressAuth: true });
            existingCount = existing.items.length;
        }

        if (existingCount > 0) {
            return { success: false, error: 'This card is already linked to your account' };
        }

        // Check max cards limit (5 per driver) using dual-source routing
        const cardCount = await countData(COLLECTION_KEYS.fuelCards, COLLECTIONS.CARDS, {
            eq: { driver_id: driverId },
            filter: `{Driver Id} = "${driverId}"`
        });

        if (cardCount >= 5) {
            return { success: false, error: 'Maximum of 5 fuel cards allowed per driver' };
        }

        // Determine if this should be primary (first card = primary)
        const isPrimary = cardCount === 0;

        const record = {
            driver_id: driverId,
            card_type: cardInfo.cardType,
            card_number_last4: cardInfo.last4,
            nickname: cardInfo.nickname || `${cardInfo.cardType.toUpperCase()} ****${cardInfo.last4}`,
            is_primary: isPrimary,
            linked_at: new Date()
        };

        // Use dual-source routing
        const result = await insertData(COLLECTION_KEYS.fuelCards, COLLECTIONS.CARDS, record);

        return {
            success: true,
            card: {
                _id: result._id,
                cardType: result.card_type,
                last4: result.card_number_last4,
                nickname: result.nickname,
                isPrimary: result.is_primary
            }
        };
    } catch (error) {
        console.error('[FuelService] linkFuelCard failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get driver's linked fuel cards
 * @param {string} driverId - Driver ID
 */
export async function getDriverFuelCards(driverId) {
    if (!driverId) return { success: false, error: 'driverId is required' };

    try {
        let resultItems = [];

        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.fuelCards)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.fuelCards);
            const filter = `{Driver Id} = "${driverId}"`;
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                sort: [{ field: 'Is Primary', direction: 'desc' }],
                maxRecords: 100
            });
            resultItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                card_type: r['Card Type'] || r.card_type,
                card_number_last4: r['Card Number Last4'] || r.card_number_last4,
                nickname: r.Nickname || r.nickname,
                is_primary: r['Is Primary'] || r.is_primary,
                linked_at: r['Linked At'] || r.linked_at
            }));
        } else {
            const result = await wixData.query(COLLECTIONS.CARDS)
                .eq('driver_id', driverId)
                .descending('is_primary')
                .find({ suppressAuth: true });
            resultItems = result.items;
        }

        const cards = resultItems.map(card => ({
            _id: card._id,
            cardType: card.card_type,
            last4: card.card_number_last4,
            nickname: card.nickname,
            isPrimary: card.is_primary,
            linkedAt: card.linked_at
        }));

        return { success: true, cards };
    } catch (error) {
        console.error('[FuelService] getDriverFuelCards failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Remove a linked fuel card
 * @param {string} driverId - Driver ID
 * @param {string} cardId - Card record ID
 */
export async function unlinkFuelCard(driverId, cardId) {
    if (!driverId || !cardId) {
        return { success: false, error: 'driverId and cardId are required' };
    }

    try {
        // Verify ownership using dual-source routing
        const card = await getRecord(COLLECTION_KEYS.fuelCards, COLLECTIONS.CARDS, cardId);
        const cardDriverId = card?.driver_id || card?.['Driver Id'];
        if (!card || cardDriverId !== driverId) {
            return { success: false, error: 'Card not found or access denied' };
        }

        // Remove using dual-source routing
        await removeData(COLLECTION_KEYS.fuelCards, COLLECTIONS.CARDS, cardId);

        // If this was primary, make another card primary
        const isPrimary = card.is_primary || card['Is Primary'];
        if (isPrimary) {
            let remainingItems = [];
            if (usesAirtable(COLLECTION_KEYS.fuelCards)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.fuelCards);
                const filter = `{Driver Id} = "${driverId}"`;
                const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
                remainingItems = (result.records || []).map(r => ({
                    _id: r.id || r._id,
                    is_primary: true
                }));
            } else {
                const remaining = await wixData.query(COLLECTIONS.CARDS)
                    .eq('driver_id', driverId)
                    .limit(1)
                    .find({ suppressAuth: true });
                remainingItems = remaining.items.map(r => ({ _id: r._id, is_primary: true }));
            }

            if (remainingItems.length > 0) {
                await updateData(COLLECTION_KEYS.fuelCards, COLLECTIONS.CARDS, remainingItems[0]);
            }
        }

        return { success: true, message: 'Card removed successfully' };
    } catch (error) {
        console.error('[FuelService] unlinkFuelCard failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get price trends for a state
 * @param {string} state - State abbreviation
 * @param {number} days - Number of days to look back (default 30)
 */
export async function getFuelPriceTrends(state, days = 30) {
    if (!state) return { success: false, error: 'state is required' };

    try {
        // In production, this would query historical data from EIA or cached API responses
        // For now, generate mock trend data
        const currentAvg = await getStateAveragePrice(state);
        const trends = [];

        for (let i = days; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);

            // Simulate price fluctuation
            const variation = (Math.random() - 0.5) * 0.15;
            const price = currentAvg + variation + (i * 0.002); // Slight downward trend

            trends.push({
                date: date.toISOString().split('T')[0],
                avgPrice: parseFloat(price.toFixed(3))
            });
        }

        // Calculate trend direction
        const firstWeekAvg = trends.slice(0, 7).reduce((sum, t) => sum + t.avgPrice, 0) / 7;
        const lastWeekAvg = trends.slice(-7).reduce((sum, t) => sum + t.avgPrice, 0) / 7;
        const trendChange = lastWeekAvg - firstWeekAvg;

        return {
            success: true,
            state,
            currentAverage: currentAvg,
            trendDirection: trendChange < -0.02 ? 'down' : trendChange > 0.02 ? 'up' : 'stable',
            trendAmount: parseFloat(Math.abs(trendChange).toFixed(3)),
            trends
        };
    } catch (error) {
        console.error('[FuelService] getFuelPriceTrends failed:', error);
        return { success: false, error: error.message };
    }
}
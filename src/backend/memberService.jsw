import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';

// Gamification - lazy-loaded streak service to avoid circular dependencies
async function getStreakService() {
  return await import('backend/streakService');
}

async function recordLoginStreakNonBlocking(driverId) {
  try {
    const streakService = await getStreakService();
    await streakService.recordDailyLogin(driverId);
  } catch (err) { }
}

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
  driverProfiles: 'driverProfiles',
  interests: 'driverCarrierInterests',
  memberNotifications: 'memberNotifications', // Pinned to Wix in configData
  memberActivity: 'memberActivity'
};

/**
 * Get comprehensive member dashboard data
 */
export async function getMemberDashboard() {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const [profile, applications, notifications, activity] = await Promise.all([
      getProfileSummary(userId),
      getApplicationsSummary(userId),
      getRecentNotifications(userId, 5),
      getActivitySummary(userId)
    ]);

    return { success: true, profile, applications, notifications, activity, quickActions: generateQuickActions(profile, applications) };
  } catch (err) {
    console.error('getMemberDashboard error:', err);
    return { success: false, error: err.message };
  }
}

async function getProfileSummary(userId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, {
      filters: { _owner: userId }, limit: 1, suppressAuth: true
    });

    if (!result.items?.length) return { exists: false, completeness: 0, missingFields: ['All profile fields'], isDiscoverable: false };
    const profile = result.items[0];

    return {
      exists: true, id: profile._id, displayName: profile.display_name || 'Driver',
      email: profile.email, homeZip: profile.home_zip,
      completeness: profile.profile_completeness_score || 0,
      missingFields: profile.missing_fields || [], isDiscoverable: profile.is_discoverable || false,
      totalSearches: profile.total_searches || 0, hasCdlFront: !!profile.cdl_front_image,
      hasCdlBack: !!profile.cdl_back_image, hasMedCard: !!profile.med_card_image,
      hasResume: !!profile.resume_file, lastUpdated: profile._updatedDate
    };
  } catch (err) {
    console.error('getProfileSummary error:', err);
    return { exists: false, completeness: 0, missingFields: [] };
  }
}

async function getApplicationsSummary(userId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: userId }, sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 100, suppressAuth: true
    });
    const applications = result.items || [];

    const byStatus = applications.reduce((acc, app) => {
      const status = app.status || 'pending';
      acc[status] = (acc[status] || 0) + 1;
      return acc;
    }, {});

    const weekAgo = new Date(); weekAgo.setDate(weekAgo.getDate() - 7);
    const recentActivity = applications.filter(app => new Date(app._updatedDate) > weekAgo);

    return {
      total: applications.length, byStatus,
      activeCount: (byStatus.applied || 0) + (byStatus.interviewing || 0) + (byStatus.reviewing || 0),
      recentActivityCount: recentActivity.length,
      recentApplications: applications.slice(0, 5).map(app => ({
        id: app._id, carrierName: app.carrier_name, carrierDOT: app.carrier_dot,
        status: app.status || 'pending', appliedDate: app.applied_date || app._createdDate,
        lastUpdate: app._updatedDate, matchScore: app.match_score
      }))
    };
  } catch (err) {
    console.error('getApplicationsSummary error:', err);
    return { total: 0, byStatus: {}, activeCount: 0, recentApplications: [] };
  }
}

async function getActivitySummary(userId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.memberActivity, {
      filters: { member_id: userId }, sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 1, suppressAuth: true
    });

    if (result.items?.length) {
      const activity = result.items[0];
      return { profileViews: activity.profile_views || 0, profileViewsTrend: activity.profile_views_trend || 'stable', lastActive: activity.last_active || new Date(), searchesThisWeek: activity.searches_this_week || 0, matchScoreTrend: activity.match_score_trend || 'stable' };
    }
    return { profileViews: 0, profileViewsTrend: 'stable', lastActive: new Date(), searchesThisWeek: 0, matchScoreTrend: 'stable' };
  } catch (err) {
    return { profileViews: 0, profileViewsTrend: 'stable', lastActive: new Date(), searchesThisWeek: 0, matchScoreTrend: 'stable' };
  }
}

function generateQuickActions(profile, applications) {
  const actions = [];
  if (!profile.exists) actions.push({ id: 'create_profile', label: 'Create Your Profile', description: 'Set up your driver profile', priority: 'high', url: '/ai-matching' });
  else if (profile.completeness < 50) actions.push({ id: 'complete_profile', label: 'Complete Your Profile', description: `Your profile is ${profile.completeness}% complete`, priority: 'high', url: '/ai-matching' });
  if (profile.exists && !profile.hasCdlFront) actions.push({ id: 'upload_cdl', label: 'Upload Your CDL', description: 'Add your CDL for faster applications', priority: 'medium', url: '/quick-apply' });
  if (applications.total === 0) actions.push({ id: 'find_matches', label: 'Find Your Matches', description: 'Discover carriers', priority: 'high', url: '/ai-matching' });
  return actions.slice(0, 4);
}

/**
 * Get member notifications
 */
export async function getMemberNotifications(limit = 20) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    // MemberNotifications is pinned to Wix in configData
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.memberNotifications, {
      filters: { member_id: userId }, sort: [{ field: 'created_date', direction: 'desc' }],
      limit, suppressAuth: true
    });

    const items = result.items || [];
    const unreadCount = items.filter(n => !n.is_read).length;

    return {
      success: true,
      notifications: items.map(n => ({
        id: n._id, type: n.type, title: n.title, message: n.message, isRead: n.is_read || false,
        actionUrl: n.action_url, createdDate: n.created_date, icon: getNotificationIcon(n.type)
      })),
      unreadCount, totalCount: items.length
    };
  } catch (err) {
    console.error('getMemberNotifications error:', err);
    return { success: false, notifications: [], unreadCount: 0, error: err.message };
  }
}

export async function markNotificationRead(notificationId) {
  try {
    const userId = await getCurrentUserId();
    const notification = await dataAccess.getRecord(COLLECTION_KEYS.memberNotifications, notificationId, { suppressAuth: true });
    if (!notification || notification.member_id !== userId) return { success: false, error: 'Not found' };

    notification.is_read = true;
    await dataAccess.updateRecord(COLLECTION_KEYS.memberNotifications, notification, { suppressAuth: true });
    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

export async function markAllNotificationsRead() {
  try {
    const userId = await getCurrentUserId();
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.memberNotifications, {
      filters: { member_id: userId, is_read: false }, suppressAuth: true
    });

    if (result.items?.length) {
      const updates = result.items.map(n => ({ ...n, is_read: true }));
      await dataAccess.bulkUpdateRecords(COLLECTION_KEYS.memberNotifications, updates, { suppressAuth: true });
    }
    return { success: true, markedCount: result.items?.length || 0 };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

export async function getMemberActivityStats() {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const thirtyDaysAgo = new Date(); thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { driver_id: userId, _createdDate: { gte: thirtyDaysAgo } }, suppressAuth: true
    });
    const items = result.items || [];

    const scores = items.map(a => a.match_score).filter(Boolean);
    const avgScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : null;

    return { success: true, stats: { applicationsLast30Days: items.length, avgMatchScore: avgScore } };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

export async function createNotification(userId, type, title, message, actionUrl = null) {
  try {
    const notification = { member_id: userId, type, title, message, is_read: false, action_url: actionUrl, created_date: new Date() };
    await dataAccess.insertRecord(COLLECTION_KEYS.memberNotifications, notification, { suppressAuth: true });
    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

export async function updateLastActive() {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.memberActivity, {
      filters: { member_id: userId }, limit: 1, suppressAuth: true
    });

    if (result.items?.length) {
      const activity = result.items[0];
      activity.last_active = new Date();
      await dataAccess.updateRecord(COLLECTION_KEYS.memberActivity, activity, { suppressAuth: true });
    } else {
      await dataAccess.insertRecord(COLLECTION_KEYS.memberActivity, { member_id: userId, last_active: new Date(), profile_views: 0, searches_this_week: 0 }, { suppressAuth: true });
    }

    recordLoginStreakNonBlocking(userId);
    return { success: true };
  } catch (err) {
    return { success: false };
  }
}

/**
 * Get carrier DOT for a member (from private member data)
 */
export async function getMemberCarrierDot(email) {
  try {
    const result = await wixData.query('Members/PrivateMembersData')
      .eq('loginEmail', email)
      .find({ suppressAuth: true });
    
    if (result.items?.length) {
      const data = result.items[0];
      return { success: true, carrierDot: data.carrierDot || data.dotNumber || null };
    }
    return { success: true, carrierDot: null };
  } catch (err) {
    console.error('getMemberCarrierDot error:', err);
    return { success: false, error: err.message };
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

async function getRecentNotifications(userId, limit) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.memberNotifications, {
      filters: { member_id: userId }, sort: [{ field: 'created_date', direction: 'desc' }],
      limit, suppressAuth: true
    });
    return (result.items || []).map(n => ({
      id: n._id, type: n.type, title: n.title, message: n.message, isRead: n.is_read || false,
      actionUrl: n.action_url, createdDate: n.created_date
    }));
  } catch (err) {
    return [];
  }
}

function getNotificationIcon(type) {
  const icons = { 'application_update': 'briefcase', 'message': 'envelope', 'match': 'star', 'profile': 'user', 'document': 'file', 'system': 'bell', 'level_up': 'arrow-up', 'achievement_earned': 'award', 'xp_earned': 'zap', 'streak_at_risk': 'alert-triangle', 'streak_broken': 'x-circle', 'streak_milestone': 'flame' };
  return icons[type] || 'bell';
}
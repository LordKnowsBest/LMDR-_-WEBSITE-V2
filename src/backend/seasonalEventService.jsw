/**
 * Seasonal Event Service
 *
 * Manages seasonal and promotional events including:
 * - Event lifecycle management (start/end)
 * - XP/Points multipliers during events
 * - Event-specific challenges
 * - Event leaderboards
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import { getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';
import { createNotification } from 'backend/memberService';

// =============================================================================
// COLLECTION KEYS (Airtable-only)
// =============================================================================

const COLLECTION_KEYS = {
    seasonalEvents: 'seasonalEvents',
    eventParticipants: 'eventParticipants',
    eventLeaderboard: 'eventLeaderboard',
    challengeDefinitions: 'challengeDefinitions'
};

// =============================================================================
// EVENT STATUS
// =============================================================================

const EVENT_STATUS = {
    DRAFT: 'draft',
    SCHEDULED: 'scheduled',
    ACTIVE: 'active',
    ENDED: 'ended',
    CANCELLED: 'cancelled'
};

// =============================================================================
// AIRTABLE-ONLY HELPER FUNCTIONS
// =============================================================================

async function queryData(collectionKey, options = {}) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.queryRecords(tableName, {
        filterByFormula: options.filter || '',
        sort: options.sort,
        maxRecords: options.limit || 100
    });
    return result.records || [];
}

async function insertData(collectionKey, data) {
    const tableName = getAirtableTableName(collectionKey);
    return await airtable.createRecord(tableName, data);
}

async function updateData(collectionKey, recordId, data) {
    const tableName = getAirtableTableName(collectionKey);
    return await airtable.updateRecord(tableName, recordId, data);
}

async function getRecord(collectionKey, recordId) {
    const tableName = getAirtableTableName(collectionKey);
    return await airtable.getRecord(tableName, recordId);
}

// =============================================================================
// GET ACTIVE EVENTS
// =============================================================================

/**
 * Get all currently active events
 * @returns {array} Active events with multipliers and details
 */
export async function getActiveEvents() {
    try {
        const now = new Date().toISOString();

        const records = await queryData(COLLECTION_KEYS.seasonalEvents, {
            filter: `AND({Status} = "${EVENT_STATUS.ACTIVE}", {Start Date} <= "${now}", {End Date} >= "${now}")`,
            sort: [{ field: 'Priority', direction: 'desc' }],
            limit: 10
        });

        return records.map(normalizeEvent);
    } catch (error) {
        console.error('getActiveEvents error:', error);
        return [];
    }
}

/**
 * Get upcoming events (for preview/announcement)
 * @param {number} daysAhead - How many days ahead to look
 * @returns {array} Upcoming events
 */
export async function getUpcomingEvents(daysAhead = 7) {
    try {
        const now = new Date();
        const futureDate = new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);

        const records = await queryData(COLLECTION_KEYS.seasonalEvents, {
            filter: `AND({Status} = "${EVENT_STATUS.SCHEDULED}", {Start Date} >= "${now.toISOString()}", {Start Date} <= "${futureDate.toISOString()}")`,
            sort: [{ field: 'Start Date', direction: 'asc' }],
            limit: 5
        });

        return records.map(normalizeEvent);
    } catch (error) {
        console.error('getUpcomingEvents error:', error);
        return [];
    }
}

/**
 * Get a specific event by ID
 * @param {string} eventId
 * @returns {object} Event details
 */
export async function getEventById(eventId) {
    try {
        const record = await getRecord(COLLECTION_KEYS.seasonalEvents, eventId);
        if (!record) return null;
        return normalizeEvent(record);
    } catch (error) {
        console.error('getEventById error:', error);
        return null;
    }
}

// =============================================================================
// EVENT PARTICIPATION
// =============================================================================

/**
 * Join an active event
 * @param {string} userId - User ID
 * @param {string} userType - 'driver' or 'recruiter'
 * @param {string} eventId - Event ID
 * @returns {object} Participation record
 */
export async function joinEvent(userId, userType, eventId) {
    try {
        // Verify event is active
        const event = await getEventById(eventId);
        if (!event) {
            return { success: false, error: 'event_not_found' };
        }

        if (event.status !== EVENT_STATUS.ACTIVE) {
            return { success: false, error: 'event_not_active' };
        }

        // Check if already participating
        const existing = await queryData(COLLECTION_KEYS.eventParticipants, {
            filter: `AND({User ID} = "${userId}", {Event ID} = "${eventId}")`,
            limit: 1
        });

        if (existing.length > 0) {
            return { success: true, already_joined: true, participant: normalizeParticipant(existing[0]) };
        }

        // Create participation record
        const now = new Date().toISOString();
        const participantData = {
            'User ID': userId,
            'User Type': userType,
            'Event ID': eventId,
            'Event Name': event.name,
            'Points Earned': 0,
            'XP Earned': 0,
            'Challenges Completed': 0,
            'Joined At': now,
            'Created At': now,
            'Updated At': now
        };

        const result = await insertData(COLLECTION_KEYS.eventParticipants, participantData);

        return {
            success: true,
            participant: normalizeParticipant(result)
        };
    } catch (error) {
        console.error('joinEvent error:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Get user's participation in an event
 * @param {string} userId
 * @param {string} eventId
 * @returns {object} Participation status and stats
 */
export async function getEventParticipation(userId, eventId) {
    try {
        const records = await queryData(COLLECTION_KEYS.eventParticipants, {
            filter: `AND({User ID} = "${userId}", {Event ID} = "${eventId}")`,
            limit: 1
        });

        if (records.length === 0) {
            return { participating: false };
        }

        return {
            participating: true,
            participant: normalizeParticipant(records[0])
        };
    } catch (error) {
        console.error('getEventParticipation error:', error);
        return { participating: false, error: error.message };
    }
}

/**
 * Update event participation stats (called when user earns XP/points during event)
 * @param {string} userId
 * @param {string} eventId
 * @param {object} stats - { xpEarned, pointsEarned, challengeCompleted }
 */
export async function updateEventStats(userId, eventId, stats) {
    try {
        const records = await queryData(COLLECTION_KEYS.eventParticipants, {
            filter: `AND({User ID} = "${userId}", {Event ID} = "${eventId}")`,
            limit: 1
        });

        if (records.length === 0) return;

        const participant = records[0];
        const updateFields = {
            'Updated At': new Date().toISOString()
        };

        if (stats.xpEarned) {
            updateFields['XP Earned'] = (participant['XP Earned'] || 0) + stats.xpEarned;
        }
        if (stats.pointsEarned) {
            updateFields['Points Earned'] = (participant['Points Earned'] || 0) + stats.pointsEarned;
        }
        if (stats.challengeCompleted) {
            updateFields['Challenges Completed'] = (participant['Challenges Completed'] || 0) + 1;
        }

        await updateData(COLLECTION_KEYS.eventParticipants, participant.id, updateFields);
    } catch (error) {
        console.error('updateEventStats error:', error);
    }
}

// =============================================================================
// EVENT LEADERBOARD
// =============================================================================

/**
 * Get event leaderboard
 * @param {string} eventId
 * @param {string} userType - 'driver' or 'recruiter' or 'all'
 * @param {object} options - { limit, offset }
 * @returns {object} { leaderboard, total }
 */
export async function getEventLeaderboard(eventId, userType = 'all', options = {}) {
    try {
        const limit = options.limit || 20;

        let filter = `{Event ID} = "${eventId}"`;
        if (userType !== 'all') {
            filter = `AND(${filter}, {User Type} = "${userType}")`;
        }

        // Sort by XP for drivers, points for recruiters, or combined for all
        const sortField = userType === 'recruiter' ? 'Points Earned' : 'XP Earned';

        const records = await queryData(COLLECTION_KEYS.eventParticipants, {
            filter,
            sort: [{ field: sortField, direction: 'desc' }],
            limit: limit + 1
        });

        const hasMore = records.length > limit;
        const leaderboard = records.slice(0, limit).map((record, index) => ({
            rank: index + 1,
            ...normalizeParticipant(record)
        }));

        return {
            leaderboard,
            total: records.length,
            hasMore
        };
    } catch (error) {
        console.error('getEventLeaderboard error:', error);
        return { leaderboard: [], total: 0, error: error.message };
    }
}

/**
 * Get user's rank in an event
 * @param {string} userId
 * @param {string} eventId
 * @returns {object} { rank, totalParticipants, score }
 */
export async function getUserEventRank(userId, eventId) {
    try {
        // Get all participants sorted by score
        const allRecords = await queryData(COLLECTION_KEYS.eventParticipants, {
            filter: `{Event ID} = "${eventId}"`,
            sort: [{ field: 'XP Earned', direction: 'desc' }],
            limit: 10000
        });

        const userIndex = allRecords.findIndex(r => r['User ID'] === userId);

        if (userIndex === -1) {
            return { participating: false };
        }

        const userRecord = allRecords[userIndex];

        return {
            participating: true,
            rank: userIndex + 1,
            totalParticipants: allRecords.length,
            xpEarned: userRecord['XP Earned'] || 0,
            pointsEarned: userRecord['Points Earned'] || 0,
            challengesCompleted: userRecord['Challenges Completed'] || 0
        };
    } catch (error) {
        console.error('getUserEventRank error:', error);
        return { participating: false, error: error.message };
    }
}

// =============================================================================
// EVENT LIFECYCLE (Admin/Scheduled Jobs)
// =============================================================================

/**
 * Start scheduled events that are due (called by scheduled job)
 * @returns {object} { started, count }
 */
export async function startScheduledEvents() {
    try {
        const now = new Date().toISOString();

        // Find events that should start now
        const records = await queryData(COLLECTION_KEYS.seasonalEvents, {
            filter: `AND({Status} = "${EVENT_STATUS.SCHEDULED}", {Start Date} <= "${now}")`,
            limit: 50
        });

        let startedCount = 0;

        for (const record of records) {
            await updateData(COLLECTION_KEYS.seasonalEvents, record.id, {
                'Status': EVENT_STATUS.ACTIVE,
                'Activated At': now,
                'Updated At': now
            });

            // Notify subscribers about event start
            await notifyEventStart(normalizeEvent(record));
            startedCount++;
        }

        console.log(`âœ… Started ${startedCount} scheduled events`);
        return { started: true, count: startedCount };
    } catch (error) {
        console.error('startScheduledEvents error:', error);
        return { started: false, error: error.message };
    }
}

/**
 * End events that have passed their end date (called by scheduled job)
 * @returns {object} { ended, count }
 */
export async function endExpiredEvents() {
    try {
        const now = new Date().toISOString();

        // Find events that should end now
        const records = await queryData(COLLECTION_KEYS.seasonalEvents, {
            filter: `AND({Status} = "${EVENT_STATUS.ACTIVE}", {End Date} <= "${now}")`,
            limit: 50
        });

        let endedCount = 0;

        for (const record of records) {
            await updateData(COLLECTION_KEYS.seasonalEvents, record.id, {
                'Status': EVENT_STATUS.ENDED,
                'Ended At': now,
                'Updated At': now
            });

            // Process final leaderboard and awards
            await processEventEnd(record.id, normalizeEvent(record));
            endedCount++;
        }

        console.log(`âœ… Ended ${endedCount} expired events`);
        return { ended: true, count: endedCount };
    } catch (error) {
        console.error('endExpiredEvents error:', error);
        return { ended: false, error: error.message };
    }
}

/**
 * Process event end - calculate winners and distribute rewards
 */
async function processEventEnd(eventId, event) {
    try {
        // Get top participants for each user type
        const driverLeaderboard = await getEventLeaderboard(eventId, 'driver', { limit: 10 });
        const recruiterLeaderboard = await getEventLeaderboard(eventId, 'recruiter', { limit: 10 });

        // Notify top participants
        for (const entry of driverLeaderboard.leaderboard.slice(0, 3)) {
            await createNotification(
                entry.userId,
                'event_ended',
                `${event.name} Has Ended!`,
                `Congratulations! You finished #${entry.rank} in the ${event.name} event! Check your rewards.`,
                '/driver/achievements'
            );
        }

        for (const entry of recruiterLeaderboard.leaderboard.slice(0, 3)) {
            await createNotification(
                entry.userId,
                'event_ended',
                `${event.name} Has Ended!`,
                `Congratulations! You finished #${entry.rank} in the ${event.name} event! Check your rewards.`,
                '/recruiter/leaderboard'
            );
        }

        console.log(`âœ… Processed end for event: ${event.name}`);
    } catch (error) {
        console.error('processEventEnd error:', error);
    }
}

/**
 * Notify users about event starting
 */
async function notifyEventStart(event) {
    try {
        // For now, we'll create notifications for recently active users
        // In production, this could use a proper notification service
        console.log(`ðŸ“£ Event started: ${event.name}`);
    } catch (error) {
        console.error('notifyEventStart error:', error);
    }
}

// =============================================================================
// EVENT MULTIPLIERS
// =============================================================================

/**
 * Get current XP multiplier from active events
 * @returns {number} Combined multiplier (minimum 1.0)
 */
export async function getCurrentXPMultiplier() {
    try {
        const activeEvents = await getActiveEvents();

        let maxMultiplier = 1.0;
        for (const event of activeEvents) {
            if (event.xpMultiplier > maxMultiplier) {
                maxMultiplier = event.xpMultiplier;
            }
        }

        return maxMultiplier;
    } catch (error) {
        return 1.0;
    }
}

/**
 * Get current points multiplier from active events
 * @returns {number} Combined multiplier (minimum 1.0)
 */
export async function getCurrentPointsMultiplier() {
    try {
        const activeEvents = await getActiveEvents();

        let maxMultiplier = 1.0;
        for (const event of activeEvents) {
            if (event.pointsMultiplier > maxMultiplier) {
                maxMultiplier = event.pointsMultiplier;
            }
        }

        return maxMultiplier;
    } catch (error) {
        return 1.0;
    }
}

// =============================================================================
// EVENT CHALLENGES
// =============================================================================

/**
 * Get challenges specific to an event
 * @param {string} eventId
 * @param {string} userType - 'driver' or 'recruiter'
 * @returns {array} Event-specific challenges
 */
export async function getEventChallenges(eventId, userType) {
    try {
        const records = await queryData(COLLECTION_KEYS.challengeDefinitions, {
            filter: `AND({Challenge Type} = "event", {Event ID} = "${eventId}", {User Type} = "${userType}", {Is Active} = "Yes")`,
            sort: [{ field: 'Display Order', direction: 'asc' }],
            limit: 20
        });

        return records.map(r => ({
            _id: r.id,
            challengeId: r['Challenge ID'],
            name: r['Name'],
            description: r['Description'],
            actionType: r['Action Type'],
            targetValue: r['Target Value'] || 1,
            xpReward: r['XP Reward'] || 0,
            pointsReward: r['Points Reward'] || 0,
            icon: r['Icon'],
            color: r['Color']
        }));
    } catch (error) {
        console.error('getEventChallenges error:', error);
        return [];
    }
}

// =============================================================================
// EVENT SUMMARY
// =============================================================================

/**
 * Get summary of current events for dashboard
 * @param {string} userId
 * @param {string} userType
 * @returns {object} Event summary
 */
export async function getEventSummary(userId, userType) {
    try {
        const [active, upcoming] = await Promise.all([
            getActiveEvents(),
            getUpcomingEvents(7)
        ]);

        // Check participation in active events
        const participationPromises = active.map(event =>
            getEventParticipation(userId, event._id)
        );
        const participations = await Promise.all(participationPromises);

        const activeWithParticipation = active.map((event, i) => ({
            ...event,
            participating: participations[i].participating,
            stats: participations[i].participant || null
        }));

        // Get multipliers
        const xpMultiplier = await getCurrentXPMultiplier();
        const pointsMultiplier = await getCurrentPointsMultiplier();

        return {
            activeEvents: activeWithParticipation,
            upcomingEvents: upcoming,
            multipliers: {
                xp: xpMultiplier,
                points: pointsMultiplier,
                hasBonus: xpMultiplier > 1.0 || pointsMultiplier > 1.0
            }
        };
    } catch (error) {
        console.error('getEventSummary error:', error);
        return { error: error.message };
    }
}

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Normalize event record from Airtable
 */
function normalizeEvent(record) {
    return {
        _id: record.id,
        eventId: record['Event ID'],
        name: record['Name'],
        description: record['Description'],
        type: record['Event Type'], // 'seasonal', 'promotional', 'holiday', 'milestone'
        status: record['Status'],
        startDate: record['Start Date'],
        endDate: record['End Date'],
        xpMultiplier: record['XP Multiplier'] || 1.0,
        pointsMultiplier: record['Points Multiplier'] || 1.0,
        icon: record['Icon'],
        bannerImage: record['Banner Image'],
        color: record['Color'],
        priority: record['Priority'] || 0,
        isActive: record['Is Active'] === 'Yes',
        createdAt: record['Created At'],
        updatedAt: record['Updated At']
    };
}

/**
 * Normalize participant record from Airtable
 */
function normalizeParticipant(record) {
    return {
        _id: record.id,
        userId: record['User ID'],
        userType: record['User Type'],
        eventId: record['Event ID'],
        eventName: record['Event Name'],
        xpEarned: record['XP Earned'] || 0,
        pointsEarned: record['Points Earned'] || 0,
        challengesCompleted: record['Challenges Completed'] || 0,
        joinedAt: record['Joined At'],
        createdAt: record['Created At']
    };
}

/**
 * Get event status options
 */
export function getEventStatuses() {
    return EVENT_STATUS;
}

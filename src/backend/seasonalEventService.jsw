import * as airtableClient from 'backend/airtableClient';
import { getAirtableTableName } from 'backend/config';
import { createNotification } from 'backend/memberService';
import { log } from 'backend/observabilityService';

const COLLECTION_KEYS = {
  seasonalEvents: 'seasonalEvents',
  eventParticipants: 'eventParticipants',
  eventLeaderboard: 'eventLeaderboard',
  challengeDefinitions: 'challengeDefinitions'
};

const EVENT_STATUS = {
  DRAFT: 'draft',
  SCHEDULED: 'scheduled',
  ACTIVE: 'active',
  ENDED: 'ended',
  CANCELLED: 'cancelled'
};

function table(key) {
  return getAirtableTableName(key);
}

function toItems(result) {
  return result?.records || result?.items || [];
}

function mapEventRecord(r) {
  return {
    _id: r._id || r.id,
    eventId: r.event_id || r['Event ID'],
    name: r.name || r['Name'],
    description: r.description || r['Description'],
    type: r.event_type || r['Event Type'],
    status: (r.status || r['Status'] || '').toLowerCase(),
    startDate: r.start_date || r['Start Date'],
    endDate: r.end_date || r['End Date'],
    xpMultiplier: r.xp_multiplier || r['XP Multiplier'] || 1,
    pointsMultiplier: r.points_multiplier || r['Points Multiplier'] || 1,
    priority: r.priority || r['Priority'] || 0
  };
}

function mapParticipant(r) {
  return {
    _id: r._id || r.id,
    userId: r.user_id || r['User ID'],
    userType: r.user_type || r['User Type'],
    eventId: r.event_id || r['Event ID'],
    eventName: r.event_name || r['Event Name'],
    xpEarned: r.xp_earned || r['XP Earned'] || 0,
    pointsEarned: r.points_earned || r['Points Earned'] || 0,
    challengesCompleted: r.challenges_completed || r['Challenges Completed'] || 0,
    joinedAt: r.joined_at || r['Joined At']
  };
}

async function queryEventsByStatus(status) {
  const result = await airtableClient.queryRecords(table(COLLECTION_KEYS.seasonalEvents), {
    filters: { status }
  });
  return toItems(result).map(mapEventRecord);
}

export async function getActiveEvents() {
  try {
    const now = Date.now();
    const events = await queryEventsByStatus(EVENT_STATUS.ACTIVE);
    return events.filter((e) => {
      const start = e.startDate ? new Date(e.startDate).getTime() : 0;
      const end = e.endDate ? new Date(e.endDate).getTime() : Number.MAX_SAFE_INTEGER;
      return start <= now && end >= now;
    });
  } catch (error) {
    return [];
  }
}

export async function getUpcomingEvents(daysAhead = 7) {
  try {
    const now = Date.now();
    const endWindow = now + (daysAhead * 24 * 60 * 60 * 1000);
    const events = await queryEventsByStatus(EVENT_STATUS.SCHEDULED);
    return events
      .filter((e) => {
        const start = e.startDate ? new Date(e.startDate).getTime() : 0;
        return start >= now && start <= endWindow;
      })
      .sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime());
  } catch (error) {
    return [];
  }
}

export async function getEventById(eventId) {
  try {
    const record = await airtableClient.getRecord(table(COLLECTION_KEYS.seasonalEvents), eventId);
    return record ? mapEventRecord(record) : null;
  } catch (error) {
    return null;
  }
}

export async function joinEvent(userId, userType, eventId) {
  try {
    const event = await getEventById(eventId);
    if (!event || event.status !== EVENT_STATUS.ACTIVE) {
      return { success: false, error: 'event_not_active' };
    }

    const existingResult = await airtableClient.queryRecords(table(COLLECTION_KEYS.eventParticipants), {
      filters: { user_id: userId, event_id: eventId },
      limit: 1
    });
    const existing = toItems(existingResult);

    if (existing.length) {
      return { success: true, already_joined: true, participant: mapParticipant(existing[0]) };
    }

    const now = new Date().toISOString();
    const created = await airtableClient.createRecord(table(COLLECTION_KEYS.eventParticipants), {
      user_id: userId,
      user_type: userType,
      event_id: eventId,
      event_name: event.name,
      points_earned: 0,
      xp_earned: 0,
      challenges_completed: 0,
      joined_at: now,
      created_at: now,
      updated_at: now
    });

    return { success: true, participant: mapParticipant(created || {}) };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getEventParticipation(userId, eventId) {
  try {
    const result = await airtableClient.queryRecords(table(COLLECTION_KEYS.eventParticipants), {
      filters: { user_id: userId, event_id: eventId },
      limit: 1
    });
    const items = toItems(result);
    if (!items.length) return { participating: false };
    return { participating: true, participant: mapParticipant(items[0]) };
  } catch (error) {
    return { participating: false, error: error.message };
  }
}

export async function updateEventStats(userId, eventId, stats) {
  try {
    const res = await airtableClient.queryRecords(table(COLLECTION_KEYS.eventParticipants), {
      filters: { user_id: userId, event_id: eventId },
      limit: 1
    });
    const items = toItems(res);
    if (!items.length) return;

    const p = items[0];
    const update = {
      ...p,
      _id: p._id || p.id,
      xp_earned: (p.xp_earned || 0) + (stats.xpEarned || 0),
      points_earned: (p.points_earned || 0) + (stats.pointsEarned || 0),
      challenges_completed: (p.challenges_completed || 0) + (stats.challengeCompleted ? 1 : 0),
      updated_at: new Date().toISOString()
    };

    await airtableClient.updateRecord(table(COLLECTION_KEYS.eventParticipants), update._id, update);
  } catch (error) {}
}

export async function getEventLeaderboard(eventId, userType = 'all', options = {}) {
  try {
    const limit = options.limit || 20;
    const result = await airtableClient.queryRecords(table(COLLECTION_KEYS.eventParticipants), {
      filters: userType === 'all' ? { event_id: eventId } : { event_id: eventId, user_type: userType }
    });
    const items = toItems(result).map(mapParticipant);

    const sortField = userType === 'recruiter' ? 'pointsEarned' : 'xpEarned';
    items.sort((a, b) => (b[sortField] || 0) - (a[sortField] || 0));

    return {
      leaderboard: items.slice(0, limit).map((item, i) => ({ rank: i + 1, ...item })),
      total: items.length,
      hasMore: items.length > limit
    };
  } catch (error) {
    return { leaderboard: [], total: 0, error: error.message };
  }
}

export async function getUserEventRank(userId, eventId) {
  try {
    const result = await airtableClient.queryRecords(table(COLLECTION_KEYS.eventParticipants), {
      filters: { event_id: eventId }
    });
    const items = toItems(result).map(mapParticipant).sort((a, b) => (b.xpEarned || 0) - (a.xpEarned || 0));
    const idx = items.findIndex((r) => r.userId === userId);
    if (idx === -1) return { participating: false };

    return {
      participating: true,
      rank: idx + 1,
      totalParticipants: items.length,
      xpEarned: items[idx].xpEarned,
      pointsEarned: items[idx].pointsEarned,
      challengesCompleted: items[idx].challengesCompleted
    };
  } catch (error) {
    return { participating: false, error: error.message };
  }
}

export async function startScheduledEvents() {
  try {
    const now = new Date().toISOString();
    const events = await queryEventsByStatus(EVENT_STATUS.SCHEDULED);
    const due = events.filter((e) => new Date(e.startDate).getTime() <= Date.now());

    for (const e of due) {
      await airtableClient.updateRecord(table(COLLECTION_KEYS.seasonalEvents), e._id, {
        status: EVENT_STATUS.ACTIVE,
        activated_at: now,
        updated_at: now
      });
    }

    return { started: true, count: due.length };
  } catch (error) {
    return { started: false, error: error.message };
  }
}

export async function endExpiredEvents() {
  try {
    const now = new Date().toISOString();
    const events = await queryEventsByStatus(EVENT_STATUS.ACTIVE);
    const expired = events.filter((e) => new Date(e.endDate).getTime() <= Date.now());

    for (const e of expired) {
      await airtableClient.updateRecord(table(COLLECTION_KEYS.seasonalEvents), e._id, {
        status: EVENT_STATUS.ENDED,
        ended_at: now,
        updated_at: now
      });
    }

    return { ended: true, count: expired.length };
  } catch (error) {
    return { ended: false, error: error.message };
  }
}

export async function getCurrentXPMultiplier() {
  const events = await getActiveEvents();
  if (!events.length) return 1;
  return Math.max(1, ...events.map((e) => e.xpMultiplier || 1));
}

export async function getCurrentPointsMultiplier() {
  const events = await getActiveEvents();
  if (!events.length) return 1;
  return Math.max(1, ...events.map((e) => e.pointsMultiplier || 1));
}

export async function getEventChallenges(eventId, userType) {
  try {
    const result = await airtableClient.queryRecords(table(COLLECTION_KEYS.challengeDefinitions), {
      filters: {
        challenge_type: 'event',
        event_id: eventId,
        user_type: userType,
        is_active: 'Yes'
      }
    });
    const items = toItems(result);
    return items.map((r) => ({
      _id: r._id || r.id,
      challengeId: r.challenge_id || r['Challenge ID'],
      name: r.name || r['Name'],
      description: r.description || r['Description'],
      actionType: r.action_type || r['Action Type'],
      targetValue: r.target_value || r['Target Value'] || 1,
      xpReward: r.xp_reward || r['XP Reward'] || 0,
      pointsReward: r.points_reward || r['Points Reward'] || 0,
      icon: r.icon || r['Icon'],
      color: r.color || r['Color']
    }));
  } catch (error) {
    return [];
  }
}

export async function getEventSummary(userId, userType) {
  try {
    const [active, upcoming] = await Promise.all([getActiveEvents(), getUpcomingEvents(7)]);
    const participations = await Promise.all(active.map((e) => getEventParticipation(userId, e._id)));

    const activeWithParticipation = active.map((e, i) => ({
      ...e,
      participating: participations[i].participating,
      stats: participations[i].participant || null
    }));

    const [xpM, ptsM] = await Promise.all([getCurrentXPMultiplier(), getCurrentPointsMultiplier()]);

    return {
      activeEvents: activeWithParticipation,
      upcomingEvents: upcoming,
      multipliers: { xp: xpM, points: ptsM, hasBonus: xpM > 1 || ptsM > 1 }
    };
  } catch (error) {
    return { error: error.message };
  }
}

export function getEventStatuses() {
  return EVENT_STATUS;
}

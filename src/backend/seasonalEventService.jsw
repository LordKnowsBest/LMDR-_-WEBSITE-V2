/**
 * Seasonal Event Service
 *
 * Manages seasonal and promotional events including:
 * - Event lifecycle management (start/end)
 * - XP/Points multipliers during events
 * - Event-specific challenges
 * - Event leaderboards
 *
 * This service uses Airtable-only collections (no Wix fallback).
 */

import * as dataAccess from 'backend/dataAccess';
import { createNotification } from 'backend/memberService';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    seasonalEvents: 'seasonalEvents',
    eventParticipants: 'eventParticipants',
    eventLeaderboard: 'eventLeaderboard',
    challengeDefinitions: 'challengeDefinitions'
};

// =============================================================================
// EVENT STATUS
// =============================================================================

const EVENT_STATUS = {
    DRAFT: 'draft',
    SCHEDULED: 'scheduled',
    ACTIVE: 'active',
    ENDED: 'ended',
    CANCELLED: 'cancelled'
};

// =============================================================================
// GET ACTIVE EVENTS
// =============================================================================

/**
 * Get all currently active events
 */
export async function getActiveEvents() {
    try {
        const now = new Date().toISOString();
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.seasonalEvents, {
            filters: { status: EVENT_STATUS.ACTIVE, start_date: { le: now }, end_date: { ge: now } },
            sort: [{ field: 'priority', direction: 'desc' }], limit: 10, suppressAuth: true
        });
        return (result.items || []).map(normalizeEvent);
    } catch (error) { return []; }
}

/**
 * Get upcoming events
 */
export async function getUpcomingEvents(daysAhead = 7) {
    try {
        const now = new Date();
        const futureDate = new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.seasonalEvents, {
            filters: { status: EVENT_STATUS.SCHEDULED, start_date: { gte: now.toISOString(), le: futureDate.toISOString() } },
            sort: [{ field: 'start_date', direction: 'asc' }], limit: 5, suppressAuth: true
        });
        return (result.items || []).map(normalizeEvent);
    } catch (error) { return []; }
}

export async function getEventById(eventId) {
    try {
        const record = await dataAccess.getRecord(COLLECTION_KEYS.seasonalEvents, eventId, { suppressAuth: true });
        return record ? normalizeEvent(record) : null;
    } catch (error) { return null; }
}

// =============================================================================
// EVENT PARTICIPATION
// =============================================================================

export async function joinEvent(userId, userType, eventId) {
    try {
        const event = await getEventById(eventId);
        if (!event || event.status !== EVENT_STATUS.ACTIVE) return { success: false, error: 'event_not_active' };

        const existing = await dataAccess.queryRecords(COLLECTION_KEYS.eventParticipants, {
            filters: { user_id: userId, event_id: eventId }, limit: 1, suppressAuth: true
        });
        if (existing.items?.length) return { success: true, already_joined: true, participant: normalizeParticipant(existing.items[0]) };

        const now = new Date().toISOString();
        const result = await dataAccess.insertRecord(COLLECTION_KEYS.eventParticipants, {
            user_id: userId, user_type: userType, event_id: eventId, event_name: event.name,
            points_earned: 0, xp_earned: 0, challenges_completed: 0, joined_at: now, created_at: now, updated_at: now
        }, { suppressAuth: true });

        return { success: result.success, participant: normalizeParticipant(result.record) };
    } catch (error) { return { success: false, error: error.message }; }
}

export async function getEventParticipation(userId, eventId) {
    try {
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.eventParticipants, { filters: { user_id: userId, event_id: eventId }, limit: 1, suppressAuth: true });
        return res.items?.length ? { participating: true, participant: normalizeParticipant(res.items[0]) } : { participating: false };
    } catch (error) { return { participating: false, error: error.message }; }
}

export async function updateEventStats(userId, eventId, stats) {
    try {
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.eventParticipants, { filters: { user_id: userId, event_id: eventId }, limit: 1, suppressAuth: true });
        if (!res.items?.length) return;
        const p = res.items[0];
        const update = { ...p, updated_at: new Date().toISOString() };
        if (stats.xpEarned) update.xp_earned = (p.xp_earned || 0) + stats.xpEarned;
        if (stats.pointsEarned) update.points_earned = (p.points_earned || 0) + stats.pointsEarned;
        if (stats.challengeCompleted) update.challenges_completed = (p.challenges_completed || 0) + 1;
        await dataAccess.updateRecord(COLLECTION_KEYS.eventParticipants, update, { suppressAuth: true });
    } catch (error) { }
}

// =============================================================================
// EVENT LEADERBOARD
// =============================================================================

export async function getEventLeaderboard(eventId, userType = 'all', options = {}) {
    try {
        const limit = options.limit || 20;
        const filters = { event_id: eventId };
        if (userType !== 'all') filters.user_type = userType;
        const sortField = userType === 'recruiter' ? 'points_earned' : 'xp_earned';

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.eventParticipants, {
            filters, sort: [{ field: sortField, direction: 'desc' }], limit: limit + 1, suppressAuth: true
        });
        const items = result.items || [];
        return { leaderboard: items.slice(0, limit).map((r, i) => ({ rank: i + 1, ...normalizeParticipant(r) })), total: result.totalCount || items.length, hasMore: items.length > limit };
    } catch (error) { return { leaderboard: [], total: 0, error: error.message }; }
}

export async function getUserEventRank(userId, eventId) {
    try {
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.eventParticipants, { filters: { event_id: eventId }, sort: [{ field: 'xp_earned', direction: 'desc' }], limit: 10000, suppressAuth: true });
        const items = res.items || [];
        const idx = items.findIndex(r => r.user_id === userId);
        if (idx === -1) return { participating: false };
        const r = items[idx];
        return { participating: true, rank: idx + 1, totalParticipants: items.length, xpEarned: r.xp_earned || 0, pointsEarned: r.points_earned || 0, challengesCompleted: r.challenges_completed || 0 };
    } catch (error) { return { participating: false, error: error.message }; }
}

// =============================================================================
// EVENT LIFECYCLE
// =============================================================================

export async function startScheduledEvents() {
    try {
        const now = new Date().toISOString();
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.seasonalEvents, { filters: { status: EVENT_STATUS.SCHEDULED, start_date: { le: now } }, limit: 50, suppressAuth: true });
        for (const r of (res.items || [])) {
            await dataAccess.updateRecord(COLLECTION_KEYS.seasonalEvents, { ...r, status: EVENT_STATUS.ACTIVE, activated_at: now, updated_at: now }, { suppressAuth: true });
        }
        return { started: true, count: res.items?.length || 0 };
    } catch (error) { return { started: false, error: error.message }; }
}

export async function endExpiredEvents() {
    try {
        const now = new Date().toISOString();
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.seasonalEvents, { filters: { status: EVENT_STATUS.ACTIVE, end_date: { le: now } }, limit: 50, suppressAuth: true });
        for (const r of (res.items || [])) {
            await dataAccess.updateRecord(COLLECTION_KEYS.seasonalEvents, { ...r, status: EVENT_STATUS.ENDED, ended_at: now, updated_at: now }, { suppressAuth: true });
        }
        return { ended: true, count: res.items?.length || 0 };
    } catch (error) { return { ended: false, error: error.message }; }
}

export async function getCurrentXPMultiplier() {
    try {
        const events = await getActiveEvents();
        return Math.max(1.0, ...events.map(e => e.xpMultiplier || 1.0));
    } catch (error) { return 1.0; }
}

export async function getCurrentPointsMultiplier() {
    try {
        const events = await getActiveEvents();
        return Math.max(1.0, ...events.map(e => e.pointsMultiplier || 1.0));
    } catch (error) { return 1.0; }
}

export async function getEventChallenges(eventId, userType) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.challengeDefinitions, {
            filters: { challenge_type: 'event', event_id: eventId, user_type: userType, is_active: 'Yes' },
            sort: [{ field: 'display_order', direction: 'asc' }], limit: 20, suppressAuth: true
        });
        return (result.items || []).map(r => ({ _id: r._id, challengeId: r.challenge_id, name: r.name, description: r.description, actionType: r.action_type, targetValue: r.target_value || 1, xpReward: r.xp_reward || 0, pointsReward: r.points_reward || 0, icon: r.icon, color: r.color }));
    } catch (error) { return []; }
}

export async function getEventSummary(userId, userType) {
    try {
        const [active, upcoming] = await Promise.all([getActiveEvents(), getUpcomingEvents(7)]);
        const participations = await Promise.all(active.map(e => getEventParticipation(userId, e._id)));
        const activeWithParticipation = active.map((e, i) => ({ ...e, participating: participations[i].participating, stats: participations[i].participant || null }));
        const xpM = await getCurrentXPMultiplier(), ptsM = await getCurrentPointsMultiplier();
        return { activeEvents: activeWithParticipation, upcomingEvents: upcoming, multipliers: { xp: xpM, points: ptsM, hasBonus: xpM > 1.0 || ptsM > 1.0 } };
    } catch (error) { return { error: error.message }; }
}

function normalizeEvent(r) {
    return { _id: r._id, eventId: r.event_id, name: r.name, description: r.description, type: r.event_type, status: r.status, startDate: r.start_date, endDate: r.end_date, xpMultiplier: r.xp_multiplier || 1.0, pointsMultiplier: r.points_multiplier || 1.0, icon: r.icon, bannerImage: r.banner_image, color: r.color, priority: r.priority || 0, isActive: r.is_active === 'Yes', createdAt: r.created_at, updatedAt: r.updated_at };
}

function normalizeParticipant(r) {
    return { _id: r._id, userId: r.user_id, userType: r.user_type, eventId: r.event_id, eventName: r.event_name, xpEarned: r.xp_earned || 0, pointsEarned: r.points_earned || 0, challengesCompleted: r.challenges_completed || 0, joinedAt: r.joined_at, createdAt: r.created_at };
}

export function getEventStatuses() { return EVENT_STATUS; }

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Normalize event record from Airtable
 */
function normalizeEvent(record) {
    return {
        _id: record.id,
        eventId: record['Event ID'],
        name: record['Name'],
        description: record['Description'],
        type: record['Event Type'], // 'seasonal', 'promotional', 'holiday', 'milestone'
        status: record['Status'],
        startDate: record['Start Date'],
        endDate: record['End Date'],
        xpMultiplier: record['XP Multiplier'] || 1.0,
        pointsMultiplier: record['Points Multiplier'] || 1.0,
        icon: record['Icon'],
        bannerImage: record['Banner Image'],
        color: record['Color'],
        priority: record['Priority'] || 0,
        isActive: record['Is Active'] === 'Yes',
        createdAt: record['Created At'],
        updatedAt: record['Updated At']
    };
}

/**
 * Normalize participant record from Airtable
 */
function normalizeParticipant(record) {
    return {
        _id: record.id,
        userId: record['User ID'],
        userType: record['User Type'],
        eventId: record['Event ID'],
        eventName: record['Event Name'],
        xpEarned: record['XP Earned'] || 0,
        pointsEarned: record['Points Earned'] || 0,
        challengesCompleted: record['Challenges Completed'] || 0,
        joinedAt: record['Joined At'],
        createdAt: record['Created At']
    };
}

/**
 * Get event status options
 */
export function getEventStatuses() {
    return EVENT_STATUS;
}

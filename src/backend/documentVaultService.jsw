import * as dataAccess from 'backend/dataAccess';
import { createComplianceEvent } from './complianceCalendarService';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    carrierDocuments: 'carrierDocuments'
};

// ============================================================
// DOCUMENT MANAGEMENT
// ============================================================

/**
 * Upload a document to the vault
 */
export async function uploadDocument(carrierDot, documentData) {
  if (!carrierDot) throw new Error('Carrier DOT required');

  const newDoc = {
    ...documentData, carrier_dot: carrierDot, version: 1,
    status: 'active', verification_status: 'pending',
    is_expired: false, _createdDate: new Date()
  };

  if (newDoc.expiration_date) {
    const expDate = new Date(newDoc.expiration_date);
    const now = new Date();
    newDoc.is_expired = expDate < now;
    newDoc.days_until_expiry = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
  }

  const result = await dataAccess.insertRecord(COLLECTION_KEYS.carrierDocuments, newDoc, { suppressAuth: true });
  if (!result.success) throw new Error(result.error);
  const record = result.record;

  if (record.expiration_date && record.document_type) {
    createComplianceEvent({
      carrier_dot: carrierDot, driver_id: record.driver_id,
      event_type: record.document_type, event_category: record.document_category || 'license',
      title: `Renew ${record.title || record.document_type}`,
      due_date: record.expiration_date, document_id: record._id
    }).catch(() => {});
  }

  return record;
}

/**
 * Get all documents for a carrier
 */
export async function getDocuments(carrierDot, filters = {}) {
  const queryFilters = { carrier_dot: carrierDot };
  if (filters.category) queryFilters.document_category = filters.category;
  if (filters.type) queryFilters.document_type = filters.type;
  if (filters.driverId) queryFilters.driver_id = filters.driverId;
  if (filters.status) queryFilters.status = filters.status;
  if (filters.expired !== undefined) queryFilters.is_expired = filters.expired;

  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierDocuments, {
    filters: queryFilters, limit: 500, suppressAuth: true
  });
  return result.items || [];
}

/**
 * Get a single document by ID
 */
export async function getDocument(documentId) {
  return await dataAccess.getRecord(COLLECTION_KEYS.carrierDocuments, documentId, { suppressAuth: true });
}

/**
 * Update document metadata
 */
export async function updateDocument(documentId, updates) {
  delete updates.version;
  delete updates.previous_version_id;
  
  const existing = await getDocument(documentId);
  if (!existing) throw new Error('Document not found');

  const toUpdate = { ...existing, ...updates, _id: documentId };

  if (updates.expiration_date) {
    const expDate = new Date(updates.expiration_date);
    const now = new Date();
    toUpdate.is_expired = expDate < now;
    toUpdate.days_until_expiry = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
  }

  const result = await dataAccess.updateRecord(COLLECTION_KEYS.carrierDocuments, toUpdate, { suppressAuth: true });
  if (!result.success) throw new Error(result.error);
  return result.record;
}

/**
 * Upload a new version of an existing document
 */
export async function uploadNewVersion(documentId, newVersionData) {
  const previousDoc = await getDocument(documentId);
  if (!previousDoc) throw new Error('Previous document not found');

  await dataAccess.updateRecord(COLLECTION_KEYS.carrierDocuments, { ...previousDoc, status: 'superseded' }, { suppressAuth: true });

  const newDoc = {
    ...previousDoc, ...newVersionData, _id: undefined,
    version: (previousDoc.version || 1) + 1,
    previous_version_id: documentId,
    status: 'active', verification_status: 'pending'
  };

  if (newDoc.expiration_date) {
    const expDate = new Date(newDoc.expiration_date);
    const now = new Date();
    newDoc.is_expired = expDate < now;
    newDoc.days_until_expiry = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
  }

  const result = await dataAccess.insertRecord(COLLECTION_KEYS.carrierDocuments, newDoc, { suppressAuth: true });
  if (!result.success) throw new Error(result.error);
  return result.record;
}

/**
 * Get version history for a document
 */
export async function getDocumentVersionHistory(documentId) {
  const doc = await getDocument(documentId);
  if (!doc) return [];

  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierDocuments, {
    filters: { carrier_dot: doc.carrier_dot, document_type: doc.document_type, driver_id: doc.driver_id },
    sort: [{ field: 'version', direction: 'desc' }],
    limit: 100, suppressAuth: true
  });
  return result.items || [];
}

/**
 * Archive a document
 */
export async function archiveDocument(documentId) {
  const doc = await getDocument(documentId);
  if (!doc) return false;
  const result = await dataAccess.updateRecord(COLLECTION_KEYS.carrierDocuments, { ...doc, status: 'archived' }, { suppressAuth: true });
  return result.success;
}

// ============================================================
// EXPIRATION TRACKING
// ============================================================

export async function getExpiringDocuments(carrierDot, daysAhead = 30) {
  const future = new Date();
  future.setDate(future.getDate() + daysAhead);

  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierDocuments, {
    filters: { carrier_dot, status: 'active', is_expired: false, expiration_date: { le: future } },
    sort: [{ field: 'expiration_date', direction: 'asc' }],
    limit: 100, suppressAuth: true
  });
  return result.items || [];
}

export async function getExpiredDocuments(carrierDot) {
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierDocuments, {
    filters: { carrier_dot, status: 'active', is_expired: true },
    limit: 100, suppressAuth: true
  });
  return result.items || [];
}

// ============================================================
// VERIFICATION
// ============================================================

export async function verifyDocument(documentId, verifierId, status, notes = '') {
  const doc = await getDocument(documentId);
  if (!doc) throw new Error('Document not found');

  const verifyUpdate = { ...doc, verification_status: status, verified_by: verifierId, verified_date: new Date(), notes };
  const result = await dataAccess.updateRecord(COLLECTION_KEYS.carrierDocuments, verifyUpdate, { suppressAuth: true });
  if (!result.success) throw new Error(result.error);
  return result.record;
}

export async function updateDocumentExpirations() {
  const now = new Date();
  const result = await dataAccess.queryRecords(COLLECTION_KEYS.carrierDocuments, { filters: { status: 'active' }, limit: 1000, suppressAuth: true });
  const items = result.items || [];

  let updatedCount = 0;
  for (const doc of items) {
    if (!doc.expiration_date) continue;
    const expDate = new Date(doc.expiration_date);
    const isExpired = expDate < now;
    const daysUntil = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));

    if (doc.is_expired !== isExpired || doc.days_until_expiry !== daysUntil) {
      await dataAccess.updateRecord(COLLECTION_KEYS.carrierDocuments, { ...doc, is_expired: isExpired, days_until_expiry: daysUntil }, { suppressAuth: true });
      updatedCount++;
    }
  }
  return { processed: items.length, updated: updatedCount };
}

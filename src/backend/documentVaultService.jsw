import wixData from 'wix-data';
import wixAuth from 'wix-auth';
import { getComplianceEvents, createComplianceEvent, updateComplianceEvent } from './complianceCalendarService';
import { usesAirtable, getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

const COLLECTION = 'CarrierDocuments';

// Collection keys for dual-source routing
const COLLECTION_KEYS = {
    carrierDocuments: 'carrierDocuments'
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

async function queryData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            sort: options.sort,
            maxRecords: options.limit || 100
        });
        return result.records || [];
    }
    let query = wixData.query(wixCollectionName);
    if (options.eq) {
        for (const [field, value] of Object.entries(options.eq)) {
            query = query.eq(field, value);
        }
    }
    if (options.le) {
        for (const [field, value] of Object.entries(options.le)) {
            query = query.le(field, value);
        }
    }
    if (options.ascending) {
        query = query.ascending(options.ascending);
    }
    if (options.descending) {
        query = query.descending(options.descending);
    }
    if (options.limit) {
        query = query.limit(options.limit);
    }
    const result = await query.find({ suppressAuth: true });
    return result.items;
}

async function getRecord(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.getRecord(tableName, recordId);
    }
    return await wixData.get(wixCollectionName, recordId, { suppressAuth: true });
}

async function insertData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.createRecord(tableName, data);
    }
    return await wixData.insert(wixCollectionName, data, { suppressAuth: true });
}

async function updateData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.updateRecord(tableName, data._id || data.id, data);
    }
    return await wixData.update(wixCollectionName, data, { suppressAuth: true });
}

// ============================================================
// DOCUMENT MANAGEMENT
// ============================================================

/**
 * Upload a document to the vault
 * @param {string} carrierDot - Carrier DOT number
 * @param {Object} documentData - { type, category, file_url, file_name, driverId, expirationDate, etc. }
 * @returns {Promise<Object>} - Created document record
 */
export async function uploadDocument(carrierDot, documentData) {
  if (!carrierDot) throw new Error('Carrier DOT required');

  const newDoc = {
    ...documentData,
    carrier_dot: carrierDot,
    version: 1,
    status: 'active',
    verification_status: 'pending',
    is_expired: false,
    _createdDate: new Date()
  };

  // Calculate expiration status
  if (newDoc.expiration_date) {
    const expDate = new Date(newDoc.expiration_date);
    const now = new Date();
    newDoc.is_expired = expDate < now;
    newDoc.days_until_expiry = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
  }

  // Use dual-source routing
  const result = await insertData(COLLECTION_KEYS.carrierDocuments, COLLECTION, newDoc);

  // Auto-create compliance event if expiration date exists
  if (result.expiration_date && result.document_type) {
    try {
      await createComplianceEvent({
        carrier_dot: carrierDot,
        driver_id: result.driver_id,
        event_type: result.document_type, // Map doc type to event type logic might be needed
        event_category: result.document_category || 'license',
        title: `Renew ${result.title || result.document_type}`,
        due_date: result.expiration_date,
        document_id: result._id,
        status: 'upcoming' // Will be auto-calculated by createComplianceEvent anyway
      });
    } catch (err) {
      console.error('Failed to auto-create compliance event:', err);
    }
  }

  return result;
}

/**
 * Get all documents for a carrier
 * @param {string} carrierDot - Carrier DOT number
 * @param {Object} filters - { category, type, driverId, status, expired }
 * @returns {Promise<Array>} - List of documents
 */
export async function getDocuments(carrierDot, filters = {}) {
  // Dual-source routing
  if (usesAirtable(COLLECTION_KEYS.carrierDocuments)) {
    const tableName = getAirtableTableName(COLLECTION_KEYS.carrierDocuments);
    const filterParts = [`{Carrier Dot} = "${carrierDot}"`];

    if (filters.category) filterParts.push(`{Document Category} = "${filters.category}"`);
    if (filters.type) filterParts.push(`{Document Type} = "${filters.type}"`);
    if (filters.driverId) filterParts.push(`{Driver Id} = "${filters.driverId}"`);
    if (filters.status) filterParts.push(`{Status} = "${filters.status}"`);
    if (filters.expired === true) filterParts.push(`{Is Expired} = TRUE()`);
    else if (filters.expired === false) filterParts.push(`{Is Expired} = FALSE()`);

    const filter = filterParts.length > 1 ? `AND(${filterParts.join(', ')})` : filterParts[0];
    const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 500 });
    return (result.records || []).map(r => ({
      _id: r.id || r._id,
      carrier_dot: r['Carrier Dot'] || r.carrier_dot,
      document_type: r['Document Type'] || r.document_type,
      document_category: r['Document Category'] || r.document_category,
      driver_id: r['Driver Id'] || r.driver_id,
      status: r.Status || r.status,
      is_expired: r['Is Expired'] || r.is_expired,
      expiration_date: r['Expiration Date'] || r.expiration_date,
      file_url: r['File Url'] || r.file_url,
      title: r.Title || r.title,
      version: r.Version || r.version
    }));
  }

  // Wix Data path
  let query = wixData.query(COLLECTION).eq('carrier_dot', carrierDot);

  if (filters.category) query = query.eq('document_category', filters.category);
  if (filters.type) query = query.eq('document_type', filters.type);
  if (filters.driverId) query = query.eq('driver_id', filters.driverId);
  if (filters.status) query = query.eq('status', filters.status);

  if (filters.expired === true) query = query.eq('is_expired', true);
  else if (filters.expired === false) query = query.eq('is_expired', false);

  const result = await query.find({ suppressAuth: true });
  return result.items;
}

/**
 * Get a single document by ID
 * @param {string} documentId - Document ID
 * @returns {Promise<Object>} - Document
 */
export async function getDocument(documentId) {
  // Use dual-source routing
  return getRecord(COLLECTION_KEYS.carrierDocuments, COLLECTION, documentId);
}

/**
 * Update document metadata
 * @param {string} documentId - Document ID
 * @param {Object} updates - Fields to update
 * @returns {Promise<Object>} - Updated document
 */
export async function updateDocument(documentId, updates) {
  // Prevent version overwrite via update
  delete updates.version;
  delete updates.previous_version_id;
  
  const existing = await getDocument(documentId);
  if (!existing) throw new Error('Document not found');

  const toUpdate = { ...existing, ...updates, _id: existing._id || existing.id };

  // Recalc expiration if date changes
  if (updates.expiration_date) {
    const expDate = new Date(updates.expiration_date);
    const now = new Date();
    toUpdate.is_expired = expDate < now;
    toUpdate.days_until_expiry = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
  }

  // Use dual-source routing
  return updateData(COLLECTION_KEYS.carrierDocuments, COLLECTION, toUpdate);
}

/**
 * Upload a new version of an existing document
 * @param {string} documentId - Original document ID
 * @param {Object} newVersionData - New file and metadata
 * @returns {Promise<Object>} - New version document
 */
export async function uploadNewVersion(documentId, newVersionData) {
  const previousDoc = await getDocument(documentId);
  if (!previousDoc) throw new Error('Previous document not found');

  // Archive previous using dual-source routing
  const archiveUpdate = { ...previousDoc, _id: previousDoc._id || previousDoc.id, status: 'superseded' };
  await updateData(COLLECTION_KEYS.carrierDocuments, COLLECTION, archiveUpdate);

  // Create new
  const newDoc = {
    ...previousDoc,
    ...newVersionData,
    _id: undefined, // Create new ID
    version: (previousDoc.version || 1) + 1,
    previous_version_id: previousDoc._id || previousDoc.id,
    status: 'active',
    verification_status: 'pending'
  };

  // Recalc expiration
  if (newDoc.expiration_date) {
    const expDate = new Date(newDoc.expiration_date);
    const now = new Date();
    newDoc.is_expired = expDate < now;
    newDoc.days_until_expiry = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
  }

  // Use dual-source routing
  return insertData(COLLECTION_KEYS.carrierDocuments, COLLECTION, newDoc);
}

/**
 * Get version history for a document
 * @param {string} documentId - Document ID (or any version ID in chain)
 * @returns {Promise<Array>} - All versions of document
 */
export async function getDocumentVersionHistory(documentId) {
  // Find the 'active' or latest version if possible, or walk the chain.
  // For simplicity, we can query by some common grouping ID if we had one,
  // but here we might rely on previous_version_id chain.
  // A better schema would have a 'root_document_id' field.
  // For now, let's assume we find all by matching title + carrier + driver + type

  const doc = await getDocument(documentId);
  if (!doc) return [];

  const carrierDot = doc.carrier_dot || doc['Carrier Dot'];
  const docType = doc.document_type || doc['Document Type'];
  const driverId = doc.driver_id || doc['Driver Id'];

  // Dual-source routing
  if (usesAirtable(COLLECTION_KEYS.carrierDocuments)) {
    const tableName = getAirtableTableName(COLLECTION_KEYS.carrierDocuments);
    const filter = `AND({Carrier Dot} = "${carrierDot}", {Document Type} = "${docType}", {Driver Id} = "${driverId}")`;
    const result = await airtable.queryRecords(tableName, {
      filterByFormula: filter,
      sort: [{ field: 'Version', direction: 'desc' }],
      maxRecords: 100
    });
    return (result.records || []).map(r => ({
      _id: r.id || r._id,
      carrier_dot: r['Carrier Dot'] || r.carrier_dot,
      document_type: r['Document Type'] || r.document_type,
      driver_id: r['Driver Id'] || r.driver_id,
      version: r.Version || r.version,
      status: r.Status || r.status,
      file_url: r['File Url'] || r.file_url
    }));
  }

  const result = await wixData.query(COLLECTION)
    .eq('carrier_dot', carrierDot)
    .eq('document_type', docType)
    .eq('driver_id', driverId)
    .descending('version')
    .find({ suppressAuth: true });

  return result.items;
}

/**
 * Archive a document (soft delete)
 * @param {string} documentId - Document ID
 * @returns {Promise<boolean>} - Success
 */
export async function archiveDocument(documentId) {
  const doc = await getDocument(documentId);
  if (!doc) return false;

  const archiveUpdate = { ...doc, _id: doc._id || doc.id, status: 'archived' };
  // Use dual-source routing
  await updateData(COLLECTION_KEYS.carrierDocuments, COLLECTION, archiveUpdate);
  return true;
}

// ============================================================
// EXPIRATION TRACKING
// ============================================================

/**
 * Get documents expiring within a date range
 * @param {string} carrierDot - Carrier DOT number
 * @param {number} daysAhead - Days to look ahead
 * @returns {Promise<Array>} - Expiring documents
 */
export async function getExpiringDocuments(carrierDot, daysAhead = 30) {
  const now = new Date();
  const future = new Date();
  future.setDate(future.getDate() + daysAhead);

  // Dual-source routing
  if (usesAirtable(COLLECTION_KEYS.carrierDocuments)) {
    const tableName = getAirtableTableName(COLLECTION_KEYS.carrierDocuments);
    const filter = `AND({Carrier Dot} = "${carrierDot}", {Status} = "active", {Is Expired} = FALSE(), {Expiration Date} <= "${future.toISOString()}")`;
    const result = await airtable.queryRecords(tableName, {
      filterByFormula: filter,
      sort: [{ field: 'Expiration Date', direction: 'asc' }],
      maxRecords: 100
    });
    return (result.records || []).map(r => ({
      _id: r.id || r._id,
      carrier_dot: r['Carrier Dot'] || r.carrier_dot,
      document_type: r['Document Type'] || r.document_type,
      expiration_date: r['Expiration Date'] || r.expiration_date,
      title: r.Title || r.title,
      status: r.Status || r.status
    }));
  }

  const result = await wixData.query(COLLECTION)
    .eq('carrier_dot', carrierDot)
    .eq('status', 'active')
    .eq('is_expired', false)
    .le('expiration_date', future)
    .ascending('expiration_date')
    .find({ suppressAuth: true });

  return result.items;
}

/**
 * Get all expired documents
 * @param {string} carrierDot - Carrier DOT number
 * @returns {Promise<Array>} - Expired documents
 */
export async function getExpiredDocuments(carrierDot) {
  // Dual-source routing
  if (usesAirtable(COLLECTION_KEYS.carrierDocuments)) {
    const tableName = getAirtableTableName(COLLECTION_KEYS.carrierDocuments);
    const filter = `AND({Carrier Dot} = "${carrierDot}", {Status} = "active", {Is Expired} = TRUE())`;
    const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 100 });
    return (result.records || []).map(r => ({
      _id: r.id || r._id,
      carrier_dot: r['Carrier Dot'] || r.carrier_dot,
      document_type: r['Document Type'] || r.document_type,
      expiration_date: r['Expiration Date'] || r.expiration_date,
      title: r.Title || r.title,
      status: r.Status || r.status,
      is_expired: true
    }));
  }

  const result = await wixData.query(COLLECTION)
    .eq('carrier_dot', carrierDot)
    .eq('status', 'active')
    .eq('is_expired', true)
    .find({ suppressAuth: true });

  return result.items;
}

// ============================================================
// VERIFICATION
// ============================================================

/**
 * Verify a document (admin action)
 * @param {string} documentId - Document ID
 * @param {string} verifierId - Verifying user ID
 * @param {string} status - 'verified' or 'rejected'
 * @param {string} notes - Verification notes
 * @returns {Promise<Object>} - Updated document
 */
export async function verifyDocument(documentId, verifierId, status, notes = '') {
  const doc = await getDocument(documentId);
  if (!doc) throw new Error('Document not found');

  const verifyUpdate = {
    ...doc,
    _id: doc._id || doc.id,
    verification_status: status,
    verified_by: verifierId,
    verified_date: new Date(),
    notes: notes
  };

  // If rejected, maybe update status? Keeping active for now so they can see it's rejected.

  // Use dual-source routing
  return updateData(COLLECTION_KEYS.carrierDocuments, COLLECTION, verifyUpdate);
}

/**
 * Process document expirations (Scheduled Job)
 * Updates days_until_expiry and is_expired flags
 */
export async function updateDocumentExpirations() {
  const now = new Date();

  // Get all active documents using dual-source routing
  let items = [];

  if (usesAirtable(COLLECTION_KEYS.carrierDocuments)) {
    const tableName = getAirtableTableName(COLLECTION_KEYS.carrierDocuments);
    const result = await airtable.queryRecords(tableName, {
      filterByFormula: `{Status} = "active"`,
      maxRecords: 5000
    });
    items = (result.records || []).map(r => ({
      _id: r.id || r._id,
      expiration_date: r['Expiration Date'] || r.expiration_date,
      is_expired: r['Is Expired'] || r.is_expired,
      days_until_expiry: r['Days Until Expiry'] || r.days_until_expiry
    }));
  } else {
    // Pagination would be needed for scale
    let query = wixData.query(COLLECTION).eq('status', 'active');
    let result = await query.find({ suppressAuth: true });
    items = result.items;

    while(result.hasNext()) {
        result = await result.next();
        items = items.concat(result.items);
    }
  }

  let updatedCount = 0;

  for (const doc of items) {
    if (!doc.expiration_date) continue;

    const expDate = new Date(doc.expiration_date);
    const isExpired = expDate < now;
    const daysUntil = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));

    if (doc.is_expired !== isExpired || doc.days_until_expiry !== daysUntil) {
      const expirationUpdate = {
        _id: doc._id,
        is_expired: isExpired,
        days_until_expiry: daysUntil
      };
      await updateData(COLLECTION_KEYS.carrierDocuments, COLLECTION, expirationUpdate);
      updatedCount++;
    }
  }

  return { processed: items.length, updated: updatedCount };
}

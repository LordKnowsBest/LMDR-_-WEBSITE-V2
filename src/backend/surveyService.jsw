/**
 * Survey Service
 *
 * Manages the "Pulse Check" system for drivers.
 * Triggers surveys based on lifecycle events and processes responses.
 *
 * @module backend/surveyService
 */

import { insertRecord, queryRecords, updateRecord, getRecord } from 'backend/dataAccess';
import * as lifecycleService from 'backend/lifecycleService';
import { sendEmail } from 'backend/emailService'; // Hypothetical email sender
import { awardDriverXP } from 'backend/gamificationService';

// ============================================================================
// CONSTANTS
// ============================================================================

export const SURVEY_TYPES = {
  ORIENTATION: 'ORIENTATION',
  DAY_7: 'DAY_7',
  DAY_30: 'DAY_30',
  EXIT: 'EXIT'
};

const DEFAULT_QUESTIONS = {
  ORIENTATION: [
    { id: 'q1', text: 'Did the job description match reality?', type: 'scale_1_5' },
    { id: 'q2', text: 'Was orientation organized?', type: 'scale_1_5' }
  ],
  DAY_7: [
    { id: 'q1', text: 'How was your first week?', type: 'scale_1_5' },
    { id: 'q2', text: 'Are you getting the miles promised?', type: 'yes_no' }
  ],
  DAY_30: [
    { id: 'q1', text: 'Do you see yourself here in a year?', type: 'scale_1_5' },
    { id: 'q2', text: 'Rate your dispatcher', type: 'scale_1_5' }
  ]
};

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

/**
 * Check for drivers who need a survey triggered
 * Designed to be run by a scheduled job (e.g., daily)
 */
export async function checkSurveyTriggers() {
  console.log('üîç Checking survey triggers...');
  
  // In a real implementation, this would query:
  // 1. Drivers who are 'Active'
  // 2. Calculate days since 'HIRE' event
  // 3. Check if survey already sent
  // For prototype, we'll stub this logic.
  
  return { success: true, surveysSent: 0 };
}

/**
 * Send a specific survey to a driver
 *
 * @param {string} driverId
 * @param {string} carrierId
 * @param {string} surveyType - One of SURVEY_TYPES
 */
export async function sendSurvey(driverId, carrierId, surveyType) {
  try {
    // 1. Get Survey Definition (or use default)
    const questions = DEFAULT_QUESTIONS[surveyType] || [];

    // 2. Log the "Survey Sent" event
    await lifecycleService.logEvent(driverId, carrierId, lifecycleService.EVENT_TYPES.SURVEY_SENT, {
      surveyType,
      questionCount: questions.length
    });

    // 3. Send Notification (Email/SMS/Push)
    // await sendEmail(driverId, 'Survey Available', ...);
    
    console.log(`‚úÖ Survey ${surveyType} sent to driver ${driverId}`);
    return { success: true };

  } catch (error) {
    console.error(`[surveyService] sendSurvey error:`, error);
    return { success: false, error: error.message };
  }
}

/**
 * Process a survey response
 *
 * @param {string} driverId
 * @param {string} carrierId
 * @param {string} surveyType
 * @param {Object} responseData - { scores: {}, comments: '' }
 */
export async function processResponse(driverId, carrierId, surveyType, responseData) {
  try {
    // 1. Save Response
    const responseRecord = {
      driverId,
      carrierId,
      surveyId: surveyType, // Using type as ID for default/static surveys
      scores: JSON.stringify(responseData.scores),
      comments: responseData.comments || ''
    };

    const result = await insertRecord('surveyResponses', responseRecord);

    if (!result.success) {
      throw new Error(`Failed to save response: ${result.error}`);
    }

    // 2. Log Completion Event
    await lifecycleService.logEvent(driverId, carrierId, lifecycleService.EVENT_TYPES.SURVEY_COMPLETED, {
      surveyType,
      avgScore: calculateAvgScore(responseData.scores)
    });

    // 3. Trigger Feedback Loop (if score is low)
    const feedbackLoop = await import('backend/feedbackLoopService'); // Lazy load
    await feedbackLoop.analyzeSurvey(result.record);

    return { success: true, record: result.record };

  } catch (error) {
    console.error(`[surveyService] processResponse error:`, error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// AGENT-FACING API (driver_lifecycle router)
// ============================================================================

/**
 * Get pending surveys for a driver
 * @param {string} driverId
 * @param {string} [surveyType="all"]
 * @returns {Promise<object>} { items, totalCount } or { error }
 */
export async function getPendingSurveys(driverId, surveyType = 'all') {
  try {
    const filters = {
      driver_id: driverId,
      status: 'pending'
    };

    if (surveyType && surveyType !== 'all') {
      filters.survey_type = surveyType;
    }

    const result = await queryRecords('driverSurveyRequests', {
      filters,
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 50,
      suppressAuth: true
    });

    return { items: result.items || [], totalCount: result.totalCount || 0 };
  } catch (error) {
    console.error('surveyService.getPendingSurveys error:', error);
    return { error: error.message };
  }
}

/**
 * Submit a survey response (agent-facing)
 * @param {string} driverId
 * @param {string} surveyRequestId
 * @param {object} responses - key-value map of question IDs to answers
 * @returns {Promise<object>} { responseId } or { error }
 */
export async function submitSurveyResponse(driverId, surveyRequestId, responses = {}) {
  try {
    if (!surveyRequestId) return { error: 'surveyRequestId is required' };
    if (!responses || Object.keys(responses).length === 0) {
      return { error: 'responses object is required' };
    }

    const requestResult = await queryRecords('driverSurveyRequests', {
      filters: { _id: surveyRequestId, driver_id: driverId },
      limit: 1,
      suppressAuth: true
    });

    if (!requestResult.items || requestResult.items.length === 0) {
      return { error: 'Survey request not found' };
    }

    const request = requestResult.items[0];
    if (request.status !== 'pending') {
      return { error: 'Survey already completed' };
    }

    const record = {
      driver_id: driverId,
      survey_request_id: surveyRequestId,
      survey_type: request.survey_type || 'general',
      responses: JSON.stringify(responses),
      submitted_at: new Date().toISOString()
    };

    const created = await insertRecord('driverSurveyResponses', record, { suppressAuth: true });

    const completedAt = new Date().toISOString();
    await updateRecord('driverSurveyRequests', {
      _id: surveyRequestId,
      status: 'completed',
      completed_at: completedAt
    }, { suppressAuth: true });

    // Award XP for completing the 30-day post-hire survey (Phase 9)
    if (request.survey_type === SURVEY_TYPES.DAY_30) {
      await awardDriverXP(driverId, 'post_hire_survey_completed', {
        surveyType: SURVEY_TYPES.DAY_30,
        completedAt
      }).catch(e => console.warn('XP award failed (post_hire_survey_completed):', e.message));
    }

    return { responseId: created._id || created.id };
  } catch (error) {
    console.error('surveyService.submitSurveyResponse error:', error);
    return { error: error.message };
  }
}

// ============================================================================
// HELPERS
// ============================================================================

function calculateAvgScore(scores) {
  if (!scores) return 0;
  const values = Object.values(scores).filter(v => typeof v === 'number');
  if (values.length === 0) return 0;
  return values.reduce((a, b) => a + b, 0) / values.length;
}

/**
 * Survey Service
 *
 * Manages the "Pulse Check" system for drivers.
 * Triggers surveys based on lifecycle events and processes responses.
 *
 * @module backend/surveyService
 */

import { insertRecord, queryRecords, updateRecord, getRecord } from 'backend/dataAccess';
import * as lifecycleService from 'backend/lifecycleService';
import { sendSurveyEmail } from 'backend/emailService';
import { awardDriverXP } from 'backend/gamificationService';

// ============================================================================
// CONSTANTS
// ============================================================================

export const SURVEY_TYPES = {
  ORIENTATION: 'ORIENTATION',
  DAY_7: 'DAY_7',
  DAY_30: 'DAY_30',
  EXIT: 'EXIT'
};

const DEFAULT_QUESTIONS = {
  ORIENTATION: [
    { id: 'q1', text: 'Did the job description match reality?', type: 'scale_1_5' },
    { id: 'q2', text: 'Was orientation organized?', type: 'scale_1_5' }
  ],
  DAY_7: [
    { id: 'q1', text: 'How was your first week?', type: 'scale_1_5' },
    { id: 'q2', text: 'Are you getting the miles promised?', type: 'yes_no' }
  ],
  DAY_30: [
    { id: 'q1', text: 'Do you see yourself here in a year?', type: 'scale_1_5' },
    { id: 'q2', text: 'Rate your dispatcher', type: 'scale_1_5' }
  ]
};

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

/**
 * Check for drivers who need a survey triggered.
 * Runs daily via scheduled job (08:00 UTC).
 *
 * Scans HIRED_ACTIVE lifecycle events and sends:
 *  - DAY_7 survey: hired 6–8 days ago, no DAY_7 survey sent yet
 *  - DAY_30 survey: hired 28–32 days ago, no DAY_30 survey sent yet
 */
export async function checkSurveyTriggers() {
  console.log('[surveyService] Checking survey triggers...');

  const now = Date.now();
  let surveysSent = 0;
  let errors = 0;

  // Time-based triggers keyed to HIRED_ACTIVE events
  const timeTriggers = [
    { surveyType: SURVEY_TYPES.DAY_7,  minDays: 6,  maxDays: 8  },
    { surveyType: SURVEY_TYPES.DAY_30, minDays: 28, maxDays: 32 }
  ];

  try {
    // --- DAY_7 and DAY_30: scan HIRED_ACTIVE events ---
    for (const { surveyType, minDays, maxDays } of timeTriggers) {
      const windowStart = new Date(now - maxDays * 86400000).toISOString();
      const windowEnd   = new Date(now - minDays * 86400000).toISOString();

      const hireResult = await queryRecords('lifecycleEvents', {
        filters: {
          event_type: lifecycleService.EVENT_TYPES.HIRE,
          event_date: { gte: windowStart, lte: windowEnd }
        },
        limit: 500,
        suppressAuth: true
      });

      for (const hireEvent of (hireResult.items || [])) {
        try {
          const { driver_id, carrier_id } = hireEvent;
          if (!driver_id) continue;
          const sent = await sendSurveyIfNotSent(driver_id, carrier_id, surveyType);
          if (sent) surveysSent++;
        } catch (driverErr) {
          console.warn(`[surveyService] Trigger error for driver ${hireEvent.driver_id}:`, driverErr.message);
          errors++;
        }
      }
    }

    // --- EXIT: scan TERMINATION and RESIGNATION events from last 2 days (safety net) ---
    const exitWindow = new Date(now - 2 * 86400000).toISOString();
    const exitResult = await queryRecords('lifecycleEvents', {
      filters: {
        event_type: { hasSome: [lifecycleService.EVENT_TYPES.TERMINATION, lifecycleService.EVENT_TYPES.RESIGNATION] },
        event_date: { gte: exitWindow }
      },
      limit: 500,
      suppressAuth: true
    });

    for (const event of (exitResult.items || [])) {
      try {
        const { driver_id, carrier_id } = event;
        if (!driver_id) continue;
        const sent = await sendSurveyIfNotSent(driver_id, carrier_id, SURVEY_TYPES.EXIT);
        if (sent) surveysSent++;
      } catch (eventErr) {
        console.warn(`[surveyService] Exit trigger error for driver ${event.driver_id}:`, eventErr.message);
        errors++;
      }
    }

    // --- ORIENTATION: scan ORIENTATION_COMPLETE events from last 2 days (safety net) ---
    const orientationWindow = new Date(now - 2 * 86400000).toISOString();
    const orientationResult = await queryRecords('lifecycleEvents', {
      filters: {
        event_type: lifecycleService.EVENT_TYPES.ORIENTATION,
        event_date: { gte: orientationWindow }
      },
      limit: 500,
      suppressAuth: true
    });

    for (const event of (orientationResult.items || [])) {
      try {
        const { driver_id, carrier_id } = event;
        if (!driver_id) continue;
        const sent = await sendSurveyIfNotSent(driver_id, carrier_id, SURVEY_TYPES.ORIENTATION);
        if (sent) surveysSent++;
      } catch (eventErr) {
        console.warn(`[surveyService] Orientation trigger error for driver ${event.driver_id}:`, eventErr.message);
        errors++;
      }
    }

    console.log(`[surveyService] Survey trigger check complete — sent: ${surveysSent}, errors: ${errors}`);
    return { success: true, surveysSent, errors };
  } catch (error) {
    console.error('[surveyService] checkSurveyTriggers error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Send a survey only if one hasn't already been sent for this driver+type.
 * Safe to call from any trigger point — deduplicates against driverSurveyRequests.
 *
 * @param {string} driverId
 * @param {string} carrierId
 * @param {string} surveyType - One of SURVEY_TYPES
 * @returns {Promise<boolean>} true if a new survey was sent, false if already existed
 */
export async function sendSurveyIfNotSent(driverId, carrierId, surveyType) {
  const existing = await queryRecords('driverSurveyRequests', {
    filters: { driver_id: driverId, survey_type: surveyType },
    limit: 1,
    suppressAuth: true
  });
  if ((existing.items || []).length > 0) return false;

  await sendSurvey(driverId, carrierId, surveyType);
  return true;
}

/**
 * Send a specific survey to a driver.
 * Creates a driverSurveyRequests record, logs the lifecycle event,
 * and sends a Wix triggered email.
 *
 * @param {string} driverId
 * @param {string} carrierId
 * @param {string} surveyType - One of SURVEY_TYPES
 */
export async function sendSurvey(driverId, carrierId, surveyType) {
  try {
    const questions = DEFAULT_QUESTIONS[surveyType] || [];
    const expiresAt = new Date(Date.now() + 7 * 86400000).toISOString(); // 7 days to complete

    // 1. Create the survey request record
    const surveyRequest = await insertRecord('driverSurveyRequests', {
      driver_id:   driverId,
      carrier_id:  carrierId,
      survey_type: surveyType,
      status:      'pending',
      questions:   JSON.stringify(questions),
      expires_at:  expiresAt,
      sent_at:     new Date().toISOString()
    }, { suppressAuth: true });

    // 2. Log the lifecycle event
    await lifecycleService.logEvent(driverId, carrierId, lifecycleService.EVENT_TYPES.SURVEY_SENT, {
      surveyType,
      surveyRequestId: surveyRequest.record?._id || surveyRequest._id,
      questionCount: questions.length
    });

    // 3. Send Wix triggered email
    // Look up driver profile for name and Wix user ID
    const driverResult = await queryRecords('driverProfiles', {
      filters: { _id: driverId },
      limit: 1,
      suppressAuth: true
    });
    const driver = (driverResult.items || [])[0];
    const wixUserId = driver?.wix_user_id || driver?.member_id || driverId;
    const driverName = driver?.display_name || driver?.driver_name || 'Driver';

    // Look up carrier name
    const carrierResult = await queryRecords('carriers', {
      filters: { _id: carrierId },
      limit: 1,
      suppressAuth: true
    });
    const carrier = (carrierResult.items || [])[0];
    const carrierName = carrier?.legal_name || carrier?.title || 'your carrier';

    await sendSurveyEmail(wixUserId, {
      surveyType,
      driverName,
      carrierName,
      surveyUrl: 'https://www.lastmiledr.app/driver/surveys',
      expiresIn: '7 days'
    });

    console.log(`[surveyService] Survey ${surveyType} sent to driver ${driverId}`);
    return { success: true, surveyRequestId: surveyRequest.record?._id || surveyRequest._id };

  } catch (error) {
    console.error(`[surveyService] sendSurvey error:`, error);
    return { success: false, error: error.message };
  }
}

/**
 * Process a survey response
 *
 * @param {string} driverId
 * @param {string} carrierId
 * @param {string} surveyType
 * @param {Object} responseData - { scores: {}, comments: '' }
 */
export async function processResponse(driverId, carrierId, surveyType, responseData) {
  try {
    // 1. Save Response
    const responseRecord = {
      driverId,
      carrierId,
      surveyId: surveyType, // Using type as ID for default/static surveys
      scores: JSON.stringify(responseData.scores),
      comments: responseData.comments || ''
    };

    const result = await insertRecord('surveyResponses', responseRecord);

    if (!result.success) {
      throw new Error(`Failed to save response: ${result.error}`);
    }

    // 2. Log Completion Event
    await lifecycleService.logEvent(driverId, carrierId, lifecycleService.EVENT_TYPES.SURVEY_COMPLETED, {
      surveyType,
      avgScore: calculateAvgScore(responseData.scores)
    });

    // 3. Trigger Feedback Loop (if score is low)
    const feedbackLoop = await import('backend/feedbackLoopService'); // Lazy load
    await feedbackLoop.analyzeSurvey(result.record);

    return { success: true, record: result.record };

  } catch (error) {
    console.error(`[surveyService] processResponse error:`, error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// AGENT-FACING API (driver_lifecycle router)
// ============================================================================

/**
 * Get pending surveys for a driver
 * @param {string} driverId
 * @param {string} [surveyType="all"]
 * @returns {Promise<object>} { items, totalCount } or { error }
 */
export async function getPendingSurveys(driverId, surveyType = 'all') {
  try {
    const filters = {
      driver_id: driverId,
      status: 'pending'
    };

    if (surveyType && surveyType !== 'all') {
      filters.survey_type = surveyType;
    }

    const result = await queryRecords('driverSurveyRequests', {
      filters,
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 50,
      suppressAuth: true
    });

    return { items: result.items || [], totalCount: result.totalCount || 0 };
  } catch (error) {
    console.error('surveyService.getPendingSurveys error:', error);
    return { error: error.message };
  }
}

/**
 * Submit a survey response (agent-facing)
 * @param {string} driverId
 * @param {string} surveyRequestId
 * @param {object} responses - key-value map of question IDs to answers
 * @returns {Promise<object>} { responseId } or { error }
 */
export async function submitSurveyResponse(driverId, surveyRequestId, responses = {}) {
  try {
    if (!surveyRequestId) return { error: 'surveyRequestId is required' };
    if (!responses || Object.keys(responses).length === 0) {
      return { error: 'responses object is required' };
    }

    const requestResult = await queryRecords('driverSurveyRequests', {
      filters: { _id: surveyRequestId, driver_id: driverId },
      limit: 1,
      suppressAuth: true
    });

    if (!requestResult.items || requestResult.items.length === 0) {
      return { error: 'Survey request not found' };
    }

    const request = requestResult.items[0];
    if (request.status !== 'pending') {
      return { error: 'Survey already completed' };
    }

    const record = {
      driver_id: driverId,
      survey_request_id: surveyRequestId,
      survey_type: request.survey_type || 'general',
      responses: JSON.stringify(responses),
      submitted_at: new Date().toISOString()
    };

    const created = await insertRecord('driverSurveyResponses', record, { suppressAuth: true });

    const completedAt = new Date().toISOString();
    await updateRecord('driverSurveyRequests', {
      _id: surveyRequestId,
      status: 'completed',
      completed_at: completedAt
    }, { suppressAuth: true });

    // Award XP for completing the 30-day post-hire survey (Phase 9)
    if (request.survey_type === SURVEY_TYPES.DAY_30) {
      await awardDriverXP(driverId, 'post_hire_survey_completed', {
        surveyType: SURVEY_TYPES.DAY_30,
        completedAt
      }).catch(e => console.warn('XP award failed (post_hire_survey_completed):', e.message));
    }

    return { responseId: created._id || created.id };
  } catch (error) {
    console.error('surveyService.submitSurveyResponse error:', error);
    return { error: error.message };
  }
}

// ============================================================================
// HELPERS
// ============================================================================

function calculateAvgScore(scores) {
  if (!scores) return 0;
  const values = Object.values(scores).filter(v => typeof v === 'number');
  if (values.length === 0) return 0;
  return values.reduce((a, b) => a + b, 0) / values.length;
}

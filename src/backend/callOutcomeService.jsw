import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import { logFeatureInteraction } from 'backend/featureAdoptionService';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
  callOutcomes: 'callOutcomes',
  callFeedback: 'callFeedback'
};

const VALID_OUTCOMES = ['interested', 'callback', 'not_now', 'wrong_fit', 'no_answer', 'voicemail'];
const VALID_SENTIMENTS = ['positive', 'neutral', 'negative'];

// Helper to get current user ID
async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

// ============================================================================
// LOG CALL OUTCOME
// ============================================================================

export async function logCallOutcome(carrierDot, outcomeData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const { driverId, outcome, outcomeDetails, notes, callDurationSeconds, followUpDate, followUpType, matchScoreAtCall, source, sentiment } = outcomeData;
    if (!driverId) return { success: false, error: 'Driver ID is required' };
    if (!VALID_OUTCOMES.includes(outcome)) return { success: false, error: 'Invalid outcome' };

    const record = {
      recruiter_id: userId, carrier_dot: String(carrierDot), driver_id: driverId,
      call_timestamp: new Date().toISOString(), call_duration_seconds: callDurationSeconds || 0,
      outcome, outcome_details: outcomeDetails || '', follow_up_date: followUpDate || null,
      follow_up_type: followUpType || null, match_score_at_call: matchScoreAtCall || 0,
      source: source || 'manual', sentiment: VALID_SENTIMENTS.includes(sentiment) ? sentiment : 'neutral',
      notes: notes || ''
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.callOutcomes, record, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    // Gamification hook
    try {
      const gamification = await import('backend/gamificationService');
      await gamification.awardRecruiterPoints(userId, 'log_call', { carrierDot, driverId, outcome });
    } catch (err) { }

    logFeatureInteraction('call_outcome', userId, 'log', { carrierDot, outcome }).catch(() => {});
    return { success: true, callOutcome: result.record };
  } catch (error) {
    console.error('logCallOutcome error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET DRIVER OUTCOMES
// ============================================================================

export async function getDriverOutcomes(driverId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.callOutcomes, {
      filters: { driver_id: driverId },
      sort: [{ field: 'call_timestamp', direction: 'desc' }],
      limit: 50, suppressAuth: true
    });
    return { success: true, outcomes: result.items || [] };
  } catch (error) {
    console.error('getDriverOutcomes error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET CARRIER OUTCOMES
// ============================================================================

export async function getCarrierOutcomes(carrierDot, options = {}) {
  try {
    const { outcome, startDate, endDate, limit } = options;
    const filters = { carrier_dot: String(carrierDot) };
    if (outcome && VALID_OUTCOMES.includes(outcome)) filters.outcome = outcome;
    if (startDate) filters.call_timestamp = { gte: startDate };
    // Handle upper bound if needed

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.callOutcomes, {
      filters, sort: [{ field: 'call_timestamp', direction: 'desc' }],
      limit: limit || 100, suppressAuth: true
    });
    return { success: true, outcomes: result.items || [], total: result.totalCount || result.items?.length };
  } catch (error) {
    console.error('getCarrierOutcomes error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET OUTCOME ANALYTICS
// ============================================================================

export async function getOutcomeAnalytics(carrierDot, dateRange = {}) {
  try {
    const filters = { carrier_dot: String(carrierDot) };
    if (dateRange.startDate) filters.call_timestamp = { gte: dateRange.startDate };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.callOutcomes, {
      filters, limit: 1000, suppressAuth: true
    });
    const outcomes = result.items || [];

    const distribution = {};
    VALID_OUTCOMES.forEach(o => { distribution[o] = 0; });
    const sentimentCounts = { positive: 0, neutral: 0, negative: 0 };
    const scoreBands = { '90-100': { t: 0, i: 0 }, '80-89': { t: 0, i: 0 }, '70-79': { t: 0, i: 0 }, '60-69': { t: 0, i: 0 }, 'below-60': { t: 0, i: 0 } };

    outcomes.forEach(o => {
      if (distribution.hasOwnProperty(o.outcome)) distribution[o.outcome]++;
      if (sentimentCounts.hasOwnProperty(o.sentiment)) sentimentCounts[o.sentiment]++;
      const score = o.match_score_at_call || 0;
      let band = score >= 90 ? '90-100' : score >= 80 ? '80-89' : score >= 70 ? '70-79' : score >= 60 ? '60-69' : 'below-60';
      scoreBands[band].t++;
      if (o.outcome === 'interested' || o.outcome === 'callback') scoreBands[band].i++;
    });

    const conversionByBand = {};
    for (const [band, data] of Object.entries(scoreBands)) {
      conversionByBand[band] = data.t > 0 ? Math.round((data.i / data.t) * 100) : 0;
    }

    const totalCalls = outcomes.length;
    const positiveOutcomes = (distribution.interested || 0) + (distribution.callback || 0);

    return {
      success: true,
      analytics: {
        totalCalls, outcomeDistribution: distribution, sentimentBreakdown: sentimentCounts,
        conversionByScoreBand: conversionByBand, overallConversionRate: totalCalls > 0 ? Math.round((positiveOutcomes / totalCalls) * 100) : 0,
        avgSentiment: totalCalls > 0 ? (sentimentCounts.positive - sentimentCounts.negative) / totalCalls : 0
      }
    };
  } catch (error) {
    console.error('getOutcomeAnalytics error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// PROCESS FEEDBACK BATCH
// ============================================================================

export async function processFeedbackBatch() {
  const startTime = Date.now();
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.callOutcomes, { limit: 5000, suppressAuth: true });
    const allOutcomes = result.items || [];
    const byCarrier = {};
    allOutcomes.forEach(o => {
      const dot = o.carrier_dot;
      if (!byCarrier[dot]) byCarrier[dot] = [];
      byCarrier[dot].push(o);
    });

    let processedCarriers = 0;
    for (const [carrierDot, outcomes] of Object.entries(byCarrier)) {
      const pos = outcomes.filter(o => o.outcome === 'interested' || o.outcome === 'callback').length;
      const neg = outcomes.filter(o => o.outcome === 'wrong_fit' || o.outcome === 'not_now').length;
      const total = outcomes.length;
      if (total === 0) continue;

      const posW = Math.min(0.20, (pos / total) * 0.30);
      const negW = Math.min(0.20, (neg / total) * 0.30);

      const existingFeedback = await dataAccess.queryRecords(COLLECTION_KEYS.callFeedback, {
        filters: { carrier_dot: carrierDot }, limit: 1, suppressAuth: true
      });

      const feedbackData = {
        carrier_dot: carrierDot, criteria_key: 'overall', outcome_count: total,
        positive_weight: Math.round(posW * 100) / 100, negative_weight: Math.round(negW * 100) / 100,
        last_calculated: new Date().toISOString()
      };

      if (existingFeedback.success && existingFeedback.items.length > 0) {
        await dataAccess.updateRecord(COLLECTION_KEYS.callFeedback, { ...existingFeedback.items[0], ...feedbackData }, { suppressAuth: true });
      } else {
        await dataAccess.insertRecord(COLLECTION_KEYS.callFeedback, feedbackData, { suppressAuth: true });
      }
      processedCarriers++;
    }

    return { success: true, processedCarriers, durationMs: Date.now() - startTime };
  } catch (error) {
    console.error('[CallOutcomeService] Feedback batch failed:', error);
    return { success: false, error: error.message };
  }
}

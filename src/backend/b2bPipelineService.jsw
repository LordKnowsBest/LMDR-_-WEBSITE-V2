import * as dataAccess from 'backend/dataAccess';
import { logStageChange, logTask } from 'backend/b2bActivityService';
import { predictCloseRate } from 'backend/b2bAIService';

// Collection keys for dataAccess routing
const COLLECTIONS = {
  opportunities: 'b2bOpportunities',
  automationRules: 'b2bAutomationRules',
  accounts: 'b2bAccounts',
  activities: 'b2bActivities',
  playbooks: 'b2bPlaybooks',
  valueProps: 'b2bValueProps'
};

const STAGES = {
  PROSPECTING: { id: 'prospecting', name: 'Prospecting', probability: 0.10, order: 1, sla_days: 14 },
  DISCOVERY: { id: 'discovery', name: 'Discovery', probability: 0.25, order: 2, sla_days: 10 },
  PROPOSAL: { id: 'proposal', name: 'Proposal', probability: 0.50, order: 3, sla_days: 7 },
  NEGOTIATION: { id: 'negotiation', name: 'Negotiation', probability: 0.75, order: 4, sla_days: 7 },
  CLOSED_WON: { id: 'closed_won', name: 'Closed Won', probability: 1.0, order: 5, sla_days: null },
  CLOSED_LOST: { id: 'closed_lost', name: 'Closed Lost', probability: 0, order: 6, sla_days: null }
};

const STAGE_ORDER = ['prospecting', 'discovery', 'proposal', 'negotiation', 'closed_won', 'closed_lost'];

// ============================================================================
// OPPORTUNITY CRUD
// ============================================================================

export async function createOpportunity(oppData) {
  try {
    if (!oppData.account_id) return { success: false, error: 'Account ID required' };
    const stage = oppData.stage || 'prospecting';
    if (!STAGE_ORDER.includes(stage)) return { success: false, error: 'Invalid stage' };

    const record = {
      account_id: oppData.account_id, stage, value_estimate: oppData.value_estimate || 0,
      match_signal_id: oppData.match_signal_id || '', owner_id: oppData.owner_id || '',
      next_step: oppData.next_step || '', next_step_at: oppData.next_step_at || '',
      stage_entered_at: new Date().toISOString(), created_at: new Date().toISOString(), updated_at: new Date().toISOString()
    };

    const result = await dataAccess.insertRecord(COLLECTIONS.opportunities, record, { suppressAuth: true });
    return { success: result.success, opportunity: result.record, error: result.error };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getOpportunity(opportunityId) {
  try {
    const record = await dataAccess.getRecord(COLLECTIONS.opportunities, opportunityId, { suppressAuth: true });
    if (!record) return { success: false, error: 'Not found' };
    return { success: true, opportunity: { ...record, risk_flags: computeRiskFlags(record) } };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateOpportunity(opportunityId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.opportunities, opportunityId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.opportunities, { ...existing, ...updates, _id: opportunityId, updated_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: result.success, opportunity: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function moveStage(opportunityId, newStage, closeReason = '') {
  try {
    if (!STAGE_ORDER.includes(newStage)) return { success: false, error: 'Invalid stage' };
    const current = await dataAccess.getRecord(COLLECTIONS.opportunities, opportunityId, { suppressAuth: true });
    if (!current) return { success: false, error: 'Not found' };
    if (current.stage === newStage) return { success: false, error: 'Same stage' };

    const updates = { stage: newStage, stage_entered_at: new Date().toISOString(), updated_at: new Date().toISOString() };
    if (closeReason) updates.close_reason = closeReason;

    const result = await dataAccess.updateRecord(COLLECTIONS.opportunities, { ...current, ...updates, _id: opportunityId }, { suppressAuth: true });
    logStageChange(current.account_id, current.stage, newStage, current.owner_id).catch(() => {});
    evaluateAutomationRules(current.stage, newStage, current).catch(() => {});

    return { success: result.success, opportunity: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// PIPELINE VIEWS & ROLLUPS
// ============================================================================

export async function getPipelineView(filters = {}) {
  try {
    const queryFilters = { stage: { ne: ['closed_won', 'closed_lost'] } };
    if (filters.ownerId) queryFilters.owner_id = filters.ownerId;

    const result = await dataAccess.queryRecords(COLLECTIONS.opportunities, { filters: queryFilters, limit: 500, suppressAuth: true });
    const opps = result.items || [];

    const stageMap = {};
    STAGE_ORDER.filter(s => s !== 'closed_won' && s !== 'closed_lost').forEach(s => {
      const def = Object.values(STAGES).find(st => st.id === s);
      stageMap[s] = { stage_id: s, name: def.name, probability: def.probability, opportunities: [], value_sum: 0, weighted_value: 0 };
    });

    opps.forEach(o => {
      if (stageMap[o.stage]) {
        stageMap[o.stage].opportunities.push({ ...o, risk_flags: computeRiskFlags(o) });
        const val = Number(o.value_estimate) || 0;
        stageMap[o.stage].value_sum += val;
        stageMap[o.stage].weighted_value += val * stageMap[o.stage].probability;
      }
    });

    const stages = STAGE_ORDER.filter(s => s !== 'closed_won' && s !== 'closed_lost').map(s => stageMap[s]);
    return { success: true, stages, summary: { total_pipeline: stages.reduce((s, st) => s + st.value_sum, 0), weighted_pipeline: Math.round(stages.reduce((s, st) => s + st.weighted_value, 0)), total_deals: opps.length } };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getForecast(options = {}) {
  try {
    const res = await getPipelineView(options);
    if (!res.success) throw new Error(res.error);
    const opps = res.stages.flatMap(s => s.opportunities);
    const useAI = options.useAI !== false;
    const refreshPredictions = options.refreshPredictions === true;
    let commit = 0;
    let best = 0;
    let pipeline = 0;
    let weighted = 0;
    const divergenceDeals = [];

    opps.forEach(o => {
      const v = Number(o.value_estimate) || 0;
      pipeline += v;
      const stageProb = Math.round((STAGES[o.stage?.toUpperCase()]?.probability || 0) * 100);
      const aiProb = Number(o.ai_close_probability || 0);
      const appliedProb = useAI && aiProb > 0 ? aiProb : stageProb;

      weighted += v * (appliedProb / 100);
      if (appliedProb >= 70) {
        commit += v;
        best += v;
      } else if (appliedProb >= 40) {
        best += v;
      }

      if (useAI && aiProb > 0 && Math.abs(aiProb - stageProb) >= 20) {
        divergenceDeals.push({
          opportunity_id: o._id || o.id,
          account_id: o.account_id,
          value_estimate: v,
          stage_probability: stageProb,
          ai_probability: aiProb,
          delta: aiProb - stageProb
        });
      }
    });

    if (refreshPredictions) {
      await Promise.all(opps.map(o => predictCloseRate(o, { save: true }).catch(() => null)));
    }

    return {
      success: true,
      forecast: {
        mode: useAI ? 'ai' : 'stage',
        ai_enabled: useAI,
        commit: Math.round(commit),
        best: Math.round(best),
        pipeline: Math.round(pipeline),
        weighted_pipeline: Math.round(weighted),
        deal_count: opps.length,
        divergence_deals: divergenceDeals.slice(0, 10),
        divergence_count: divergenceDeals.length
      }
    };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getPipelineKPIs(options = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.opportunities, { filters: { stage: { hasSome: ['closed_won', 'closed_lost'] } }, limit: 500, suppressAuth: true });
    const closed = res.items || [];
    const won = closed.filter(o => o.stage === 'closed_won');
    const winRate = closed.length > 0 ? Math.round((won.length / closed.length) * 100) : 0;
    const wonRev = won.reduce((s, o) => s + (Number(o.value_estimate) || 0), 0);
    return { success: true, kpis: { win_rate: winRate, deals_won: won.length, won_revenue: Math.round(wonRev), period_days: options.days || 90 } };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function createAutomationRule(ruleData) {
  try {
    const res = await dataAccess.insertRecord(COLLECTIONS.automationRules, { ...ruleData, is_active: true, created_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: res.success, rule: res.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getPlaybookSuggestions(segment, stage) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.playbooks, { filters: { segment, stage, is_active: true }, limit: 10, suppressAuth: true });
    return { success: true, playbooks: res.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getDealsAtRisk(options = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.opportunities, { filters: { stage: { ne: ['closed_won', 'closed_lost'] } }, limit: 200, suppressAuth: true });
    const atRisk = (res.items || []).map(o => ({ ...o, risk_flags: computeRiskFlags(o) })).filter(o => o.risk_flags.length > 0);
    return { success: true, atRisk: atRisk.sort((a,b) => b.risk_flags.length - a.risk_flags.length) };
  } catch (error) { return { success: false, error: error.message }; }
}

function computeRiskFlags(opp) {
  const flags = [], now = new Date();
  if (opp.updated_at && (now - new Date(opp.updated_at)) / 86400000 > 10) flags.push({ type: 'stalled', message: 'No activity > 10 days' });
  if (!opp.next_step?.trim()) flags.push({ type: 'no_next_step', message: 'No next step' });
  if (opp.next_step_at && new Date(opp.next_step_at) < now) flags.push({ type: 'overdue', message: 'Next step overdue' });
  return flags;
}

async function evaluateAutomationRules(from, to, opp) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.automationRules, { filters: { trigger_event: 'stage_change', is_active: true, from_stage: from, to_stage: to }, limit: 20, suppressAuth: true });
    for (const rule of (res.items || [])) {
      const actions = typeof rule.actions === 'string' ? JSON.parse(rule.actions) : rule.actions;
      if (Array.isArray(actions)) for (const a of actions) await executeAction(a, opp);
    }
  } catch (e) { }
}

async function executeAction(action, opp) {
  if (action?.type === 'create_task') await logTask(opp.account_id, action.subject || 'Auto task', 'scheduled', opp.owner_id);
}

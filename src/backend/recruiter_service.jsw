/**
 * Recruiter Service
 *
 * Core service for recruiter-specific operations including:
 * - Profile management
 * - Carrier portfolio management (Agency Model)
 * - Pipeline and candidate tracking
 * - Stats and analytics
 *
 * This service uses unified dataAccess for dual-source support.
 * 
 * @module backend/recruiter_service
 */

import wixUsersBackend from 'wix-users-backend';
import * as dataAccess from 'backend/dataAccess';
import { sendStatusUpdateNotification } from 'backend/emailService';
import * as lifecycleService from 'backend/lifecycleService';
import { log } from 'backend/observabilityService';

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const CONFIG = {
  // Pipeline status values (matches DriverCarrierInterests statuses)
  PIPELINE_STAGES: {
    INTERESTED: 'interested',
    APPLIED: 'applied',
    IN_REVIEW: 'in_review',
    CONTACTED: 'contacted',
    OFFER: 'offer',
    HIRED: 'hired',
    REJECTED: 'rejected',
    WITHDRAWN: 'withdrawn'
  },

  // Display order for Kanban columns
  STAGE_ORDER: ['interested', 'applied', 'in_review', 'contacted', 'offer', 'hired']
};

const COLLECTION_KEYS = {
  recruiterProfiles: 'recruiterProfiles',
  recruiterCarriers: 'recruiterCarriers',
  interests: 'driverCarrierInterests',
  driverProfiles: 'driverProfiles',
  carriers: 'carriers'
};

// ============================================================================
// LAZY-LOADED SERVICES
// ============================================================================

async function getGamificationService() {
  return await import('backend/gamificationService');
}

async function getChallengeService() {
  return await import('backend/challengeService');
}

async function getReferralService() {
  return await import('backend/referralService');
}

async function getPipelineAutomation() {
  return await import('backend/pipelineAutomationService');
}

// ============================================================================
// NON-BLOCKING HELPERS
// ============================================================================

async function awardDriverXPNonBlocking(driverId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardDriverXP(driverId, action, metadata);
  } catch (err) {
    console.warn(`[recruiter_service] Driver XP award failed for ${action}:`, err.message);
  }
}

async function awardRecruiterPointsNonBlocking(recruiterId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardRecruiterPoints(recruiterId, action, metadata);
  } catch (err) {
    console.warn(`[recruiter_service] Recruiter points award failed for ${action}:`, err.message);
  }
}

async function updateChallengeProgressNonBlocking(userId, action, count = 1) {
  try {
    const challengeService = await getChallengeService();
    await challengeService.updateChallengeProgress(userId, action, count);
  } catch (err) {
    console.warn(`[recruiter_service] Challenge progress update failed for ${action}:`, err.message);
  }
}

async function processHireBonusNonBlocking(driverId, recruiterId, matchScore, metadata = {}) {
  try {
    const referralService = await getReferralService();
    await referralService.processHireBonus(driverId, recruiterId, matchScore, metadata);
  } catch (err) {
    console.warn('[recruiter_service] Hire bonus processing failed:', err.message);
  }
}

async function emitPipelineEventNonBlocking(carrierDot, eventType, eventData) {
  try {
    const automation = await getPipelineAutomation();
    await automation.processEvent(carrierDot, eventType, eventData);
  } catch (err) {
    console.warn(`[recruiter_service] Pipeline event emission failed for ${eventType}:`, err.message);
  }
}

// ============================================================================
// AUTH HELPERS
// ============================================================================

async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

async function verifyRecruiterAccess(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const dotNum = Number(String(carrierDOT).trim());

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: {
        recruiter_id: userId,
        carrier_dot: dotNum,
        is_active: 'Yes'
      },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) {
      return { success: false, error: 'No access to this carrier' };
    }

    return { success: true, carrierAccess: result.items[0] };
  } catch (error) {
    console.error('[recruiter_service] verifyRecruiterAccess error:', error.message);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// PUBLIC WEB METHODS
// ============================================================================

/**
 * Get or create recruiter profile
 */
export async function getOrCreateRecruiterProfile() {
  try {
    const currentUser = wixUsersBackend.currentUser;
    if (!currentUser.loggedIn) return { success: false, error: 'User not logged in' };

    const userId = currentUser.id;
    const userEmail = await currentUser.getEmail();

    // Query for existing profile
    const profileResult = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterProfiles, {
      filters: { _owner: userId },
      limit: 1,
      suppressAuth: true
    });

    let profile;
    if (!profileResult.success || profileResult.items.length === 0) {
      const newProfile = {
        display_name: '',
        email: userEmail || '',
        phone: '',
        agency_name: '',
        is_independent: true,
        created_date: new Date(),
        last_active_date: new Date(),
        is_active: 'No',
        verification_status: 'pending'
      };

      const result = await dataAccess.insertRecord(COLLECTION_KEYS.recruiterProfiles, newProfile, { suppressAuth: true });
      if (!result.success) throw new Error(result.error);
      profile = result.record;
    } else {
      profile = profileResult.items[0];
      await dataAccess.updateRecord(COLLECTION_KEYS.recruiterProfiles, {
        ...profile,
        _id: profile._id,
        last_active_date: new Date()
      }, { suppressAuth: true });
    }

    // Get carriers
    const carriersResult = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: { recruiter_id: userId, is_active: 'Yes' },
      sort: [{ field: 'added_date', direction: 'desc' }],
      limit: 100,
      suppressAuth: true
    });

    const carriers = carriersResult.items || [];

    let defaultCarrier = null;
    if (carriers.length > 0) {
      const carrierDot = carriers[0].carrier_dot;
      defaultCarrier = await dataAccess.findByField(COLLECTION_KEYS.carriers, 'dot_number', carrierDot, { suppressAuth: true });
    }

    return {
      success: true,
      needsSetup: carriers.length === 0,
      profile: profile,
      carriers: carriers,
      defaultCarrier: defaultCarrier,
      defaultCarrierDOT: carriers.length > 0 ? carriers[0].carrier_dot : null
    };
  } catch (error) {
    console.error('[recruiter_service] getOrCreateRecruiterProfile error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Add a carrier to recruiter portfolio
 */
export async function addCarrier(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'User not logged in' };

    const dotNum = Number(String(carrierDOT).trim());
    const carrier = await dataAccess.findByField(COLLECTION_KEYS.carriers, 'dot_number', dotNum, { suppressAuth: true });

    if (!carrier) return { success: false, error: `Carrier with DOT ${dotNum} not found` };

    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: { recruiter_id: userId, carrier_dot: dotNum },
      limit: 1,
      suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      const existing = existingResult.items[0];
      if (existing.is_active === 'Yes') return { success: false, error: 'Already in portfolio' };

      await dataAccess.updateRecord(COLLECTION_KEYS.recruiterCarriers, {
        ...existing,
        _id: existing._id,
        is_active: 'Yes',
        added_date: new Date()
      }, { suppressAuth: true });

      return { success: true, carrierAccess: existing, carrierInfo: carrier, reactivated: true };
    }

    const newAccess = {
      recruiter_id: userId,
      carrier_dot: dotNum,
      carrier_name: carrier.legal_name || carrier.title || 'Unknown',
      added_date: new Date(),
      is_active: 'No', // Default to inactive until verified
      verification_status: 'pending_verification'
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.recruiterCarriers, newAccess, { suppressAuth: true });
    return { success: true, carrierAccess: result.record, carrierInfo: carrier };
  } catch (error) {
    console.error('[recruiter_service] addCarrier error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Remove a carrier (soft delete)
 */
export async function removeCarrier(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'User not logged in' };

    const dotNum = Number(String(carrierDOT).trim());
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: { recruiter_id: userId, carrier_dot: dotNum },
      limit: 1,
      suppressAuth: true
    });

    if (!result.success || result.items.length === 0) return { success: false, error: 'Carrier not found' };

    const access = result.items[0];
    await dataAccess.updateRecord(COLLECTION_KEYS.recruiterCarriers, {
      ...access,
      _id: access._id,
      is_active: 'No'
    }, { suppressAuth: true });

    return { success: true };
  } catch (error) {
    console.error('[recruiter_service] removeCarrier error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get all carriers for the current recruiter
 */
export async function getRecruiterCarriers() {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'User not logged in' };

    const accessResult = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: { recruiter_id: userId, is_active: 'Yes' },
      sort: [{ field: 'added_date', direction: 'desc' }],
      limit: 100,
      suppressAuth: true
    });

    const carrierAccess = accessResult.items || [];
    if (carrierAccess.length === 0) return { success: true, carriers: [] };

    const dotNumbers = carrierAccess.map(a => a.carrier_dot);
    const carriersResult = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { dot_number: { hasSome: dotNumbers } },
      limit: 100,
      suppressAuth: true
    });

    const carriersItems = carriersResult.items || [];
    const carrierMap = new Map(carriersItems.map(c => [String(c.dot_number), c]));

    const carriers = carrierAccess.map(access => {
      const carrier = carrierMap.get(String(access.carrier_dot)) || {};
      return {
        dot_number: access.carrier_dot,
        carrier_name: access.carrier_name || carrier.legal_name || 'Unknown',
        phy_city: carrier.phy_city,
        phy_state: carrier.phy_state,
        nbr_power_unit: carrier.nbr_power_unit,
        driver_total: carrier.driver_total,
        added_date: access.added_date
      };
    });

    return { success: true, carriers };
  } catch (error) {
    console.error('[recruiter_service] getRecruiterCarriers error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Validate DOT exists
 */
export async function validateCarrierDOT(carrierDOT) {
  try {
    const dotNum = Number(String(carrierDOT).trim());
    const carrier = await dataAccess.findByField(COLLECTION_KEYS.carriers, 'dot_number', dotNum, { suppressAuth: true });

    if (!carrier) return { success: false, error: `DOT ${dotNum} not found` };

    return {
      success: true,
      carrier: {
        dot_number: carrier.dot_number,
        legal_name: carrier.legal_name || 'Unknown',
        phy_city: carrier.phy_city,
        phy_state: carrier.phy_state,
        nbr_power_unit: carrier.nbr_power_unit,
        driver_total: carrier.driver_total
      }
    };
  } catch (error) {
    console.error('[recruiter_service] validateCarrierDOT error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get candidates in pipeline
 */
export async function getPipelineCandidates(carrierDOT, filters = {}) {
  try {
    const accessCheck = await verifyRecruiterAccess(carrierDOT);
    if (!accessCheck.success) return accessCheck;

    const dotNum = Number(String(carrierDOT).trim());
    const interestFilters = { carrier_dot: dotNum };

    if (filters.status && filters.status !== 'all') {
      interestFilters.status = filters.status;
    }

    if (!filters.includeHidden) {
      interestFilters.status = { 
        ne: [CONFIG.PIPELINE_STAGES.REJECTED, CONFIG.PIPELINE_STAGES.WITHDRAWN] 
      };
    }

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: interestFilters,
      sort: [{ field: 'action_timestamp', direction: 'desc' }],
      limit: 100,
      suppressAuth: true
    });

    const interests = result.items || [];
    const driverIds = [...new Set(interests.map(i => i.driver_id).filter(Boolean))];

    let driverProfiles = new Map();
    if (driverIds.length > 0) {
      const profilesResult = await dataAccess.queryRecords(COLLECTION_KEYS.driverProfiles, {
        filters: { _id: { hasSome: driverIds } },
        limit: 100,
        suppressAuth: true
      });
      (profilesResult.items || []).forEach(p => driverProfiles.set(p._id, p));
    }

    const candidates = interests.map(interest => {
      const driver = driverProfiles.get(interest.driver_id) || {};
      let statusHistory = [];
      try {
        statusHistory = interest.status_history ? (typeof interest.status_history === 'string' ? JSON.parse(interest.status_history) : interest.status_history) : [];
      } catch (e) {
        statusHistory = [];
      }

      return {
        interestId: interest._id,
        driverId: interest.driver_id,
        status: interest.status || CONFIG.PIPELINE_STAGES.INTERESTED,
        match_score: interest.match_score || 0,
        actionTimestamp: interest.action_timestamp,
        applicationDate: interest.application_date,
        recruiterNotes: interest.recruiter_notes || '',
        recruiterResponseTime: interest.recruiter_response_time,
        statusHistory: statusHistory,
        contactPhone: interest.contact_phone,
        contactEmail: interest.contact_email,
        preferredContact: interest.preferred_contact,
        availability: interest.availability,
        driverMessage: interest.driver_message,
        driverName: driver.display_name || driver.driver_name || 'Unknown Driver',
        driverEmail: driver.email || interest.contact_email || '',
        driverPhone: driver.phone || interest.contact_phone || '',
        homeZip: driver.home_zip || '',
        yearsExperience: driver.years_experience,
        cdlClass: driver.cdl_class,
        endorsements: driver.endorsements,
        cleanMvr: driver.clean_mvr
      };
    });

    const groupedByStatus = {};
    CONFIG.STAGE_ORDER.forEach(stage => groupedByStatus[stage] = []);
    candidates.forEach(c => {
      const stage = c.status || CONFIG.PIPELINE_STAGES.INTERESTED;
      if (groupedByStatus[stage]) groupedByStatus[stage].push(c);
    });

    return {
      success: true,
      candidates,
      groupedByStatus,
      totalCount: candidates.length,
      stageOrder: CONFIG.STAGE_ORDER
    };
  } catch (error) {
    console.error('[recruiter_service] getPipelineCandidates error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Move candidate to new stage
 */
export async function updateCandidateStatus(interestId, newStatus, notes = '') {
  try {
    const interest = await dataAccess.getRecord(COLLECTION_KEYS.interests, interestId, { suppressAuth: true });
    if (!interest) return { success: false, error: 'Record not found' };

    const accessCheck = await verifyRecruiterAccess(interest.carrier_dot);
    if (!accessCheck.success) return accessCheck;

    const now = new Date();
    let statusHistory = [];
    try {
      statusHistory = interest.status_history ? (typeof interest.status_history === 'string' ? JSON.parse(interest.status_history) : interest.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    statusHistory.push({
      status: newStatus,
      timestamp: now.toISOString(),
      note: notes || `Status changed to ${newStatus}`,
      actor: 'recruiter'
    });

    let recruiterResponseTime = interest.recruiter_response_time;
    if (!recruiterResponseTime && (newStatus === CONFIG.PIPELINE_STAGES.CONTACTED || newStatus === CONFIG.PIPELINE_STAGES.IN_REVIEW)) {
      const startTime = interest.application_date || interest.action_timestamp;
      if (startTime) {
        const hoursElapsed = (now.getTime() - new Date(startTime).getTime()) / (1000 * 60 * 60);
        recruiterResponseTime = Math.round(hoursElapsed * 10) / 10;
      }
    }

    const updatedRecord = {
      ...interest,
      _id: interest._id,
      status: newStatus,
      status_history: JSON.stringify(statusHistory),
      action_timestamp: now,
      recruiter_response_time: recruiterResponseTime
    };

    if ([CONFIG.PIPELINE_STAGES.HIRED, CONFIG.PIPELINE_STAGES.REJECTED, CONFIG.PIPELINE_STAGES.WITHDRAWN].includes(newStatus)) {
      updatedRecord.outcome = newStatus;
      updatedRecord.outcome_date = now;
    }

    await dataAccess.updateRecord(COLLECTION_KEYS.interests, updatedRecord, { suppressAuth: true });

    // Background notifications
    if (interest.driver_id) {
      dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, interest.driver_id, { suppressAuth: true }).then(async (dp) => {
        if (dp && dp._owner) {
          const carrier = await dataAccess.findByField(COLLECTION_KEYS.carriers, 'dot_number', interest.carrier_dot, { suppressAuth: true });
          const carrierName = carrier?.legal_name || carrier?.title || 'the carrier';
          await sendStatusUpdateNotification(dp._owner, {
            driverName: dp.display_name || 'Driver',
            carrierName,
            newStatus,
            applicationId: interestId
          });
        }
      }).catch(() => {});
    }

    if (newStatus === CONFIG.PIPELINE_STAGES.HIRED) {
      const recruiterId = wixUsersBackend.currentUser?.id;
      lifecycleService.logEvent(interest.driver_id, interest.carrier_dot, lifecycleService.EVENT_TYPES.HIRE, {
        recruiterId,
        matchScore: interest.match_score,
        applicationId: interestId
      }).catch(() => {});

      if (interest.driver_id) {
        awardDriverXPNonBlocking(interest.driver_id, 'get_hired', { carrierDot: interest.carrier_dot, carrierName: interest.carrier_name });
        updateChallengeProgressNonBlocking(interest.driver_id, 'get_hired', 1);
      }

      if (recruiterId) {
        awardRecruiterPointsNonBlocking(recruiterId, 'make_hire', { driverId: interest.driver_id, carrierDot: interest.carrier_dot });
        updateChallengeProgressNonBlocking(recruiterId, 'make_hire', 1);
      }

      processHireBonusNonBlocking(interest.driver_id, recruiterId, interest.match_score || 0, { carrierDot: interest.carrier_dot });
    }

    emitPipelineEventNonBlocking(interest.carrier_dot, 'status_change', {
      driverId: interest.driver_id,
      interestId,
      fromStatus: interest.status,
      toStatus: newStatus
    });

    return { success: true, record: updatedRecord, newStatus, responseTime: recruiterResponseTime };
  } catch (error) {
    console.error('[recruiter_service] updateCandidateStatus error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get pipeline stats
 */
export async function getPipelineStats(carrierDOT) {
  try {
    const accessCheck = await verifyRecruiterAccess(carrierDOT);
    if (!accessCheck.success) return accessCheck;

    const dotNum = Number(String(carrierDOT).trim());
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { carrier_dot: dotNum },
      limit: 1000,
      suppressAuth: true
    });

    const interests = result.items || [];
    const stats = { totalPipeline: 0, byStage: {}, avgResponseTime: null, last7Days: 0, last30Days: 0, conversionRate: 0 };
    
    CONFIG.STAGE_ORDER.forEach(s => stats.byStage[s] = 0);
    ['rejected', 'withdrawn'].forEach(s => stats.byStage[s] = 0);

    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    let hiredCount = 0, completedCount = 0, responseTimes = [];

    interests.forEach(interest => {
      const status = interest.status || CONFIG.PIPELINE_STAGES.INTERESTED;
      if (stats.byStage.hasOwnProperty(status)) stats.byStage[status]++;
      
      if (![CONFIG.PIPELINE_STAGES.REJECTED, CONFIG.PIPELINE_STAGES.WITHDRAWN].includes(status)) {
        stats.totalPipeline++;
      }

      const actionDate = new Date(interest.action_timestamp);
      if (actionDate >= sevenDaysAgo) stats.last7Days++;
      if (actionDate >= thirtyDaysAgo) stats.last30Days++;

      if (interest.recruiter_response_time) responseTimes.push(interest.recruiter_response_time);

      if (status === CONFIG.PIPELINE_STAGES.HIRED) hiredCount++;
      if ([CONFIG.PIPELINE_STAGES.HIRED, CONFIG.PIPELINE_STAGES.REJECTED, CONFIG.PIPELINE_STAGES.WITHDRAWN].includes(status)) {
        completedCount++;
      }
    });

    if (responseTimes.length > 0) {
      stats.avgResponseTime = Math.round((responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length) * 10) / 10;
    }

    if (completedCount > 0) stats.conversionRate = Math.round((hiredCount / completedCount) * 100);

    return { success: true, stats };
  } catch (error) {
    console.error('[recruiter_service] getPipelineStats error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get candidate details
 */
export async function getCandidateDetails(interestId) {
  try {
    const interest = await dataAccess.getRecord(COLLECTION_KEYS.interests, interestId, { suppressAuth: true });
    if (!interest) return { success: false, error: 'Not found' };

    const accessCheck = await verifyRecruiterAccess(interest.carrier_dot);
    if (!accessCheck.success) return accessCheck;

    let driverProfile = null;
    if (interest.driver_id) {
      driverProfile = await dataAccess.getRecord(COLLECTION_KEYS.driverProfiles, interest.driver_id, { suppressAuth: true });
    }

    let statusHistory = [];
    try {
      statusHistory = interest.status_history ? (typeof interest.status_history === 'string' ? JSON.parse(interest.status_history) : interest.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    return {
      success: true,
      interest: { ...interest, status_history: statusHistory },
      driverProfile
    };
  } catch (error) {
    console.error('[recruiter_service] getCandidateDetails error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Add recruiter notes
 */
export async function addRecruiterNotes(interestId, notes) {
  try {
    const interest = await dataAccess.getRecord(COLLECTION_KEYS.interests, interestId, { suppressAuth: true });
    if (!interest) return { success: false, error: 'Not found' };

    const accessCheck = await verifyRecruiterAccess(interest.carrier_dot);
    if (!accessCheck.success) return accessCheck;

    await dataAccess.updateRecord(COLLECTION_KEYS.interests, {
      ...interest,
      _id: interest._id,
      recruiter_notes: notes
    }, { suppressAuth: true });

    return { success: true, interestId };
  } catch (error) {
    console.error('[recruiter_service] addRecruiterNotes error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Update recruiter profile
 */
export async function updateRecruiterProfile(profileData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const profile = await dataAccess.findByField(COLLECTION_KEYS.recruiterProfiles, '_owner', userId, { suppressAuth: true });
    if (!profile) return { success: false, error: 'Profile not found' };

    const updatedProfile = {
      ...profile,
      _id: profile._id,
      display_name: profileData.displayName || profile.display_name,
      email: profileData.email || profile.email,
      phone: profileData.phone || profile.phone,
      agency_name: profileData.agencyName || profile.agency_name,
      is_independent: profileData.isIndependent !== undefined ? profileData.isIndependent : profile.is_independent,
      weight_preferences: profileData.weight_preferences || profile.weight_preferences
    };

    await dataAccess.updateRecord(COLLECTION_KEYS.recruiterProfiles, updatedProfile, { suppressAuth: true });
    return { success: true, profile: updatedProfile };
  } catch (error) {
    console.error('[recruiter_service] updateRecruiterProfile error:', error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Get carrier by DOT
 */
export async function getCarrierByDOT(dotNumber) {
  try {
    if (!dotNumber) return null;
    return await dataAccess.findByField(COLLECTION_KEYS.carriers, 'dot_number', Number(dotNumber), { suppressAuth: true });
  } catch (error) {
    console.error('[recruiter_service] getCarrierByDOT error:', error.message);
    return null;
  }
}

/**
 * Get carrier identity
 */
export async function getCarrierIdentity() {
  try {
    const result = await getOrCreateRecruiterProfile();
    if (!result.success) return { success: false, error: result.error, needsOnboarding: true };

    const hasDOT = !!result.defaultCarrierDOT;
    const carrier = result.defaultCarrier || {};

    return {
      success: true,
      needsOnboarding: !hasDOT,
      dotNumber: result.defaultCarrierDOT || null,
      companyName: carrier.legal_name || carrier.company_name || result.profile?.agency_name || null,
      city: carrier.phy_city || null,
      state: carrier.phy_state || null,
      fleetSize: carrier.fleet_size || null,
      safetyRating: carrier.safety_rating || null,
      recruiterProfile: result.profile,
      carriers: result.carriers
    };
  } catch (error) {
    console.error('[recruiter_service] getCarrierIdentity error:', error.message);
    return { success: false, error: error.message, needsOnboarding: true };
  }
}

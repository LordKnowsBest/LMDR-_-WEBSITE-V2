// ============================================================================
// RECRUITER SERVICE - Backend for Recruiter Operating System
// Supports Agency Model: One recruiter can manage multiple carriers
//
// DUAL-SOURCE SUPPORT: Supports both Wix Data and Airtable based on config.jsw settings
// ============================================================================

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { sendStatusUpdateNotification } from 'backend/emailService';
import { usesAirtable, getAirtableTableName } from 'backend/config';
import * as airtable from 'backend/airtableClient';

// Gamification hooks - lazy-loaded to avoid circular dependencies
async function getGamificationService() {
  return await import('backend/gamificationService');
}

async function getChallengeService() {
  return await import('backend/challengeService');
}

// Non-blocking gamification award helpers
async function awardDriverXPNonBlocking(driverId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardDriverXP(driverId, action, metadata);
  } catch (err) {
    console.warn(`Driver XP award failed for ${action}:`, err.message);
  }
}

async function awardRecruiterPointsNonBlocking(recruiterId, action, metadata = {}) {
  try {
    const gamification = await getGamificationService();
    await gamification.awardRecruiterPoints(recruiterId, action, metadata);
  } catch (err) {
    console.warn(`Recruiter points award failed for ${action}:`, err.message);
  }
}

async function updateChallengeProgressNonBlocking(userId, action, count = 1) {
  try {
    const challengeService = await getChallengeService();
    await challengeService.updateChallengeProgress(userId, action, count);
  } catch (err) {
    console.warn(`Challenge progress update failed for ${action}:`, err.message);
  }
}

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  recruiterProfilesCollection: 'recruiterProfiles',
  recruiterCarriersCollection: 'recruiterCarriers',
  interestsCollection: 'DriverCarrierInterests',
  driverProfilesCollection: 'DriverProfiles',
  carriersCollection: 'Carriers',

  // Pipeline status values (matches DriverCarrierInterests statuses)
  PIPELINE_STAGES: {
    INTERESTED: 'interested',
    APPLIED: 'applied',
    IN_REVIEW: 'in_review',
    CONTACTED: 'contacted',
    OFFER: 'offer',
    HIRED: 'hired',
    REJECTED: 'rejected',
    WITHDRAWN: 'withdrawn'
  },

  // Display order for Kanban columns
  STAGE_ORDER: ['interested', 'applied', 'in_review', 'contacted', 'offer', 'hired']
};

// Collection key mapping for config.jsw
const COLLECTION_KEYS = {
  recruiterProfiles: 'recruiterProfiles',
  recruiterCarriers: 'recruiterCarriers',
  interests: 'driverCarrierInterests',
  driverProfiles: 'driverProfiles',
  carriers: 'carriers'
};

// ============================================================================
// DUAL-SOURCE DATA HELPERS
// ============================================================================

async function queryData(collectionKey, wixCollectionName, options = {}) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.queryRecords(tableName, {
      filterByFormula: options.filter || '',
      sort: options.sort,
      maxRecords: options.limit || 100
    });
    return result.records || [];
  }

  let query = wixData.query(wixCollectionName);
  if (options.wixQuery) {
    query = options.wixQuery;
  }
  if (options.limit) {
    query = query.limit(options.limit);
  }
  const result = await query.find(options.suppressAuth ? { suppressAuth: true } : undefined);
  return result.items;
}

async function getRecord(collectionKey, wixCollectionName, recordId, options = {}) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.getRecord(tableName, recordId);
    return result.record || null;
  }
  return await wixData.get(wixCollectionName, recordId, options.suppressAuth ? { suppressAuth: true } : undefined);
}

async function insertData(collectionKey, wixCollectionName, record, options = {}) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.createRecord(tableName, record);
    return result.record || record;
  }
  return await wixData.insert(wixCollectionName, record, options.suppressAuth ? { suppressAuth: true } : undefined);
}

async function updateData(collectionKey, wixCollectionName, record, options = {}) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    const result = await airtable.updateRecord(tableName, record._id || record.id, record);
    return result.record || record;
  }
  return await wixData.update(wixCollectionName, record, options.suppressAuth ? { suppressAuth: true } : undefined);
}

async function findByField(collectionKey, wixCollectionName, conditions, options = {}) {
  if (usesAirtable(collectionKey)) {
    const tableName = getAirtableTableName(collectionKey);
    // Build filter formula from conditions
    const filterParts = Object.entries(conditions).map(([field, value]) => {
      const airtableField = field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      return `{${airtableField}} = '${value}'`;
    });
    const filter = filterParts.length > 1 ? `AND(${filterParts.join(', ')})` : filterParts[0];
    const result = await airtable.queryRecords(tableName, {
      filterByFormula: filter,
      maxRecords: options.limit || 100
    });
    return result.records || [];
  }

  let query = wixData.query(wixCollectionName);
  Object.entries(conditions).forEach(([field, value]) => {
    query = query.eq(field, value);
  });
  if (options.limit) {
    query = query.limit(options.limit);
  }
  if (options.descending) {
    query = query.descending(options.descending);
  }
  const result = await query.find(options.suppressAuth ? { suppressAuth: true } : undefined);
  return result.items;
}

// ============================================================================
// HELPER: Get current user ID
// ============================================================================

async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  if (!currentUser.loggedIn) {
    return null;
  }
  return currentUser.id;
}

// ============================================================================
// HELPER: Verify recruiter has access to carrier
// ============================================================================

async function verifyRecruiterAccess(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      return { success: false, error: 'Not authenticated' };
    }

    const dotString = String(carrierDOT).trim();

    // Check RecruiterCarriers for access
    const items = await findByField(
      COLLECTION_KEYS.recruiterCarriers,
      CONFIG.recruiterCarriersCollection,
      { recruiter_id: userId, carrier_dot: dotString, is_active: true },
      { limit: 1, suppressAuth: true }
    );

    if (items.length === 0) {
      return { success: false, error: 'No access to this carrier' };
    }

    return { success: true, carrierAccess: items[0] };
  } catch (error) {
    console.error('verifyRecruiterAccess error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET OR CREATE RECRUITER PROFILE
// ============================================================================

/**
 * Get the logged-in user's recruiter profile
 * Returns profile + list of carriers they have access to
 */
export async function getOrCreateRecruiterProfile() {
  try {
    const currentUser = wixUsersBackend.currentUser;

    if (!currentUser.loggedIn) {
      return { success: false, error: 'User not logged in' };
    }

    const userId = currentUser.id;
    const userEmail = await currentUser.getEmail();

    // Query for existing profile (dual-source)
    let profileItems = [];
    if (usesAirtable(COLLECTION_KEYS.recruiterProfiles)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.recruiterProfiles);
      const filter = `{Owner} = '${userId}'`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
      profileItems = result.records || [];
    } else {
      const result = await wixData.query(CONFIG.recruiterProfilesCollection)
        .eq('_owner', userId)
        .limit(1)
        .find({ suppressAuth: true });
      profileItems = result.items;
    }

    let profile;

    if (profileItems.length === 0) {
      // Create new profile
      const newProfile = {
        display_name: '',
        email: userEmail || '',
        phone: '',
        agency_name: '',
        is_independent: true,
        created_date: new Date(),
        last_active_date: new Date(),
        is_active: false, // SECURITY: Default to inactive/pending until admin approves
        verification_status: 'pending'
      };

      profile = await insertData(COLLECTION_KEYS.recruiterProfiles, CONFIG.recruiterProfilesCollection, newProfile, { suppressAuth: true });
      console.log('Created new recruiter profile');
    } else {
      profile = profileItems[0];

      // Update last active date
      await updateData(COLLECTION_KEYS.recruiterProfiles, CONFIG.recruiterProfilesCollection, {
        ...profile,
        last_active_date: new Date()
      }, { suppressAuth: true });
    }

    // Get carriers this recruiter has access to (dual-source)
    let carriers = [];
    if (usesAirtable(COLLECTION_KEYS.recruiterCarriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.recruiterCarriers);
      const filter = `AND({Recruiter ID} = '${userId}', {Is Active} = TRUE())`;
      const result = await airtable.queryRecords(tableName, {
        filterByFormula: filter,
        sort: [{ field: 'Added Date', direction: 'desc' }],
        maxRecords: 100
      });
      carriers = result.records || [];
    } else {
      const carriersResult = await wixData.query(CONFIG.recruiterCarriersCollection)
        .eq('recruiter_id', userId)
        .eq('is_active', true)
        .descending('added_date')
        .find({ suppressAuth: true });
      carriers = carriersResult.items;
    }

    // If they have carriers, get full carrier info for the first one (dual-source)
    let defaultCarrier = null;
    if (carriers.length > 0) {
      const carrierDot = carriers[0].carrier_dot;
      if (usesAirtable(COLLECTION_KEYS.carriers)) {
        const tableName = getAirtableTableName(COLLECTION_KEYS.carriers);
        const filter = `{DOT_NUMBER} = ${carrierDot}`;
        const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
        if (result.records && result.records.length > 0) {
          defaultCarrier = result.records[0];
        }
      } else {
        const carrierInfo = await wixData.query(CONFIG.carriersCollection)
          .eq('dot_number', carrierDot)
          .limit(1)
          .find({ suppressAuth: true });
        if (carrierInfo.items.length > 0) {
          defaultCarrier = carrierInfo.items[0];
        }
      }
    }

    console.log(`Recruiter profile loaded with ${carriers.length} carriers`);

    return {
      success: true,
      needsSetup: carriers.length === 0,
      profile: profile,
      carriers: carriers,
      defaultCarrier: defaultCarrier,
      defaultCarrierDOT: carriers.length > 0 ? carriers[0].carrier_dot : null
    };

  } catch (error) {
    console.error('getOrCreateRecruiterProfile error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ADD CARRIER TO RECRUITER'S PORTFOLIO
// ============================================================================

/**
 * Add a carrier to the recruiter's portfolio
 */
export async function addCarrier(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      return { success: false, error: 'User not logged in' };
    }

    const dotString = String(carrierDOT).trim();

    // Check if carrier exists (dual-source)
    let carrierItems = [];
    if (usesAirtable(COLLECTION_KEYS.carriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.carriers);
      const filter = `{DOT_NUMBER} = ${dotString}`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
      carrierItems = result.records || [];
    } else {
      const carrierResult = await wixData.query(CONFIG.carriersCollection)
        .eq('dot_number', dotString)
        .limit(1)
        .find({ suppressAuth: true });
      carrierItems = carrierResult.items;
    }

    if (carrierItems.length === 0) {
      return {
        success: false,
        error: `Carrier with DOT ${dotString} not found`
      };
    }

    const carrier = carrierItems[0];

    // Check if already added (dual-source)
    let existingItems = [];
    if (usesAirtable(COLLECTION_KEYS.recruiterCarriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.recruiterCarriers);
      const filter = `AND({Recruiter ID} = '${userId}', {Carrier DOT} = '${dotString}')`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
      existingItems = result.records || [];
    } else {
      const existingAccess = await wixData.query(CONFIG.recruiterCarriersCollection)
        .eq('recruiter_id', userId)
        .eq('carrier_dot', dotString)
        .limit(1)
        .find({ suppressAuth: true });
      existingItems = existingAccess.items;
    }

    if (existingItems.length > 0) {
      const existing = existingItems[0];
      if (existing.is_active) {
        return {
          success: false,
          error: 'This carrier is already in your portfolio'
        };
      } else {
        // Reactivate
        await updateData(COLLECTION_KEYS.recruiterCarriers, CONFIG.recruiterCarriersCollection, {
          ...existing,
          is_active: true,
          added_date: new Date()
        }, { suppressAuth: true });

        return {
          success: true,
          carrierAccess: existing,
          carrierInfo: carrier,
          reactivated: true
        };
      }
    }

    // Create new carrier access record
    const newAccess = {
      recruiter_id: userId,
      carrier_dot: dotString,
      carrier_name: carrier.legal_name || carrier.title || 'Unknown',
      added_date: new Date(),
      is_active: false, // SECURITY: Default to inactive/pending until ownership verified
      verification_status: 'pending_verification'
    };

    const insertedAccess = await insertData(COLLECTION_KEYS.recruiterCarriers, CONFIG.recruiterCarriersCollection, newAccess, { suppressAuth: true });

    console.log(`Recruiter added carrier ${dotString} to portfolio`);

    return {
      success: true,
      carrierAccess: insertedAccess,
      carrierInfo: carrier
    };

  } catch (error) {
    console.error('addCarrier error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// REMOVE CARRIER FROM PORTFOLIO
// ============================================================================

/**
 * Remove a carrier from the recruiter's portfolio
 */
export async function removeCarrier(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      return { success: false, error: 'User not logged in' };
    }

    const dotString = String(carrierDOT).trim();

    // Find the access record (dual-source)
    let accessItems = [];
    if (usesAirtable(COLLECTION_KEYS.recruiterCarriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.recruiterCarriers);
      const filter = `AND({Recruiter ID} = '${userId}', {Carrier DOT} = '${dotString}')`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
      accessItems = result.records || [];
    } else {
      const accessResult = await wixData.query(CONFIG.recruiterCarriersCollection)
        .eq('recruiter_id', userId)
        .eq('carrier_dot', dotString)
        .limit(1)
        .find({ suppressAuth: true });
      accessItems = accessResult.items;
    }

    if (accessItems.length === 0) {
      return { success: false, error: 'Carrier not found in your portfolio' };
    }

    // Soft delete - set is_active to false
    const access = accessItems[0];
    await updateData(COLLECTION_KEYS.recruiterCarriers, CONFIG.recruiterCarriersCollection, {
      ...access,
      is_active: false
    }, { suppressAuth: true });

    console.log(`Recruiter removed carrier ${dotString} from portfolio`);

    return { success: true };

  } catch (error) {
    console.error('removeCarrier error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET RECRUITER'S CARRIERS
// ============================================================================

/**
 * Get list of all carriers in recruiter's portfolio
 */
export async function getRecruiterCarriers() {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      return { success: false, error: 'User not logged in' };
    }

    // Get all carrier access records (dual-source)
    let carrierAccess = [];
    if (usesAirtable(COLLECTION_KEYS.recruiterCarriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.recruiterCarriers);
      const filter = `AND({Recruiter ID} = '${userId}', {Is Active} = TRUE())`;
      const result = await airtable.queryRecords(tableName, {
        filterByFormula: filter,
        sort: [{ field: 'Added Date', direction: 'desc' }],
        maxRecords: 100
      });
      carrierAccess = result.records || [];
    } else {
      const accessResult = await wixData.query(CONFIG.recruiterCarriersCollection)
        .eq('recruiter_id', userId)
        .eq('is_active', true)
        .descending('added_date')
        .find({ suppressAuth: true });
      carrierAccess = accessResult.items;
    }

    if (carrierAccess.length === 0) {
      return {
        success: true,
        carriers: []
      };
    }

    // Get full carrier info for each (dual-source)
    const dotNumbers = carrierAccess.map(a => a.carrier_dot);
    let carriersItems = [];
    if (usesAirtable(COLLECTION_KEYS.carriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.carriers);
      // Build OR formula for multiple DOT numbers
      const orClauses = dotNumbers.map(dot => `{DOT_NUMBER} = ${dot}`);
      const filter = orClauses.length > 1 ? `OR(${orClauses.join(', ')})` : orClauses[0];
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 100 });
      carriersItems = result.records || [];
    } else {
      const carriersResult = await wixData.query(CONFIG.carriersCollection)
        .hasSome('dot_number', dotNumbers)
        .find({ suppressAuth: true });
      carriersItems = carriersResult.items;
    }

    // Create lookup map
    const carrierMap = {};
    carriersItems.forEach(c => {
      carrierMap[c.dot_number] = c;
    });

    // Combine access with carrier info
    const carriers = carrierAccess.map(access => {
      const carrier = carrierMap[access.carrier_dot] || {};
      return {
        dot_number: access.carrier_dot,
        carrier_name: access.carrier_name || carrier.legal_name || carrier.title || 'Unknown',
        phy_city: carrier.phy_city,
        phy_state: carrier.phy_state,
        nbr_power_unit: carrier.nbr_power_unit,
        driver_total: carrier.driver_total,
        added_date: access.added_date
      };
    });

    return {
      success: true,
      carriers: carriers
    };

  } catch (error) {
    console.error('getRecruiterCarriers error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// VALIDATE CARRIER DOT
// ============================================================================

/**
 * Validate a carrier DOT exists and return carrier info
 */
export async function validateCarrierDOT(carrierDOT) {
  try {
    const dotString = String(carrierDOT).trim();

    // Query carrier (dual-source)
    let carrierItems = [];
    if (usesAirtable(COLLECTION_KEYS.carriers)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.carriers);
      const filter = `{DOT_NUMBER} = ${dotString}`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
      carrierItems = result.records || [];
    } else {
      const result = await wixData.query(CONFIG.carriersCollection)
        .eq('dot_number', dotString)
        .limit(1)
        .find({ suppressAuth: true });
      carrierItems = result.items;
    }

    if (carrierItems.length === 0) {
      return {
        success: false,
        error: `No carrier found with DOT ${dotString}`
      };
    }

    const carrier = carrierItems[0];

    return {
      success: true,
      carrier: {
        dot_number: carrier.dot_number,
        legal_name: carrier.legal_name || carrier.title || 'Unknown',
        phy_city: carrier.phy_city,
        phy_state: carrier.phy_state,
        nbr_power_unit: carrier.nbr_power_unit,
        driver_total: carrier.driver_total
      }
    };

  } catch (error) {
    console.error('validateCarrierDOT error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET PIPELINE CANDIDATES
// ============================================================================

/**
 * Get all candidates in the pipeline for a carrier
 */
export async function getPipelineCandidates(carrierDOT, filters = {}) {
  try {
    // Verify access
    const accessCheck = await verifyRecruiterAccess(carrierDOT);
    if (!accessCheck.success) {
      return accessCheck;
    }

    const dotString = String(carrierDOT).trim();

    // Build query (dual-source)
    let interests = [];
    if (usesAirtable(COLLECTION_KEYS.interests)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.interests);

      // Build Airtable filter
      let filterParts = [`{Carrier DOT} = '${dotString}'`];

      if (filters.status && filters.status !== 'all') {
        filterParts.push(`{Status} = '${filters.status}'`);
      }

      if (!filters.includeHidden) {
        filterParts.push(`{Status} != '${CONFIG.PIPELINE_STAGES.REJECTED}'`);
        filterParts.push(`{Status} != '${CONFIG.PIPELINE_STAGES.WITHDRAWN}'`);
      }

      const filter = filterParts.length > 1 ? `AND(${filterParts.join(', ')})` : filterParts[0];

      const result = await airtable.queryRecords(tableName, {
        filterByFormula: filter,
        sort: [{ field: 'Action Timestamp', direction: 'desc' }],
        maxRecords: 100
      });
      interests = result.records || [];
    } else {
      let query = wixData.query(CONFIG.interestsCollection)
        .eq('carrier_dot', dotString);

      if (filters.status && filters.status !== 'all') {
        query = query.eq('status', filters.status);
      }

      if (!filters.includeHidden) {
        query = query.ne('status', CONFIG.PIPELINE_STAGES.REJECTED)
          .ne('status', CONFIG.PIPELINE_STAGES.WITHDRAWN);
      }

      query = query.descending('action_timestamp');
      const result = await query.find({ suppressAuth: true });
      interests = result.items;
    }

    // Get driver profile IDs
    const driverIds = [...new Set(interests.map(i => i.driver_id).filter(Boolean))];

    // Fetch driver profiles (dual-source)
    let driverProfiles = {};
    if (driverIds.length > 0) {
      let profileItems = [];
      if (usesAirtable(COLLECTION_KEYS.driverProfiles)) {
        const tableName = getAirtableTableName(COLLECTION_KEYS.driverProfiles);
        // Build OR formula for multiple IDs
        const orClauses = driverIds.map(id => `RECORD_ID() = '${id}'`);
        const filter = orClauses.length > 1 ? `OR(${orClauses.join(', ')})` : orClauses[0];
        const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 100 });
        profileItems = result.records || [];
      } else {
        const profilesResult = await wixData.query(CONFIG.driverProfilesCollection)
          .hasSome('_id', driverIds)
          .find({ suppressAuth: true });
        profileItems = profilesResult.items;
      }

      profileItems.forEach(p => {
        driverProfiles[p._id] = p;
      });
    }

    // Combine interests with driver profiles
    const candidates = interests.map(interest => {
      const driver = driverProfiles[interest.driver_id] || {};

      // Parse status history
      let statusHistory = [];
      try {
        statusHistory = interest.status_history ? JSON.parse(interest.status_history) : [];
      } catch (e) {
        statusHistory = [];
      }

      return {
        interestId: interest._id,
        driverId: interest.driver_id,
        status: interest.status || CONFIG.PIPELINE_STAGES.INTERESTED,
        matchScore: interest.match_score || 0,
        actionTimestamp: interest.action_timestamp,
        applicationDate: interest.application_date,
        recruiterNotes: interest.recruiter_notes || '',
        recruiterResponseTime: interest.recruiter_response_time,
        statusHistory: statusHistory,
        contactPhone: interest.contact_phone,
        contactEmail: interest.contact_email,
        preferredContact: interest.preferred_contact,
        availability: interest.availability,
        driverMessage: interest.driver_message,
        // Driver profile fields
        driverName: driver.display_name || driver.driver_name || 'Unknown Driver',
        driverEmail: driver.email || interest.contact_email || '',
        driverPhone: driver.phone || interest.contact_phone || '',
        homeZip: driver.home_zip || '',
        yearsExperience: driver.years_experience,
        cdlClass: driver.cdl_class,
        endorsements: driver.endorsements,
        cleanMvr: driver.clean_mvr
      };
    });

    // Group by status
    const groupedByStatus = {};
    CONFIG.STAGE_ORDER.forEach(stage => {
      groupedByStatus[stage] = [];
    });

    candidates.forEach(candidate => {
      const stage = candidate.status || CONFIG.PIPELINE_STAGES.INTERESTED;
      if (groupedByStatus[stage]) {
        groupedByStatus[stage].push(candidate);
      }
    });

    console.log(`Pipeline loaded: ${candidates.length} candidates for carrier ${dotString}`);

    return {
      success: true,
      candidates: candidates,
      groupedByStatus: groupedByStatus,
      totalCount: candidates.length,
      stageOrder: CONFIG.STAGE_ORDER
    };

  } catch (error) {
    console.error('getPipelineCandidates error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// UPDATE CANDIDATE STATUS
// ============================================================================

/**
 * Move a candidate to a new pipeline stage
 */
export async function updateCandidateStatus(interestId, newStatus, notes = '') {
  try {
    // Get the interest record (dual-source)
    let interest = null;
    if (usesAirtable(COLLECTION_KEYS.interests)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.interests);
      interest = await airtable.getRecord(tableName, interestId);
      if (interest && interest.error) interest = null;
    } else {
      interest = await wixData.get(CONFIG.interestsCollection, interestId, { suppressAuth: true });
    }

    if (!interest) {
      return { success: false, error: 'Candidate record not found' };
    }

    // Verify access to this carrier
    const accessCheck = await verifyRecruiterAccess(interest.carrier_dot);
    if (!accessCheck.success) {
      return accessCheck;
    }

    const now = new Date();

    // Parse existing status history
    let statusHistory = [];
    try {
      statusHistory = interest.status_history ? JSON.parse(interest.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    // Add new status entry
    statusHistory.push({
      status: newStatus,
      timestamp: now.toISOString(),
      note: notes || `Status changed to ${newStatus}`,
      actor: 'recruiter'
    });

    // Calculate recruiter response time if this is first recruiter action
    let recruiterResponseTime = interest.recruiter_response_time;
    if (!recruiterResponseTime && (newStatus === CONFIG.PIPELINE_STAGES.CONTACTED || newStatus === CONFIG.PIPELINE_STAGES.IN_REVIEW)) {
      const startTime = interest.application_date || interest.action_timestamp;
      if (startTime) {
        const hoursElapsed = (now.getTime() - new Date(startTime).getTime()) / (1000 * 60 * 60);
        recruiterResponseTime = Math.round(hoursElapsed * 10) / 10;
      }
    }

    // Update the record
    const updatedRecord = {
      ...interest,
      status: newStatus,
      status_history: JSON.stringify(statusHistory),
      action_timestamp: now,
      recruiter_response_time: recruiterResponseTime
    };

    // Add outcome fields for terminal statuses
    if (newStatus === CONFIG.PIPELINE_STAGES.HIRED ||
        newStatus === CONFIG.PIPELINE_STAGES.REJECTED ||
        newStatus === CONFIG.PIPELINE_STAGES.WITHDRAWN) {
      updatedRecord.outcome = newStatus;
      updatedRecord.outcome_date = now;
    }

    await updateData(COLLECTION_KEYS.interests, CONFIG.interestsCollection, updatedRecord, { suppressAuth: true });

    console.log(`Candidate ${interestId} moved to ${newStatus}`);

    // Send email notification to driver (non-blocking)
    try {
      // Get driver profile to find user ID (dual-source)
      if (interest.driver_id) {
        let driverProfile = null;
        if (usesAirtable(COLLECTION_KEYS.driverProfiles)) {
          const tableName = getAirtableTableName(COLLECTION_KEYS.driverProfiles);
          driverProfile = await airtable.getRecord(tableName, interest.driver_id);
          if (driverProfile && driverProfile.error) driverProfile = null;
        } else {
          driverProfile = await wixData.get(CONFIG.driverProfilesCollection, interest.driver_id, { suppressAuth: true });
        }

        if (driverProfile && driverProfile._owner) {
          // Get carrier name (dual-source)
          let carrierName = 'the carrier';
          let carrierItems = [];
          if (usesAirtable(COLLECTION_KEYS.carriers)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.carriers);
            const filter = `{DOT_NUMBER} = ${parseInt(interest.carrier_dot, 10)}`;
            const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
            carrierItems = result.records || [];
          } else {
            const carrierResult = await wixData.query(CONFIG.carriersCollection)
              .eq('dot_number', parseInt(interest.carrier_dot, 10))
              .limit(1)
              .find({ suppressAuth: true });
            carrierItems = carrierResult.items;
          }

          if (carrierItems.length > 0) {
            carrierName = carrierItems[0].legal_name || carrierItems[0].title || carrierName;
          }

          // Send notification
          await sendStatusUpdateNotification(driverProfile._owner, {
            driverName: driverProfile.display_name || driverProfile.driver_name || 'Driver',
            carrierName: carrierName,
            newStatus: newStatus,
            applicationId: interestId
          });
          console.log(`ðŸ“§ Status notification sent to driver for ${newStatus}`);
        }
      }
    } catch (emailError) {
      // Don't fail the status update if email fails
      console.error('âš ï¸ Failed to send status notification email:', emailError.message);
    }

    // Gamification: Award XP/points for hire completion (non-blocking)
    if (newStatus === CONFIG.PIPELINE_STAGES.HIRED) {
      const recruiterId = wixUsersBackend.currentUser?.id;

      // Award XP to the driver who got hired
      if (interest.driver_id) {
        awardDriverXPNonBlocking(interest.driver_id, 'get_hired', {
          carrierDot: interest.carrier_dot,
          carrierName: interest.carrier_name
        });

        // Update driver challenge progress for 'get_hired' action
        updateChallengeProgressNonBlocking(interest.driver_id, 'get_hired', 1);
      }

      // Award points to the recruiter who made the hire
      if (recruiterId) {
        awardRecruiterPointsNonBlocking(recruiterId, 'make_hire', {
          driverId: interest.driver_id,
          carrierDot: interest.carrier_dot
        });

        // Update recruiter challenge progress for 'make_hire' action
        updateChallengeProgressNonBlocking(recruiterId, 'make_hire', 1);
      }

      console.log(`ðŸŽ® Gamification rewards triggered for hire: driver ${interest.driver_id}, recruiter ${recruiterId}`);
    }

    return {
      success: true,
      record: updatedRecord,
      newStatus: newStatus,
      responseTime: recruiterResponseTime
    };

  } catch (error) {
    console.error('updateCandidateStatus error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET PIPELINE STATS
// ============================================================================

/**
 * Get aggregate statistics for a carrier's pipeline
 */
export async function getPipelineStats(carrierDOT) {
  try {
    // Verify access
    const accessCheck = await verifyRecruiterAccess(carrierDOT);
    if (!accessCheck.success) {
      return accessCheck;
    }

    const dotString = String(carrierDOT).trim();

    // Get all interests for this carrier (dual-source)
    let interests = [];
    if (usesAirtable(COLLECTION_KEYS.interests)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.interests);
      const filter = `{Carrier DOT} = '${dotString}'`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1000 });
      interests = result.records || [];
    } else {
      const result = await wixData.query(CONFIG.interestsCollection)
        .eq('carrier_dot', dotString)
        .find({ suppressAuth: true });
      interests = result.items;
    }

    // Calculate stats
    const stats = {
      totalPipeline: 0,
      byStage: {},
      avgResponseTime: null,
      responseTimes: [],
      last7Days: 0,
      last30Days: 0,
      conversionRate: 0
    };

    // Initialize stage counts
    CONFIG.STAGE_ORDER.forEach(stage => {
      stats.byStage[stage] = 0;
    });
    stats.byStage.rejected = 0;
    stats.byStage.withdrawn = 0;

    const now = new Date();
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    let hiredCount = 0;
    let completedCount = 0;

    interests.forEach(interest => {
      const status = interest.status || CONFIG.PIPELINE_STAGES.INTERESTED;

      // Count by stage
      if (stats.byStage.hasOwnProperty(status)) {
        stats.byStage[status]++;
      }

      // Exclude rejected/withdrawn from total pipeline count
      if (status !== CONFIG.PIPELINE_STAGES.REJECTED &&
          status !== CONFIG.PIPELINE_STAGES.WITHDRAWN) {
        stats.totalPipeline++;
      }

      // Count recent interests
      const actionDate = new Date(interest.action_timestamp);
      if (actionDate >= sevenDaysAgo) {
        stats.last7Days++;
      }
      if (actionDate >= thirtyDaysAgo) {
        stats.last30Days++;
      }

      // Track response times
      if (interest.recruiter_response_time) {
        stats.responseTimes.push(interest.recruiter_response_time);
      }

      // Track conversion
      if (status === CONFIG.PIPELINE_STAGES.HIRED) {
        hiredCount++;
      }
      if (status === CONFIG.PIPELINE_STAGES.HIRED ||
          status === CONFIG.PIPELINE_STAGES.REJECTED ||
          status === CONFIG.PIPELINE_STAGES.WITHDRAWN) {
        completedCount++;
      }
    });

    // Calculate average response time
    if (stats.responseTimes.length > 0) {
      const sum = stats.responseTimes.reduce((a, b) => a + b, 0);
      stats.avgResponseTime = Math.round((sum / stats.responseTimes.length) * 10) / 10;
    }

    // Calculate conversion rate
    if (completedCount > 0) {
      stats.conversionRate = Math.round((hiredCount / completedCount) * 100);
    }

    // Response time badge
    if (stats.avgResponseTime !== null) {
      if (stats.avgResponseTime < 4) {
        stats.responseBadge = 'Lightning Responder';
        stats.badgeColor = '#10b981';
      } else if (stats.avgResponseTime < 24) {
        stats.responseBadge = 'Fast Responder';
        stats.badgeColor = '#3b82f6';
      } else if (stats.avgResponseTime < 48) {
        stats.responseBadge = 'Active Recruiter';
        stats.badgeColor = '#6366f1';
      }
    }

    delete stats.responseTimes;

    console.log(`Pipeline stats loaded for carrier ${dotString}`);

    return {
      success: true,
      stats: stats
    };

  } catch (error) {
    console.error('getPipelineStats error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// GET CANDIDATE DETAILS
// ============================================================================

/**
 * Get full details for a candidate
 */
export async function getCandidateDetails(interestId) {
  try {
    // Get the interest record (dual-source)
    let interest = null;
    if (usesAirtable(COLLECTION_KEYS.interests)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.interests);
      interest = await airtable.getRecord(tableName, interestId);
      if (interest && interest.error) interest = null;
    } else {
      interest = await wixData.get(CONFIG.interestsCollection, interestId, { suppressAuth: true });
    }

    if (!interest) {
      return { success: false, error: 'Candidate record not found' };
    }

    // Verify access
    const accessCheck = await verifyRecruiterAccess(interest.carrier_dot);
    if (!accessCheck.success) {
      return accessCheck;
    }

    // Get driver profile (dual-source)
    let driverProfile = null;
    if (interest.driver_id) {
      if (usesAirtable(COLLECTION_KEYS.driverProfiles)) {
        const tableName = getAirtableTableName(COLLECTION_KEYS.driverProfiles);
        driverProfile = await airtable.getRecord(tableName, interest.driver_id);
        if (driverProfile && driverProfile.error) driverProfile = null;
      } else {
        driverProfile = await wixData.get(CONFIG.driverProfilesCollection, interest.driver_id, { suppressAuth: true });
      }
    }

    // Parse status history
    let statusHistory = [];
    try {
      statusHistory = interest.status_history ? JSON.parse(interest.status_history) : [];
    } catch (e) {
      statusHistory = [];
    }

    return {
      success: true,
      interest: {
        ...interest,
        status_history: statusHistory
      },
      driverProfile: driverProfile
    };

  } catch (error) {
    console.error('getCandidateDetails error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ADD RECRUITER NOTES
// ============================================================================

/**
 * Add or update recruiter notes for a candidate
 */
export async function addRecruiterNotes(interestId, notes) {
  try {
    // Get the interest record (dual-source)
    let interest = null;
    if (usesAirtable(COLLECTION_KEYS.interests)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.interests);
      interest = await airtable.getRecord(tableName, interestId);
      if (interest && interest.error) interest = null;
    } else {
      interest = await wixData.get(CONFIG.interestsCollection, interestId, { suppressAuth: true });
    }

    if (!interest) {
      return { success: false, error: 'Candidate record not found' };
    }

    // Verify access
    const accessCheck = await verifyRecruiterAccess(interest.carrier_dot);
    if (!accessCheck.success) {
      return accessCheck;
    }

    // Update notes
    const updatedRecord = {
      ...interest,
      recruiter_notes: notes
    };

    await updateData(COLLECTION_KEYS.interests, CONFIG.interestsCollection, updatedRecord, { suppressAuth: true });

    console.log(`Notes updated for candidate ${interestId}`);

    return {
      success: true,
      interestId: interestId
    };

  } catch (error) {
    console.error('addRecruiterNotes error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// UPDATE RECRUITER PROFILE
// ============================================================================

/**
 * Update recruiter's profile info
 */
export async function updateRecruiterProfile(profileData) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) {
      return { success: false, error: 'User not logged in' };
    }

    // Get existing profile (dual-source)
    let profileItems = [];
    if (usesAirtable(COLLECTION_KEYS.recruiterProfiles)) {
      const tableName = getAirtableTableName(COLLECTION_KEYS.recruiterProfiles);
      const filter = `{Owner} = '${userId}'`;
      const result = await airtable.queryRecords(tableName, { filterByFormula: filter, maxRecords: 1 });
      profileItems = result.records || [];
    } else {
      const result = await wixData.query(CONFIG.recruiterProfilesCollection)
        .eq('_owner', userId)
        .limit(1)
        .find({ suppressAuth: true });
      profileItems = result.items;
    }

    if (profileItems.length === 0) {
      return { success: false, error: 'Profile not found' };
    }

    const profile = profileItems[0];

    // Update allowed fields
    const updatedProfile = {
      ...profile,
      display_name: profileData.displayName || profile.display_name,
      email: profileData.email || profile.email,
      phone: profileData.phone || profile.phone,
      agency_name: profileData.agencyName || profile.agency_name,
      is_independent: profileData.isIndependent !== undefined ? profileData.isIndependent : profile.is_independent,
      weight_preferences: profileData.weight_preferences || profile.weight_preferences
    };

    await updateData(COLLECTION_KEYS.recruiterProfiles, CONFIG.recruiterProfilesCollection, updatedProfile, { suppressAuth: true });

    console.log('Recruiter profile updated');

    return {
      success: true,
      profile: updatedProfile
    };

  } catch (error) {
    console.error('updateRecruiterProfile error:', error);
    return { success: false, error: error.message };
  }
}

import * as dataAccess from 'backend/dataAccess';
import { getCarrierSafetyData } from 'backend/fmcsaService';
import { createAccountFromSignal, updateAccount } from 'backend/b2bAccountService';

// ============================================================================
// COLLECTION KEYS
// ============================================================================

const COLLECTIONS = {
  signals: 'b2bMatchSignals',
  accounts: 'b2bAccounts',
  carriers: 'carriers',
  hiringPrefs: 'carrierHiringPreferences',
  matchEvents: 'matchEvents'
};

// ============================================================================
// SIGNAL GENERATION
// ============================================================================

export async function generateSignal(carrierDot, matchData = null) {
  try {
    if (!carrierDot) return { success: false, error: 'DOT required' };
    const dotStr = String(carrierDot).trim();
    let data = matchData || await computeMatchData(dotStr);

    const score = computeSignalScore(data);
    const signal = {
      carrier_dot: dotStr, signal_score: Math.round(score * 100) / 100,
      driver_count_high_match: data.driverCountHighMatch || 0,
      top_regions: Array.isArray(data.topRegions) ? data.topRegions.join(', ') : '',
      top_equipment: Array.isArray(data.topEquipment) ? data.topEquipment.join(', ') : '',
      job_types: Array.isArray(data.jobTypes) ? data.jobTypes.join(', ') : '',
      signal_reason: buildSignalReason(data, score),
      confidence: computeConfidence(data), urgency: computeUrgency(data),
      generated_at: new Date().toISOString()
    };

    const existing = await dataAccess.findByField(COLLECTIONS.signals, 'carrier_dot', dotStr, { suppressAuth: true });
    const result = existing 
      ? await dataAccess.updateRecord(COLLECTIONS.signals, { ...existing, ...signal }, { suppressAuth: true })
      : await dataAccess.insertRecord(COLLECTIONS.signals, signal, { suppressAuth: true });

    return { success: result.success, signal: result.record };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function generateBatchSignals(options = {}) {
  try {
    const hiringResult = await dataAccess.queryRecords(COLLECTIONS.hiringPrefs, { limit: 200, suppressAuth: true });
    const hiringDots = (hiringResult.items || []).map(i => String(i.carrier_dot)).filter(Boolean);

    const accountsRes = await dataAccess.queryRecords(COLLECTIONS.accounts, { filters: { status: { hasSome: ['client', 'active'] } }, limit: 500, suppressAuth: true });
    const clientDots = new Set((accountsRes.items || []).map(a => String(a.carrier_dot)));

    const prospectDots = hiringDots.filter(dot => !clientDots.has(dot));
    const signals = [];
    for (const dot of prospectDots.slice(0, options.limit || 25)) {
      const res = await generateSignal(dot);
      if (res.success && res.signal?.driver_count_high_match >= (options.minDriverCount || 5)) signals.push(res.signal);
    }
    return { success: true, processed: prospectDots.length, signals: signals.sort((a,b)=>b.signal_score-a.signal_score) };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// RETRIEVAL
// ============================================================================

export async function getTopOpportunities(options = {}) {
  try {
    const filters = { signal_score: { gte: options.minScore || 50 } };
    const result = await dataAccess.queryRecords(COLLECTIONS.signals, {
      filters, sort: [{ field: 'signal_score', direction: 'desc' }],
      limit: options.limit || 25, suppressAuth: true
    });
    return { success: true, signals: result.items || [], totalCount: result.totalCount || result.items?.length };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getSignalByCarrier(carrierDot) {
  try {
    const record = await dataAccess.findByField(COLLECTIONS.signals, 'carrier_dot', String(carrierDot), { suppressAuth: true });
    return record ? { success: true, signal: record } : { success: false, error: 'Not found' };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function checkOpportunityAlerts(options = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.signals, {
      filters: { signal_score: { gte: options.scoreThreshold || 80 } },
      limit: 50, suppressAuth: true
    });
    const alerts = (res.items || []).map(s => ({
      type: 'high_score', severity: s.signal_score >= 90 ? 'HIGH' : 'MEDIUM',
      carrier_dot: s.carrier_dot, signal_score: s.signal_score,
      message: `High-value prospect: ${s.driver_count_high_match} matching drivers`,
      created_at: new Date().toISOString()
    }));
    return { success: true, alerts };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function runB2BSignalBatch() {
  const stats = { signalsGenerated: 0, snapshotsStored: 0, accountsCreated: 0, errors: [] };
  try {
    const batch = await generateBatchSignals({ limit: 25, minDriverCount: 3 });
    if (!batch.success) throw new Error(batch.error);
    const signals = batch.signals || [];
    stats.signalsGenerated = signals.length;

    for (const signal of signals) {
      if (signal.signal_score >= 55) {
        const accRes = await createAccountFromSignal(signal);
        if (accRes.success && !accRes.alreadyExists) {
          stats.accountsCreated++;
          try {
            const safety = await getCarrierSafetyData(signal.carrier_dot);
            if (safety && !safety.error) await updateAccount(accRes.account._id, { fleet_size: safety.total_power_units });
          } catch (e) { }
        }
      }
    }
    return { success: true, stats };
  } catch (error) { return { success: false, error: error.message, stats }; }
}

async function computeMatchData(carrierDot) {
  const data = { driverCountHighMatch: 0, topRegions: [], topEquipment: [], jobTypes: [], fleetSize: 0, hasHiringPrefs: false };
  try {
    const prefs = await dataAccess.queryRecords(COLLECTIONS.hiringPrefs, { filters: { carrier_dot: carrierDot }, limit: 1, suppressAuth: true });
    if (prefs.items?.length) {
      const p = prefs.items[0]; data.hasHiringPrefs = true;
      data.topRegions = String(p.regions || '').split(',').map(r => r.trim()).filter(Boolean);
    }
    const matches = await dataAccess.queryRecords(COLLECTIONS.matchEvents, { filters: { carrier_dot: carrierDot, match_score: { gte: 70 } }, limit: 200, suppressAuth: true });
    data.driverCountHighMatch = matches.totalCount || (matches.items || []).length;
  } catch (e) { }
  return data;
}

function computeSignalScore(data) {
  let score = Math.min((data.driverCountHighMatch || 0) / 50, 1) * 35;
  if (data.hasHiringPrefs) score += 40;
  return Math.min(100, score);
}

function computeConfidence(data) { return data.driverCountHighMatch > 10 ? 'high' : 'medium'; }
function computeUrgency(data) { return data.hasHiringPrefs ? 'high' : 'low'; }
function buildSignalReason(data, score) { return `${data.driverCountHighMatch} high-match drivers identified`; }

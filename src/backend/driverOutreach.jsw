import wixUsersBackend from 'wix-users-backend';
import { sendMessage as sendMessagingMessage } from 'backend/messaging.jsw';
import { checkViewQuota } from 'backend/subscriptionService.jsw';
import * as dataAccess from 'backend/dataAccess';

// Match notifications - lazy-loaded to avoid circular dependencies
async function getMatchNotifications() {
  return await import('backend/matchNotifications');
}

function notifyDriverContactedNonBlocking(driverId, contactInfo) {
  getMatchNotifications()
    .then(svc => svc.notifyDriverContacted(driverId, contactInfo))
    .catch(err => console.warn('Contact notification failed (non-critical):', err.message));
}

// ============================================================================
// CONFIGURATION
// ============================================================================

/** DEV MODE: Set to true to bypass access checks for development/demo */
const DEV_MODE_BYPASS_CARRIER = true; // TODO: Set to false for production

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    interests: 'driverCarrierInterests',
    driverProfiles: 'driverProfiles',
    recruiterCarriers: 'recruiterCarriers',
    carriers: 'carriers',
    profileViews: 'carrierDriverViews',
    outreachHistory: 'recruiterOutreachHistory'
};

const CONFIG = {
  // Origin types for tracking where interest came from
  ORIGIN: { DRIVER_APPLIED: 'driver_applied', RECRUITER_SEARCH: 'recruiter_search', MUTUAL_MATCH: 'mutual_match' },
  // Initial status when recruiter saves a driver
  RECRUITER_INITIAL_STATUS: 'contacted'
};

// ============================================================================
// HELPER: Get current user ID
// ============================================================================

async function getCurrentUserId() {
  const currentUser = wixUsersBackend.currentUser;
  return currentUser.loggedIn ? currentUser.id : null;
}

// ============================================================================
// HELPER: Verify recruiter has access to carrier
// ============================================================================

async function verifyRecruiterAccess(carrierDOT) {
  try {
    const userId = await getCurrentUserId();
    if (!userId) return { success: false, error: 'Not authenticated' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.recruiterCarriers, {
      filters: { recruiter_id: userId, carrier_dot: String(carrierDOT).trim(), is_active: true },
      limit: 1, suppressAuth: true
    });

    if (!result.success || result.items.length === 0) return { success: false, error: 'No access to this carrier' };
    return { success: true, carrierAccess: result.items[0], userId };
  } catch (error) {
    console.error('verifyRecruiterAccess error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// SAVE DRIVER TO PIPELINE
// ============================================================================

export async function saveDriverToPipeline(carrierDot, driverId, notes = '') {
  try {
    let userId = 'dev-mode';
    if (!DEV_MODE_BYPASS_CARRIER) {
      const accessCheck = await verifyRecruiterAccess(carrierDot);
      if (!accessCheck.success) return accessCheck;
      userId = accessCheck.userId;
    }

    const dotString = String(carrierDot).trim();

    // Check for duplicate
    const existingResult = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { carrier_dot: dotString, driver_id: driverId }, limit: 1, suppressAuth: true
    });

    if (existingResult.success && existingResult.items.length > 0) {
      return { success: false, errorCode: 'DUPLICATE_SAVE', error: 'Driver already in pipeline', interestId: existingResult.items[0]._id, status: existingResult.items[0].status };
    }

    // In dev mode, skip profile-view requirement
    if (!DEV_MODE_BYPASS_CARRIER) {
      const viewResult = await dataAccess.queryRecords(COLLECTION_KEYS.profileViews, {
        filters: { carrier_dot: dotString, driver_id: driverId },
        sort: [{ field: 'view_timestamp', direction: 'desc' }], limit: 1, suppressAuth: true
      });
      if (!viewResult.items?.length) return { success: false, errorCode: 'PROFILE_VIEW_REQUIRED', error: 'View profile required before saving' };
    }

    const now = new Date();
    const interestRecord = {
      driver_id: driverId, carrier_dot: dotString, status: CONFIG.RECRUITER_INITIAL_STATUS, match_score: 0,
      origin: CONFIG.ORIGIN.RECRUITER_SEARCH, recruiter_notes: notes || '', action_timestamp: now, application_date: now,
      status_history: JSON.stringify([{ status: CONFIG.RECRUITER_INITIAL_STATUS, timestamp: now.toISOString(), by: 'recruiter' }])
    };

    const result = await dataAccess.insertRecord(COLLECTION_KEYS.interests, interestRecord, { suppressAuth: true });
    await recordOutreachAction(dotString, driverId, 'save_to_pipeline', userId);

    return { success: true, interestId: result.record._id, status: CONFIG.RECRUITER_INITIAL_STATUS };
  } catch (error) {
    console.error('saveDriverToPipeline error:', error);
    return { success: false, error: error.message };
  }
}

export const saveToRecruiterPipeline = saveDriverToPipeline;

// ============================================================================
// SEND MESSAGE TO DRIVER
// ============================================================================

export async function sendMessageToDriver(carrierDot, driverId, messageContent) {
  try {
    let userId = 'dev-mode';
    if (!DEV_MODE_BYPASS_CARRIER) {
      const accessCheck = await verifyRecruiterAccess(carrierDot);
      if (!accessCheck.success) return accessCheck;
      userId = accessCheck.userId;
    }
    if (!messageContent?.trim()) return { success: false, errorCode: 'EMPTY_MESSAGE', error: 'Message required' };

    const dotString = String(carrierDot).trim();

    // In dev mode, skip profile-view requirement (viewing the profile modal already implies access)
    if (!DEV_MODE_BYPASS_CARRIER) {
      const viewResult = await dataAccess.queryRecords(COLLECTION_KEYS.profileViews, {
        filters: { carrier_dot: dotString, driver_id: driverId }, limit: 1, suppressAuth: true
      });
      if (!viewResult.items?.length) return { success: false, errorCode: 'PROFILE_VIEW_REQUIRED', error: 'View profile required before messaging' };
    }

    const interestResult = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { carrier_dot: dotString, driver_id: driverId }, limit: 1, suppressAuth: true
    });

    let applicationId;
    if (interestResult.items?.length) applicationId = interestResult.items[0]._id;
    else {
      const saveResult = await saveDriverToPipeline(carrierDot, driverId, '');
      if (!saveResult.success) return saveResult;
      applicationId = saveResult.interestId;
    }

    const result = await sendMessagingMessage(applicationId, messageContent.trim(), driverId, 'recruiter');
    if (result.success) {
      await recordOutreachAction(dotString, driverId, 'message_sent', userId);
      notifyDriverContactedNonBlocking(driverId, { carrierDot: dotString, messagePreview: messageContent.trim().substring(0, 100) });
    }
    return result;
  } catch (error) {
    console.error('sendMessageToDriver error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// RECORD OUTREACH ACTION
// ============================================================================

async function recordOutreachAction(carrierDot, driverId, actionType, recruiterId) {
  try {
    await dataAccess.insertRecord(COLLECTION_KEYS.outreachHistory, {
      carrier_dot: carrierDot, driver_id: driverId, action_type: actionType, recruiter_id: recruiterId, timestamp: new Date()
    }, { suppressAuth: true });
  } catch (err) { }
}

// ============================================================================
// GET OUTREACH HISTORY
// ============================================================================

export async function getOutreachHistory(carrierDot, driverId = null) {
  try {
    const accessCheck = await verifyRecruiterAccess(carrierDot);
    if (!accessCheck.success) return accessCheck;

    const filters = { carrier_dot: String(carrierDot).trim() };
    if (driverId) filters.driver_id = driverId;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.outreachHistory, {
      filters, sort: [{ field: 'timestamp', direction: 'desc' }], limit: 100, suppressAuth: true
    });

    return { success: true, history: (result.items || []).map(item => ({ actionType: item.action_type, driverId: item.driver_id, timestamp: item.timestamp, recruiterId: item.recruiter_id })) };
  } catch (error) {
    console.error('getOutreachHistory error:', error);
    return { success: false, error: error.message, history: [] };
  }
}

// ============================================================================
// GET QUOTA STATUS
// ============================================================================

export async function getQuotaStatus(carrierDot) {
  try {
    const accessCheck = await verifyRecruiterAccess(carrierDot);
    if (!accessCheck.success) return accessCheck;

    const quotaCheck = await checkViewQuota(carrierDot);
    return { success: true, tier: quotaCheck.tier || 'free', used: quotaCheck.used || 0, limit: quotaCheck.limit || 5, remaining: quotaCheck.remaining || 0, resetDate: quotaCheck.resetDate, hasQuota: quotaCheck.hasQuota };
  } catch (error) {
    console.error('getQuotaStatus error:', error);
    return { success: false, error: error.message, tier: 'free', used: 0, limit: 5, remaining: 0 };
  }
}

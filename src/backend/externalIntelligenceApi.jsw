import * as dataAccess from 'backend/dataAccess';
import { getCarrierSafetyData } from 'backend/fmcsaService';
import { scanSocialMedia } from 'backend/socialScanner';
import { validateDotNumber } from 'backend/externalFmcsaApi';
import { enrichCarrier } from 'backend/aiEnrichment';

const COLLECTIONS = {
  enrichments: 'carrierEnrichments'
};

const CACHE_TTL_DAYS = 14;
const MARKET_CACHE_TTL_MS = 24 * 60 * 60 * 1000;
const marketCache = new Map();

export async function getExternalCarrierIntelligence(dotNumber, options = {}) {
  const validation = validateDotNumber(dotNumber);
  if (!validation.valid) {
    return { success: false, errorCode: 'invalid_request', message: validation.error };
  }

  const dot = String(validation.value);
  const [enrichment, safety] = await Promise.all([
    getOrBuildEnrichment(dot),
    getCarrierSafetyData(dot).catch(() => ({}))
  ]);

  if (!enrichment) {
    return {
      success: false,
      errorCode: 'resource_not_found',
      message: 'Carrier intelligence not found'
    };
  }

  const fullAccess = String(options.accessLevel || 'full') === 'full';

  return {
    success: true,
    data: {
      dot_number: Number(dot),
      legal_name: safety?.legal_name || null,
      enrichment: {
        pay: {
          cpm_range: parseCpmRange(enrichment.pay_cpm_range),
          sign_on_bonus: parseBonus(enrichment.sign_on_bonus),
          home_time: enrichment.home_time || null,
          benefits: splitList(enrichment.benefits)
        },
        sentiment: {
          overall: normalizeSentiment(enrichment.driver_sentiment),
          score: estimateSentimentScore(enrichment.driver_sentiment),
          sample_size: fullAccess ? 0 : null,
          themes: {
            pay_satisfaction: 'mixed',
            home_time: 'mixed',
            equipment: 'mixed',
            management: 'mixed'
          }
        },
        hiring_status: {
          actively_hiring: String(enrichment.hiring_status || '').toLowerCase().includes('active'),
          positions_open: [],
          experience_required: null
        },
        sources: parseJsonArray(enrichment.sources_found).map((source) => ({
          platform: String(source).toLowerCase(),
          posts_analyzed: null
        }))
      },
      enriched_at: toIsoDateTime(enrichment.enriched_date),
      confidence_level: String(enrichment.data_confidence || 'low').toLowerCase()
    }
  };
}

export async function getExternalSentiment(dotNumber) {
  const validation = validateDotNumber(dotNumber);
  if (!validation.valid) {
    return { success: false, errorCode: 'invalid_request', message: validation.error };
  }

  const dot = String(validation.value);
  const safety = await getCarrierSafetyData(dot).catch(() => ({}));
  const carrierName = safety?.legal_name || `DOT ${dot}`;
  const rawIntel = await scanSocialMedia(carrierName, dot);

  if (!rawIntel) {
    return {
      success: false,
      errorCode: 'resource_not_found',
      message: 'Sentiment data unavailable'
    };
  }

  const snippets = rawIntel
    .split('\n')
    .map((line) => line.trim())
    .filter((line) => line && !line.startsWith('#'))
    .slice(0, 3)
    .map((line) => ({
      platform: inferPlatform(line),
      date: new Date().toISOString().slice(0, 10),
      sentiment: 'mixed',
      snippet: line.slice(0, 180)
    }));
  const platformStats = toPlatformBreakdown(snippets);
  const themes = extractThemes(snippets.map((item) => item.snippet));

  return {
    success: true,
    data: {
      dot_number: Number(dot),
      carrier_name: carrierName,
      sentiment_analysis: {
        overall_score: 6.5,
        rating: 'mixed',
        confidence: 'medium',
        sample_size: snippets.length
      },
      by_platform: platformStats,
      key_themes: themes,
      recent_mentions: snippets,
      warnings: [],
      scanned_at: new Date().toISOString()
    }
  };
}

export async function getExternalMarketIntelligence(filters = {}) {
  const cacheKey = buildMarketCacheKey(filters);
  const cached = marketCache.get(cacheKey);
  if (cached && (Date.now() - cached.cachedAt) < MARKET_CACHE_TTL_MS) {
    return { success: true, data: cached.payload };
  }

  const result = await dataAccess.queryRecords(COLLECTIONS.enrichments, {
    limit: 250,
    suppressAuth: true
  });

  const items = applyMarketFilters(result?.items || [], filters);
  if (!items.length) {
    const emptyPayload = {
      query: {
        region: filters.region || null,
        freight_type: filters.freight_type || null,
        operation_type: filters.operation_type || null
      },
      market_data: {
        avg_cpm: null,
        cpm_range: { p25: null, p50: null, p75: null },
        avg_sign_on_bonus: null,
        demand_index: null,
        demand_trend: 'stable',
        driver_shortage_severity: 'unknown'
      },
      top_hiring_carriers: [],
      regional_insights: {
        hot_lanes: [],
        seasonal_factors: null
      },
      data_date: new Date().toISOString().slice(0, 10)
    };
    marketCache.set(cacheKey, { payload: emptyPayload, cachedAt: Date.now() });
    return {
      success: true,
      data: emptyPayload
    };
  }

  const cpmValues = items
    .map((item) => parseCpmRange(item.pay_cpm_range))
    .map((range) => range.max || range.min || null)
    .filter((value) => Number.isFinite(value));

  cpmValues.sort((a, b) => a - b);

  const payload = {
    query: {
      region: filters.region || null,
      freight_type: filters.freight_type || null,
      operation_type: filters.operation_type || null
    },
    market_data: {
      avg_cpm: average(cpmValues),
      cpm_range: {
        p25: percentile(cpmValues, 0.25),
        p50: percentile(cpmValues, 0.5),
        p75: percentile(cpmValues, 0.75)
      },
      avg_sign_on_bonus: averageSignOnBonus(items),
      demand_index: 7.0,
      demand_trend: 'stable',
      driver_shortage_severity: 'medium'
    },
    top_hiring_carriers: buildTopHiringCarriers(items),
    regional_insights: {
      hot_lanes: [],
      seasonal_factors: null
    },
    data_date: new Date().toISOString().slice(0, 10)
  };
  marketCache.set(cacheKey, { payload, cachedAt: Date.now() });

  return {
    success: true,
    data: payload
  };
}

export async function searchExternalCarriers(filters = {}, options = {}) {
  const limit = Math.min(100, Math.max(1, Number(options.limit) || 25));
  const offset = Math.max(0, Number(options.offset) || 0);

  const result = await dataAccess.queryRecords(COLLECTIONS.enrichments, {
    limit: 500,
    suppressAuth: true
  });

  let items = result?.items || [];

  if (filters.sentiment) {
    const target = normalizeSentiment(filters.sentiment);
    items = items.filter((item) => normalizeSentiment(item.driver_sentiment) === target);
  }
  if (filters.fleet_size_min) {
    const min = Number(filters.fleet_size_min);
    if (Number.isFinite(min)) {
      items = items.filter((item) => Number(item.total_power_units || 0) >= min);
    }
  }
  if (filters.fleet_size_max) {
    const max = Number(filters.fleet_size_max);
    if (Number.isFinite(max)) {
      items = items.filter((item) => Number(item.total_power_units || 0) <= max);
    }
  }
  if (filters.safety_rating) {
    const targetRating = String(filters.safety_rating).toLowerCase();
    items = items.filter((item) => String(item.safety_rating || '').toLowerCase() === targetRating);
  }

  const sortBy = String(options.sort_by || 'match_score').toLowerCase();
  const sortDirection = String(options.sort_direction || 'desc').toLowerCase() === 'asc' ? 1 : -1;
  items = items.sort((a, b) => compareCarrierSort(a, b, sortBy) * sortDirection);

  const total = items.length;
  const page = items.slice(offset, offset + limit).map((item) => ({
    dot_number: Number(item.dot_number),
    match_score: estimateMatchScore(item),
    sentiment: normalizeSentiment(item.driver_sentiment),
    confidence: String(item.data_confidence || 'low').toLowerCase(),
    pay_cpm_range: parseCpmRange(item.pay_cpm_range),
    home_time: item.home_time || null,
    hiring_status: item.hiring_status || null,
    enriched_at: toIsoDateTime(item.enriched_date)
  }));

  return {
    success: true,
    data: {
      total,
      limit,
      offset,
      results: page
    }
  };
}

async function getLatestEnrichment(dotNumber) {
  const result = await dataAccess.queryRecords(COLLECTIONS.enrichments, {
    filters: { dot_number: String(dotNumber) },
    sort: [{ field: 'enriched_date', direction: 'desc' }],
    limit: 1,
    suppressAuth: true
  });

  const item = result?.items?.[0] || null;
  if (!item) return null;

  const enrichedDate = item.enriched_date ? new Date(item.enriched_date) : null;
  if (!enrichedDate || Number.isNaN(enrichedDate.getTime())) return item;

  const ageDays = (Date.now() - enrichedDate.getTime()) / (1000 * 60 * 60 * 24);
  if (ageDays > CACHE_TTL_DAYS) {
    return item;
  }
  return item;
}

async function getOrBuildEnrichment(dotNumber) {
  const latest = await getLatestEnrichment(dotNumber);
  if (latest) return latest;

  const enriched = await enrichCarrier(String(dotNumber), {}, {}, null).catch(() => null);
  if (enriched && !enriched.error) {
    return enriched;
  }
  return null;
}

function parseCpmRange(value) {
  const text = String(value || '');
  const matches = text.match(/(\d+(\.\d+)?)/g) || [];
  if (!matches.length) {
    return { min: null, max: null, confidence: 'low' };
  }
  const numbers = matches.map((n) => Number(n)).filter((n) => Number.isFinite(n));
  if (!numbers.length) {
    return { min: null, max: null, confidence: 'low' };
  }
  const normalized = numbers.map((n) => n > 10 ? n / 100 : n);
  const min = Math.min(...normalized);
  const max = Math.max(...normalized);
  return { min, max, confidence: 'medium' };
}

function parseBonus(value) {
  const text = String(value || '');
  const numberMatch = text.replace(/,/g, '').match(/(\d+(\.\d+)?)/);
  if (!numberMatch) return { amount: null, confidence: 'low' };
  return { amount: Number(numberMatch[1]), confidence: 'medium' };
}

function splitList(value) {
  if (!value) return [];
  return String(value)
    .split(',')
    .map((item) => item.trim())
    .filter(Boolean);
}

function parseJsonArray(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value;
  try {
    const parsed = JSON.parse(value);
    return Array.isArray(parsed) ? parsed : [];
  } catch (_e) {
    return splitList(value);
  }
}

function normalizeSentiment(value) {
  const raw = String(value || '').toLowerCase();
  if (raw.includes('pos')) return 'positive';
  if (raw.includes('neg')) return 'negative';
  if (raw.includes('mix')) return 'mixed';
  return 'mixed';
}

function estimateSentimentScore(value) {
  const sentiment = normalizeSentiment(value);
  if (sentiment === 'positive') return 7.5;
  if (sentiment === 'negative') return 4.5;
  return 6.0;
}

function estimateMatchScore(item) {
  const confidence = String(item.data_confidence || 'low').toLowerCase();
  if (confidence === 'high') return 85;
  if (confidence === 'medium') return 72;
  return 60;
}

function buildTopHiringCarriers(items) {
  return items
    .filter((item) => String(item.hiring_status || '').toLowerCase().includes('active'))
    .slice(0, 10)
    .map((item) => ({
      dot_number: Number(item.dot_number),
      carrier_name: item.legal_name || item.carrier_name || null,
      hiring_status: item.hiring_status || 'unknown',
      confidence: String(item.data_confidence || 'low').toLowerCase()
    }));
}

function applyMarketFilters(items, filters) {
  let filtered = Array.isArray(items) ? [...items] : [];
  const region = String(filters.region || '').toLowerCase();
  const freightType = String(filters.freight_type || '').toLowerCase();
  const operationType = String(filters.operation_type || '').toLowerCase();

  if (region) {
    filtered = filtered.filter((item) => {
      const hay = `${item.phy_state || ''} ${item.region || ''} ${item.primary_region || ''}`.toLowerCase();
      return hay.includes(region);
    });
  }
  if (freightType) {
    filtered = filtered.filter((item) => String(item.freight_types || '').toLowerCase().includes(freightType));
  }
  if (operationType) {
    filtered = filtered.filter((item) => String(item.route_types || '').toLowerCase().includes(operationType));
  }
  return filtered;
}

function buildMarketCacheKey(filters) {
  const region = String(filters.region || '').toLowerCase();
  const freightType = String(filters.freight_type || '').toLowerCase();
  const operationType = String(filters.operation_type || '').toLowerCase();
  const day = new Date().toISOString().slice(0, 10);
  return `${day}|${region}|${freightType}|${operationType}`;
}

function averageSignOnBonus(items) {
  const values = items
    .map((item) => parseBonus(item.sign_on_bonus).amount)
    .filter((value) => Number.isFinite(value));
  return average(values);
}

function compareCarrierSort(a, b, sortBy) {
  if (sortBy === 'sentiment') {
    return scoreSentiment(a.driver_sentiment) - scoreSentiment(b.driver_sentiment);
  }
  if (sortBy === 'confidence') {
    return scoreConfidence(a.data_confidence) - scoreConfidence(b.data_confidence);
  }
  const scoreA = estimateMatchScore(a);
  const scoreB = estimateMatchScore(b);
  return scoreA - scoreB;
}

function scoreSentiment(value) {
  const sentiment = normalizeSentiment(value);
  if (sentiment === 'positive') return 3;
  if (sentiment === 'mixed') return 2;
  return 1;
}

function scoreConfidence(value) {
  const confidence = String(value || '').toLowerCase();
  if (confidence === 'high') return 3;
  if (confidence === 'medium') return 2;
  return 1;
}

function inferPlatform(snippet) {
  const text = String(snippet || '').toLowerCase();
  if (text.includes('reddit')) return 'reddit';
  if (text.includes('truckersreport') || text.includes('forum')) return 'truckersreport';
  if (text.includes('twitter') || text.includes('x.com') || text.includes('@')) return 'twitter';
  return 'social';
}

function toPlatformBreakdown(snippets) {
  const base = {
    reddit: { score: 6.5, posts_analyzed: 0, subreddits: [] },
    truckersreport: { score: 6.5, threads_analyzed: 0 },
    twitter: { score: 6.5, tweets_analyzed: 0 }
  };

  snippets.forEach((item) => {
    if (item.platform === 'reddit') base.reddit.posts_analyzed += 1;
    if (item.platform === 'truckersreport') base.truckersreport.threads_analyzed += 1;
    if (item.platform === 'twitter') base.twitter.tweets_analyzed += 1;
  });
  return base;
}

function extractThemes(lines) {
  const buckets = {
    pay: ['pay', 'cpm', 'bonus'],
    home_time: ['home time', 'hometime', 'weekend'],
    equipment: ['truck', 'equipment', 'maintenance'],
    management: ['dispatch', 'manager', 'management']
  };

  const scores = Object.keys(buckets).map((key) => {
    const words = buckets[key];
    const count = lines.reduce((acc, line) => {
      const hay = String(line || '').toLowerCase();
      const matches = words.some((word) => hay.includes(word));
      return acc + (matches ? 1 : 0);
    }, 0);
    return { theme: key, mentions: count };
  });

  return scores
    .filter((item) => item.mentions > 0)
    .sort((a, b) => b.mentions - a.mentions)
    .slice(0, 5);
}

function average(values) {
  if (!values.length) return null;
  return Number((values.reduce((acc, n) => acc + n, 0) / values.length).toFixed(3));
}

function percentile(values, p) {
  if (!values.length) return null;
  const index = Math.min(values.length - 1, Math.max(0, Math.floor(values.length * p)));
  return Number(values[index].toFixed(3));
}

function toIsoDateTime(value) {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toISOString();
}

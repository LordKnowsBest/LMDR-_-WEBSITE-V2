import * as dataAccess from 'backend/dataAccess';
import { createNotification } from 'backend/memberService';
import wixUsersBackend from 'wix-users-backend';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    driverReferrals: 'driverReferrals',
    matchQualityBonuses: 'matchQualityBonuses',
    driverProgression: 'driverProgression',
    recruiterProgression: 'recruiterProgression'
};

// =============================================================================
// REFERRAL CONFIGURATION
// =============================================================================

const REFERRAL_CONFIG = {
    // XP/Points rewards
    rewards: {
        referrer_on_signup: 200,        // XP for referrer when referral signs up
        referrer_on_application: 100,   // XP when referral submits first application
        referrer_on_hire: 500,          // XP when referral gets hired
        referee_signup_bonus: 50        // XP bonus for new user who used referral
    },

    // Referral link format
    linkPrefix: 'ref_',

    // Match quality bonus thresholds
    matchQuality: {
        excellent: { threshold: 90, driverBonus: 150, recruiterBonus: 200 },
        great: { threshold: 80, driverBonus: 100, recruiterBonus: 150 },
        good: { threshold: 70, driverBonus: 50, recruiterBonus: 75 }
    }
};

// Lazy-load gamification service to avoid circular dependencies
async function getGamificationService() {
    return await import('backend/gamificationService');
}

// =============================================================================
// REFERRAL LINK GENERATION
// =============================================================================

/**
 * Generate a unique referral code for a driver
 */
export async function generateReferralCode(driverId) {
  try {
    if (!driverId) return { success: false, error: 'Driver ID required' };
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: driverId, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    if (res.items?.length) {
      const code = getFieldValue(res.items[0], ['referral_code', 'Referral Code']);
      return { success: true, referralCode: code, referralLink: buildReferralLink(code), existingCode: true };
    }

    const code = generateUniqueCode(driverId), now = new Date().toISOString();
    await dataAccess.insertRecord(COLLECTION_KEYS.driverReferrals, { referrer_id: driverId, referral_code: code, is_referrer_record: 'Yes', total_referrals: 0, successful_hires: 0, total_xp_earned: 0, created_at: now, updated_at: now }, { suppressAuth: true });
    return { success: true, referralCode: code, referralLink: buildReferralLink(code), existingCode: false };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Get driver's referral stats
 */
export async function getReferralStats(driverId) {
  try {
    const masterRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: driverId, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    if (!masterRes.items?.length) return { success: true, hasReferralCode: false, stats: { totalReferrals: 0, successfulHires: 0, totalXPEarned: 0 } };
    const master = masterRes.items[0];
    const referralCode = getFieldValue(master, ['referral_code', 'Referral Code']);
    const totalXPEarned = getFieldValue(master, ['total_xp_earned', 'Total XP Earned'], 0);

    const refsRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: driverId, is_referrer_record: 'No' }, sort: [{ field: 'created_at', direction: 'desc' }], limit: 50, suppressAuth: true });
    const referrals = refsRes.items || [];

    return { success: true, hasReferralCode: true, referralCode, referralLink: buildReferralLink(referralCode), stats: { totalReferrals: referrals.length, pendingSignups: referrals.filter(r => getFieldValue(r, ['status', 'Status']) === 'signed_up').length, successfulHires: referrals.filter(r => getFieldValue(r, ['status', 'Status']) === 'hired').length, totalXPEarned }, recentReferrals: referrals.slice(0, 5).map(r => ({ refereeId: getFieldValue(r, ['referee_id', 'Referee ID']), status: getFieldValue(r, ['status', 'Status']), signupDate: getFieldValue(r, ['signup_date', 'Signup Date']), xpEarned: getFieldValue(r, ['xp_earned_from_referral', 'XP Earned From Referral'], 0) })) };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Track a referral signup
 */
export async function trackReferralSignup(referralCode, newUserId, newUserEmail = '') {
  try {
    if (!referralCode || !newUserId) return { success: false, error: 'Required fields missing' };
    const refRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referral_code: referralCode, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    if (!refRes.items?.length) return { success: false, error: 'Invalid referral code' };
    const referrer = refRes.items[0], now = new Date().toISOString();
    const referrerId = getFieldValue(referrer, ['referrer_id', 'Referrer ID']);
    const currentTotalReferrals = getFieldValue(referrer, ['total_referrals', 'Total Referrals'], 0);

    const existing = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referee_id: newUserId }, limit: 1, suppressAuth: true });
    if (existing.items?.length) return { success: false, error: 'User already has a referral record' };

    await dataAccess.insertRecord(COLLECTION_KEYS.driverReferrals, { referrer_id: referrerId, referee_id: newUserId, referee_email: newUserEmail, referral_code: referralCode, is_referrer_record: 'No', status: 'signed_up', signup_date: now, created_at: now, updated_at: now }, { suppressAuth: true });
    await dataAccess.updateRecord(COLLECTION_KEYS.driverReferrals, { ...referrer, referrer_id: referrerId, total_referrals: currentTotalReferrals + 1, updated_at: now }, { suppressAuth: true });

    awardReferralXP(referrerId, 'referrer_on_signup', { refereeId: newUserId });
    awardReferralXP(newUserId, 'referee_signup_bonus', { referrerId });
    createNotification(referrerId, 'referral_signup', 'New Referral!', 'Someone signed up! +200 XP', '/driver/referrals').catch(() => {});

    return {
      success: true,
      referrerId,
      bonusAwarded: {
        referrer: REFERRAL_CONFIG.rewards.referrer_on_signup,
        referee: REFERRAL_CONFIG.rewards.referee_signup_bonus
      }
    };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Track referral conversion
 */
export async function trackReferralConversion(userId, conversionType, metadata = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referee_id: userId, is_referrer_record: 'No' }, limit: 1, suppressAuth: true });
    if (!res.items?.length) return { success: true, wasReferred: false };
    const referral = res.items[0], now = new Date().toISOString();
    const referrerId = getFieldValue(referral, ['referrer_id', 'Referrer ID']);
    const currentReferralXP = getFieldValue(referral, ['xp_earned_from_referral', 'XP Earned From Referral'], 0);

    let xpReward = conversionType === 'applied' ? 100 : conversionType === 'hired' ? 500 : 0;
    if (xpReward > 0) {
      const update = { ...referral, referrer_id: referrerId, status: conversionType, updated_at: now, xp_earned_from_referral: currentReferralXP + xpReward };
      await dataAccess.updateRecord(COLLECTION_KEYS.driverReferrals, update, { suppressAuth: true });

      const masterRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: referrerId, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
      if (masterRes.items?.length) {
        const master = masterRes.items[0];
        const totalXPEarned = getFieldValue(master, ['total_xp_earned', 'Total XP Earned'], 0);
        const successfulHires = getFieldValue(master, ['successful_hires', 'Successful Hires'], 0);
        const masterUpd = { ...master, total_xp_earned: totalXPEarned + xpReward, updated_at: now };
        if (conversionType === 'hired') masterUpd.successful_hires = successfulHires + 1;
        await dataAccess.updateRecord(COLLECTION_KEYS.driverReferrals, masterUpd, { suppressAuth: true });
      }
      const rewardType = conversionType === 'applied' ? 'referrer_on_application' : 'referrer_on_hire';
      awardReferralXP(referrerId, rewardType, { refereeId: userId, ...metadata });
      createNotification(referrerId, 'referral_conversion', 'Referral Goal!', `Your referral goal reached: ${conversionType}`, '/driver/referrals').catch(() => {});
    }
    return { success: true, wasReferred: true, xpAwarded: xpReward };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Award match quality bonus when a hire is made
 */
export async function awardMatchQualityBonus(driverId, recruiterId, matchScore, metadata = {}) {
    try {
        if (!driverId || !recruiterId || matchScore === undefined) return { success: false, error: 'Missing required parameters' };
        let tier = null, dBonus = 0, rBonus = 0;
        if (matchScore >= 90) { tier = 'excellent'; dBonus = 150; rBonus = 200; }
        else if (matchScore >= 80) { tier = 'great'; dBonus = 100; rBonus = 150; }
        else if (matchScore >= 70) { tier = 'good'; dBonus = 50; rBonus = 75; }
        if (!tier) return { success: true, bonusAwarded: false, reason: 'Match score below threshold' };

        const now = new Date().toISOString();
        await dataAccess.insertRecord(COLLECTION_KEYS.matchQualityBonuses, { driver_id: driverId, recruiter_id: recruiterId, match_score: matchScore, bonus_tier: tier, driver_bonus_xp: dBonus, recruiter_bonus_points: rBonus, carrier_dot: String(metadata.carrierDot || ''), hire_date: now, created_at: now }, { suppressAuth: true });

        const gamification = await getGamificationService();
        gamification.awardDriverXP(driverId, 'match_quality_bonus', { matchScore, bonusTier: tier, bonusXP: dBonus }).catch(() => {});
        gamification.awardRecruiterPoints(recruiterId, 'match_quality_bonus', { matchScore, bonusTier: tier, bonusPoints: rBonus }).catch(() => {});

        createNotification(driverId, 'match_quality_bonus', 'Match Bonus!', `Score ${matchScore}% earned you ${dBonus} XP`, '/driver/achievements').catch(() => {});
        createNotification(recruiterId, 'match_quality_bonus', 'Match Bonus!', `Hire score ${matchScore}% earned you ${rBonus} pts`, '/recruiter/leaderboard').catch(() => {});

        return {
          success: true,
          bonusAwarded: true,
          bonusTier: tier,
          driverBonus: dBonus,
          recruiterBonus: rBonus
        };
    } catch (error) { return { success: false, error: error.message }; }
}

export async function getMatchQualityBonusHistory(userId, userType) {
    try {
        const filterField = userType === 'driver' ? 'driver_id' : 'recruiter_id';
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.matchQualityBonuses, { filters: { [filterField]: userId }, sort: [{ field: 'created_at', direction: 'desc' }], limit: 20, suppressAuth: true });
        const items = result.items || [];
        const bonusField = userType === 'driver' ? 'driver_bonus_xp' : 'recruiter_bonus_points';
        const bonusByTier = { excellent: 0, great: 0, good: 0 };
        items.forEach((item) => {
          const tier = getFieldValue(item, ['bonus_tier', 'Bonus Tier']);
          if (tier && bonusByTier[tier] !== undefined) {
            bonusByTier[tier]++;
          }
        });

        return {
          success: true,
          totalBonuses: items.length,
          totalEarned: items.reduce((s, r) => s + (getFieldValue(r, [bonusField, userType === 'driver' ? 'Driver Bonus XP' : 'Recruiter Bonus Points'], 0) || 0), 0),
          bonusByTier,
          recentBonuses: items.slice(0, 10)
        };
    } catch (error) { return { success: false, error: error.message }; }
}

export async function processHireBonus(driverId, recruiterId, matchScore, metadata = {}) {
  const results = {
    matchQualityBonus: null,
    referralConversion: null
  };

  if (matchScore >= REFERRAL_CONFIG.matchQuality.good.threshold) {
    results.matchQualityBonus = await awardMatchQualityBonus(driverId, recruiterId, matchScore, metadata);
  }

  results.referralConversion = await trackReferralConversion(driverId, 'hired', metadata);
  return { success: true, results };
}

// =============================================================================
// INTERNAL HELPERS
// =============================================================================

function generateUniqueCode(driverId) {
    return REFERRAL_CONFIG.linkPrefix + Math.random().toString(36).substr(2, 6).toUpperCase();
}

function buildReferralLink(code) {
    return `https://www.lastmiledr.app/signup?ref=${code}`;
}

function getFieldValue(record, keys, fallback = undefined) {
    for (const key of keys) {
        if (record && record[key] !== undefined && record[key] !== null) {
            return record[key];
        }
    }
    return fallback;
}

export async function validateReferralCode(code) {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referral_code: code, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    return {
      valid: !!res.items?.length,
      referrerId: res.items?.length ? getFieldValue(res.items[0], ['referrer_id', 'Referrer ID']) : null
    };
}

async function awardReferralXP(userId, rewardType, metadata = {}) {
    try {
        const gamification = await getGamificationService();
        const xpAmount = REFERRAL_CONFIG.rewards[rewardType] || 0;
        if (xpAmount > 0) {
            await gamification.awardDriverXP(userId, 'referral_bonus', { rewardType, xpAmount, ...metadata });
        }
    } catch (error) { }
}

export function getReferralConfig() {
    return { rewards: REFERRAL_CONFIG.rewards, matchQuality: REFERRAL_CONFIG.matchQuality };
}

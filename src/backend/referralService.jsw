import * as dataAccess from 'backend/dataAccess';
import { createNotification } from 'backend/memberService';
import wixUsersBackend from 'wix-users-backend';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    driverReferrals: 'driverReferrals',
    matchQualityBonuses: 'matchQualityBonuses',
    driverProgression: 'driverProgression',
    recruiterProgression: 'recruiterProgression'
};

// =============================================================================
// REFERRAL CONFIGURATION
// =============================================================================

const REFERRAL_CONFIG = {
    // XP/Points rewards
    rewards: {
        referrer_on_signup: 200,        // XP for referrer when referral signs up
        referrer_on_application: 100,   // XP when referral submits first application
        referrer_on_hire: 500,          // XP when referral gets hired
        referee_signup_bonus: 50        // XP bonus for new user who used referral
    },

    // Referral link format
    linkPrefix: 'ref_',

    // Match quality bonus thresholds
    matchQuality: {
        excellent: { threshold: 90, driverBonus: 150, recruiterBonus: 200 },
        great: { threshold: 80, driverBonus: 100, recruiterBonus: 150 },
        good: { threshold: 70, driverBonus: 50, recruiterBonus: 75 }
    }
};

// Lazy-load gamification service to avoid circular dependencies
async function getGamificationService() {
    return await import('backend/gamificationService');
}

// =============================================================================
// REFERRAL LINK GENERATION
// =============================================================================

/**
 * Generate a unique referral code for a driver
 */
export async function generateReferralCode(driverId) {
  try {
    if (!driverId) return { success: false, error: 'Driver ID required' };
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: driverId, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    if (res.items?.length) return { success: true, referralCode: res.items[0].referral_code, referralLink: buildReferralLink(res.items[0].referral_code), existingCode: true };

    const code = generateUniqueCode(driverId), now = new Date().toISOString();
    await dataAccess.insertRecord(COLLECTION_KEYS.driverReferrals, { referrer_id: driverId, referral_code: code, is_referrer_record: 'Yes', total_referrals: 0, successful_hires: 0, total_xp_earned: 0, created_at: now, updated_at: now }, { suppressAuth: true });
    return { success: true, referralCode: code, referralLink: buildReferralLink(code), existingCode: false };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Get driver's referral stats
 */
export async function getReferralStats(driverId) {
  try {
    const masterRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: driverId, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    if (!masterRes.items?.length) return { success: true, hasReferralCode: false, stats: { totalReferrals: 0, successfulHires: 0, totalXPEarned: 0 } };
    const master = masterRes.items[0];

    const refsRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: driverId, is_referrer_record: 'No' }, sort: [{ field: 'created_at', direction: 'desc' }], limit: 50, suppressAuth: true });
    const referrals = refsRes.items || [];

    return { success: true, hasReferralCode: true, referralCode: master.referral_code, referralLink: buildReferralLink(master.referral_code), stats: { totalReferrals: referrals.length, pendingSignups: referrals.filter(r => r.status === 'signed_up').length, successfulHires: referrals.filter(r => r.status === 'hired').length, totalXPEarned: master.total_xp_earned || 0 }, recentReferrals: referrals.slice(0, 5).map(r => ({ refereeId: r.referee_id, status: r.status, signupDate: r.signup_date, xpEarned: r.xp_earned_from_referral || 0 })) };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Track a referral signup
 */
export async function trackReferralSignup(referralCode, newUserId, newUserEmail = '') {
  try {
    if (!referralCode || !newUserId) return { success: false, error: 'Required fields missing' };
    const refRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referral_code: referralCode, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    if (!refRes.items?.length) return { success: false, error: 'Invalid code' };
    const referrer = refRes.items[0], now = new Date().toISOString();

    const existing = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referee_id: newUserId }, limit: 1, suppressAuth: true });
    if (existing.items?.length) return { success: false, error: 'Already referred' };

    await dataAccess.insertRecord(COLLECTION_KEYS.driverReferrals, { referrer_id: referrer.referrer_id, referee_id: newUserId, referee_email: newUserEmail, referral_code: referralCode, is_referrer_record: 'No', status: 'signed_up', signup_date: now, created_at: now, updated_at: now }, { suppressAuth: true });
    await dataAccess.updateRecord(COLLECTION_KEYS.driverReferrals, { ...referrer, total_referrals: (referrer.total_referrals || 0) + 1, updated_at: now }, { suppressAuth: true });

    awardReferralXP(referrer.referrer_id, 'referrer_on_signup', { refereeId: newUserId });
    awardReferralXP(newUserId, 'referee_signup_bonus', { referrerId: referrer.referrer_id });
    createNotification(referrer.referrer_id, 'referral_signup', 'New Referral!', 'Someone signed up! +200 XP', '/driver/referrals').catch(() => {});

    return { success: true, referrerId: referrer.referrer_id };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Track referral conversion
 */
export async function trackReferralConversion(userId, conversionType, metadata = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referee_id: userId, is_referrer_record: 'No' }, limit: 1, suppressAuth: true });
    if (!res.items?.length) return { success: true, wasReferred: false };
    const referral = res.items[0], now = new Date().toISOString();

    let xpReward = conversionType === 'applied' ? 100 : conversionType === 'hired' ? 500 : 0;
    if (xpReward > 0) {
      const update = { ...referral, status: conversionType, updated_at: now, xp_earned_from_referral: (referral.xp_earned_from_referral || 0) + xpReward };
      await dataAccess.updateRecord(COLLECTION_KEYS.driverReferrals, update, { suppressAuth: true });

      const masterRes = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referrer_id: referral.referrer_id, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
      if (masterRes.items?.length) {
        const master = masterRes.items[0];
        const masterUpd = { ...master, total_xp_earned: (master.total_xp_earned || 0) + xpReward, updated_at: now };
        if (conversionType === 'hired') masterUpd.successful_hires = (master.successful_hires || 0) + 1;
        await dataAccess.updateRecord(COLLECTION_KEYS.driverReferrals, masterUpd, { suppressAuth: true });
      }
      awardReferralXP(referral.referrer_id, `referrer_on_${conversionType}`, { refereeId: userId, ...metadata });
      createNotification(referral.referrer_id, 'referral_conversion', 'Referral Goal!', `Your referral goal reached: ${conversionType}`, '/driver/referrals').catch(() => {});
    }
    return { success: true, wasReferred: true };
  } catch (error) { return { success: false, error: error.message }; }
}

/**
 * Award match quality bonus when a hire is made
 */
export async function awardMatchQualityBonus(driverId, recruiterId, matchScore, metadata = {}) {
    try {
        if (!driverId || !recruiterId || matchScore === undefined) return { success: false, error: 'Missing params' };
        let tier = null, dBonus = 0, rBonus = 0;
        if (matchScore >= 90) { tier = 'excellent'; dBonus = 150; rBonus = 200; }
        else if (matchScore >= 80) { tier = 'great'; dBonus = 100; rBonus = 150; }
        else if (matchScore >= 70) { tier = 'good'; dBonus = 50; rBonus = 75; }
        if (!tier) return { success: true, bonusAwarded: false };

        const now = new Date().toISOString();
        await dataAccess.insertRecord(COLLECTION_KEYS.matchQualityBonuses, { driver_id: driverId, recruiter_id: recruiterId, match_score: matchScore, bonus_tier: tier, driver_bonus_xp: dBonus, recruiter_bonus_points: rBonus, carrier_dot: String(metadata.carrierDot || ''), hire_date: now, created_at: now }, { suppressAuth: true });

        const gamification = await getGamificationService();
        gamification.awardDriverXP(driverId, 'match_quality_bonus', { matchScore, bonusTier: tier, bonusXP: dBonus }).catch(() => {});
        gamification.awardRecruiterPoints(recruiterId, 'match_quality_bonus', { matchScore, bonusTier: tier, bonusPoints: rBonus }).catch(() => {});

        createNotification(driverId, 'match_quality_bonus', 'Match Bonus!', `Score ${matchScore}% earned you ${dBonus} XP`, '/driver/achievements').catch(() => {});
        createNotification(recruiterId, 'match_quality_bonus', 'Match Bonus!', `Hire score ${matchScore}% earned you ${rBonus} pts`, '/recruiter/leaderboard').catch(() => {});

        return { success: true, bonusAwarded: true, bonusTier: tier, dBonus, rBonus };
    } catch (error) { return { success: false, error: error.message }; }
}

export async function getMatchQualityBonusHistory(userId, userType) {
    try {
        const filterField = userType === 'driver' ? 'driver_id' : 'recruiter_id';
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.matchQualityBonuses, { filters: { [filterField]: userId }, sort: [{ field: 'created_at', direction: 'desc' }], limit: 20, suppressAuth: true });
        const bonusField = userType === 'driver' ? 'driver_bonus_xp' : 'recruiter_bonus_points';
        return { success: true, totalEarned: (result.items || []).reduce((s, r) => s + (r[bonusField] || 0), 0), recentBonuses: (result.items || []).slice(0, 10) };
    } catch (error) { return { success: false, error: error.message }; }
}

// =============================================================================
// INTERNAL HELPERS
// =============================================================================

function generateUniqueCode(driverId) {
    return REFERRAL_CONFIG.linkPrefix + Math.random().toString(36).substr(2, 6).toUpperCase();
}

function buildReferralLink(code) {
    return `https://www.lastmiledr.app/signup?ref=${code}`;
}

export async function validateReferralCode(code) {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.driverReferrals, { filters: { referral_code: code, is_referrer_record: 'Yes' }, limit: 1, suppressAuth: true });
    return { valid: !!res.items?.length, referrerId: res.items?.[0]?.referrer_id || null };
}

async function awardReferralXP(userId, rewardType, metadata = {}) {
    try {
        const gamification = await getGamificationService();
        const xpAmount = REFERRAL_CONFIG.rewards[rewardType] || 0;
        if (xpAmount > 0) {
            await gamification.awardDriverXP(userId, 'referral_bonus', { rewardType, xpAmount, ...metadata });
        }
    } catch (error) { }
}

export function getReferralConfig() {
    return { rewards: REFERRAL_CONFIG.rewards, matchQuality: REFERRAL_CONFIG.matchQuality };
}
import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    prompts: 'promptLibrary',
    versions: 'promptVersions',
    auditLog: 'auditLog'
};

const CONFIG = {
    categories: [
        { id: 'enrichment', name: 'Carrier Enrichment', description: 'Prompts for AI carrier analysis' },
        { id: 'research', name: 'Web Research', description: 'Prompts for web data gathering' },
        { id: 'social', name: 'Social Analysis', description: 'Prompts for social media scanning' },
        { id: 'ocr', name: 'Document OCR', description: 'Prompts for document extraction' },
        { id: 'chat', name: 'Chat/Support', description: 'Prompts for driver/admin chat' },
        { id: 'classification', name: 'Classification', description: 'Prompts for content classification' },
        { id: 'extraction', name: 'Data Extraction', description: 'Prompts for structured data extraction' },
        { id: 'other', name: 'Other', description: 'Miscellaneous prompts' }
    ]
};

// ============================================
// AUTHORIZATION
// ============================================

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const role = member.contactDetails?.customFields?.role || '';
        return role.toLowerCase() === 'super_admin';
    } catch (error) { return false; }
}

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const role = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(role.toLowerCase());
    } catch (error) { return false; }
}

async function requireSuperAdmin() {
    if (!await isSuperAdmin()) throw new Error('Unauthorized');
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized');
}

async function getCurrentAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        return { id: member?._id || 'system', email: member?.loginEmail || 'system@lmdr.com' };
    } catch { return { id: 'system', email: 'system@lmdr.com' }; }
}

// ============================================
// PROMPT CRUD OPERATIONS
// ============================================

export async function getPrompts(options = {}) {
    await requireAdmin();
    try {
        const filters = {};
        if (options.category) filters.category = options.category;
        if (options.isActive !== undefined) filters.isActive = options.isActive;
        if (options.search) filters.name = { contains: options.search };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.prompts, {
            filters, sort: [{ field: 'category', direction: 'asc' }, { field: 'name', direction: 'asc' }],
            limit: 1000, suppressAuth: true
        });

        return { items: result.items || [], totalCount: result.totalCount || result.items?.length, categories: CONFIG.categories };
    } catch (error) { throw new Error('Failed to fetch prompts'); }
}

export async function getPrompt(promptId) {
    await requireAdmin();
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.prompts, { filters: { promptId: promptId }, limit: 1, suppressAuth: true });
        if (!result.items?.length) throw new Error('Prompt not found');
        const prompt = result.items[0];

        const versionsRes = await dataAccess.queryRecords(COLLECTION_KEYS.versions, { filters: { promptId: promptId }, sort: [{ field: 'version', direction: 'desc' }], limit: 10, suppressAuth: true });
        return { prompt, versions: versionsRes.items || [] };
    } catch (error) { throw new Error('Failed to fetch prompt'); }
}

export async function createPrompt(promptData) {
    await requireSuperAdmin();
    try {
        const admin = await getCurrentAdmin();
        if (!promptData.promptId || !promptData.name || !promptData.systemPrompt) throw new Error('Missing fields');

        const existing = await dataAccess.queryRecords(COLLECTION_KEYS.prompts, { filters: { promptId: promptData.promptId }, limit: 1, suppressAuth: true });
        if (existing.items?.length) throw new Error('Prompt ID already exists');

        const newPrompt = { ...promptData, isActive: promptData.isActive !== false, version: 1, createdAt: new Date(), createdBy: admin.email, updatedAt: new Date(), updatedBy: admin.email };
        const created = await dataAccess.insertRecord(COLLECTION_KEYS.prompts, newPrompt, { suppressAuth: true });
        if (!created.success) throw new Error(created.error);

        await createVersion(promptData.promptId, { ...newPrompt, version: 1 }, admin.email, 'Initial creation');
        await logAction('createPrompt', 'prompt', created.record._id, { promptId: promptData.promptId, name: newPrompt.name }, admin);
        return created.record;
    } catch (error) { throw new Error(error.message); }
}

export async function updatePrompt(promptId, updates, changeNote = '') {
    await requireSuperAdmin();
    try {
        const admin = await getCurrentAdmin();
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.prompts, { filters: { promptId: promptId }, limit: 1, suppressAuth: true });
        if (!res.items?.length) throw new Error('Prompt not found');
        const prompt = res.items[0];

        const updatedPrompt = { ...prompt, ...updates, version: (prompt.version || 0) + 1, updatedAt: new Date(), updatedBy: admin.email };
        const updated = await dataAccess.updateRecord(COLLECTION_KEYS.prompts, updatedPrompt, { suppressAuth: true });
        if (!updated.success) throw new Error(updated.error);

        await createVersion(promptId, updatedPrompt, admin.email, changeNote);
        await logAction('updatePrompt', 'prompt', prompt._id, { promptId, name: updatedPrompt.name, version: updatedPrompt.version, changeNote }, admin);
        return updated.record;
    } catch (error) { throw new Error(error.message); }
}

export async function deletePrompt(promptId) {
    await requireSuperAdmin();
    try {
        const admin = await getCurrentAdmin();
        const res = await dataAccess.queryRecords(COLLECTION_KEYS.prompts, { filters: { promptId: promptId }, limit: 1, suppressAuth: true });
        if (!res.items?.length) throw new Error('Prompt not found');
        const prompt = res.items[0];

        await dataAccess.updateRecord(COLLECTION_KEYS.prompts, { ...prompt, isActive: false, deletedAt: new Date(), deletedBy: admin.email }, { suppressAuth: true });
        await logAction('deletePrompt', 'prompt', prompt._id, { promptId, name: prompt.name }, admin);
        return { success: true };
    } catch (error) { throw new Error('Failed to delete prompt'); }
}

async function createVersion(promptId, promptData, author, changeNote) {
    const version = { promptId, version: promptData.version, systemPrompt: promptData.systemPrompt, userPromptTemplate: promptData.userPromptTemplate, variables: promptData.variables, provider: promptData.provider, model: promptData.model, changeNote: changeNote || '', createdAt: new Date(), createdBy: author };
    await dataAccess.insertRecord(COLLECTION_KEYS.versions, version, { suppressAuth: true });
}

export async function getActivePrompt(promptId) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.prompts, { filters: { promptId: promptId, isActive: true }, limit: 1, suppressAuth: true });
        return result.items?.[0] || null;
    } catch (error) { return null; }
}

export function renderPrompt(template, variables = {}) {
    let rendered = template;
    for (const [key, value] of Object.entries(variables)) rendered = rendered.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value || '');
    return rendered;
}

async function logAction(action, targetType, targetId, details, admin) {
    try {
        await dataAccess.insertRecord(COLLECTION_KEYS.auditLog, { action, targetType, targetId, details, adminId: admin.id, adminEmail: admin.email, timestamp: new Date() }, { suppressAuth: true });
    } catch (error) { }
}
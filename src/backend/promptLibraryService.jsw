/**
 * Prompt Library Service - Backend functions for managing AI prompts
 * Provides CRUD operations for system prompts with version history
 * Super Admin has full read/write access
 */

import wixData from 'wix-data';
import { currentMember } from 'wix-members-backend';
import { usesAirtable, getAirtableTableName } from 'backend/configData';
import * as airtable from 'backend/airtableClient';

// ============================================
// CONFIGURATION
// ============================================

// Collection keys for dual-source routing
const COLLECTION_KEYS = {
    prompts: 'promptLibrary',
    versions: 'promptVersions',
    auditLog: 'adminAuditLog'
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

async function queryData(collectionKey, wixCollectionName, options = {}) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        const result = await airtable.queryRecords(tableName, {
            filterByFormula: options.filter || '',
            sort: options.sort,
            maxRecords: options.limit || 100
        });
        return result.records || [];
    }
    let query = wixData.query(wixCollectionName);
    if (options.sort) {
        query = options.sortDir === 'asc' ? query.ascending(options.sort) : query.descending(options.sort);
    }
    if (options.limit) {
        query = query.limit(options.limit);
    }
    const result = await query.find({ suppressAuth: true });
    return result.items;
}

async function insertData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.createRecord(tableName, data);
    }
    return await wixData.insert(wixCollectionName, data, { suppressAuth: true });
}

async function updateData(collectionKey, wixCollectionName, data) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.updateRecord(tableName, data._id || data.id, data);
    }
    return await wixData.update(wixCollectionName, data, { suppressAuth: true });
}

async function getRecord(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.getRecord(tableName, recordId);
    }
    return await wixData.get(wixCollectionName, recordId, { suppressAuth: true });
}

async function removeData(collectionKey, wixCollectionName, recordId) {
    if (usesAirtable(collectionKey)) {
        const tableName = getAirtableTableName(collectionKey);
        return await airtable.deleteRecord(tableName, recordId);
    }
    return await wixData.remove(wixCollectionName, recordId, { suppressAuth: true });
}

const CONFIG = {
    collections: {
        prompts: 'PromptLibrary',
        versions: 'PromptVersions',
        auditLog: 'AdminAuditLog'
    },
    // Prompt categories for organization
    categories: [
        { id: 'enrichment', name: 'Carrier Enrichment', description: 'Prompts for AI carrier analysis' },
        { id: 'research', name: 'Web Research', description: 'Prompts for web data gathering' },
        { id: 'social', name: 'Social Analysis', description: 'Prompts for social media scanning' },
        { id: 'ocr', name: 'Document OCR', description: 'Prompts for document extraction' },
        { id: 'chat', name: 'Chat/Support', description: 'Prompts for driver/admin chat' },
        { id: 'classification', name: 'Classification', description: 'Prompts for content classification' },
        { id: 'extraction', name: 'Data Extraction', description: 'Prompts for structured data extraction' },
        { id: 'other', name: 'Other', description: 'Miscellaneous prompts' }
    ],
    // Default prompts (seeded on first run)
    defaultPrompts: [
        {
            promptId: 'carrier_synthesis',
            name: 'Carrier Synthesis',
            category: 'enrichment',
            description: 'Main prompt for synthesizing carrier intelligence from multiple data sources',
            systemPrompt: `You are the Lead Data Analyst for LMDR (Last Mile Driver Recruiting).
Your job is to create concise, actionable intelligence summaries for CDL drivers evaluating carriers.
CORE RULES:
1. FMCSA safety data provided is VERIFIED TRUTH. Never contradict it.
2. Extract pay rates, sentiment, and job details from web research when available.
3. If "SOCIAL MEDIA INTEL" is provided, prioritize those unfiltered driver opinions for 'driver_sentiment' and 'pros/cons'.
4. Be concise - drivers want quick, scannable insights.
5. Always include a confidence score based on data quality.`,
            userPromptTemplate: `Analyze this carrier for a CDL driver:\n\nCarrier: {{carrierName}}\nDOT: {{dotNumber}}\nFleet Size: {{fleetSize}}\nLocation: {{location}}\n\nFMCSA Data:\n{{fmcsaData}}\n\nWeb Research:\n{{webResearch}}\n\nSocial Intel:\n{{socialIntel}}`,
            variables: ['carrierName', 'dotNumber', 'fleetSize', 'location', 'fmcsaData', 'webResearch', 'socialIntel'],
            provider: 'anthropic',
            model: 'claude-sonnet-4-20250514',
            isActive: true
        },
        {
            promptId: 'web_research',
            name: 'Web Research Query',
            category: 'research',
            description: 'Prompt for Perplexity to gather carrier job information',
            systemPrompt: 'You are a trucking industry researcher. Provide factual, concise information about carrier jobs. Include source citations as [1], [2] etc. Be brief - max 300 words.',
            userPromptTemplate: 'Research CDL driver jobs at "{{carrierName}}" ({{location}}). Find: current CPM pay range, any sign-on bonuses, typical home time, and 2-3 driver reviews or sentiment. Focus on 2024-2025 data only.',
            variables: ['carrierName', 'location'],
            provider: 'perplexity',
            model: 'sonar-pro',
            isActive: true
        },
        {
            promptId: 'social_scanner',
            name: 'Social Media Scanner',
            category: 'social',
            description: 'Prompt for analyzing driver chatter on social media',
            systemPrompt: 'You are a specialized Social Media Analyst. You summarize unstructured driver chatter into actionable intelligence. Be skeptical and blunt.',
            userPromptTemplate: 'Analyze recent driver discussions about {{carrierName}}:\n\n{{rawContent}}\n\nProvide: Overall sentiment (positive/negative/mixed), key complaints, key praises, and any red flags.',
            variables: ['carrierName', 'rawContent'],
            provider: 'perplexity',
            model: 'sonar-pro',
            isActive: true
        },
        {
            promptId: 'cdl_ocr',
            name: 'CDL Document OCR',
            category: 'ocr',
            description: 'Prompt for extracting data from CDL license images',
            systemPrompt: 'You are an expert document data extractor. Extract all visible text and structured data from the provided CDL (Commercial Driver License) image.',
            userPromptTemplate: 'Extract the following from this CDL image:\n- Full legal name\n- License number\n- State of issue\n- License class (A, B, C)\n- Endorsements (list all)\n- Restrictions (list all)\n- Issue date\n- Expiration date\n- Date of birth\n\nReturn as JSON. If a field is not visible, use null.',
            variables: [],
            provider: 'google',
            model: 'gemini-1.5-flash',
            isActive: true
        },
        {
            promptId: 'med_card_ocr',
            name: 'Medical Card OCR',
            category: 'ocr',
            description: 'Prompt for extracting data from DOT medical card images',
            systemPrompt: 'You are an expert document data extractor specializing in DOT medical certificates.',
            userPromptTemplate: 'Extract the following from this DOT Medical Examiner Certificate:\n- Driver name\n- Examiner name and credentials\n- Exam date\n- Expiration date\n- Medical certification status\n- Any restrictions or conditions\n- National Registry number\n\nReturn as JSON. If a field is not visible, use null.',
            variables: [],
            provider: 'google',
            model: 'gemini-1.5-flash',
            isActive: true
        }
    ]
};

// ============================================
// AUTHORIZATION
// ============================================

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;

        const role = member.contactDetails?.customFields?.role || '';
        return role.toLowerCase() === 'super_admin';
    } catch (error) {
        console.error('[PromptLibrary] Super admin check failed:', error);
        return false;
    }
}

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;

        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const role = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(role.toLowerCase());
    } catch (error) {
        console.error('[PromptLibrary] Admin check failed:', error);
        return false;
    }
}

async function requireSuperAdmin() {
    const authorized = await isSuperAdmin();
    if (!authorized) {
        throw new Error('Unauthorized: Super Admin access required');
    }
}

async function requireAdmin() {
    const authorized = await isAdmin();
    if (!authorized) {
        throw new Error('Unauthorized: Admin access required');
    }
}

async function getCurrentAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        return {
            id: member?._id || 'system',
            email: member?.loginEmail || 'system@lmdr.com'
        };
    } catch {
        return { id: 'system', email: 'system@lmdr.com' };
    }
}

// ============================================
// PROMPT CRUD OPERATIONS
// ============================================

/**
 * Get all prompts (Admin read access)
 * @param {Object} options - Filter options
 * @returns {Promise<Object>} - Prompts list with metadata
 */
export async function getPrompts(options = {}) {
    await requireAdmin();

    try {
        let resultItems = [];
        let totalCount = 0;

        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);

            // Build Airtable filter
            const filterParts = [];
            if (options.category) {
                filterParts.push(`{Category} = "${options.category}"`);
            }
            if (options.isActive !== undefined) {
                filterParts.push(`{Is Active} = ${options.isActive ? 'TRUE()' : 'FALSE()'}`);
            }
            if (options.search) {
                filterParts.push(`SEARCH("${options.search.toLowerCase()}", LOWER({Name}))`);
            }

            const filter = filterParts.length > 0 ? `AND(${filterParts.join(', ')})` : '';
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: filter,
                sort: [{ field: 'Category', direction: 'asc' }, { field: 'Name', direction: 'asc' }],
                maxRecords: 1000
            });

            resultItems = (result.records || []).map(r => ({
                _id: r.id || r._id,
                promptId: r['Prompt Id'] || r.promptId,
                name: r.Name || r.name,
                category: r.Category || r.category,
                description: r.Description || r.description,
                systemPrompt: r['System Prompt'] || r.systemPrompt,
                userPromptTemplate: r['User Prompt Template'] || r.userPromptTemplate,
                variables: r.Variables || r.variables,
                provider: r.Provider || r.provider,
                model: r.Model || r.model,
                isActive: r['Is Active'] !== undefined ? r['Is Active'] : r.isActive,
                version: r.Version || r.version,
                createdAt: r['Created At'] || r.createdAt,
                updatedAt: r['Updated At'] || r.updatedAt
            }));
            totalCount = resultItems.length;
        } else {
            // Wix Data path
            let query = wixData.query(CONFIG.collections.prompts);

            if (options.category) {
                query = query.eq('category', options.category);
            }

            if (options.isActive !== undefined) {
                query = query.eq('isActive', options.isActive);
            }

            if (options.search) {
                query = query.contains('name', options.search);
            }

            const result = await query
                .ascending('category')
                .ascending('name')
                .find({ suppressAuth: true });

            resultItems = result.items;
            totalCount = result.totalCount;
        }

        return {
            items: resultItems,
            totalCount,
            categories: CONFIG.categories
        };

    } catch (error) {
        console.error('[PromptLibrary] Error fetching prompts:', error);
        throw new Error('Failed to fetch prompts');
    }
}

/**
 * Get a single prompt by ID (Admin read access)
 * @param {string} promptId - Prompt ID
 * @returns {Promise<Object>} - Prompt with version history
 */
export async function getPrompt(promptId) {
    await requireAdmin();

    try {
        let promptData = null;
        let versionItems = [];

        // Dual-source routing for prompts
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Prompt Id} = "${promptId}"`,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                promptData = {
                    _id: r.id || r._id,
                    promptId: r['Prompt Id'] || r.promptId,
                    name: r.Name || r.name,
                    category: r.Category || r.category,
                    description: r.Description || r.description,
                    systemPrompt: r['System Prompt'] || r.systemPrompt,
                    userPromptTemplate: r['User Prompt Template'] || r.userPromptTemplate,
                    variables: r.Variables || r.variables,
                    provider: r.Provider || r.provider,
                    model: r.Model || r.model,
                    isActive: r['Is Active'] !== undefined ? r['Is Active'] : r.isActive,
                    version: r.Version || r.version,
                    createdAt: r['Created At'] || r.createdAt,
                    updatedAt: r['Updated At'] || r.updatedAt
                };
            }
        } else {
            const result = await wixData.query(CONFIG.collections.prompts)
                .eq('promptId', promptId)
                .find({ suppressAuth: true });
            if (result.items.length > 0) {
                promptData = result.items[0];
            }
        }

        if (!promptData) {
            throw new Error('Prompt not found');
        }

        // Dual-source routing for versions
        if (usesAirtable(COLLECTION_KEYS.versions)) {
            const versionsTable = getAirtableTableName(COLLECTION_KEYS.versions);
            const versionsResult = await airtable.queryRecords(versionsTable, {
                filterByFormula: `{Prompt Id} = "${promptId}"`,
                sort: [{ field: 'Version', direction: 'desc' }],
                maxRecords: 10
            });
            versionItems = (versionsResult.records || []).map(v => ({
                _id: v.id || v._id,
                promptId: v['Prompt Id'] || v.promptId,
                version: v.Version || v.version,
                systemPrompt: v['System Prompt'] || v.systemPrompt,
                userPromptTemplate: v['User Prompt Template'] || v.userPromptTemplate,
                changeNote: v['Change Note'] || v.changeNote,
                createdAt: v['Created At'] || v.createdAt,
                createdBy: v['Created By'] || v.createdBy
            }));
        } else {
            const versions = await wixData.query(CONFIG.collections.versions)
                .eq('promptId', promptId)
                .descending('version')
                .limit(10)
                .find({ suppressAuth: true });
            versionItems = versions.items;
        }

        return {
            prompt: promptData,
            versions: versionItems
        };

    } catch (error) {
        console.error('[PromptLibrary] Error fetching prompt:', error);
        throw new Error('Failed to fetch prompt');
    }
}

/**
 * Create a new prompt (Super Admin only)
 * @param {Object} promptData - Prompt data
 * @returns {Promise<Object>} - Created prompt
 */
export async function createPrompt(promptData) {
    await requireSuperAdmin();

    try {
        const admin = await getCurrentAdmin();

        // Validate required fields
        if (!promptData.promptId || !promptData.name || !promptData.systemPrompt) {
            throw new Error('Missing required fields: promptId, name, systemPrompt');
        }

        // Check for duplicate promptId using dual-source routing
        let existingCount = 0;
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const existingResult = await airtable.queryRecords(tableName, {
                filterByFormula: `{Prompt Id} = "${promptData.promptId}"`,
                maxRecords: 1
            });
            existingCount = (existingResult.records || []).length;
        } else {
            const existing = await wixData.query(CONFIG.collections.prompts)
                .eq('promptId', promptData.promptId)
                .find({ suppressAuth: true });
            existingCount = existing.items.length;
        }

        if (existingCount > 0) {
            throw new Error('Prompt ID already exists');
        }

        const newPrompt = {
            promptId: promptData.promptId,
            name: promptData.name,
            category: promptData.category || 'other',
            description: promptData.description || '',
            systemPrompt: promptData.systemPrompt,
            userPromptTemplate: promptData.userPromptTemplate || '',
            variables: promptData.variables || [],
            provider: promptData.provider || 'anthropic',
            model: promptData.model || 'claude-sonnet-4-20250514',
            isActive: promptData.isActive !== false,
            version: 1,
            createdAt: new Date(),
            createdBy: admin.email,
            updatedAt: new Date(),
            updatedBy: admin.email
        };

        // Use dual-source routing for insert
        const created = await insertData(COLLECTION_KEYS.prompts, CONFIG.collections.prompts, newPrompt);
        const createdId = created._id || created.id;
        const createdPromptId = created.promptId || created['Prompt Id'] || newPrompt.promptId;

        // Create initial version
        await createVersion(createdPromptId, { ...newPrompt, version: 1 }, admin.email, 'Initial creation');

        // Log action
        await logAction('createPrompt', 'prompt', createdId, {
            promptId: createdPromptId,
            name: newPrompt.name
        }, admin);

        return created;

    } catch (error) {
        console.error('[PromptLibrary] Error creating prompt:', error);
        throw new Error(error.message || 'Failed to create prompt');
    }
}

/**
 * Update an existing prompt (Super Admin only)
 * @param {string} promptId - Prompt ID
 * @param {Object} updates - Fields to update
 * @param {string} changeNote - Note describing the change
 * @returns {Promise<Object>} - Updated prompt
 */
export async function updatePrompt(promptId, updates, changeNote = '') {
    await requireSuperAdmin();

    try {
        const admin = await getCurrentAdmin();

        // Get existing prompt using dual-source routing
        let prompt = null;
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Prompt Id} = "${promptId}"`,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                prompt = {
                    _id: r.id || r._id,
                    promptId: r['Prompt Id'] || r.promptId,
                    name: r.Name || r.name,
                    category: r.Category || r.category,
                    description: r.Description || r.description,
                    systemPrompt: r['System Prompt'] || r.systemPrompt,
                    userPromptTemplate: r['User Prompt Template'] || r.userPromptTemplate,
                    variables: r.Variables || r.variables,
                    provider: r.Provider || r.provider,
                    model: r.Model || r.model,
                    isActive: r['Is Active'] !== undefined ? r['Is Active'] : r.isActive,
                    version: r.Version || r.version || 0
                };
            }
        } else {
            const existing = await wixData.query(CONFIG.collections.prompts)
                .eq('promptId', promptId)
                .find({ suppressAuth: true });
            if (existing.items.length > 0) {
                prompt = existing.items[0];
            }
        }

        if (!prompt) {
            throw new Error('Prompt not found');
        }

        // Apply updates
        const updatedPrompt = {
            ...prompt,
            name: updates.name || prompt.name,
            category: updates.category || prompt.category,
            description: updates.description !== undefined ? updates.description : prompt.description,
            systemPrompt: updates.systemPrompt || prompt.systemPrompt,
            userPromptTemplate: updates.userPromptTemplate !== undefined ? updates.userPromptTemplate : prompt.userPromptTemplate,
            variables: updates.variables || prompt.variables,
            provider: updates.provider || prompt.provider,
            model: updates.model || prompt.model,
            isActive: updates.isActive !== undefined ? updates.isActive : prompt.isActive,
            version: (prompt.version || 0) + 1,
            updatedAt: new Date(),
            updatedBy: admin.email
        };

        // Use dual-source routing for update
        const updated = await updateData(COLLECTION_KEYS.prompts, CONFIG.collections.prompts, updatedPrompt);

        // Create version snapshot
        await createVersion(promptId, updatedPrompt, admin.email, changeNote);

        // Log action
        await logAction('updatePrompt', 'prompt', prompt._id, {
            promptId: promptId,
            name: updatedPrompt.name,
            version: updatedPrompt.version,
            changeNote
        }, admin);

        return updated;

    } catch (error) {
        console.error('[PromptLibrary] Error updating prompt:', error);
        throw new Error(error.message || 'Failed to update prompt');
    }
}

/**
 * Delete a prompt (Super Admin only)
 * @param {string} promptId - Prompt ID
 * @returns {Promise<Object>} - Deletion result
 */
export async function deletePrompt(promptId) {
    await requireSuperAdmin();

    try {
        const admin = await getCurrentAdmin();

        // Get existing prompt using dual-source routing
        let prompt = null;
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Prompt Id} = "${promptId}"`,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                prompt = {
                    _id: r.id || r._id,
                    promptId: r['Prompt Id'] || r.promptId,
                    name: r.Name || r.name
                };
            }
        } else {
            const existing = await wixData.query(CONFIG.collections.prompts)
                .eq('promptId', promptId)
                .find({ suppressAuth: true });
            if (existing.items.length > 0) {
                prompt = existing.items[0];
            }
        }

        if (!prompt) {
            throw new Error('Prompt not found');
        }

        // Soft delete - mark as inactive instead of removing
        const softDeleteUpdate = {
            _id: prompt._id,
            isActive: false,
            deletedAt: new Date(),
            deletedBy: admin.email
        };

        await updateData(COLLECTION_KEYS.prompts, CONFIG.collections.prompts, softDeleteUpdate);

        // Log action
        await logAction('deletePrompt', 'prompt', prompt._id, {
            promptId: prompt.promptId || promptId,
            name: prompt.name
        }, admin);

        return { success: true, message: 'Prompt deactivated' };

    } catch (error) {
        console.error('[PromptLibrary] Error deleting prompt:', error);
        throw new Error('Failed to delete prompt');
    }
}

/**
 * Restore a deleted prompt (Super Admin only)
 * @param {string} promptId - Prompt ID
 * @returns {Promise<Object>} - Restored prompt
 */
export async function restorePrompt(promptId) {
    await requireSuperAdmin();

    try {
        const admin = await getCurrentAdmin();

        // Get existing prompt using dual-source routing
        let prompt = null;
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Prompt Id} = "${promptId}"`,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                prompt = {
                    _id: r.id || r._id,
                    promptId: r['Prompt Id'] || r.promptId,
                    name: r.Name || r.name
                };
            }
        } else {
            const existing = await wixData.query(CONFIG.collections.prompts)
                .eq('promptId', promptId)
                .find({ suppressAuth: true });
            if (existing.items.length > 0) {
                prompt = existing.items[0];
            }
        }

        if (!prompt) {
            throw new Error('Prompt not found');
        }

        // Restore prompt
        const restoreUpdate = {
            _id: prompt._id,
            isActive: true,
            deletedAt: null,
            deletedBy: null,
            updatedAt: new Date(),
            updatedBy: admin.email
        };

        const restored = await updateData(COLLECTION_KEYS.prompts, CONFIG.collections.prompts, restoreUpdate);

        await logAction('restorePrompt', 'prompt', prompt._id, {
            promptId: prompt.promptId || promptId,
            name: prompt.name
        }, admin);

        return restored;

    } catch (error) {
        console.error('[PromptLibrary] Error restoring prompt:', error);
        throw new Error('Failed to restore prompt');
    }
}

// ============================================
// VERSION MANAGEMENT
// ============================================

async function createVersion(promptId, promptData, author, changeNote) {
    const version = {
        promptId,
        version: promptData.version,
        systemPrompt: promptData.systemPrompt,
        userPromptTemplate: promptData.userPromptTemplate,
        variables: promptData.variables,
        provider: promptData.provider,
        model: promptData.model,
        changeNote: changeNote || '',
        createdAt: new Date(),
        createdBy: author
    };

    // Use dual-source routing
    await insertData(COLLECTION_KEYS.versions, CONFIG.collections.versions, version);
}

/**
 * Rollback to a specific version (Super Admin only)
 * @param {string} promptId - Prompt ID
 * @param {number} targetVersion - Version to rollback to
 * @returns {Promise<Object>} - Rolled back prompt
 */
export async function rollbackPrompt(promptId, targetVersion) {
    await requireSuperAdmin();

    try {
        const admin = await getCurrentAdmin();

        // Get the target version using dual-source routing
        let targetVersionData = null;
        if (usesAirtable(COLLECTION_KEYS.versions)) {
            const versionsTable = getAirtableTableName(COLLECTION_KEYS.versions);
            const versionsResult = await airtable.queryRecords(versionsTable, {
                filterByFormula: `AND({Prompt Id} = "${promptId}", {Version} = ${targetVersion})`,
                maxRecords: 1
            });
            if (versionsResult.records && versionsResult.records.length > 0) {
                const v = versionsResult.records[0];
                targetVersionData = {
                    systemPrompt: v['System Prompt'] || v.systemPrompt,
                    userPromptTemplate: v['User Prompt Template'] || v.userPromptTemplate,
                    variables: v.Variables || v.variables,
                    provider: v.Provider || v.provider,
                    model: v.Model || v.model
                };
            }
        } else {
            const versions = await wixData.query(CONFIG.collections.versions)
                .eq('promptId', promptId)
                .eq('version', targetVersion)
                .find({ suppressAuth: true });
            if (versions.items.length > 0) {
                targetVersionData = versions.items[0];
            }
        }

        if (!targetVersionData) {
            throw new Error('Version not found');
        }

        // Get current prompt using dual-source routing
        let prompt = null;
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `{Prompt Id} = "${promptId}"`,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                prompt = {
                    _id: r.id || r._id,
                    promptId: r['Prompt Id'] || r.promptId,
                    name: r.Name || r.name,
                    category: r.Category || r.category,
                    description: r.Description || r.description,
                    isActive: r['Is Active'] !== undefined ? r['Is Active'] : r.isActive,
                    version: r.Version || r.version || 0
                };
            }
        } else {
            const existing = await wixData.query(CONFIG.collections.prompts)
                .eq('promptId', promptId)
                .find({ suppressAuth: true });
            if (existing.items.length > 0) {
                prompt = existing.items[0];
            }
        }

        if (!prompt) {
            throw new Error('Prompt not found');
        }

        // Apply rollback
        const rolledBack = {
            ...prompt,
            systemPrompt: targetVersionData.systemPrompt,
            userPromptTemplate: targetVersionData.userPromptTemplate,
            variables: targetVersionData.variables,
            provider: targetVersionData.provider,
            model: targetVersionData.model,
            version: (prompt.version || 0) + 1,
            updatedAt: new Date(),
            updatedBy: admin.email
        };

        const updated = await updateData(COLLECTION_KEYS.prompts, CONFIG.collections.prompts, rolledBack);

        // Create version snapshot for rollback
        await createVersion(promptId, rolledBack, admin.email, `Rolled back to version ${targetVersion}`);

        await logAction('rollbackPrompt', 'prompt', prompt._id, {
            promptId: prompt.promptId || promptId,
            fromVersion: prompt.version,
            toVersion: targetVersion
        }, admin);

        return updated;

    } catch (error) {
        console.error('[PromptLibrary] Error rolling back prompt:', error);
        throw new Error('Failed to rollback prompt');
    }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Get prompt for use in AI services (internal)
 * Called by AI services to fetch active prompts
 * @param {string} promptId - Prompt ID
 * @returns {Promise<Object|null>} - Active prompt or null
 */
export async function getActivePrompt(promptId) {
    try {
        // Dual-source routing
        if (usesAirtable(COLLECTION_KEYS.prompts)) {
            const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
            const result = await airtable.queryRecords(tableName, {
                filterByFormula: `AND({Prompt Id} = "${promptId}", {Is Active} = TRUE())`,
                maxRecords: 1
            });
            if (result.records && result.records.length > 0) {
                const r = result.records[0];
                return {
                    _id: r.id || r._id,
                    promptId: r['Prompt Id'] || r.promptId,
                    name: r.Name || r.name,
                    category: r.Category || r.category,
                    description: r.Description || r.description,
                    systemPrompt: r['System Prompt'] || r.systemPrompt,
                    userPromptTemplate: r['User Prompt Template'] || r.userPromptTemplate,
                    variables: r.Variables || r.variables,
                    provider: r.Provider || r.provider,
                    model: r.Model || r.model,
                    isActive: true,
                    version: r.Version || r.version
                };
            }
            return null;
        }

        // Wix Data path
        const result = await wixData.query(CONFIG.collections.prompts)
            .eq('promptId', promptId)
            .eq('isActive', true)
            .find({ suppressAuth: true });

        return result.items.length > 0 ? result.items[0] : null;

    } catch (error) {
        console.error('[PromptLibrary] Error fetching active prompt:', error);
        return null;
    }
}

/**
 * Render a prompt template with variables
 * @param {string} template - Template string with {{variable}} placeholders
 * @param {Object} variables - Key-value pairs for substitution
 * @returns {string} - Rendered prompt
 */
export function renderPrompt(template, variables = {}) {
    let rendered = template;

    for (const [key, value] of Object.entries(variables)) {
        const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        rendered = rendered.replace(placeholder, value || '');
    }

    return rendered;
}

/**
 * Get categories list
 * @returns {Promise<Array>} - Categories
 */
export async function getCategories() {
    await requireAdmin();
    return CONFIG.categories;
}

/**
 * Seed default prompts (run once)
 * @returns {Promise<Object>} - Seed result
 */
export async function seedDefaultPrompts() {
    await requireSuperAdmin();

    try {
        const admin = await getCurrentAdmin();
        let created = 0;
        let skipped = 0;

        for (const promptData of CONFIG.defaultPrompts) {
            // Check for existing prompt using dual-source routing
            let existingCount = 0;
            if (usesAirtable(COLLECTION_KEYS.prompts)) {
                const tableName = getAirtableTableName(COLLECTION_KEYS.prompts);
                const result = await airtable.queryRecords(tableName, {
                    filterByFormula: `{Prompt Id} = "${promptData.promptId}"`,
                    maxRecords: 1
                });
                existingCount = (result.records || []).length;
            } else {
                const existing = await wixData.query(CONFIG.collections.prompts)
                    .eq('promptId', promptData.promptId)
                    .find({ suppressAuth: true });
                existingCount = existing.items.length;
            }

            if (existingCount === 0) {
                const newPrompt = {
                    ...promptData,
                    version: 1,
                    createdAt: new Date(),
                    createdBy: admin.email,
                    updatedAt: new Date(),
                    updatedBy: admin.email
                };

                // Use dual-source routing for insert
                await insertData(COLLECTION_KEYS.prompts, CONFIG.collections.prompts, newPrompt);
                created++;
            } else {
                skipped++;
            }
        }

        return {
            success: true,
            created,
            skipped,
            total: CONFIG.defaultPrompts.length
        };

    } catch (error) {
        console.error('[PromptLibrary] Error seeding prompts:', error);
        throw new Error('Failed to seed default prompts');
    }
}

// ============================================
// AUDIT LOGGING
// ============================================

async function logAction(action, targetType, targetId, details, admin) {
    try {
        const auditRecord = {
            action,
            targetType,
            targetId,
            details,
            adminId: admin.id,
            adminEmail: admin.email,
            timestamp: new Date()
        };

        // Use dual-source routing
        await insertData(COLLECTION_KEYS.auditLog, CONFIG.collections.auditLog, auditRecord);
    } catch (error) {
        console.error('[PromptLibrary] Failed to log action:', error);
    }
}

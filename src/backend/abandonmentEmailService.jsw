import { triggeredEmails, contacts } from 'wix-crm-backend';
import wixData from 'wix-data';
import * as dataAccess from 'backend/dataAccess';
import { chunkArray } from 'backend/utils/arrayUtils';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    checkoutAbandonment: 'checkoutAbandonment',
    abandonmentEmailLog: 'abandonmentEmailLog'
};

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  // Email timing (in hours from abandonment)
  emailTiming: { email1: 2, email2: 72, email3: 168 },

  // Wix Triggered Email Template IDs
  emailTemplates: {
    abandonment1: 'checkoutAbandonment1',
    abandonment2: 'checkoutAbandonment2',
    abandonment3: 'checkoutAbandonment3'
  },

  planInfo: {
    pro: { price: '$249/month', displayName: 'Pro Plan' },
    enterprise: { price: '$749/month', displayName: 'Enterprise Plan' }
  }
};

// ============================================================================
// TRACK ABANDONED CHECKOUT (Called from Stripe Webhook)
// ============================================================================

export async function trackAbandonedCheckout(session) {
  try {
    const email = session.customer_email;
    if (!email) return { success: false, error: 'No email' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, {
      filters: { email, recovered: false },
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 1, suppressAuth: true
    });

    if (result.items?.length) {
      const existing = result.items[0];
      const hoursSince = (Date.now() - new Date(existing._createdDate)) / 3600000;
      if (hoursSince < 24) {
        const updated = await dataAccess.updateRecord(COLLECTION_KEYS.checkoutAbandonment, { ...existing, stripeSessionId: session.id, abandonedAt: new Date() }, { suppressAuth: true });
        return { success: true, abandonmentId: updated.record._id, updated: true };
      }
    }

    const abandonmentRecord = { email, carrierDot: session.metadata?.carrier_dot || '', planType: determinePlanType(session), stripeSessionId: session.id, abandonedAt: new Date(), email1Sent: false, email2Sent: false, email3Sent: false, recovered: false };
    const res = await dataAccess.insertRecord(COLLECTION_KEYS.checkoutAbandonment, abandonmentRecord, { suppressAuth: true });
    await findOrCreateContact(email, session.metadata?.contact_name || '');
    return { success: true, abandonmentId: res.record._id };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function markCheckoutRecovered(email, sessionId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, { filters: { email, recovered: false }, limit: 1, suppressAuth: true });
    if (!result.items?.length) return { success: true, wasAbandoned: false };
    await dataAccess.updateRecord(COLLECTION_KEYS.checkoutAbandonment, { ...result.items[0], recovered: true, recoveredAt: new Date(), recoverySessionId: sessionId }, { suppressAuth: true });
    return { success: true, wasAbandoned: true };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function processAbandonmentEmails() {
  try {
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, { filters: { recovered: false, email3Sent: false }, limit: 100, suppressAuth: true });
    if (!res.items?.length) return { success: true, count: 0 };
    const chunks = chunkArray(res.items, 5);
    for (const chunk of chunks) {
      await Promise.all(chunk.map(processAbandonmentRecord));
      await new Promise(r => setTimeout(r, 500));
    }
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

async function processAbandonmentRecord(abandonment) {
  const hoursSince = (Date.now() - new Date(abandonment.abandonedAt)) / 3600000;
  let emailToSend = null;
  if (!abandonment.email1Sent && hoursSince >= CONFIG.emailTiming.email1) emailToSend = 1;
  else if (!abandonment.email2Sent && abandonment.email1Sent && hoursSince >= CONFIG.emailTiming.email2) emailToSend = 2;
  else if (!abandonment.email3Sent && abandonment.email2Sent && hoursSince >= CONFIG.emailTiming.email3) emailToSend = 3;

  if (emailToSend) {
    const data = { email: abandonment.email, firstName: abandonment.contactName?.split(' ')[0], planType: abandonment.planType };
    let res = emailToSend === 1 ? await sendAbandonmentEmail1(data) : (emailToSend === 2 ? await sendAbandonmentEmail2(data) : await sendAbandonmentEmail3(data));
    if (res.success) await markEmailSent(abandonment._id, emailToSend);
  }
}

async function findOrCreateContact(email, firstName) {
  const res = await contacts.queryContacts().eq('primaryInfo.email', email).limit(1).find({ suppressAuth: true });
  if (res.items.length) return res.items[0]._id;
  const contact = await contacts.createContact({ name: { first: firstName || 'Recruiter' }, emails: [{ email, primary: true }] }, { suppressAuth: true });
  return contact._id;
}

export async function markEmailSent(recordId, num) {
  const record = await dataAccess.getRecord(COLLECTION_KEYS.checkoutAbandonment, recordId, { suppressAuth: true });
  if (record) await dataAccess.updateRecord(COLLECTION_KEYS.checkoutAbandonment, { ...record, [`email${num}Sent`]: true, [`email${num}SentAt`]: new Date() }, { suppressAuth: true });
}

async function logEmailSend(abandonmentId, templateId, recipientEmail) {
  await dataAccess.insertRecord(COLLECTION_KEYS.abandonmentEmailLog, { abandonmentId, templateId, recipientEmail, sentAt: new Date(), emailType: 'checkout_abandonment' }, { suppressAuth: true });
}

function determinePlanType(session) {
  if (session.metadata?.plan_type) return session.metadata.plan_type;
  for (const item of (session.line_items?.data || [])) {
    if (item.price?.id?.toLowerCase().includes('enterprise')) return 'enterprise';
  }
  return 'pro';
}

function getPlanDisplayName(type) { return CONFIG.planInfo[type]?.displayName || 'Pro Plan'; }

export async function getAbandonmentStats() {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  const res = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, { filters: { abandonedAt: { gte: thirtyDaysAgo } }, limit: 1000, suppressAuth: true });
  const items = res.items || [];
  const recovered = items.filter(i => i.recovered).length;
  return { success: true, stats: { total: items.length, recovered, recoveryRate: items.length > 0 ? (recovered / items.length * 100).toFixed(1) : 0 } };
}

export async function getRecentAbandonments(limit = 50) {
  const res = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, { sort: [{ field: 'abandonedAt', direction: 'desc' }], limit, suppressAuth: true });
  return { success: true, abandonments: res.items || [] };
}

import { triggeredEmails, contacts } from 'wix-crm-backend';
import * as dataAccess from 'backend/dataAccess';
import { chunkArray } from 'backend/utils/arrayUtils';

// Collection keys for dataAccess routing
const COLLECTION_KEYS = {
    checkoutAbandonment: 'checkoutAbandonment',
    abandonmentEmailLog: 'abandonmentEmailLog'
};

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  // Email timing (in hours from abandonment)
  emailTiming: { email1: 2, email2: 72, email3: 168 },

  // Wix Triggered Email Template IDs
  emailTemplates: {
    abandonment1: 'checkoutAbandonment1',
    abandonment2: 'checkoutAbandonment2',
    abandonment3: 'checkoutAbandonment3'
  },

  planInfo: {
    pro: { price: '$249/month', displayName: 'Pro Plan' },
    enterprise: { price: '$749/month', displayName: 'Enterprise Plan' }
  }
};

// ============================================================================
// FIELD HELPERS
// Airtable table uses Single Select 'Yes'/'No' for boolean-like fields.
// Date fields require YYYY-MM-DD format (never full ISO datetime strings).
// snake_case keys match the FIELD_MAPPINGS in airtableClient.jsw.
// ============================================================================

const toDate = (d) => (d instanceof Date ? d : new Date(d)).toISOString().slice(0, 10);
const isSent = (val) => val === 'Yes';
const sentVal = (bool) => bool ? 'Yes' : 'No';

// ============================================================================
// TRACK ABANDONED CHECKOUT (Called from Stripe Webhook)
// ============================================================================

export async function trackAbandonedCheckout(session) {
  try {
    const email = session.customer_email;
    if (!email) return { success: false, error: 'No email' };

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, {
      filters: { email, recovered: 'No' },
      sort: [{ field: '_createdDate', direction: 'desc' }],
      limit: 1, suppressAuth: true
    });

    if (result.items?.length) {
      const existing = result.items[0];
      const hoursSince = (Date.now() - new Date(existing._createdDate)) / 3600000;
      if (hoursSince < 24) {
        const updated = await dataAccess.updateRecord(COLLECTION_KEYS.checkoutAbandonment, {
          ...existing,
          stripe_session_id: session.id,
          abandoned_date: toDate(new Date())
        }, { suppressAuth: true });
        return { success: true, abandonmentId: updated.record._id, updated: true };
      }
    }

    const abandonmentRecord = {
      email,
      carrier_dot: session.metadata?.carrier_dot ? Number(session.metadata.carrier_dot) : null,
      plan: capitalizePlan(determinePlanType(session)),
      stripe_session_id: session.id,
      abandoned_date: toDate(new Date()),
      email_1_sent: 'No',
      email_2_sent: 'No',
      email_3_sent: 'No',
      recovered: 'No',
      contact_name: session.metadata?.contact_name || ''
    };
    const res = await dataAccess.insertRecord(COLLECTION_KEYS.checkoutAbandonment, abandonmentRecord, { suppressAuth: true });
    await findOrCreateContact(email, session.metadata?.contact_name || '');
    return { success: true, abandonmentId: res.record._id };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function markCheckoutRecovered(email, sessionId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, {
      filters: { email, recovered: 'No' },
      limit: 1, suppressAuth: true
    });
    if (!result.items?.length) return { success: true, wasAbandoned: false };
    await dataAccess.updateRecord(COLLECTION_KEYS.checkoutAbandonment, {
      ...result.items[0],
      recovered: 'Yes',
      recovered_at: toDate(new Date()),
      recovery_session_id: sessionId
    }, { suppressAuth: true });
    return { success: true, wasAbandoned: true };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// EMAIL SENDING FUNCTIONS
// ============================================================================

/**
 * Sends the first abandonment email (Immediate/2hr)
 */
export async function sendAbandonmentEmail1(data) {
    try {
        const contactId = await findOrCreateContact(data.email, data.firstName);
        await triggeredEmails.emailContact(CONFIG.emailTemplates.abandonment1, contactId, {
            variables: {
                firstName: data.firstName || 'there',
                planName: getPlanDisplayName(data.planType),
                checkoutUrl: 'https://www.lastmiledr.app/pricing'
            }
        });
        await logEmailSend(null, CONFIG.emailTemplates.abandonment1, data.email);
        return { success: true };
    } catch (error) {
        console.error('Error sending abandonment email 1:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Sends the second abandonment email (3 days)
 */
export async function sendAbandonmentEmail2(data) {
    try {
        const contactId = await findOrCreateContact(data.email, data.firstName);
        await triggeredEmails.emailContact(CONFIG.emailTemplates.abandonment2, contactId, {
            variables: {
                firstName: data.firstName || 'there',
                planName: getPlanDisplayName(data.planType)
            }
        });
        await logEmailSend(null, CONFIG.emailTemplates.abandonment2, data.email);
        return { success: true };
    } catch (error) {
        console.error('Error sending abandonment email 2:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Sends the third abandonment email (7 days)
 */
export async function sendAbandonmentEmail3(data) {
    try {
        const contactId = await findOrCreateContact(data.email, data.firstName);
        await triggeredEmails.emailContact(CONFIG.emailTemplates.abandonment3, contactId, {
            variables: {
                firstName: data.firstName || 'there',
                planName: getPlanDisplayName(data.planType)
            }
        });
        await logEmailSend(null, CONFIG.emailTemplates.abandonment3, data.email);
        return { success: true };
    } catch (error) {
        console.error('Error sending abandonment email 3:', error);
        return { success: false, error: error.message };
    }
}

export async function processAbandonmentEmails() {
  try {
    // Fetch all unrecovered records that haven't had email 3 sent yet
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, {
      filters: { recovered: 'No', email_3_sent: 'No' },
      limit: 100, suppressAuth: true
    });
    if (!res.items?.length) return { success: true, count: 0 };
    const chunks = chunkArray(res.items, 5);
    for (const chunk of chunks) {
      await Promise.all(chunk.map(processAbandonmentRecord));
      await new Promise(r => setTimeout(r, 500));
    }
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

async function processAbandonmentRecord(abandonment) {
  // abandoned_date is YYYY-MM-DD string from Airtable â€” parse to ms
  const abandonedMs = abandonment.abandoned_date
    ? new Date(abandonment.abandoned_date).getTime()
    : (abandonment._createdDate ? new Date(abandonment._createdDate).getTime() : 0);
  const hoursSince = (Date.now() - abandonedMs) / 3600000;

  let emailToSend = null;
  if (!isSent(abandonment.email_1_sent) && hoursSince >= CONFIG.emailTiming.email1) {
    emailToSend = 1;
  } else if (!isSent(abandonment.email_2_sent) && isSent(abandonment.email_1_sent) && hoursSince >= CONFIG.emailTiming.email2) {
    emailToSend = 2;
  } else if (!isSent(abandonment.email_3_sent) && isSent(abandonment.email_2_sent) && hoursSince >= CONFIG.emailTiming.email3) {
    emailToSend = 3;
  }

  if (emailToSend) {
    const data = {
      email: abandonment.email,
      firstName: abandonment.contact_name?.split(' ')[0],
      planType: (abandonment.plan || 'pro').toLowerCase()
    };
    const res = emailToSend === 1
      ? await sendAbandonmentEmail1(data)
      : (emailToSend === 2 ? await sendAbandonmentEmail2(data) : await sendAbandonmentEmail3(data));
    if (res.success) await markEmailSent(abandonment._id, emailToSend);
  }
}

async function findOrCreateContact(email, firstName) {
  const res = await contacts.queryContacts().eq('primaryInfo.email', email).limit(1).find({ suppressAuth: true });
  if (res.items.length) return res.items[0]._id;
  const contact = await contacts.createContact(
    { name: { first: firstName || 'Recruiter' }, emails: [{ email, primary: true }] },
    { suppressAuth: true }
  );
  return contact._id;
}

export async function markEmailSent(recordId, num) {
  const record = await dataAccess.getRecord(COLLECTION_KEYS.checkoutAbandonment, recordId, { suppressAuth: true });
  if (record) {
    await dataAccess.updateRecord(COLLECTION_KEYS.checkoutAbandonment, {
      ...record,
      [`email_${num}_sent`]: 'Yes',
      [`email_${num}_sent_at`]: toDate(new Date())
    }, { suppressAuth: true });
  }
}

async function logEmailSend(abandonmentId, templateId, recipientEmail) {
  await dataAccess.insertRecord(COLLECTION_KEYS.abandonmentEmailLog, {
    abandonment_id: abandonmentId,
    template_id: templateId,
    recipient_email: recipientEmail,
    sent_at: toDate(new Date()),
    email_type: 'checkout_abandonment'
  }, { suppressAuth: true });
}

function determinePlanType(session) {
  if (session.metadata?.plan_type) return session.metadata.plan_type;
  for (const item of (session.line_items?.data || [])) {
    if (item.price?.id?.toLowerCase().includes('enterprise')) return 'enterprise';
  }
  return 'pro';
}

function capitalizePlan(type) {
  // Airtable Single Select options are 'Pro' and 'Enterprise'
  return type === 'enterprise' ? 'Enterprise' : 'Pro';
}

function getPlanDisplayName(type) { return CONFIG.planInfo[type]?.displayName || 'Pro Plan'; }

export async function getAbandonmentStats() {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  const res = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, {
    filters: { abandoned_date: { gte: toDate(thirtyDaysAgo) } },
    limit: 1000, suppressAuth: true
  });
  const items = res.items || [];
  const recovered = items.filter(i => i.recovered === 'Yes').length;
  return {
    success: true,
    stats: {
      total: items.length,
      recovered,
      recoveryRate: items.length > 0 ? (recovered / items.length * 100).toFixed(1) : 0
    }
  };
}

export async function getRecentAbandonments(limit = 50) {
  const res = await dataAccess.queryRecords(COLLECTION_KEYS.checkoutAbandonment, {
    sort: [{ field: 'abandoned_date', direction: 'desc' }],
    limit, suppressAuth: true
  });
  return { success: true, abandonments: res.items || [] };
}

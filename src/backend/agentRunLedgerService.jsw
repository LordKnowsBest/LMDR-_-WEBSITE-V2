// ============================================================================
// AGENT RUN LEDGER SERVICE — Immutable event log for agent orchestration
// Tracks runs, steps, approval gates, and enables outcome evaluation
// ============================================================================

import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  runs: 'agentRuns',
  steps: 'agentSteps',
  gates: 'approvalGates',
  outcomes: 'runOutcomes'
};

function generateId(prefix) {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function normalizeRunMetadata(metadata = {}) {
  return {
    plan_id: metadata.plan_id || '',
    execution_model: metadata.execution_model || 'sequential',
    planned_nodes: Number(metadata.planned_nodes || 0),
    parallel_nodes: Number(metadata.parallel_nodes || 0),
  };
}

function normalizeStepMetadata(metadata = {}) {
  return {
    execution_mode: metadata.execution_mode || '',
    side_effect_class: metadata.side_effect_class || '',
    node_id: metadata.node_id || '',
    branch_id: metadata.branch_id || '',
    join_key: metadata.join_key || '',
    timeout_ms: Number(metadata.timeout_ms || 0),
  };
}

function normalizeGateMetadata(metadata = {}) {
  return {
    node_id: metadata.node_id || '',
    branch_id: metadata.branch_id || '',
    execution_mode: metadata.execution_mode || '',
  };
}

function toTimestamp(value) {
  const ts = value ? new Date(value).getTime() : NaN;
  return Number.isFinite(ts) ? ts : 0;
}

function buildExecutionBreakdown(steps = [], gates = []) {
  const executionModes = {};
  const sideEffectClasses = {};
  const branchMap = new Map();
  const timeline = [];

  const sortedSteps = [...steps].sort((a, b) => {
    return toTimestamp(a.executed_at || a.created_at) - toTimestamp(b.executed_at || b.created_at);
  });

  for (const step of sortedSteps) {
    const branchId = step.branch_id || 'sequential';
    const executionMode = step.execution_mode || 'unspecified';
    const sideEffectClass = step.side_effect_class || 'unspecified';
    executionModes[executionMode] = (executionModes[executionMode] || 0) + 1;
    sideEffectClasses[sideEffectClass] = (sideEffectClasses[sideEffectClass] || 0) + 1;

    if (!branchMap.has(branchId)) {
      branchMap.set(branchId, {
        branch_id: branchId,
        node_ids: new Set(),
        join_keys: new Set(),
        execution_modes: {},
        side_effect_classes: {},
        step_count: 0,
        gate_count: 0,
        degraded_steps: 0,
        failed_steps: 0,
        total_latency_ms: 0,
        started_at: step.executed_at || step.created_at || '',
        ended_at: step.executed_at || step.created_at || ''
      });
    }

    const branch = branchMap.get(branchId);
    branch.step_count += 1;
    branch.total_latency_ms += Number(step.latency_ms || 0);
    branch.execution_modes[executionMode] = (branch.execution_modes[executionMode] || 0) + 1;
    branch.side_effect_classes[sideEffectClass] = (branch.side_effect_classes[sideEffectClass] || 0) + 1;
    if (step.node_id) branch.node_ids.add(step.node_id);
    if (step.join_key) branch.join_keys.add(step.join_key);
    if (step.status === 'skipped' || step.status === 'degraded') branch.degraded_steps += 1;
    if (step.status === 'failed' || step.status === 'error') branch.failed_steps += 1;
    if (!branch.started_at || toTimestamp(step.executed_at || step.created_at) < toTimestamp(branch.started_at)) {
      branch.started_at = step.executed_at || step.created_at || branch.started_at;
    }
    if (!branch.ended_at || toTimestamp(step.executed_at || step.created_at) > toTimestamp(branch.ended_at)) {
      branch.ended_at = step.executed_at || step.created_at || branch.ended_at;
    }

    timeline.push({
      type: 'step',
      id: step.step_id || '',
      run_id: step.run_id || '',
      branch_id: branchId,
      node_id: step.node_id || '',
      label: step.tool_name || 'unknown',
      status: step.status || 'unknown',
      execution_mode: executionMode,
      timestamp: step.executed_at || step.created_at || '',
      latency_ms: Number(step.latency_ms || 0)
    });
  }

  for (const gate of gates) {
    const branchId = gate.branch_id || 'sequential';
    if (!branchMap.has(branchId)) {
      branchMap.set(branchId, {
        branch_id: branchId,
        node_ids: new Set(),
        join_keys: new Set(),
        execution_modes: {},
        side_effect_classes: {},
        step_count: 0,
        gate_count: 0,
        degraded_steps: 0,
        failed_steps: 0,
        total_latency_ms: 0,
        started_at: gate.presented_at || '',
        ended_at: gate.decided_at || gate.presented_at || ''
      });
    }
    const branch = branchMap.get(branchId);
    branch.gate_count += 1;

    timeline.push({
      type: 'gate',
      id: gate.gate_id || '',
      run_id: gate.run_id || '',
      branch_id: branchId,
      node_id: gate.node_id || '',
      label: gate.tool_name || 'approval_gate',
      status: gate.decision || 'pending',
      execution_mode: gate.execution_mode || 'unspecified',
      timestamp: gate.decided_at || gate.presented_at || '',
      latency_ms: 0
    });
  }

  const branches = Array.from(branchMap.values()).map(branch => ({
    branch_id: branch.branch_id,
    node_ids: Array.from(branch.node_ids),
    join_keys: Array.from(branch.join_keys),
    execution_modes: branch.execution_modes,
    side_effect_classes: branch.side_effect_classes,
    step_count: branch.step_count,
    gate_count: branch.gate_count,
    degraded_steps: branch.degraded_steps,
    failed_steps: branch.failed_steps,
    total_latency_ms: branch.total_latency_ms,
    started_at: branch.started_at,
    ended_at: branch.ended_at
  })).sort((a, b) => b.total_latency_ms - a.total_latency_ms);

  timeline.sort((a, b) => toTimestamp(a.timestamp) - toTimestamp(b.timestamp));

  return {
    execution_modes: executionModes,
    side_effect_classes: sideEffectClasses,
    branch_count: branches.length,
    node_count: new Set(sortedSteps.map(step => step.node_id).filter(Boolean)).size,
    degraded_steps: sortedSteps.filter(step => step.status === 'skipped' || step.status === 'degraded').length,
    branches,
    timeline
  };
}

function buildRunExecutionTrace(run, steps = [], gates = []) {
  const breakdown = buildExecutionBreakdown(steps, gates);
  const criticalPathMs = breakdown.branches.length > 0
    ? Math.max(...breakdown.branches.map(branch => branch.total_latency_ms || 0))
    : steps.reduce((sum, step) => sum + Number(step.latency_ms || 0), 0);

  return {
    run,
    steps,
    gates,
    plan: {
      plan_id: run.plan_id || '',
      execution_model: run.execution_model || 'sequential',
      planned_nodes: Number(run.planned_nodes || 0),
      parallel_nodes: Number(run.parallel_nodes || 0)
    },
    execution: {
      execution_modes: breakdown.execution_modes,
      side_effect_classes: breakdown.side_effect_classes,
      branch_count: breakdown.branch_count,
      node_count: breakdown.node_count,
      degraded_steps: breakdown.degraded_steps,
      critical_path_ms: criticalPathMs,
      degraded_path: breakdown.degraded_steps > 0 || breakdown.branches.some(branch => branch.failed_steps > 0)
    },
    branches: breakdown.branches,
    timeline: breakdown.timeline
  };
}

/**
 * Start a new agent run — creates the immutable run record
 */
export async function startRun(conversationId, role, userId, goalText, metadata = {}) {
  const runId = generateId('run');
  const runMetadata = normalizeRunMetadata(metadata);
  await dataAccess.insertRecord(COLLECTIONS.runs, {
    run_id: runId,
    conversation_id: conversationId || '',
    initiator_id: userId || '',
    role: role || '',
    goal_text: goalText || '',
    status: 'running',
    total_tokens: 0,
    total_cost_usd: 0,
    steps_count: 0,
    started_at: new Date().toISOString(),
    completed_at: '',
    sla_ms: 0,
    plan_id: runMetadata.plan_id,
    execution_model: runMetadata.execution_model,
    planned_nodes: runMetadata.planned_nodes,
    parallel_nodes: runMetadata.parallel_nodes
  }, { suppressAuth: true });
  return { runId };
}

/**
 * Log a single tool execution step within a run
 */
export async function logStep(runId, toolName, riskLevel, args, result, latencyMs, status, metadata = {}) {
  const stepId = generateId('step');
  const stepMetadata = normalizeStepMetadata(metadata);
  // Hash args for storage (avoid storing full PII)
  const argsHash = typeof args === 'object' ? JSON.stringify(Object.keys(args || {})) : '';
  // Summarize result (first 200 chars)
  let resultSummary = '';
  try {
    const resultStr = typeof result === 'string' ? result : JSON.stringify(result);
    resultSummary = resultStr.substring(0, 200);
  } catch (e) {
    resultSummary = 'error_serializing';
  }

  await dataAccess.insertRecord(COLLECTIONS.steps, {
    step_id: stepId,
    run_id: runId || '',
    tool_name: toolName || '',
    risk_level: riskLevel || '',
    args_hash: argsHash,
    result_summary: result && result.error ? 'error' : resultSummary,
    latency_ms: latencyMs || 0,
    retries: 0,
    status: status || 'executed',
    approval_gate_id: '',
    created_at: new Date().toISOString(),
    executed_at: new Date().toISOString(),
    execution_mode: stepMetadata.execution_mode,
    side_effect_class: stepMetadata.side_effect_class,
    node_id: stepMetadata.node_id,
    branch_id: stepMetadata.branch_id,
    join_key: stepMetadata.join_key,
    timeout_ms: stepMetadata.timeout_ms
  }, { suppressAuth: true });
  return { stepId };
}

/**
 * Create an approval gate — pauses execution until resolved
 */
export async function createGate(runId, stepId, toolName, reason, riskLevel, metadata = {}) {
  const gateId = generateId('gate');
  const gateMetadata = normalizeGateMetadata(metadata);
  await dataAccess.insertRecord(COLLECTIONS.gates, {
    gate_id: gateId,
    run_id: runId || '',
    step_id: stepId || '',
    tool_name: toolName || '',
    reason: reason || `Tool ${toolName} requires approval (risk: ${riskLevel})`,
    risk_level: riskLevel || '',
    presented_at: new Date().toISOString(),
    decision: 'pending',
    decided_by: '',
    decided_at: '',
    node_id: gateMetadata.node_id,
    branch_id: gateMetadata.branch_id,
    execution_mode: gateMetadata.execution_mode
  }, { suppressAuth: true });
  return { gateId };
}

/**
 * Resolve an approval gate — records the decision
 */
export async function resolveGate(gateId, decision, decidedBy) {
  // Find the gate record
  const gates = await dataAccess.queryRecords(COLLECTIONS.gates, {
    filters: { gate_id: gateId },
    limit: 1,
    suppressAuth: true
  });
  if (!gates || !gates.items || gates.items.length === 0) {
    throw new Error(`Gate not found: ${gateId}`);
  }
  const gate = gates.items[0];
  const recordId = gate._id || gate.id;
  await dataAccess.updateRecord(COLLECTIONS.gates, recordId, {
    decision: decision || 'unknown',
    decided_by: decidedBy || '',
    decided_at: new Date().toISOString()
  }, { suppressAuth: true });
  return { gateId, decision };
}

/**
 * Complete a run — updates final stats
 */
export async function completeRun(runId, status, totalTokens, totalCost) {
  const runs = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { run_id: runId },
    limit: 1,
    suppressAuth: true
  });
  if (!runs || !runs.items || runs.items.length === 0) {
    throw new Error(`Run not found: ${runId}`);
  }
  const run = runs.items[0];
  const recordId = run._id || run.id;
  const startedAt = run.started_at ? new Date(run.started_at).getTime() : Date.now();
  await dataAccess.updateRecord(COLLECTIONS.runs, recordId, {
    status: status || 'completed',
    total_tokens: totalTokens || 0,
    total_cost_usd: totalCost || 0,
    completed_at: new Date().toISOString(),
    sla_ms: Date.now() - startedAt
  }, { suppressAuth: true });
}

/**
 * Update planning metadata for a run after a plan is built.
 * Backward-compatible helper for Phase 2 planner scaffolding.
 */
export async function updateRunPlanningMetadata(runId, metadata = {}) {
  const runs = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { run_id: runId },
    limit: 1,
    suppressAuth: true
  });
  if (!runs || !runs.items || runs.items.length === 0) {
    throw new Error(`Run not found: ${runId}`);
  }
  const run = runs.items[0];
  const recordId = run._id || run.id;
  const runMetadata = normalizeRunMetadata(metadata);
  await dataAccess.updateRecord(COLLECTIONS.runs, recordId, runMetadata, { suppressAuth: true });
  return { runId, ...runMetadata };
}

/**
 * Get a run by run_id
 */
export async function getRun(runId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { run_id: runId },
    limit: 1,
    suppressAuth: true
  });
  return (result && result.items && result.items[0]) || null;
}

/**
 * Get a run plus derived execution trace data for replay/monitoring.
 */
export async function getRunExecutionTrace(runId) {
  const [run, steps, gates] = await Promise.all([
    getRun(runId),
    getSteps(runId),
    getGatesForRun(runId)
  ]);

  if (!run) return null;
  return buildRunExecutionTrace(run, steps, gates);
}

/**
 * Get all steps for a run
 */
export async function getSteps(runId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.steps, {
    filters: { run_id: runId },
    limit: 100,
    suppressAuth: true
  });
  return (result && result.items) || [];
}

/**
 * Get all approval gates for a run
 */
export async function getGatesForRun(runId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.gates, {
    filters: { run_id: runId },
    limit: 50,
    suppressAuth: true
  });
  return (result && result.items) || [];
}

/**
 * Get recent runs for a user
 */
export async function getRunsByUser(userId, limit = 20) {
  const result = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { initiator_id: userId },
    limit,
    sort: [{ fieldName: 'started_at', order: 'desc' }],
    suppressAuth: true
  });
  return (result && result.items) || [];
}

/**
 * Get recent runs with optional status filter — for admin run monitor
 */
export async function getRecentRuns(filters = {}) {
  const query = {
    limit: filters.limit || 20,
    sort: [{ fieldName: 'started_at', order: 'desc' }],
    suppressAuth: true
  };
  if (filters.status) {
    query.filters = { status: filters.status };
  }
  if (filters.offset) {
    query.skip = filters.offset;
  }
  const result = await dataAccess.queryRecords(COLLECTIONS.runs, query);
  return {
    items: (result && result.items) || [],
    totalCount: (result && result.totalCount) || 0
  };
}

/**
 * Get recent runs enriched with lightweight execution summaries for admin views.
 */
export async function getRecentRunsWithExecution(filters = {}) {
  const recent = await getRecentRuns(filters);
  const runs = recent.items || [];

  const items = await Promise.all(runs.map(async (run) => {
    const trace = await getRunExecutionTrace(run.run_id);
    if (!trace) return run;

    return {
      ...run,
      branch_count: trace.execution.branch_count,
      node_count: trace.execution.node_count,
      degraded_steps: trace.execution.degraded_steps,
      critical_path_ms: trace.execution.critical_path_ms,
      gate_count: trace.gates.length,
      execution_modes: trace.execution.execution_modes
    };
  }));

  return {
    items,
    totalCount: recent.totalCount
  };
}

/**
 * Log an agent action — convenience alias expected by external callers
 * Wraps logStep with sensible defaults for action-style logging
 */
export async function logAgentAction(runId, actionName, details = {}) {
  const {
    riskLevel = 'execute_low',
    args = {},
    result = {},
    latencyMs = 0,
    status = 'executed',
    execution_mode = '',
    side_effect_class = '',
    node_id = '',
    branch_id = '',
    join_key = '',
    timeout_ms = 0
  } = details;
  return logStep(runId, actionName, riskLevel, args, result, latencyMs, status, {
    execution_mode,
    side_effect_class,
    node_id,
    branch_id,
    join_key,
    timeout_ms
  });
}

/**
 * Get approval gates within a date range — for admin audit log
 */
export async function getApprovalGatesByDateRange(days = 7) {
  const since = new Date(Date.now() - days * 86400000).toISOString();
  const result = await dataAccess.queryRecords(COLLECTIONS.gates, {
    limit: 200,
    sort: [{ fieldName: 'presented_at', order: 'desc' }],
    suppressAuth: true
  });
  const items = (result && result.items) || [];
  const sinceTime = new Date(since).getTime();
  const filtered = items.filter(g => {
    const t = new Date(g.presented_at).getTime();
    return t >= sinceTime;
  });
  return filtered;
}

// ============================================================================
// AGENT RUN LEDGER SERVICE — Immutable event log for agent orchestration
// Tracks runs, steps, approval gates, and enables outcome evaluation
// ============================================================================

import * as dataAccess from 'backend/dataAccess';

const COLLECTIONS = {
  runs: 'agentRuns',
  steps: 'agentSteps',
  gates: 'approvalGates',
  outcomes: 'runOutcomes'
};

function generateId(prefix) {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function normalizeRunMetadata(metadata = {}) {
  return {
    plan_id: metadata.plan_id || '',
    execution_model: metadata.execution_model || 'sequential',
    planned_nodes: Number(metadata.planned_nodes || 0),
    parallel_nodes: Number(metadata.parallel_nodes || 0),
  };
}

function normalizeStepMetadata(metadata = {}) {
  return {
    execution_mode: metadata.execution_mode || '',
    side_effect_class: metadata.side_effect_class || '',
    node_id: metadata.node_id || '',
    branch_id: metadata.branch_id || '',
    join_key: metadata.join_key || '',
    timeout_ms: Number(metadata.timeout_ms || 0),
  };
}

function normalizeGateMetadata(metadata = {}) {
  return {
    node_id: metadata.node_id || '',
    branch_id: metadata.branch_id || '',
    execution_mode: metadata.execution_mode || '',
  };
}

/**
 * Start a new agent run — creates the immutable run record
 */
export async function startRun(conversationId, role, userId, goalText, metadata = {}) {
  const runId = generateId('run');
  const runMetadata = normalizeRunMetadata(metadata);
  await dataAccess.insertRecord(COLLECTIONS.runs, {
    run_id: runId,
    conversation_id: conversationId || '',
    initiator_id: userId || '',
    role: role || '',
    goal_text: goalText || '',
    status: 'running',
    total_tokens: 0,
    total_cost_usd: 0,
    steps_count: 0,
    started_at: new Date().toISOString(),
    completed_at: '',
    sla_ms: 0,
    plan_id: runMetadata.plan_id,
    execution_model: runMetadata.execution_model,
    planned_nodes: runMetadata.planned_nodes,
    parallel_nodes: runMetadata.parallel_nodes
  }, { suppressAuth: true });
  return { runId };
}

/**
 * Log a single tool execution step within a run
 */
export async function logStep(runId, toolName, riskLevel, args, result, latencyMs, status, metadata = {}) {
  const stepId = generateId('step');
  const stepMetadata = normalizeStepMetadata(metadata);
  // Hash args for storage (avoid storing full PII)
  const argsHash = typeof args === 'object' ? JSON.stringify(Object.keys(args || {})) : '';
  // Summarize result (first 200 chars)
  let resultSummary = '';
  try {
    const resultStr = typeof result === 'string' ? result : JSON.stringify(result);
    resultSummary = resultStr.substring(0, 200);
  } catch (e) {
    resultSummary = 'error_serializing';
  }

  await dataAccess.insertRecord(COLLECTIONS.steps, {
    step_id: stepId,
    run_id: runId || '',
    tool_name: toolName || '',
    risk_level: riskLevel || '',
    args_hash: argsHash,
    result_summary: result && result.error ? 'error' : resultSummary,
    latency_ms: latencyMs || 0,
    retries: 0,
    status: status || 'executed',
    approval_gate_id: '',
    created_at: new Date().toISOString(),
    executed_at: new Date().toISOString(),
    execution_mode: stepMetadata.execution_mode,
    side_effect_class: stepMetadata.side_effect_class,
    node_id: stepMetadata.node_id,
    branch_id: stepMetadata.branch_id,
    join_key: stepMetadata.join_key,
    timeout_ms: stepMetadata.timeout_ms
  }, { suppressAuth: true });
  return { stepId };
}

/**
 * Create an approval gate — pauses execution until resolved
 */
export async function createGate(runId, stepId, toolName, reason, riskLevel, metadata = {}) {
  const gateId = generateId('gate');
  const gateMetadata = normalizeGateMetadata(metadata);
  await dataAccess.insertRecord(COLLECTIONS.gates, {
    gate_id: gateId,
    run_id: runId || '',
    step_id: stepId || '',
    tool_name: toolName || '',
    reason: reason || `Tool ${toolName} requires approval (risk: ${riskLevel})`,
    risk_level: riskLevel || '',
    presented_at: new Date().toISOString(),
    decision: 'pending',
    decided_by: '',
    decided_at: '',
    node_id: gateMetadata.node_id,
    branch_id: gateMetadata.branch_id,
    execution_mode: gateMetadata.execution_mode
  }, { suppressAuth: true });
  return { gateId };
}

/**
 * Resolve an approval gate — records the decision
 */
export async function resolveGate(gateId, decision, decidedBy) {
  // Find the gate record
  const gates = await dataAccess.queryRecords(COLLECTIONS.gates, {
    filters: { gate_id: gateId },
    limit: 1,
    suppressAuth: true
  });
  if (!gates || !gates.items || gates.items.length === 0) {
    throw new Error(`Gate not found: ${gateId}`);
  }
  const gate = gates.items[0];
  const recordId = gate._id || gate.id;
  await dataAccess.updateRecord(COLLECTIONS.gates, recordId, {
    decision: decision || 'unknown',
    decided_by: decidedBy || '',
    decided_at: new Date().toISOString()
  }, { suppressAuth: true });
  return { gateId, decision };
}

/**
 * Complete a run — updates final stats
 */
export async function completeRun(runId, status, totalTokens, totalCost) {
  const runs = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { run_id: runId },
    limit: 1,
    suppressAuth: true
  });
  if (!runs || !runs.items || runs.items.length === 0) {
    throw new Error(`Run not found: ${runId}`);
  }
  const run = runs.items[0];
  const recordId = run._id || run.id;
  const startedAt = run.started_at ? new Date(run.started_at).getTime() : Date.now();
  await dataAccess.updateRecord(COLLECTIONS.runs, recordId, {
    status: status || 'completed',
    total_tokens: totalTokens || 0,
    total_cost_usd: totalCost || 0,
    completed_at: new Date().toISOString(),
    sla_ms: Date.now() - startedAt
  }, { suppressAuth: true });
}

/**
 * Update planning metadata for a run after a plan is built.
 * Backward-compatible helper for Phase 2 planner scaffolding.
 */
export async function updateRunPlanningMetadata(runId, metadata = {}) {
  const runs = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { run_id: runId },
    limit: 1,
    suppressAuth: true
  });
  if (!runs || !runs.items || runs.items.length === 0) {
    throw new Error(`Run not found: ${runId}`);
  }
  const run = runs.items[0];
  const recordId = run._id || run.id;
  const runMetadata = normalizeRunMetadata(metadata);
  await dataAccess.updateRecord(COLLECTIONS.runs, recordId, runMetadata, { suppressAuth: true });
  return { runId, ...runMetadata };
}

/**
 * Get a run by run_id
 */
export async function getRun(runId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { run_id: runId },
    limit: 1,
    suppressAuth: true
  });
  return (result && result.items && result.items[0]) || null;
}

/**
 * Get all steps for a run
 */
export async function getSteps(runId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.steps, {
    filters: { run_id: runId },
    limit: 100,
    suppressAuth: true
  });
  return (result && result.items) || [];
}

/**
 * Get all approval gates for a run
 */
export async function getGatesForRun(runId) {
  const result = await dataAccess.queryRecords(COLLECTIONS.gates, {
    filters: { run_id: runId },
    limit: 50,
    suppressAuth: true
  });
  return (result && result.items) || [];
}

/**
 * Get recent runs for a user
 */
export async function getRunsByUser(userId, limit = 20) {
  const result = await dataAccess.queryRecords(COLLECTIONS.runs, {
    filters: { initiator_id: userId },
    limit,
    sort: [{ fieldName: 'started_at', order: 'desc' }],
    suppressAuth: true
  });
  return (result && result.items) || [];
}

/**
 * Get recent runs with optional status filter — for admin run monitor
 */
export async function getRecentRuns(filters = {}) {
  const query = {
    limit: filters.limit || 20,
    sort: [{ fieldName: 'started_at', order: 'desc' }],
    suppressAuth: true
  };
  if (filters.status) {
    query.filters = { status: filters.status };
  }
  if (filters.offset) {
    query.skip = filters.offset;
  }
  const result = await dataAccess.queryRecords(COLLECTIONS.runs, query);
  return {
    items: (result && result.items) || [],
    totalCount: (result && result.totalCount) || 0
  };
}

/**
 * Log an agent action — convenience alias expected by external callers
 * Wraps logStep with sensible defaults for action-style logging
 */
export async function logAgentAction(runId, actionName, details = {}) {
  const {
    riskLevel = 'execute_low',
    args = {},
    result = {},
    latencyMs = 0,
    status = 'executed',
    execution_mode = '',
    side_effect_class = '',
    node_id = '',
    branch_id = '',
    join_key = '',
    timeout_ms = 0
  } = details;
  return logStep(runId, actionName, riskLevel, args, result, latencyMs, status, {
    execution_mode,
    side_effect_class,
    node_id,
    branch_id,
    join_key,
    timeout_ms
  });
}

/**
 * Get approval gates within a date range — for admin audit log
 */
export async function getApprovalGatesByDateRange(days = 7) {
  const since = new Date(Date.now() - days * 86400000).toISOString();
  const result = await dataAccess.queryRecords(COLLECTIONS.gates, {
    limit: 200,
    sort: [{ fieldName: 'presented_at', order: 'desc' }],
    suppressAuth: true
  });
  const items = (result && result.items) || [];
  const sinceTime = new Date(since).getTime();
  const filtered = items.filter(g => {
    const t = new Date(g.presented_at).getTime();
    return t >= sinceTime;
  });
  return filtered;
}

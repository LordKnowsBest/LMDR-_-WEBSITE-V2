import * as dataAccess from 'backend/dataAccess';
import { logEmail, logSms, logCall } from 'backend/b2bActivityService';
import { validateConsent, checkQuietHours, isDoNotContact } from 'backend/b2bSecurityService';
import { generateEmailContent, generateSmsContent, generateCallScript } from 'backend/b2bContentAIService';

// Collection keys for dataAccess
const COLLECTIONS = {
  sequences: 'b2bSequences',
  sequenceSteps: 'b2bSequenceSteps',
  emails: 'b2bEmails',
  textMessages: 'b2bTextMessages',
  calls: 'b2bCalls',
  callCampaigns: 'b2bCallCampaigns',
  contacts: 'b2bContacts'
};

const SEQUENCE_STATUS = { DRAFT: 'draft', ACTIVE: 'active', PAUSED: 'paused', ARCHIVED: 'archived' };
const MESSAGE_STATUS = { QUEUED: 'queued', SENT: 'sent', DELIVERED: 'delivered', REPLIED: 'replied' };
const THROTTLE = { maxEmailsPerDay: 200, maxSmsPerDay: 100, maxCallsPerDay: 50 };

// ============================================================================
// SEQUENCE CRUD
// ============================================================================

export async function createSequence(seqData) {
  try {
    if (!seqData.name?.trim()) return { success: false, error: 'Name required' };
    const record = {
      name: seqData.name.trim(), channel_mix: Array.isArray(seqData.channel_mix) ? seqData.channel_mix.join(', ') : (seqData.channel_mix || 'email'),
      status: SEQUENCE_STATUS.DRAFT, owner_id: seqData.owner_id || '', steps: '[]',
      throttle_rules: JSON.stringify(seqData.throttle_rules || THROTTLE),
      created_at: new Date().toISOString(), updated_at: new Date().toISOString()
    };
    const result = await dataAccess.insertRecord(COLLECTIONS.sequences, record, { suppressAuth: true });
    return { success: result.success, sequence: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getSequence(sequenceId) {
  try {
    const sequence = await dataAccess.getRecord(COLLECTIONS.sequences, sequenceId, { suppressAuth: true });
    if (!sequence) return { success: false, error: 'Not found' };
    const stepsRes = await dataAccess.queryRecords(COLLECTIONS.sequenceSteps, { filters: { sequence_id: sequenceId }, sort: [{ field: 'step_order', direction: 'asc' }], limit: 100, suppressAuth: true });
    return { success: true, sequence, steps: stepsRes.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateSequence(sequenceId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.sequences, sequenceId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.sequences, { ...existing, ...updates, _id: sequenceId, updated_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: result.success, sequence: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function listSequences(filters = {}) {
  try {
    const queryFilters = {};
    if (filters.status) queryFilters.status = filters.status;
    const result = await dataAccess.queryRecords(COLLECTIONS.sequences, { filters: queryFilters, sort: [{ field: 'updated_at', direction: 'desc' }], limit: filters.limit || 50, suppressAuth: true });
    return { success: true, sequences: result.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// SEQUENCE STEPS
// ============================================================================

export async function addStep(stepData) {
  try {
    if (!stepData.sequence_id || !stepData.step_type) return { success: false, error: 'Missing fields' };
    const result = await dataAccess.insertRecord(COLLECTIONS.sequenceSteps, { ...stepData, created_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: result.success, step: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateStep(stepId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.sequenceSteps, stepId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.sequenceSteps, { ...existing, ...updates, _id: stepId }, { suppressAuth: true });
    return { success: true, step: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// TEMPLATE RENDERING WITH AI SUPPORT
// ============================================================================

/**
 * Render a template with variable substitution
 * Supports {{carrier_name}}, {{match_count}}, {{top_regions}}, {{contact_name}}, etc.
 *
 * @param {string} template - Template string with {{variable}} placeholders
 * @param {Object} variables - Key-value pairs for substitution
 * @returns {string} Rendered template
 */
export function renderTemplate(template, variables = {}) {
  if (!template) return '';

  let rendered = template;
  Object.entries(variables).forEach(([key, value]) => {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    rendered = rendered.replace(regex, String(value || ''));
  });

  // Clean up any remaining unresolved variables
  rendered = rendered.replace(/\{\{[^}]+\}\}/g, '');

  return rendered;
}

/**
 * Render a sequence step with AI generation support.
 * If step has ai_generated=true, content is generated at render time using LLM.
 * Falls back to static template rendering on AI failure.
 *
 * @param {Object} step - Sequence step with template, step_type, ai_generated flag
 * @param {Object} context - Context for rendering (accountId, contactId, variables)
 * @returns {Promise<{success: boolean, content?: Object, aiGenerated?: boolean, error?: string}>}
 */
export async function renderStepContent(step, context = {}) {
  try {
    const { accountId, contactId, variables = {} } = context;
    const stepType = step.step_type || 'email';
    const aiGenerated = step.ai_generated === true || step.ai_generated === 'true';

    // If AI generation is enabled, call the content AI service
    if (aiGenerated && accountId) {
      const purpose = step.purpose || 'follow_up';
      const sequenceStepId = step._id || step.id;

      let result;
      switch (stepType) {
        case 'email':
          result = await generateEmailContent({
            accountId,
            contactId,
            purpose,
            sequenceStepId
          });
          if (result.success) {
            return {
              success: true,
              content: {
                subject: result.content.subject,
                body: result.content.body
              },
              aiGenerated: true,
              cached: result.cached
            };
          }
          break;

        case 'sms':
          result = await generateSmsContent({
            accountId,
            contactId,
            purpose,
            sequenceStepId
          });
          if (result.success) {
            return {
              success: true,
              content: {
                message: result.content.message,
                charCount: result.content.charCount
              },
              aiGenerated: true,
              cached: result.cached
            };
          }
          break;

        case 'call':
          result = await generateCallScript({
            accountId,
            contactId,
            purpose,
            sequenceStepId
          });
          if (result.success) {
            return {
              success: true,
              content: result.content,
              aiGenerated: true,
              cached: result.cached
            };
          }
          break;
      }

      // AI generation failed, fall through to template rendering
      console.warn(`AI content generation failed for step ${stepType}, falling back to template`);
    }

    // Static template rendering (fallback or non-AI steps)
    const renderedTemplate = renderTemplate(step.template || '', variables);
    const renderedSubject = renderTemplate(step.subject || '', variables);

    return {
      success: true,
      content: {
        subject: renderedSubject,
        body: renderedTemplate,
        message: renderedTemplate // For SMS
      },
      aiGenerated: false
    };
  } catch (error) {
    console.error('Error rendering step content:', error);
    return { success: false, error: error.message || 'Failed to render step content' };
  }
}

// ============================================================================
// OUTREACH TRACKING (EMAIL, SMS, CALLS)
// ============================================================================

/**
 * Record an email send
 *
 * @param {Object} emailData
 * @param {string} emailData.account_id
 * @param {string} emailData.contact_id
 * @param {string} emailData.subject
 * @param {string} [emailData.sequence_id]
 * @param {string} [emailData.step_id]
 * @returns {Promise<{success: boolean, email?: Object, error?: string}>}
 */
export async function recordEmail(emailData) {
  try {
    if (!emailData.account_id || !emailData.contact_id) return { success: false, error: 'Missing fields' };
    const consent = await validateConsent(emailData.contact_id, 'email');
    if (!consent.allowed) return { success: false, error: consent.reason };

    const result = await dataAccess.insertRecord(COLLECTIONS.emails, { ...emailData, status: MESSAGE_STATUS.SENT, opened: false, clicked: false, sent_at: new Date().toISOString() }, { suppressAuth: true });
    logEmail(emailData.account_id, emailData.contact_id, emailData.subject, 'sent').catch(() => {});
    return { success: result.success, email: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateEmailStatus(emailId, status) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.emails, emailId, { suppressAuth: true });
    const updates = { ...existing, _id: emailId, status };
    if (status === 'opened') updates.opened = true;
    if (status === 'clicked') updates.clicked = true;
    await dataAccess.updateRecord(COLLECTIONS.emails, updates, { suppressAuth: true });
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function recordSms(smsData) {
  try {
    const consent = await validateConsent(smsData.contact_id, 'sms');
    if (!consent.allowed) return { success: false, error: consent.reason };
    if (await isDoNotContact(smsData.contact_id)) return { success: false, error: 'DNC' };

    const result = await dataAccess.insertRecord(COLLECTIONS.textMessages, { ...smsData, status: MESSAGE_STATUS.SENT, sent_at: new Date().toISOString() }, { suppressAuth: true });
    logSms(smsData.account_id, smsData.contact_id, (smsData.message || '').substring(0, 50), 'sent').catch(() => {});
    return { success: result.success, textMessage: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function recordCall(callData) {
  try {
    const consent = await validateConsent(callData.contact_id, 'call');
    if (!consent.allowed) return { success: false, error: consent.reason };
    if (await isDoNotContact(callData.contact_id)) return { success: false, error: 'DNC' };

    const result = await dataAccess.insertRecord(COLLECTIONS.calls, { ...callData, direction: 'outbound', status: 'completed', created_at: new Date().toISOString() }, { suppressAuth: true });
    logCall(callData.account_id, callData.contact_id, { outcome: callData.disposition || 'completed', duration: callData.duration }).catch(() => {});
    return { success: result.success, call: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getOutreachMetrics(options = {}) {
  try {
    const since = new Date(Date.now() - (options.days || 30) * 24 * 60 * 60 * 1000).toISOString();
    const [emails, sms, calls] = await Promise.all([
      dataAccess.queryRecords(COLLECTIONS.emails, { filters: { sent_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || []),
      dataAccess.queryRecords(COLLECTIONS.textMessages, { filters: { sent_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || []),
      dataAccess.queryRecords(COLLECTIONS.calls, { filters: { created_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || [])
    ]);

    return {
      success: true,
      metrics: {
        email: { sent: emails.length, opened: emails.filter(e => e.opened).length, replied: emails.filter(e => e.status === 'replied').length },
        sms: { sent: sms.length, replied: sms.filter(s => s.response_text).length },
        call: { total: calls.length, connected: calls.filter(c => c.disposition === 'connected').length }
      }
    };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function checkThrottleLimits(channel) {
  try {
    const today = new Date(); today.setHours(0,0,0,0);
    const key = channel === 'email' ? COLLECTIONS.emails : (channel === 'sms' ? COLLECTIONS.textMessages : COLLECTIONS.calls);
    const dateField = channel === 'call' ? 'created_at' : 'sent_at';
    const limit = channel === 'email' ? THROTTLE.maxEmailsPerDay : (channel === 'sms' ? THROTTLE.maxSmsPerDay : THROTTLE.maxCallsPerDay);

    const result = await dataAccess.queryRecords(key, { filters: { [dateField]: { gte: today.toISOString() } }, limit: 500, suppressAuth: true });
    const count = (result.items || []).length;
    return { success: true, allowed: count < limit, remaining: Math.max(0, limit - count), used: count, limit };
  } catch (error) { return { success: false, allowed: false, error: error.message }; }
}

export function isQuietHours() {
  const hour = new Date().getUTCHours();
  return hour >= 21 || hour < 8;
}

import * as dataAccess from 'backend/dataAccess';
import { logEmail, logSms, logCall } from 'backend/b2bActivityService';
import { validateConsent, checkQuietHours, isDoNotContact } from 'backend/b2bSecurityService';

// Collection keys for dataAccess
const COLLECTIONS = {
  sequences: 'b2bSequences',
  sequenceSteps: 'b2bSequenceSteps',
  emails: 'b2bEmails',
  textMessages: 'b2bTextMessages',
  calls: 'b2bCalls',
  callCampaigns: 'b2bCallCampaigns',
  contacts: 'b2bContacts'
};

const SEQUENCE_STATUS = { DRAFT: 'draft', ACTIVE: 'active', PAUSED: 'paused', ARCHIVED: 'archived' };
const MESSAGE_STATUS = { QUEUED: 'queued', SENT: 'sent', DELIVERED: 'delivered', REPLIED: 'replied' };
const THROTTLE = { maxEmailsPerDay: 200, maxSmsPerDay: 100, maxCallsPerDay: 50 };

// ============================================================================
// SEQUENCE CRUD
// ============================================================================

export async function createSequence(seqData) {
  try {
    if (!seqData.name?.trim()) return { success: false, error: 'Name required' };
    const record = {
      name: seqData.name.trim(), channel_mix: Array.isArray(seqData.channel_mix) ? seqData.channel_mix.join(', ') : (seqData.channel_mix || 'email'),
      status: SEQUENCE_STATUS.DRAFT, owner_id: seqData.owner_id || '', steps: '[]',
      throttle_rules: JSON.stringify(seqData.throttle_rules || THROTTLE),
      created_at: new Date().toISOString(), updated_at: new Date().toISOString()
    };
    const result = await dataAccess.insertRecord(COLLECTIONS.sequences, record, { suppressAuth: true });
    return { success: result.success, sequence: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getSequence(sequenceId) {
  try {
    const sequence = await dataAccess.getRecord(COLLECTIONS.sequences, sequenceId, { suppressAuth: true });
    if (!sequence) return { success: false, error: 'Not found' };
    const stepsRes = await dataAccess.queryRecords(COLLECTIONS.sequenceSteps, { filters: { sequence_id: sequenceId }, sort: [{ field: 'step_order', direction: 'asc' }], limit: 100, suppressAuth: true });
    return { success: true, sequence, steps: stepsRes.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateSequence(sequenceId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.sequences, sequenceId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.sequences, { ...existing, ...updates, _id: sequenceId, updated_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: result.success, sequence: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function listSequences(filters = {}) {
  try {
    const queryFilters = {};
    if (filters.status) queryFilters.status = filters.status;
    const result = await dataAccess.queryRecords(COLLECTIONS.sequences, { filters: queryFilters, sort: [{ field: 'updated_at', direction: 'desc' }], limit: filters.limit || 50, suppressAuth: true });
    return { success: true, sequences: result.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// SEQUENCE STEPS
// ============================================================================

export async function addStep(stepData) {
  try {
    if (!stepData.sequence_id || !stepData.step_type) return { success: false, error: 'Missing fields' };
    const result = await dataAccess.insertRecord(COLLECTIONS.sequenceSteps, { ...stepData, created_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: result.success, step: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateStep(stepId, updates) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.sequenceSteps, stepId, { suppressAuth: true });
    if (!existing) throw new Error('Not found');
    const result = await dataAccess.updateRecord(COLLECTIONS.sequenceSteps, { ...existing, ...updates, _id: stepId }, { suppressAuth: true });
    return { success: true, step: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// OUTREACH TRACKING
// ============================================================================

export async function recordEmail(emailData) {
  try {
    if (!emailData.account_id || !emailData.contact_id) return { success: false, error: 'Missing fields' };
    const consent = await validateConsent(emailData.contact_id, 'email');
    if (!consent.allowed) return { success: false, error: consent.reason };

    const result = await dataAccess.insertRecord(COLLECTIONS.emails, { ...emailData, status: MESSAGE_STATUS.SENT, opened: false, clicked: false, sent_at: new Date().toISOString() }, { suppressAuth: true });
    logEmail(emailData.account_id, emailData.contact_id, emailData.subject, 'sent').catch(() => {});
    return { success: result.success, email: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function updateEmailStatus(emailId, status) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.emails, emailId, { suppressAuth: true });
    const updates = { ...existing, _id: emailId, status };
    if (status === 'opened') updates.opened = true;
    if (status === 'clicked') updates.clicked = true;
    await dataAccess.updateRecord(COLLECTIONS.emails, updates, { suppressAuth: true });
    return { success: true };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function recordSms(smsData) {
  try {
    const consent = await validateConsent(smsData.contact_id, 'sms');
    if (!consent.allowed) return { success: false, error: consent.reason };
    if (await isDoNotContact(smsData.contact_id)) return { success: false, error: 'DNC' };

    const result = await dataAccess.insertRecord(COLLECTIONS.textMessages, { ...smsData, status: MESSAGE_STATUS.SENT, sent_at: new Date().toISOString() }, { suppressAuth: true });
    logSms(smsData.account_id, smsData.contact_id, (smsData.message || '').substring(0, 50), 'sent').catch(() => {});
    return { success: result.success, textMessage: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function recordCall(callData) {
  try {
    const consent = await validateConsent(callData.contact_id, 'call');
    if (!consent.allowed) return { success: false, error: consent.reason };
    if (await isDoNotContact(callData.contact_id)) return { success: false, error: 'DNC' };

    const result = await dataAccess.insertRecord(COLLECTIONS.calls, { ...callData, direction: 'outbound', status: 'completed', created_at: new Date().toISOString() }, { suppressAuth: true });
    logCall(callData.account_id, callData.contact_id, { outcome: callData.disposition || 'completed', duration: callData.duration }).catch(() => {});
    return { success: result.success, call: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getOutreachMetrics(options = {}) {
  try {
    const since = new Date(Date.now() - (options.days || 30) * 24 * 60 * 60 * 1000).toISOString();
    const [emails, sms, calls] = await Promise.all([
      dataAccess.queryRecords(COLLECTIONS.emails, { filters: { sent_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || []),
      dataAccess.queryRecords(COLLECTIONS.textMessages, { filters: { sent_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || []),
      dataAccess.queryRecords(COLLECTIONS.calls, { filters: { created_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || [])
    ]);

    return {
      success: true,
      metrics: {
        email: { sent: emails.length, opened: emails.filter(e => e.opened).length, replied: emails.filter(e => e.status === 'replied').length },
        sms: { sent: sms.length, replied: sms.filter(s => s.response_text).length },
        call: { total: calls.length, connected: calls.filter(c => c.disposition === 'connected').length }
      }
    };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function checkThrottleLimits(channel) {
  try {
    const today = new Date(); today.setHours(0,0,0,0);
    const key = channel === 'email' ? COLLECTIONS.emails : (channel === 'sms' ? COLLECTIONS.textMessages : COLLECTIONS.calls);
    const dateField = channel === 'call' ? 'created_at' : 'sent_at';
    const limit = channel === 'email' ? THROTTLE.maxEmailsPerDay : (channel === 'sms' ? THROTTLE.maxSmsPerDay : THROTTLE.maxCallsPerDay);

    const result = await dataAccess.queryRecords(key, { filters: { [dateField]: { gte: today.toISOString() } }, limit: 500, suppressAuth: true });
    const count = (result.items || []).length;
    return { success: true, allowed: count < limit, remaining: Math.max(0, limit - count), used: count, limit };
  } catch (error) { return { success: false, allowed: false, error: error.message }; }
}

export function isQuietHours() {
  const hour = new Date().getUTCHours();
  return hour >= 21 || hour < 8;
}

export function renderTemplate(template, variables = {}) {
  let rendered = template || '';
  Object.entries(variables).forEach(([k, v]) => { rendered = rendered.replace(new RegExp(`\\{\\{${k}\\}\\}`, 'g'), String(v || '')); });
  return rendered.replace(/\{\{[^}]+\}\}/g, '');
}

import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// COLLECTION KEYS
// ============================================================================

const COLLECTIONS = {
  snapshots: 'b2bAnalyticsSnapshots',
  attribution: 'b2bLeadAttribution',
  spend: 'b2bSpend',
  competitorIntel: 'b2bCompetitorIntel',
  opportunities: 'b2bOpportunities',
  activities: 'b2bActivities',
  accounts: 'b2bAccounts',
  emails: 'b2bEmails',
  textMessages: 'b2bTextMessages',
  calls: 'b2bCalls'
};

// ============================================================================
// DASHBOARD KPIs
// ============================================================================

export async function getDashboardKPIs(options = {}) {
  try {
    const days = options.days || 30;
    const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    const [openRes, closedRes] = await Promise.all([
      dataAccess.queryRecords(COLLECTIONS.opportunities, { filters: { stage: { ne: ['closed_won', 'closed_lost'] } }, limit: 500, suppressAuth: true }),
      dataAccess.queryRecords(COLLECTIONS.opportunities, { filters: { stage: { hasSome: ['closed_won', 'closed_lost'] } }, limit: 500, suppressAuth: true })
    ]);

    const openOpps = openRes.items || [], closedOpps = closedRes.items || [];
    const won = closedOpps.filter(o => o.stage === 'closed_won');
    const pipelineValue = openOpps.reduce((s, o) => s + (Number(o.value_estimate) || 0), 0);
    const wonRevenue = won.reduce((s, o) => s + (Number(o.value_estimate) || 0), 0);

    const totalClosed = closedOpps.length;
    const winRate = totalClosed > 0 ? Math.round((won.length / totalClosed) * 100) : 0;

    const actRes = await dataAccess.queryRecords(COLLECTIONS.activities, { filters: { created_at: { gte: since.toISOString() } }, limit: 500, suppressAuth: true });
    const activities = actRes.items || [];

    return {
      success: true,
      kpis: {
        pipeline_coverage: wonRevenue > 0 ? Math.round((pipelineValue / wonRevenue) * 10) / 10 : (pipelineValue > 0 ? 99 : 0),
        pipeline_value: Math.round(pipelineValue), win_rate: winRate,
        activity_velocity: Math.round((activities.length / days) * 7),
        responses_period: activities.filter(a => a.outcome === 'replied' || a.outcome === 'connected').length,
        deals_open: openOpps.length, deals_won: won.length, won_revenue: Math.round(wonRevenue), period_days: days
      }
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// CHANNEL PERFORMANCE
// ============================================================================

export async function getChannelPerformance(days = 30) {
  try {
    const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
    const [emails, sms, calls] = await Promise.all([
      dataAccess.queryRecords(COLLECTIONS.emails, { filters: { sent_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || []),
      dataAccess.queryRecords(COLLECTIONS.textMessages, { filters: { sent_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || []),
      dataAccess.queryRecords(COLLECTIONS.calls, { filters: { created_at: { gte: since } }, limit: 500, suppressAuth: true }).then(r => r.items || [])
    ]);

    const channels = [
      { channel: 'email', sent: emails.length, delivered: emails.filter(e => e.status !== 'bounced').length, replied: emails.filter(e => e.status === 'replied').length },
      { channel: 'sms', sent: sms.length, delivered: sms.filter(s => s.status === 'delivered').length, replied: sms.filter(s => s.response_text).length },
      { channel: 'voice', sent: calls.length, delivered: calls.filter(c => c.status === 'completed').length, replied: calls.filter(c => c.disposition === 'connected').length }
    ];
    return { success: true, channels, period_days: days };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getRepPerformance(days = 30) {
  try {
    const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
    const res = await dataAccess.queryRecords(COLLECTIONS.activities, { filters: { created_at: { gte: since } }, limit: 500, suppressAuth: true });
    const repMap = {};
    (res.items || []).forEach(a => {
      const oid = a.owner_id || 'unassigned';
      if (!repMap[oid]) repMap[oid] = { owner_id: oid, touches: 0, replies: 0, meetings: 0 };
      repMap[oid].touches++;
      if (a.outcome === 'replied' || a.outcome === 'connected') repMap[oid].replies++;
      if (a.type === 'meeting') repMap[oid].meetings++;
    });
    return { success: true, reps: Object.values(repMap).sort((a, b) => b.touches - a.touches), period_days: days };
  } catch (error) { return { success: false, error: error.message }; }
}

// ============================================================================
// LEAD ATTRIBUTION
// ============================================================================

export async function recordTouchpoint(touchData) {
  try {
    if (!touchData.account_id || !touchData.source) return { success: false, error: 'Missing fields' };
    const now = new Date().toISOString();
    const existing = await dataAccess.findByField(COLLECTIONS.attribution, 'account_id', touchData.account_id, { suppressAuth: true });

    if (existing) {
      let history = [];
      try { history = typeof existing.touchpoint_history === 'string' ? JSON.parse(existing.touchpoint_history) : (existing.touchpoint_history || []); } catch (e) { }
      history.push({ source: touchData.source, medium: touchData.medium || '', campaign: touchData.campaign || '', timestamp: now });
      const result = await dataAccess.updateRecord(COLLECTIONS.attribution, { ...existing, source: touchData.source, last_touch_at: now, touchpoint_history: JSON.stringify(history) }, { suppressAuth: true });
      return { success: true, attribution: result.record };
    } else {
      const record = { account_id: touchData.account_id, source: touchData.source, medium: touchData.medium || '', campaign: touchData.campaign || '', first_touch_at: now, last_touch_at: now, touchpoint_history: JSON.stringify([{ source: touchData.source, medium: touchData.medium || '', campaign: touchData.campaign || '', timestamp: now }]) };
      const result = await dataAccess.insertRecord(COLLECTIONS.attribution, record, { suppressAuth: true });
      return { success: true, attribution: result.record };
    }
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getAttribution(accountId) {
  try {
    const record = await dataAccess.findByField(COLLECTIONS.attribution, 'account_id', accountId, { suppressAuth: true });
    if (!record) return { success: false, error: 'Not found' };
    let history = [];
    try { history = typeof record.touchpoint_history === 'string' ? JSON.parse(record.touchpoint_history) : (record.touchpoint_history || []); } catch (e) { }
    return { success: true, attribution: { ...record, touchpoint_history: history } };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getSourcePerformance() {
  try {
    const attrRes = await dataAccess.queryRecords(COLLECTIONS.attribution, { limit: 500, suppressAuth: true });
    const wonRes = await dataAccess.queryRecords(COLLECTIONS.opportunities, { filters: { stage: 'closed_won' }, limit: 500, suppressAuth: true });
    const wonIds = new Set((wonRes.items || []).map(o => o.account_id));

    const sourceMap = {};
    (attrRes.items || []).forEach(attr => {
      const s = attr.source || 'unknown';
      if (!sourceMap[s]) sourceMap[s] = { source: s, total: 0, converted: 0 };
      sourceMap[s].total++;
      if (wonIds.has(attr.account_id)) sourceMap[s].converted++;
    });

    return { success: true, sources: Object.values(sourceMap).map(s => ({ ...s, conversion_rate: s.total > 0 ? Math.round((s.converted / s.total) * 100) : 0 })).sort((a,b) => b.total - a.total) };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function recordSpend(spendData) {
  try {
    const result = await dataAccess.insertRecord(COLLECTIONS.spend, { ...spendData, created_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: true, spend: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getCostPerAcquisition(days = 90) {
  try {
    const spendRes = await dataAccess.queryRecords(COLLECTIONS.spend, { limit: 500, suppressAuth: true });
    const spendMap = {};
    (spendRes.items || []).forEach(s => { const ch = s.channel || 'other'; spendMap[ch] = (spendMap[ch] || 0) + (Number(s.amount) || 0); });

    const wonRes = await dataAccess.countRecords(COLLECTIONS.opportunities, { stage: 'closed_won' });
    return { success: true, cpa: Object.entries(spendMap).map(([ch, amt]) => ({ channel: ch, total_spend: Math.round(amt), deals_won: wonRes, cpa: wonRes > 0 ? Math.round(amt / wonRes) : null })) };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function addCompetitorIntel(intelData) {
  try {
    const result = await dataAccess.insertRecord(COLLECTIONS.competitorIntel, { ...intelData, captured_at: new Date().toISOString() }, { suppressAuth: true });
    return { success: true, intel: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getCompetitorIntel(filters = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.competitorIntel, { sort: [{ field: 'captured_at', direction: 'desc' }], limit: filters.limit || 50, suppressAuth: true });
    return { success: true, intel: res.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function saveSnapshot(snapshotData = {}) {
  try {
    const kpisRes = await getDashboardKPIs({ days: snapshotData.period_days || 30, ownerId: snapshotData.owner_id });
    if (!kpisRes.success) throw new Error('KPI fail');
    const k = kpisRes.kpis;
    const record = { owner_id: snapshotData.owner_id || 'all', period_end: new Date().toISOString(), pipeline_coverage: k.pipeline_coverage, win_rate: k.win_rate, avg_cycle_days: k.avg_cycle_days, created_at: new Date().toISOString() };
    const result = await dataAccess.insertRecord(COLLECTIONS.snapshots, record, { suppressAuth: true });
    return { success: true, snapshot: result.record };
  } catch (error) { return { success: false, error: error.message }; }
}

export async function getSnapshots(options = {}) {
  try {
    const res = await dataAccess.queryRecords(COLLECTIONS.snapshots, { sort: [{ field: 'period_end', direction: 'desc' }], limit: options.limit || 12, suppressAuth: true });
    return { success: true, snapshots: res.items || [] };
  } catch (error) { return { success: false, error: error.message }; }
}

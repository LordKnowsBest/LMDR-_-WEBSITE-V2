import wixData from 'wix-data';
import * as dataAccess from 'backend/dataAccess';

// ============================================================================
// COLLECTION KEYS
// ============================================================================

const COLLECTIONS = {
  activities: 'b2bActivities',
  accounts: 'b2bAccounts'
};

const ACTIVITY_TYPES = {
  EMAIL: 'email', SMS: 'sms', CALL: 'call', MEETING: 'meeting',
  TASK: 'task', NOTE: 'note', STAGE_CHANGE: 'stage_change', SIGNAL: 'signal'
};

// ============================================================================
// LOG ACTIVITIES
// ============================================================================

export async function logActivity(activityData) {
  try {
    if (!activityData.account_id || !activityData.type) return { success: false, error: 'Missing fields' };

    const record = {
      account_id: activityData.account_id, contact_id: activityData.contact_id || '',
      type: activityData.type, channel: activityData.channel || activityData.type,
      subject: activityData.subject || '', notes: activityData.notes || '',
      outcome: activityData.outcome || '', owner_id: activityData.owner_id || '',
      metadata: activityData.metadata ? JSON.stringify(activityData.metadata) : '',
      created_at: new Date().toISOString()
    };

    const result = await dataAccess.insertRecord(COLLECTIONS.activities, record, { suppressAuth: true });
    if (!result.success) throw new Error(result.error);

    updateAccountActivity(activityData.account_id).catch(() => {});
    return { success: true, activity: result.record };
  } catch (error) {
    console.error('logActivity error:', error);
    return { success: false, error: error.message };
  }
}

export async function logEmail(accountId, contactId, subject, outcome = 'sent', ownerId = '') {
  return logActivity({ account_id: accountId, contact_id: contactId, type: ACTIVITY_TYPES.EMAIL, channel: 'email', subject, outcome, owner_id: ownerId });
}

export async function logSms(accountId, contactId, subject, outcome = 'sent', ownerId = '') {
  return logActivity({ account_id: accountId, contact_id: contactId, type: ACTIVITY_TYPES.SMS, channel: 'sms', subject, outcome, owner_id: ownerId });
}

export async function logCall(accountId, contactId, callDetails = {}, ownerId = '') {
  return logActivity({
    account_id: accountId, contact_id: contactId, type: ACTIVITY_TYPES.CALL, channel: 'phone',
    subject: `Call - ${callDetails.outcome || 'completed'}`, notes: callDetails.notes || '',
    outcome: callDetails.outcome || 'completed', owner_id: ownerId,
    metadata: { duration: callDetails.duration, disposition: callDetails.disposition }
  });
}

export async function logMeeting(accountId, contactId, subject, notes = '', ownerId = '') {
  return logActivity({ account_id: accountId, contact_id: contactId, type: ACTIVITY_TYPES.MEETING, channel: 'in_person', subject, notes, outcome: 'completed', owner_id: ownerId });
}

export async function logTask(accountId, subject, outcome = 'completed', ownerId = '') {
  return logActivity({ account_id: accountId, type: ACTIVITY_TYPES.TASK, channel: 'platform', subject, outcome, owner_id: ownerId });
}

export async function logNote(accountId, notes, ownerId = '') {
  return logActivity({ account_id: accountId, type: ACTIVITY_TYPES.NOTE, channel: 'platform', subject: 'Note', notes, owner_id: ownerId });
}

export async function logStageChange(accountId, fromStage, toStage, ownerId = '') {
  return logActivity({ account_id: accountId, type: ACTIVITY_TYPES.STAGE_CHANGE, channel: 'platform', subject: `Stage: ${fromStage} â†’ ${toStage}`, outcome: 'completed', owner_id: ownerId, metadata: { from_stage: fromStage, to_stage: toStage } });
}

// ============================================================================
// ACTIVITY RETRIEVAL
// ============================================================================

export async function getAccountTimeline(accountId, options = {}) {
  try {
    if (!accountId) return { success: false, error: 'Account ID required' };
    const filters = { account_id: accountId };
    if (options.type) filters.type = options.type;
    if (options.contactId) filters.contact_id = options.contactId;
    if (options.since) filters.created_at = { gt: options.since };

    const result = await dataAccess.queryRecords(COLLECTIONS.activities, {
      filters, sort: [{ field: 'created_at', direction: 'desc' }],
      limit: options.limit || 50, suppressAuth: true
    });
    return { success: true, activities: result.items || [], totalCount: result.totalCount || result.items?.length };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getRecentActivities(options = {}) {
  try {
    const filters = {};
    if (options.ownerId) filters.owner_id = options.ownerId;
    if (options.type) filters.type = options.type;

    const result = await dataAccess.queryRecords(COLLECTIONS.activities, {
      filters, sort: [{ field: 'created_at', direction: 'desc' }],
      limit: options.limit || 20, suppressAuth: true
    });
    return { success: true, activities: result.items || [] };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getActivityCounts(accountId) {
  try {
    const result = await dataAccess.queryRecords(COLLECTIONS.activities, { filters: { account_id: accountId }, limit: 500, suppressAuth: true });
    const counts = { total: 0, email: 0, sms: 0, call: 0, meeting: 0, task: 0, note: 0 };
    (result.items || []).forEach(a => { counts.total++; if (counts.hasOwnProperty(a.type)) counts[a.type]++; });
    return { success: true, counts };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

export async function getActivityVelocity(ownerId, days = 7) {
  try {
    const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
    const result = await dataAccess.queryRecords(COLLECTIONS.activities, { filters: { owner_id: ownerId, created_at: { gt: since } }, limit: 500, suppressAuth: true });
    const activities = result.items || [];
    const byType = {};
    activities.forEach(a => { const t = a.type || 'other'; byType[t] = (byType[t] || 0) + 1; });
    return { success: true, velocity: { owner_id: ownerId, period_days: days, total_touches: activities.length, touches_per_day: Math.round((activities.length / days) * 10) / 10, by_type: byType } };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// ============================================================================
// INTERNAL HELPERS
// ============================================================================

async function updateAccountActivity(accountId) {
  try {
    const existing = await dataAccess.getRecord(COLLECTIONS.accounts, accountId, { suppressAuth: true });
    if (existing) {
      await dataAccess.updateRecord(COLLECTIONS.accounts, { ...existing, last_activity_at: new Date().toISOString() }, { suppressAuth: true });
    }
  } catch (err) { }
}

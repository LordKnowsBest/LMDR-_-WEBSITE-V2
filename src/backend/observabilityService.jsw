/**
 * Observability Service - System logging and tracing for Super Admin
 * Provides comprehensive visibility into system operations
 * 
 * This service uses unified dataAccess for dual-source support.
 *
 * @module backend/observabilityService
 */

import * as dataAccess from 'backend/dataAccess';
import { currentMember } from 'wix-members-backend';

// ============================================
// COLLECTION KEYS FOR DUAL-SOURCE ROUTING
// ============================================

const COLLECTION_KEYS = {
    logs: 'systemLogs',
    traces: 'systemTraces',
    errors: 'systemErrors',
    metrics: 'systemMetrics'
};

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    // Log levels
    levels: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        CRITICAL: 4
    },
    // Log sources/services
    sources: [
        'ai-enrichment',
        'ai-router',
        'carrier-matching',
        'social-scanner',
        'ocr-service',
        'scheduler',
        'auth',
        'api',
        'database',
        'external-api',
        'system'
    ]
};

// ============================================
// AUTHORIZATION
// ============================================

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const role = member.contactDetails?.customFields?.role || '';
        return role.toLowerCase() === 'super_admin';
    } catch (error) {
        return false;
    }
}

async function requireSuperAdmin() {
    if (!(await isSuperAdmin())) {
        throw new Error('Unauthorized: Super Admin access required');
    }
}

// ============================================
// AIRTABLE WRITE THROTTLE
// ============================================
// Only CRITICAL-level events get persisted to Airtable.
// Everything else is console-only to stay within the 50k record limit.
const PERSIST_THRESHOLD = 4; // CRITICAL = 4, ERROR = 3
let __logFailCount = 0;
const LOG_FAIL_THRESHOLD = 3;

// ============================================
// LOGGING FUNCTIONS
// ============================================

/**
 * Log an event to the system
 */
export async function log(logEntry) {
    const entry = {
        timestamp: new Date().toISOString(),
        level: logEntry.level || 'INFO',
        level_num: CONFIG.levels[logEntry.level] || 1,
        source: logEntry.source || 'system',
        message: logEntry.message || '',
        details: logEntry.details || {},
        trace_id: logEntry.traceId || generateTraceId(),
        span_id: logEntry.spanId || generateSpanId(),
        parent_span_id: logEntry.parentSpanId || null,
        user_id: logEntry.userId || null,
        session_id: logEntry.sessionId || null,
        duration: logEntry.duration || null,
        tags: Array.isArray(logEntry.tags) ? logEntry.tags.join(', ') : (logEntry.tags || '')
    };

    // Below CRITICAL threshold → console only, no Airtable write
    if (entry.level_num < PERSIST_THRESHOLD || __logFailCount >= LOG_FAIL_THRESHOLD) {
        return entry;
    }

    try {
        const errorRecord = {
            timestamp: entry.timestamp,
            level: entry.level,
            level_num: entry.level_num,
            source: entry.source,
            message: entry.message,
            details: typeof entry.details === 'object' ? JSON.stringify(entry.details) : String(entry.details),
            trace_id: entry.trace_id,
            span_id: entry.span_id,
            parent_span_id: entry.parent_span_id,
            user_id: entry.user_id,
            session_id: entry.session_id,
            duration: entry.duration,
            tags: entry.tags
        };
        await dataAccess.insertRecord(COLLECTION_KEYS.errors, errorRecord, { suppressAuth: true });
        __logFailCount = 0;
    } catch (error) {
        __logFailCount++;
        if (__logFailCount === LOG_FAIL_THRESHOLD) {
            console.warn('[Observability] Circuit breaker tripped — logging disabled');
        }
    }

    return entry;
}

/**
 * Log an AI operation
 */
export async function logAIOperation(aiLog) {
    return log({
        level: aiLog.error ? 'ERROR' : 'INFO',
        source: aiLog.source || 'ai-router',
        message: `AI ${aiLog.operation}: ${aiLog.functionId}`,
        details: aiLog,
        traceId: aiLog.traceId,
        spanId: aiLog.spanId,
        duration: aiLog.latencyMs,
        tags: ['ai', aiLog.provider, aiLog.functionId]
    });
}

/**
 * Log an external API call
 */
export async function logExternalAPI(apiLog) {
    return log({
        level: apiLog.statusCode >= 400 ? 'ERROR' : 'INFO',
        source: 'external-api',
        message: `${apiLog.method} ${apiLog.endpoint} - ${apiLog.statusCode}`,
        details: apiLog,
        traceId: apiLog.traceId,
        spanId: apiLog.spanId,
        duration: apiLog.latencyMs,
        tags: ['external-api', apiLog.service]
    });
}

/**
 * Log a database operation
 */
export async function logDatabase(dbLog) {
    // Console-only — database ops are too frequent to persist
    return { timestamp: new Date().toISOString(), level: 'DEBUG', source: 'database' };
}

// ============================================
// TRACING
// ============================================

/**
 * Start a new trace
 */
export async function startTrace(name, metadata = {}) {
    // In-memory only — no Airtable write (saves record quota)
    const traceId = generateTraceId();
    return {
        traceId,
        startSpan: (spanName) => startSpan(traceId, spanName)
    };
}

/**
 * Start a span within a trace
 */
export function startSpan(traceId, name, parentSpanId = null) {
    const spanId = generateSpanId();
    const startTime = Date.now();

    return {
        traceId,
        spanId,
        parentSpanId,
        name,
        startTime,
        end: async (status = 'success', metadata = {}) => {
            const duration = Date.now() - startTime;
            await log({
                level: status === 'error' ? 'ERROR' : 'DEBUG',
                source: 'trace',
                message: `Span: ${name}`,
                traceId,
                spanId,
                parentSpanId,
                duration,
                details: { status, ...metadata }
            });
            return { duration, status };
        }
    };
}

/**
 * End a trace
 */
export async function endTrace(traceId, status = 'completed', summary = {}) {
    // No-op — traces are in-memory only (saves record quota)
    return null;
}

// ============================================
// QUERY FUNCTIONS (Super Admin)
// ============================================

export async function getLogs(options = {}) {
    await requireSuperAdmin();

    try {
        const filters = {};
        if (options.level) filters.level = options.level;
        if (options.source) filters.service = options.source;
        
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.logs, {
            filters,
            sort: [{ field: 'log_date', direction: 'desc' }],
            limit: options.limit || 50,
            skip: options.skip || 0,
            suppressAuth: true
        });

        return {
            items: result.items,
            totalCount: result.totalCount || result.items.length,
            hasMore: result.items.length === (options.limit || 50),
            page: Math.floor((options.skip || 0) / (options.limit || 50)) + 1,
            pageSize: options.limit || 50
        };
    } catch (error) {
        console.error('[Observability] Error fetching logs:', error.message);
        throw new Error('Failed to fetch logs');
    }
}

export async function getTrace(traceId) {
    await requireSuperAdmin();

    try {
        const traceRes = await dataAccess.queryRecords(COLLECTION_KEYS.traces, {
            filters: { trace_id: traceId },
            limit: 1,
            suppressAuth: true
        });

        if (!traceRes.success || traceRes.items.length === 0) {
            throw new Error('Trace not found');
        }

        const errorLogs = await dataAccess.queryRecords(COLLECTION_KEYS.errors, {
            filters: { trace_id: traceId },
            sort: [{ field: 'timestamp', direction: 'asc' }],
            limit: 100,
            suppressAuth: true
        });

        return {
            trace: traceRes.items[0],
            logs: errorLogs.items || [],
            timeline: (errorLogs.items || []).map(l => ({
                timestamp: l.timestamp,
                spanId: l.span_id,
                parentSpanId: l.parent_span_id,
                message: l.message,
                duration: l.duration,
                level: l.level
            }))
        };
    } catch (error) {
        console.error('[Observability] Error fetching trace:', error.message);
        throw new Error('Failed to fetch trace');
    }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

function generateTraceId() {
    return 'tr_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

function generateSpanId() {
    return 'sp_' + Math.random().toString(36).substr(2, 12);
}
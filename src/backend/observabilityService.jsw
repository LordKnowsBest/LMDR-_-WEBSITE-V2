/**
 * Observability Service - System logging and tracing for Super Admin
 * Provides comprehensive visibility into system operations
 * 
 * This service uses unified dataAccess for dual-source support.
 *
 * @module backend/observabilityService
 */

import * as dataAccess from 'backend/dataAccess';
import { currentMember } from 'wix-members-backend';

// ============================================
// COLLECTION KEYS FOR DUAL-SOURCE ROUTING
// ============================================

const COLLECTION_KEYS = {
    logs: 'systemLogs',
    traces: 'systemTraces',
    errors: 'systemErrors',
    metrics: 'systemMetrics'
};

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
    // Log levels
    levels: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        CRITICAL: 4
    },
    // Log sources/services
    sources: [
        'ai-enrichment',
        'ai-router',
        'carrier-matching',
        'social-scanner',
        'ocr-service',
        'scheduler',
        'auth',
        'api',
        'database',
        'external-api',
        'system'
    ]
};

// ============================================
// AUTHORIZATION
// ============================================

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const role = member.contactDetails?.customFields?.role || '';
        return role.toLowerCase() === 'super_admin';
    } catch (error) {
        return false;
    }
}

async function requireSuperAdmin() {
    if (!(await isSuperAdmin())) {
        throw new Error('Unauthorized: Super Admin access required');
    }
}

// ============================================
// CIRCUIT BREAKER — stops writing after consecutive failures
// ============================================
let __logFailCount = 0;
const LOG_FAIL_THRESHOLD = 3; // After 3 consecutive failures, stop trying

// ============================================
// LOGGING FUNCTIONS
// ============================================

/**
 * Log an event to the system
 */
export async function log(logEntry) {
    // Circuit breaker: skip writes after consecutive failures (table full, etc.)
    if (__logFailCount >= LOG_FAIL_THRESHOLD) {
        return { timestamp: new Date().toISOString(), level: logEntry.level || 'INFO', skipped: true };
    }

    const entry = {
        timestamp: new Date().toISOString(),
        level: logEntry.level || 'INFO',
        level_num: CONFIG.levels[logEntry.level] || 1,
        source: logEntry.source || 'system',
        message: logEntry.message || '',
        details: logEntry.details || {},
        trace_id: logEntry.traceId || generateTraceId(),
        span_id: logEntry.spanId || generateSpanId(),
        parent_span_id: logEntry.parentSpanId || null,
        user_id: logEntry.userId || null,
        session_id: logEntry.sessionId || null,
        duration: logEntry.duration || null,
        tags: Array.isArray(logEntry.tags) ? logEntry.tags.join(', ') : (logEntry.tags || '')
    };

    try {
        // 1. Add to errors collection for ERROR/CRITICAL levels
        if (entry.level === 'ERROR' || entry.level === 'CRITICAL') {
            const errorRecord = {
                timestamp: entry.timestamp,
                level: entry.level,
                level_num: entry.level_num,
                source: entry.source,
                message: entry.message,
                details: typeof entry.details === 'object' ? JSON.stringify(entry.details) : String(entry.details),
                trace_id: entry.trace_id,
                span_id: entry.span_id,
                parent_span_id: entry.parent_span_id,
                user_id: entry.user_id,
                session_id: entry.session_id,
                duration: entry.duration,
                tags: entry.tags
            };
            await dataAccess.insertRecord(COLLECTION_KEYS.errors, errorRecord, { suppressAuth: true });
        }

        // 2. Main SystemLogs entry
        const logRecord = {
            log_id: entry.trace_id + '_' + entry.span_id,
            level: entry.level,
            service: entry.source,
            message: entry.message,
            log_date: entry.timestamp
        };
        await dataAccess.insertRecord(COLLECTION_KEYS.logs, logRecord, { suppressAuth: true });

        // Reset circuit breaker on success
        __logFailCount = 0;
    } catch (error) {
        __logFailCount++;
        if (__logFailCount === LOG_FAIL_THRESHOLD) {
            console.warn('[Observability] Circuit breaker tripped — logging disabled until next successful write');
        }
    }

    return entry;
}

/**
 * Log an AI operation
 */
export async function logAIOperation(aiLog) {
    return log({
        level: aiLog.error ? 'ERROR' : 'INFO',
        source: aiLog.source || 'ai-router',
        message: `AI ${aiLog.operation}: ${aiLog.functionId}`,
        details: aiLog,
        traceId: aiLog.traceId,
        spanId: aiLog.spanId,
        duration: aiLog.latencyMs,
        tags: ['ai', aiLog.provider, aiLog.functionId]
    });
}

/**
 * Log an external API call
 */
export async function logExternalAPI(apiLog) {
    return log({
        level: apiLog.statusCode >= 400 ? 'ERROR' : 'INFO',
        source: 'external-api',
        message: `${apiLog.method} ${apiLog.endpoint} - ${apiLog.statusCode}`,
        details: apiLog,
        traceId: apiLog.traceId,
        spanId: apiLog.spanId,
        duration: apiLog.latencyMs,
        tags: ['external-api', apiLog.service]
    });
}

/**
 * Log a database operation
 */
export async function logDatabase(dbLog) {
    return log({
        level: dbLog.error ? 'ERROR' : 'DEBUG',
        source: 'database',
        message: `${dbLog.operation} on ${dbLog.collection}`,
        details: dbLog,
        traceId: dbLog.traceId,
        spanId: dbLog.spanId,
        duration: dbLog.latencyMs,
        tags: ['database', dbLog.collection]
    });
}

// ============================================
// TRACING
// ============================================

/**
 * Start a new trace
 */
export async function startTrace(name, metadata = {}) {
    const trace = {
        trace_id: generateTraceId(),
        name,
        start_time: new Date().toISOString(),
        status: 'active',
        spans: '[]',
        metadata: typeof metadata === 'object' ? JSON.stringify(metadata) : String(metadata),
        tags: Array.isArray(metadata.tags) ? metadata.tags.join(', ') : (metadata.tags || '')
    };

    try {
        await dataAccess.insertRecord(COLLECTION_KEYS.traces, trace, { suppressAuth: true });
    } catch (error) {
        console.warn('[Observability] Could not persist trace:', error.message);
    }

    return {
        traceId: trace.trace_id,
        startSpan: (spanName) => startSpan(trace.trace_id, spanName)
    };
}

/**
 * Start a span within a trace
 */
export function startSpan(traceId, name, parentSpanId = null) {
    const spanId = generateSpanId();
    const startTime = Date.now();

    return {
        traceId,
        spanId,
        parentSpanId,
        name,
        startTime,
        end: async (status = 'success', metadata = {}) => {
            const duration = Date.now() - startTime;
            await log({
                level: status === 'error' ? 'ERROR' : 'DEBUG',
                source: 'trace',
                message: `Span: ${name}`,
                traceId,
                spanId,
                parentSpanId,
                duration,
                details: { status, ...metadata }
            });
            return { duration, status };
        }
    };
}

/**
 * End a trace
 */
export async function endTrace(traceId, status = 'completed', summary = {}) {
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.traces, {
            filters: { trace_id: traceId },
            limit: 1,
            suppressAuth: true
        });

        if (!result.success || result.items.length === 0) return null;

        const trace = result.items[0];
        const endTime = new Date();
        const startTime = new Date(trace.start_time);
        const duration = endTime.getTime() - startTime.getTime();

        const traceUpdate = {
            ...trace,
            _id: trace._id,
            end_time: endTime.toISOString(),
            status: status,
            duration: duration,
            summary: typeof summary === 'object' ? JSON.stringify(summary) : String(summary)
        };

        const updateResult = await dataAccess.updateRecord(COLLECTION_KEYS.traces, traceUpdate, { suppressAuth: true });
        return updateResult.record;
    } catch (error) {
        console.error('[Observability] Failed to end trace:', error.message);
        return null;
    }
}

// ============================================
// QUERY FUNCTIONS (Super Admin)
// ============================================

export async function getLogs(options = {}) {
    await requireSuperAdmin();

    try {
        const filters = {};
        if (options.level) filters.level = options.level;
        if (options.source) filters.service = options.source;
        
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.logs, {
            filters,
            sort: [{ field: 'log_date', direction: 'desc' }],
            limit: options.limit || 50,
            skip: options.skip || 0,
            suppressAuth: true
        });

        return {
            items: result.items,
            totalCount: result.totalCount || result.items.length,
            hasMore: result.items.length === (options.limit || 50),
            page: Math.floor((options.skip || 0) / (options.limit || 50)) + 1,
            pageSize: options.limit || 50
        };
    } catch (error) {
        console.error('[Observability] Error fetching logs:', error.message);
        throw new Error('Failed to fetch logs');
    }
}

export async function getTrace(traceId) {
    await requireSuperAdmin();

    try {
        const traceRes = await dataAccess.queryRecords(COLLECTION_KEYS.traces, {
            filters: { trace_id: traceId },
            limit: 1,
            suppressAuth: true
        });

        if (!traceRes.success || traceRes.items.length === 0) {
            throw new Error('Trace not found');
        }

        const errorLogs = await dataAccess.queryRecords(COLLECTION_KEYS.errors, {
            filters: { trace_id: traceId },
            sort: [{ field: 'timestamp', direction: 'asc' }],
            limit: 100,
            suppressAuth: true
        });

        return {
            trace: traceRes.items[0],
            logs: errorLogs.items || [],
            timeline: (errorLogs.items || []).map(l => ({
                timestamp: l.timestamp,
                spanId: l.span_id,
                parentSpanId: l.parent_span_id,
                message: l.message,
                duration: l.duration,
                level: l.level
            }))
        };
    } catch (error) {
        console.error('[Observability] Error fetching trace:', error.message);
        throw new Error('Failed to fetch trace');
    }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

function generateTraceId() {
    return 'tr_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

function generateSpanId() {
    return 'sp_' + Math.random().toString(36).substr(2, 12);
}
import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================
// CONFIGURATION
// ============================================

const COLLECTION_KEYS = {
    auditLog: 'auditLog',
    drivers: 'driverProfiles',
    carriers: 'carriers'
};

// Action categories for filtering
const ACTION_CATEGORIES = {
    driver: ['verifyDriver', 'suspendDriver', 'updateDriverStatus', 'bulkVerify', 'bulkSuspend', 'sendDriverEmail'],
    carrier: ['flagCarrier', 'unflagCarrier', 'updateCarrierStatus', 'refreshEnrichment', 'bulkActivate', 'bulkDeactivate', 'bulkFlag'],
    system: ['resolveAlert', 'updateSettings', 'exportData'],
    auth: ['adminLogin', 'adminLogout', 'roleChange']
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) { return false; }
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized');
}

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const memberRole = member.contactDetails?.customFields?.role || '';
        return memberRole.toLowerCase() === 'super_admin';
    } catch (error) { return false; }
}

// ============================================
// AUDIT LOG QUERIES
// ============================================

export async function getAuditLog(options = {}) {
    await requireAdmin();
    const { filters = {}, page = 1, pageSize = 50, sortField = 'timestamp', sortDirection = 'desc' } = options;

    try {
        const queryFilters = {};
        if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;
        if (filters.category && filters.category !== 'all') {
            const catActions = ACTION_CATEGORIES[filters.category] || [];
            if (catActions.length) queryFilters.action = { hasSome: catActions };
        }
        if (filters.targetType && filters.targetType !== 'all') queryFilters.targetType = filters.targetType;
        if (filters.adminId && filters.adminId !== 'all') queryFilters.adminId = filters.adminId;
        if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
        if (filters.search) queryFilters.adminEmail = { contains: filters.search };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, {
            filters: queryFilters, sort: [{ field: sortField, direction: sortDirection }],
            limit: pageSize, skip: (page - 1) * pageSize, suppressAuth: true
        });

        const enrichedEntries = (result.items || []).map(entry => ({
            ...entry, actionLabel: formatActionLabel(entry.action),
            category: getActionCategory(entry.action), relativeTime: getRelativeTime(entry.timestamp)
        }));

        return { entries: enrichedEntries, totalCount: result.totalCount || enrichedEntries.length, currentPage: page, pageSize, totalPages: Math.ceil((result.totalCount || enrichedEntries.length) / pageSize) };
    } catch (error) {
        console.error('getAuditLog error:', error);
        throw new Error('Failed to fetch audit log');
    }
}

export async function getAuditEntryDetail(entryId) {
    await requireAdmin();
    try {
        const entry = await dataAccess.getRecord(COLLECTION_KEYS.auditLog, entryId, { suppressAuth: true });
        if (!entry) throw new Error('Not found');

        let targetDetails = null;
        if (entry.targetId) {
            const key = entry.targetType === 'driver' ? COLLECTION_KEYS.drivers : COLLECTION_KEYS.carriers;
            targetDetails = await dataAccess.getRecord(key, entry.targetId, { suppressAuth: true }).catch(() => null);
        }

        const relatedRes = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, {
            filters: { targetId: entry.targetId, _id: { ne: entryId } },
            sort: [{ field: 'timestamp', direction: 'desc' }], limit: 10, suppressAuth: true
        });

        return { ...entry, targetDetails, relatedEntries: relatedRes.items || [] };
    } catch (error) { throw new Error('Failed to fetch audit entry'); }
}

export async function getAuditStats() {
    await requireAdmin();
    try {
        const weekAgo = new Date(); weekAgo.setDate(weekAgo.getDate() - 7);
        const monthAgo = new Date(); monthAgo.setDate(monthAgo.getDate() - 30);
        const today = new Date(); today.setHours(0,0,0,0);

        const [total, todayCount, weekCount, monthCount] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, {}),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: today } }),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: weekAgo } }),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: monthAgo } })
        ]);

        const weekRes = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { filters: { timestamp: { gte: weekAgo } }, limit: 1000, suppressAuth: true });
        const adminCounts = {}, actionCounts = {}, targetTypeCounts = {};
        (weekRes.items || []).forEach(e => {
            if (e.adminEmail) adminCounts[e.adminEmail] = (adminCounts[e.adminEmail] || 0) + 1;
            if (e.action) actionCounts[e.action] = (actionCounts[e.action] || 0) + 1;
            if (e.targetType) targetTypeCounts[e.targetType] = (targetTypeCounts[e.targetType] || 0) + 1;
        });

        const topAdmins = Object.entries(adminCounts).sort((a,b) => b[1]-a[1]).slice(0, 5).map(([email, count]) => ({ email, count }));
        const topActions = Object.entries(actionCounts).sort((a,b) => b[1]-a[1]).slice(0, 5).map(([action, count]) => ({ action, count }));

        return { total, today: todayCount, thisWeek: weekCount, thisMonth: monthCount, dailyAverage: Math.round(weekCount / 7), topAdmins, topActions, targetTypeCounts };
    } catch (error) { throw new Error('Failed to fetch audit stats'); }
}

export async function getAdminList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { limit: 1000, suppressAuth: true });
    const admins = new Set();
    (res.items || []).forEach(e => { if (e.adminEmail && e.adminEmail !== 'system') admins.add(e.adminEmail); });
    return Array.from(admins).sort();
}

export async function getActionList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { limit: 1000, suppressAuth: true });
    const actions = new Set();
    (res.items || []).forEach(e => { if (e.action) actions.add(e.action); });
    return Array.from(actions).sort();
}

export async function exportAuditLogCSV(filters = {}) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    const queryFilters = {};
    if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
    if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;

    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { filters: queryFilters, sort: [{ field: 'timestamp', direction: 'desc' }], limit: 5000, suppressAuth: true });
    const items = res.items || [];

    const headers = ['Timestamp', 'Action', 'Target Type', 'Target ID', 'Admin Email', 'Details'];
    const rows = items.map(e => [e.timestamp, e.action, e.targetType, e.targetId, e.adminEmail, JSON.stringify(e.details)]);
    return [headers.join(','), ...rows.map(row => row.map(c => `"${String(c).replace(/"/g, '""')}"`).join(','))].join('\n');
}

function formatActionLabel(action) {
    const labels = { verifyDriver: 'Verify Driver', suspendDriver: 'Suspend Driver', updateDriverStatus: 'Update Status', flagCarrier: 'Flag Carrier', unflagCarrier: 'Unflag Carrier' };
    return labels[action] || action;
}

function getActionCategory(action) {
    for (const [cat, actions] of Object.entries(ACTION_CATEGORIES)) if (actions.includes(action)) return cat;
    return 'other';
}

function getRelativeTime(ts) {
    if (!ts) return '';
    const diff = new Date() - new Date(ts);
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff/60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff/3600000)}h ago`;
    return new Date(ts).toLocaleDateString();
}
import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================
// CONFIGURATION
// ============================================

const COLLECTION_KEYS = {
    auditLog: 'auditLog',
    drivers: 'driverProfiles',
    carriers: 'carriers'
};

// Action categories for filtering
const ACTION_CATEGORIES = {
    driver: ['verifyDriver', 'suspendDriver', 'updateDriverStatus', 'bulkVerify', 'bulkSuspend', 'sendDriverEmail'],
    carrier: ['flagCarrier', 'unflagCarrier', 'updateCarrierStatus', 'refreshEnrichment', 'bulkActivate', 'bulkDeactivate', 'bulkFlag'],
    system: ['resolveAlert', 'updateSettings', 'exportData'],
    auth: ['adminLogin', 'adminLogout', 'roleChange']
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) { return false; }
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized');
}

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const memberRole = member.contactDetails?.customFields?.role || '';
        return memberRole.toLowerCase() === 'super_admin';
    } catch (error) { return false; }
}

// ============================================
// AUDIT LOG QUERIES
// ============================================

export async function getAuditLog(options = {}) {
    await requireAdmin();
    const { filters = {}, page = 1, pageSize = 50, sortField = 'timestamp', sortDirection = 'desc' } = options;

    try {
        const queryFilters = {};
        if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;
        if (filters.category && filters.category !== 'all') {
            const catActions = ACTION_CATEGORIES[filters.category] || [];
            if (catActions.length) queryFilters.action = { hasSome: catActions };
        }
        if (filters.targetType && filters.targetType !== 'all') queryFilters.targetType = filters.targetType;
        if (filters.adminId && filters.adminId !== 'all') queryFilters.adminId = filters.adminId;
        if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
        if (filters.search) queryFilters.adminEmail = { contains: filters.search };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, {
            filters: queryFilters, sort: [{ field: sortField, direction: sortDirection }],
            limit: pageSize, skip: (page - 1) * pageSize, suppressAuth: true
        });

        const enrichedEntries = (result.items || []).map(entry => ({
            ...entry, actionLabel: formatActionLabel(entry.action),
            category: getActionCategory(entry.action), relativeTime: getRelativeTime(entry.timestamp)
        }));

        return { entries: enrichedEntries, totalCount: result.totalCount || enrichedEntries.length, currentPage: page, pageSize, totalPages: Math.ceil((result.totalCount || enrichedEntries.length) / pageSize) };
    } catch (error) {
        console.error('getAuditLog error:', error);
        throw new Error('Failed to fetch audit log');
    }
}

export async function getAuditEntryDetail(entryId) {
    await requireAdmin();
    try {
        const entry = await dataAccess.getRecord(COLLECTION_KEYS.auditLog, entryId, { suppressAuth: true });
        if (!entry) throw new Error('Not found');

        let targetDetails = null;
        if (entry.targetId) {
            const key = entry.targetType === 'driver' ? COLLECTION_KEYS.drivers : COLLECTION_KEYS.carriers;
            targetDetails = await dataAccess.getRecord(key, entry.targetId, { suppressAuth: true }).catch(() => null);
        }

        const relatedRes = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, {
            filters: { targetId: entry.targetId, _id: { ne: entryId } },
            sort: [{ field: 'timestamp', direction: 'desc' }], limit: 10, suppressAuth: true
        });

        return { ...entry, targetDetails, relatedEntries: relatedRes.items || [] };
    } catch (error) { throw new Error('Failed to fetch audit entry'); }
}

export async function getAuditStats() {
    await requireAdmin();
    try {
        const weekAgo = new Date(); weekAgo.setDate(weekAgo.getDate() - 7);
        const monthAgo = new Date(); monthAgo.setDate(monthAgo.getDate() - 30);
        const today = new Date(); today.setHours(0,0,0,0);

        const [total, todayCount, weekCount, monthCount] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, {}),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: today } }),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: weekAgo } }),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: monthAgo } })
        ]);

        const weekRes = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { filters: { timestamp: { gte: weekAgo } }, limit: 1000, suppressAuth: true });
        const adminCounts = {}, actionCounts = {}, targetTypeCounts = {};
        (weekRes.items || []).forEach(e => {
            if (e.adminEmail) adminCounts[e.adminEmail] = (adminCounts[e.adminEmail] || 0) + 1;
            if (e.action) actionCounts[e.action] = (actionCounts[e.action] || 0) + 1;
            if (e.targetType) targetTypeCounts[e.targetType] = (targetTypeCounts[e.targetType] || 0) + 1;
        });

        const topAdmins = Object.entries(adminCounts).sort((a,b) => b[1]-a[1]).slice(0, 5).map(([email, count]) => ({ email, count }));
        const topActions = Object.entries(actionCounts).sort((a,b) => b[1]-a[1]).slice(0, 5).map(([action, count]) => ({ action, count }));

        return { total, today: todayCount, thisWeek: weekCount, thisMonth: monthCount, dailyAverage: Math.round(weekCount / 7), topAdmins, topActions, targetTypeCounts };
    } catch (error) { throw new Error('Failed to fetch audit stats'); }
}

export async function getAdminList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { limit: 1000, suppressAuth: true });
    const admins = new Set();
    (res.items || []).forEach(e => { if (e.adminEmail && e.adminEmail !== 'system') admins.add(e.adminEmail); });
    return Array.from(admins).sort();
}

export async function getActionList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { limit: 1000, suppressAuth: true });
    const actions = new Set();
    (res.items || []).forEach(e => { if (e.action) actions.add(e.action); });
    return Array.from(actions).sort();
}

export async function exportAuditLogCSV(filters = {}) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    const queryFilters = {};
    if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
    if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;

    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { filters: queryFilters, sort: [{ field: 'timestamp', direction: 'desc' }], limit: 5000, suppressAuth: true });
    const items = res.items || [];

    const headers = ['Timestamp', 'Action', 'Target Type', 'Target ID', 'Admin Email', 'Details'];
    const rows = items.map(e => [e.timestamp, e.action, e.targetType, e.targetId, e.adminEmail, JSON.stringify(e.details)]);
    return [headers.join(','), ...rows.map(row => row.map(c => `"${String(c).replace(/"/g, '""')}"`).join(','))].join('\n');
}

// ============================================
// REPORTING (Phase 8.3)
// ============================================

/**
 * Create a new scheduled report
 */
export async function createScheduledReport(schedule) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    try {
        const member = await currentMember.getMember();
        const data = {
            ...schedule,
            enabled: true,
            createdBy: member?.loginEmail || 'admin',
            createdAt: new Date(),
            nextRun: calculateNextRun(schedule)
        };

        const result = await dataAccess.insertRecord('scheduledReports', data, { suppressAuth: true });
        return result.record;
    } catch (error) {
        throw new Error('Failed to create scheduled report');
    }
}

/**
 * Get all scheduled reports
 */
export async function getScheduledReports() {
    await requireAdmin();
    const result = await dataAccess.queryRecords('scheduledReports', { suppressAuth: true });
    return result.items || [];
}

/**
 * Generate a one-time compliance report
 */
export async function generateComplianceReport(options) {
    await requireAdmin();
    const { reportType, dateFrom, dateTo, filters = {} } = options;

    try {
        const member = await currentMember.getMember();
        const reportRecord = {
            reportType,
            name: `${formatActionLabel(reportType)} Report`,
            status: 'generating',
            requestedBy: member?.loginEmail || 'admin',
            requestedAt: new Date(),
            dateRangeStart: dateFrom,
            dateRangeEnd: dateTo
        };

        const insertRes = await dataAccess.insertRecord('complianceReports', reportRecord, { suppressAuth: true });
        const reportId = insertRes.record._id;

        // In a real system, this would be a background job
        // For MVP, we generate it inline or simulate it
        const csvData = await generateReportCSV(reportType, { dateFrom, dateTo, ...filters });
        
        await dataAccess.updateRecord('complianceReports', {
            _id: reportId,
            status: 'completed',
            completedAt: new Date(),
            recordCount: csvData.split('\n').length - 1,
            // In Wix, we might upload to Media Manager and store URL
            fileUrl: 'internal://csv-data-' + reportId 
        }, { suppressAuth: true });

        return { success: true, reportId, csvData };
    } catch (error) {
        console.error('generateComplianceReport error:', error);
        throw new Error('Failed to generate report');
    }
}

/**
 * Run all due scheduled reports (called by scheduler)
 */
export async function runScheduledReports() {
    const now = new Date();
    try {
        const result = await dataAccess.queryRecords('scheduledReports', {
            filters: { enabled: true, nextRun: { lte: now } },
            suppressAuth: true
        });

        const reports = result.items || [];
        for (const schedule of reports) {
            await generateComplianceReport({
                reportType: schedule.reportType,
                filters: schedule.filters,
                scheduledId: schedule._id
            });

            // Update next run
            await dataAccess.updateRecord('scheduledReports', {
                _id: schedule._id,
                lastRun: now,
                nextRun: calculateNextRun(schedule)
            }, { suppressAuth: true });
        }

        return { processed: reports.length };
    } catch (error) {
        console.error('runScheduledReports error:', error);
        return { error: error.message };
    }
}

// ============================================
// HELPERS
// ============================================

function calculateNextRun(schedule) {
    const now = new Date();
    const next = new Date(now);
    if (schedule.frequency === 'daily') next.setDate(now.getDate() + 1);
    else if (schedule.frequency === 'weekly') next.setDate(now.getDate() + 7);
    else next.setMonth(now.getMonth() + 1);
    return next;
}

async function generateReportCSV(type, options) {
    // Re-use exportAuditLogCSV or similar logic based on type
    if (type === 'audit_log') return await exportAuditLogCSV(options);
    
    // Generic fallback for other types
    return "Date,Action,Status\n" + new Date().toISOString() + ",Report Generated,Success";
}

function formatActionLabel(action) {
    const labels = { verifyDriver: 'Verify Driver', suspendDriver: 'Suspend Driver', updateDriverStatus: 'Update Status', flagCarrier: 'Flag Carrier', unflagCarrier: 'Unflag Carrier' };
    return labels[action] || action;
}

function getActionCategory(action) {
    for (const [cat, actions] of Object.entries(ACTION_CATEGORIES)) if (actions.includes(action)) return cat;
    return 'other';
}

function getRelativeTime(ts) {
    if (!ts) return '';
    const diff = new Date() - new Date(ts);
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff/60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff/3600000)}h ago`;
    return new Date(ts).toLocaleDateString();
}
import { currentMember } from 'wix-members-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================
// CONFIGURATION
// ============================================

const COLLECTION_KEYS = {
    auditLog: 'auditLog',
    drivers: 'driverProfiles',
    carriers: 'carriers'
};

// Action categories for filtering
const ACTION_CATEGORIES = {
    driver: ['verifyDriver', 'suspendDriver', 'updateDriverStatus', 'bulkVerify', 'bulkSuspend', 'sendDriverEmail'],
    carrier: ['flagCarrier', 'unflagCarrier', 'updateCarrierStatus', 'refreshEnrichment', 'bulkActivate', 'bulkDeactivate', 'bulkFlag'],
    system: ['resolveAlert', 'updateSettings', 'exportData'],
    auth: ['adminLogin', 'adminLogout', 'roleChange']
};

// ============================================
// AUTHORIZATION
// ============================================

async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';
        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) { return false; }
}

async function requireAdmin() {
    if (!await isAdmin()) throw new Error('Unauthorized');
}

async function isSuperAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;
        const memberRole = member.contactDetails?.customFields?.role || '';
        return memberRole.toLowerCase() === 'super_admin';
    } catch (error) { return false; }
}

// ============================================
// AUDIT LOG QUERIES
// ============================================

export async function getAuditLog(options = {}) {
    await requireAdmin();
    const { filters = {}, page = 1, pageSize = 50, sortField = 'timestamp', sortDirection = 'desc' } = options;

    try {
        const queryFilters = {};
        if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;
        if (filters.category && filters.category !== 'all') {
            const catActions = ACTION_CATEGORIES[filters.category] || [];
            if (catActions.length) queryFilters.action = { hasSome: catActions };
        }
        if (filters.targetType && filters.targetType !== 'all') queryFilters.targetType = filters.targetType;
        if (filters.adminId && filters.adminId !== 'all') queryFilters.adminId = filters.adminId;
        if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
        if (filters.search) queryFilters.adminEmail = { contains: filters.search };

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, {
            filters: queryFilters, sort: [{ field: sortField, direction: sortDirection }],
            limit: pageSize, skip: (page - 1) * pageSize, suppressAuth: true
        });

        const enrichedEntries = (result.items || []).map(entry => ({
            ...entry, actionLabel: formatActionLabel(entry.action),
            category: getActionCategory(entry.action), relativeTime: getRelativeTime(entry.timestamp)
        }));

        return { entries: enrichedEntries, totalCount: result.totalCount || enrichedEntries.length, currentPage: page, pageSize, totalPages: Math.ceil((result.totalCount || enrichedEntries.length) / pageSize) };
    } catch (error) {
        console.error('getAuditLog error:', error);
        throw new Error('Failed to fetch audit log');
    }
}

export async function getAuditEntryDetail(entryId) {
    await requireAdmin();
    try {
        const entry = await dataAccess.getRecord(COLLECTION_KEYS.auditLog, entryId, { suppressAuth: true });
        if (!entry) throw new Error('Not found');

        let targetDetails = null;
        if (entry.targetId) {
            const key = entry.targetType === 'driver' ? COLLECTION_KEYS.drivers : COLLECTION_KEYS.carriers;
            targetDetails = await dataAccess.getRecord(key, entry.targetId, { suppressAuth: true }).catch(() => null);
        }

        const relatedRes = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, {
            filters: { targetId: entry.targetId, _id: { ne: entryId } },
            sort: [{ field: 'timestamp', direction: 'desc' }], limit: 10, suppressAuth: true
        });

        return { ...entry, targetDetails, relatedEntries: relatedRes.items || [] };
    } catch (error) { throw new Error('Failed to fetch audit entry'); }
}

export async function getAuditStats() {
    await requireAdmin();
    try {
        const weekAgo = new Date(); weekAgo.setDate(weekAgo.getDate() - 7);
        const monthAgo = new Date(); monthAgo.setDate(monthAgo.getDate() - 30);
        const today = new Date(); today.setHours(0,0,0,0);

        const [total, todayCount, weekCount, monthCount] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, {}),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: today } }),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: weekAgo } }),
            dataAccess.countRecords(COLLECTION_KEYS.auditLog, { timestamp: { gte: monthAgo } })
        ]);

        const weekRes = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { filters: { timestamp: { gte: weekAgo } }, limit: 1000, suppressAuth: true });
        const adminCounts = {}, actionCounts = {}, targetTypeCounts = {};
        (weekRes.items || []).forEach(e => {
            if (e.adminEmail) adminCounts[e.adminEmail] = (adminCounts[e.adminEmail] || 0) + 1;
            if (e.action) actionCounts[e.action] = (actionCounts[e.action] || 0) + 1;
            if (e.targetType) targetTypeCounts[e.targetType] = (targetTypeCounts[e.targetType] || 0) + 1;
        });

        const topAdmins = Object.entries(adminCounts).sort((a,b) => b[1]-a[1]).slice(0, 5).map(([email, count]) => ({ email, count }));
        const topActions = Object.entries(actionCounts).sort((a,b) => b[1]-a[1]).slice(0, 5).map(([action, count]) => ({ action, count }));

        return { total, today: todayCount, thisWeek: weekCount, thisMonth: monthCount, dailyAverage: Math.round(weekCount / 7), topAdmins, topActions, targetTypeCounts };
    } catch (error) { throw new Error('Failed to fetch audit stats'); }
}

export async function getAdminList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { limit: 1000, suppressAuth: true });
    const admins = new Set();
    (res.items || []).forEach(e => { if (e.adminEmail && e.adminEmail !== 'system') admins.add(e.adminEmail); });
    return Array.from(admins).sort();
}

export async function getActionList() {
    await requireAdmin();
    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { limit: 1000, suppressAuth: true });
    const actions = new Set();
    (res.items || []).forEach(e => { if (e.action) actions.add(e.action); });
    return Array.from(actions).sort();
}

export async function exportAuditLogCSV(filters = {}) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    const queryFilters = {};
    if (filters.dateFrom) queryFilters.timestamp = { gte: new Date(filters.dateFrom) };
    if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;

    const res = await dataAccess.queryRecords(COLLECTION_KEYS.auditLog, { filters: queryFilters, sort: [{ field: 'timestamp', direction: 'desc' }], limit: 5000, suppressAuth: true });
    const items = res.items || [];

    const headers = ['Timestamp', 'Action', 'Target Type', 'Target ID', 'Admin Email', 'Details'];
    const rows = items.map(e => [e.timestamp, e.action, e.targetType, e.targetId, e.adminEmail, JSON.stringify(e.details)]);
    return [headers.join(','), ...rows.map(row => row.map(c => `"${String(c).replace(/"/g, '""')}"`).join(','))].join('\n');
}

// ============================================
// REPORTING (Admin Utility Expansion - Phase 3)
// ============================================

const REPORT_TEMPLATES = [
    {
        reportType: 'admin_activity',
        name: 'Admin Activity',
        description: 'All admin actions grouped by admin and action type'
    },
    {
        reportType: 'data_access',
        name: 'Data Access',
        description: 'Profile views, searches, and export actions'
    },
    {
        reportType: 'system_changes',
        name: 'System Changes',
        description: 'Config and permission/rule updates'
    },
    {
        reportType: 'security_events',
        name: 'Security Events',
        description: 'Failed login attempts, anomaly alerts, and rate-limit events'
    },
    {
        reportType: 'full_audit',
        name: 'Full Audit Trail',
        description: 'Complete raw audit log export'
    },
    {
        reportType: 'custom',
        name: 'Custom',
        description: 'User-defined filters and categories'
    }
];

export async function getReportTemplates() {
    await requireAdmin();
    return REPORT_TEMPLATES;
}

export async function getReportStatus(reportId) {
    await requireAdmin();
    return dataAccess.getRecord('complianceReports', reportId, { suppressAuth: true });
}

export async function listComplianceReports(options = {}) {
    await requireAdmin();
    const result = await dataAccess.queryRecords('complianceReports', {
        filters: options.filters || {},
        sort: [{ field: 'requestedAt', direction: 'desc' }],
        limit: options.limit || 50,
        skip: options.skip || 0,
        suppressAuth: true
    });
    return {
        items: result.items || [],
        totalCount: result.totalCount || (result.items || []).length
    };
}

export async function deleteComplianceReport(reportId) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');
    return dataAccess.removeRecord('complianceReports', reportId, { suppressAuth: true });
}

export async function downloadReport(reportId) {
    await requireAdmin();
    const report = await dataAccess.getRecord('complianceReports', reportId, { suppressAuth: true });
    if (!report) throw new Error('Report not found');
    if (report.expiresAt && new Date(report.expiresAt) < new Date()) {
        throw new Error('Report link expired');
    }
    await logAuditEntry('downloadComplianceReport', reportId, { reportType: report.reportType });
    return {
        reportId: report._id,
        status: report.status,
        format: report.format,
        fileUrl: report.fileUrl,
        fileContent: report.fileContent || null
    };
}

export async function createScheduledReport(schedule) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    const member = await currentMember.getMember();
    const data = {
        ...schedule,
        enabled: schedule.enabled !== false,
        createdBy: member?.loginEmail || 'admin',
        createdAt: new Date(),
        nextRun: calculateNextRun(schedule, new Date())
    };

    const result = await dataAccess.insertRecord('scheduledReports', data, { suppressAuth: true });
    await logAuditEntry('createScheduledReport', result.record?._id || 'unknown', { reportType: schedule.reportType });
    return result.record;
}

export async function updateScheduledReport(scheduleId, updates) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');
    const existing = await dataAccess.getRecord('scheduledReports', scheduleId, { suppressAuth: true });
    if (!existing) throw new Error('Scheduled report not found');
    const merged = {
        ...existing,
        ...updates,
        _id: scheduleId,
        updatedAt: new Date()
    };
    merged.nextRun = calculateNextRun(merged, new Date());
    const updated = await dataAccess.updateRecord('scheduledReports', merged, { suppressAuth: true });
    await logAuditEntry('updateScheduledReport', scheduleId, { updates });
    return updated;
}

export async function deleteScheduledReport(scheduleId) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');
    await logAuditEntry('deleteScheduledReport', scheduleId, {});
    return dataAccess.removeRecord('scheduledReports', scheduleId, { suppressAuth: true });
}

export async function getScheduledReports() {
    await requireAdmin();
    const result = await dataAccess.queryRecords('scheduledReports', {
        sort: [{ field: 'nextRun', direction: 'asc' }],
        limit: 200,
        suppressAuth: true
    });
    return result.items || [];
}

export async function generateComplianceReport(options) {
    await requireAdmin();
    if (!await isSuperAdmin()) throw new Error('Super admin only');

    const {
        reportType,
        name,
        description = '',
        dateRangeStart,
        dateRangeEnd,
        filters = {},
        format = 'csv',
        scheduledId = null,
        maskPII = true
    } = options || {};

    if (!reportType) throw new Error('reportType is required');
    if (!['csv', 'json', 'pdf'].includes(String(format).toLowerCase())) {
        throw new Error('Unsupported report format');
    }

    const member = await currentMember.getMember();
    const now = new Date();
    const reportRecord = {
        reportType,
        name: name || `${reportType} report`,
        description,
        dateRangeStart: dateRangeStart || null,
        dateRangeEnd: dateRangeEnd || null,
        filters,
        format: String(format).toLowerCase(),
        status: 'generating',
        requestedBy: member?.loginEmail || 'admin',
        requestedAt: now,
        scheduledId
    };

    const created = await dataAccess.insertRecord('complianceReports', reportRecord, { suppressAuth: true });
    const reportId = created.record._id;

    try {
        const rows = await aggregateReportRows(reportType, { dateRangeStart, dateRangeEnd, filters });
        const safeRows = maskPII ? rows.map((row) => applyPIIMasking(row)) : rows;
        const limitedRows = safeRows.slice(0, 10000);
        const payload = formatReportPayload(format, limitedRows);
        const fileName = buildReportFileName(reportType, format);

        const updated = await dataAccess.updateRecord('complianceReports', {
            _id: reportId,
            status: 'completed',
            completedAt: new Date(),
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
            recordCount: limitedRows.length,
            fileSize: payload.length,
            fileUrl: `internal://compliance-reports/${reportId}/${fileName}`,
            fileContent: payload
        }, { suppressAuth: true });

        await logAuditEntry('generateComplianceReport', reportId, {
            reportType,
            format: String(format).toLowerCase(),
            recordCount: limitedRows.length
        });

        return {
            success: true,
            reportId,
            report: updated
        };
    } catch (error) {
        await dataAccess.updateRecord('complianceReports', {
            _id: reportId,
            status: 'failed',
            completedAt: new Date(),
            errorMessage: error.message
        }, { suppressAuth: true });
        console.error('generateComplianceReport error:', error);
        throw new Error('Failed to generate report');
    }
}

export async function runScheduledReports() {
    const now = new Date();
    try {
        const result = await dataAccess.queryRecords('scheduledReports', {
            filters: { enabled: true, nextRun: { lte: now } },
            limit: 100,
            suppressAuth: true
        });

        const reports = result.items || [];
        const outcomes = [];
        for (const schedule of reports) {
            try {
                const runResult = await generateComplianceReport({
                    reportType: schedule.reportType,
                    name: schedule.name,
                    format: schedule.format || 'csv',
                    filters: schedule.filters || {},
                    scheduledId: schedule._id
                });
                await dataAccess.updateRecord('scheduledReports', {
                    ...schedule,
                    _id: schedule._id,
                    lastRun: now,
                    nextRun: calculateNextRun(schedule, now)
                }, { suppressAuth: true });
                outcomes.push({ scheduleId: schedule._id, success: true, reportId: runResult.reportId });
            } catch (error) {
                outcomes.push({ scheduleId: schedule._id, success: false, error: error.message });
            }
        }

        return { processed: reports.length, outcomes };
    } catch (error) {
        console.error('runScheduledReports error:', error);
        return { error: error.message };
    }
}

export async function aggregateAdminActivity(dateRange = {}, filters = {}) {
    const rows = await aggregateAuditRows(dateRange, filters);
    const grouped = {};
    rows.forEach((row) => {
        const key = `${row.adminEmail || 'system'}::${row.action || 'unknown'}`;
        grouped[key] = (grouped[key] || 0) + 1;
    });
    return Object.entries(grouped).map(([key, count]) => {
        const [adminEmail, action] = key.split('::');
        return { adminEmail, action, count };
    });
}

export async function aggregateDataAccess(dateRange = {}, filters = {}) {
    const [carrierViews, profileViews, auditRows] = await Promise.all([
        dataAccess.queryRecords('carrierDriverViews', {
            filters: buildDateFilters('viewedAt', dateRange),
            limit: 5000,
            suppressAuth: true
        }),
        dataAccess.queryRecords('profileViews', {
            filters: buildDateFilters('viewedAt', dateRange),
            limit: 5000,
            suppressAuth: true
        }),
        aggregateAuditRows(dateRange, { ...filters, actionContains: 'search' })
    ]);

    return {
        carrierDriverViews: carrierViews.items || [],
        profileViews: profileViews.items || [],
        searchActions: auditRows
    };
}

export async function aggregateSecurityEvents(dateRange = {}, filters = {}) {
    const [systemLogs, anomalyAlerts, rateLimitEvents] = await Promise.all([
        dataAccess.queryRecords('systemLogs', {
            filters: {
                ...buildDateFilters('timestamp', dateRange),
                level: { hasSome: ['WARN', 'ERROR', 'CRITICAL'] }
            },
            limit: 5000,
            suppressAuth: true
        }),
        dataAccess.queryRecords('anomalyAlerts', {
            filters: buildDateFilters('detectedAt', dateRange),
            limit: 5000,
            suppressAuth: true
        }),
        dataAccess.queryRecords('auditLog', {
            filters: {
                ...buildDateFilters('timestamp', dateRange),
                action: { contains: 'rateLimit' }
            },
            limit: 5000,
            suppressAuth: true
        })
    ]);

    return {
        failedLogins: (systemLogs.items || []).filter((row) => String(row.message || '').toLowerCase().includes('failed login')),
        anomalyAlerts: anomalyAlerts.items || [],
        rateLimitEvents: rateLimitEvents.items || []
    };
}

// ============================================
// HELPERS
// ============================================

function calculateNextRun(schedule, fromDate = new Date()) {
    const reference = new Date(fromDate);
    const next = new Date(reference);
    const frequency = String(schedule.frequency || 'daily').toLowerCase();
    const timeOfDay = schedule.timeOfDay || '06:00';
    const [hh, mm] = String(timeOfDay).split(':').map((value) => Number(value || 0));
    next.setUTCHours(hh, mm, 0, 0);

    if (frequency === 'daily') {
        if (next <= reference) next.setUTCDate(next.getUTCDate() + 1);
        return next;
    }

    if (frequency === 'weekly') {
        const targetDay = Number(schedule.dayOfWeek ?? 1);
        const currentDay = next.getUTCDay();
        let delta = targetDay - currentDay;
        if (delta < 0 || (delta === 0 && next <= reference)) delta += 7;
        next.setUTCDate(next.getUTCDate() + delta);
        return next;
    }

    const targetDay = Math.max(1, Math.min(28, Number(schedule.dayOfMonth || 1)));
    next.setUTCDate(targetDay);
    if (next <= reference) next.setUTCMonth(next.getUTCMonth() + 1);
    return next;
}

function buildDateFilters(fieldName, dateRange = {}) {
    const filter = {};
    if (dateRange.dateRangeStart || dateRange.dateFrom) {
        filter[fieldName] = { ...(filter[fieldName] || {}), gte: new Date(dateRange.dateRangeStart || dateRange.dateFrom) };
    }
    if (dateRange.dateRangeEnd || dateRange.dateTo) {
        filter[fieldName] = { ...(filter[fieldName] || {}), lte: new Date(dateRange.dateRangeEnd || dateRange.dateTo) };
    }
    return filter;
}

async function aggregateAuditRows(dateRange = {}, filters = {}) {
    const queryFilters = { ...buildDateFilters('timestamp', dateRange) };
    if (filters.actionContains) queryFilters.action = { contains: filters.actionContains };
    if (filters.action && filters.action !== 'all') queryFilters.action = filters.action;
    if (filters.targetType && filters.targetType !== 'all') queryFilters.targetType = filters.targetType;
    const result = await dataAccess.queryRecords('auditLog', {
        filters: queryFilters,
        limit: 10000,
        suppressAuth: true
    });
    return result.items || [];
}

async function aggregateReportRows(reportType, dateRangeAndFilters) {
    const { dateRangeStart, dateRangeEnd, filters = {} } = dateRangeAndFilters || {};
    const dateRange = { dateRangeStart, dateRangeEnd };

    if (reportType === 'admin_activity') {
        return aggregateAdminActivity(dateRange, filters);
    }
    if (reportType === 'data_access') {
        const data = await aggregateDataAccess(dateRange, filters);
        return [
            ...data.carrierDriverViews.map((item) => ({ type: 'carrier_view', ...item })),
            ...data.profileViews.map((item) => ({ type: 'profile_view', ...item })),
            ...data.searchActions.map((item) => ({ type: 'search_action', ...item }))
        ];
    }
    if (reportType === 'system_changes') {
        const rows = await aggregateAuditRows(dateRange, filters);
        return rows.filter((row) => ['updateSettings', 'updateAIRouterConfig', 'updateAnomalyRule', 'updateCostOptimizerConfig'].includes(row.action));
    }
    if (reportType === 'security_events') {
        const data = await aggregateSecurityEvents(dateRange, filters);
        return [
            ...data.failedLogins.map((row) => ({ type: 'failed_login', ...row })),
            ...data.anomalyAlerts.map((row) => ({ type: 'anomaly_alert', ...row })),
            ...data.rateLimitEvents.map((row) => ({ type: 'rate_limit', ...row }))
        ];
    }
    if (reportType === 'full_audit') {
        return aggregateAuditRows(dateRange, filters);
    }
    if (reportType === 'custom') {
        return aggregateAuditRows(dateRange, filters);
    }
    throw new Error(`Unsupported report type: ${reportType}`);
}

function formatReportPayload(format, rows) {
    const normalized = String(format || 'csv').toLowerCase();
    if (normalized === 'json') {
        return JSON.stringify({ generatedAt: new Date().toISOString(), rows }, null, 2);
    }
    if (normalized === 'pdf') {
        const headers = rows.length > 0 ? Object.keys(rows[0]) : [];
        const lines = [
            'LMDR Compliance Report',
            `Generated: ${new Date().toISOString()}`,
            '',
            headers.join(' | ')
        ];
        rows.forEach((row) => {
            lines.push(headers.map((header) => sanitizeCell(row[header])).join(' | '));
        });
        return lines.join('\n');
    }
    return toCSV(rows);
}

function toCSV(rows) {
    if (!rows || rows.length === 0) return '';
    const headers = Object.keys(rows[0]);
    const headerLine = headers.map((header) => `"${String(header).replace(/"/g, '""')}"`).join(',');
    const lines = rows.map((row) => headers.map((header) => `"${sanitizeCell(row[header]).replace(/"/g, '""')}"`).join(','));
    return [headerLine, ...lines].join('\n');
}

function sanitizeCell(value) {
    if (value === undefined || value === null) return '';
    if (typeof value === 'object') return JSON.stringify(value);
    return String(value);
}

function buildReportFileName(reportType, format) {
    const datePart = new Date().toISOString().slice(0, 10);
    return `${reportType}_${datePart}.${String(format).toLowerCase()}`;
}

function applyPIIMasking(row) {
    const masked = { ...row };
    Object.keys(masked).forEach((key) => {
        const value = masked[key];
        if (typeof value !== 'string') return;
        if (key.toLowerCase().includes('email') && value.includes('@')) {
            const [name, domain] = value.split('@');
            masked[key] = `${name.slice(0, 2)}***@${domain}`;
        }
        if (key.toLowerCase().includes('phone')) {
            const digits = value.replace(/\D/g, '');
            if (digits.length >= 4) masked[key] = `***-***-${digits.slice(-4)}`;
        }
    });
    return masked;
}

async function logAuditEntry(action, targetId, details) {
    const member = await currentMember.getMember();
    await dataAccess.insertRecord('auditLog', {
        action,
        targetType: 'compliance_report',
        targetId,
        details,
        adminId: member?._id || 'system',
        adminEmail: member?.loginEmail || 'system',
        timestamp: new Date()
    }, { suppressAuth: true });
}

function formatActionLabel(action) {
    const labels = { verifyDriver: 'Verify Driver', suspendDriver: 'Suspend Driver', updateDriverStatus: 'Update Status', flagCarrier: 'Flag Carrier', unflagCarrier: 'Unflag Carrier' };
    return labels[action] || action;
}

function getActionCategory(action) {
    for (const [cat, actions] of Object.entries(ACTION_CATEGORIES)) if (actions.includes(action)) return cat;
    return 'other';
}

function getRelativeTime(ts) {
    if (!ts) return '';
    const diff = new Date() - new Date(ts);
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff/60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff/3600000)}h ago`;
    return new Date(ts).toLocaleDateString();
}

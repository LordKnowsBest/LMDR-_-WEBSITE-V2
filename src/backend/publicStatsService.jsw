import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
  drivers: 'driverProfiles',
  carriers: 'carriers',
  interests: 'driverCarrierInterests'
};

/**
 * Get public platform stats for drivers and general audience
 */
export async function getPublicStats() {
  try {
    const [driversCount, carriersCount, hiresCount, interestsRes] = await Promise.all([
      dataAccess.countRecords(COLLECTION_KEYS.drivers, {}),
      dataAccess.countRecords(COLLECTION_KEYS.carriers, { is_active: true }),
      dataAccess.countRecords(COLLECTION_KEYS.interests, { status: 'hired' }),
      dataAccess.queryRecords(COLLECTION_KEYS.interests, { limit: 1000, suppressAuth: true })
    ]);

    const interestsItems = interestsRes.items || [];
    const scores = interestsItems.map(i => i.match_score).filter(Boolean);
    const avgScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 85;

    return {
      driversPlaced: hiresCount || 0,
      activeCarriers: carriersCount || 0,
      avgMatchScore: avgScore,
      openPositions: (carriersCount || 0) * 3,
      registeredDrivers: driversCount || 0
    };
  } catch (err) {
    console.error('getPublicStats error:', err);
    return { driversPlaced: 0, activeCarriers: 0, avgMatchScore: 85, openPositions: 0, registeredDrivers: 0 };
  }
}

/**
 * Get platform stats formatted for carriers (B2B audience)
 */
export async function getCarrierPlatformStats() {
  try {
    const [activeDriversCount, hiresRes] = await Promise.all([
      dataAccess.countRecords(COLLECTION_KEYS.drivers, { status: 'active', cdl_class: { ne: '' } }),
      dataAccess.queryRecords(COLLECTION_KEYS.interests, { filters: { status: 'hired' }, limit: 500, suppressAuth: true })
    ]);

    const hireTimes = (hiresRes.items || [])
      .filter(h => h.applied_date && h._updatedDate)
      .map(h => Math.ceil((new Date(h._updatedDate) - new Date(h.applied_date)) / (1000 * 60 * 60 * 24)));

    const avgDays = hireTimes.length > 0 ? Math.round(hireTimes.reduce((a, b) => a + b, 0) / hireTimes.length) : 14;

    return { qualifiedDrivers: activeDriversCount || 0, avgDaysToHire: avgDays, retentionRate: 87, avgCostPerHire: 299 };
  } catch (err) {
    console.error('getCarrierPlatformStats error:', err);
    return { qualifiedDrivers: 0, avgDaysToHire: 14, retentionRate: 87, avgCostPerHire: 299 };
  }
}

/**
 * Get featured carriers for homepage carousel
 */
export async function getFeaturedCarriers(limit = 8) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { nbr_power_unit: { gte: 50 }, logo_url: { ne: '' } },
      sort: [{ field: 'quality_score', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      name: carrier.legal_name,
      logo: carrier.logo_url,
      location: `${carrier.phy_city || ''}, ${carrier.phy_state || ''}`.replace(/^, |, $/g, ''),
      tagline: carrier.hiring_tagline || 'Now Hiring CDL Drivers',
      fleetSize: carrier.nbr_power_unit,
      payRange: carrier.pay_range || ''
    }));
  } catch (err) {
    console.error('getFeaturedCarriers error:', err);
    return [];
  }
}

/**
 * Get recent hires for social proof
 */
export async function getRecentHires(limit = 10) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { status: 'hired' },
      sort: [{ field: '_updatedDate', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(h => ({
      location: h.driver_state || 'USA',
      daysAgo: getDaysAgo(h._updatedDate),
      operationType: h.operation_type || 'OTR'
    }));
  } catch (err) {
    console.error('getRecentHires error:', err);
    return [];
  }
}

/**
 * Get top job opportunities for drivers
 */
export async function getTopJobOpportunities(limit = 6) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { pay_per_mile_max: { gte: 0.55 }, is_hiring: true },
      sort: [{ field: 'pay_per_mile_max', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrier.legal_name,
      payRange: formatPayRange(carrier.pay_per_mile_min, carrier.pay_per_mile_max),
      location: `${carrier.phy_city || ''}, ${carrier.phy_state || ''}`.replace(/^, |, $/g, ''),
      operationType: carrier.operation_type || 'OTR',
      benefits: carrier.benefits_summary || 'Full benefits package',
      fleetSize: carrier.nbr_power_unit
    }));
  } catch (err) {
    console.error('getTopJobOpportunities error:', err);
    return [];
  }
}

/**
 * Get jobs filtered by state
 */
export async function getJobsByState(state, limit = 4) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { phy_state: state, is_hiring: true },
      sort: [{ field: 'quality_score', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrier.legal_name,
      payRange: formatPayRange(carrier.pay_per_mile_min, carrier.pay_per_mile_max),
      location: `${carrier.phy_city || ''}, ${carrier.phy_state || ''}`.replace(/^, |, $/g, ''),
      operationType: carrier.operation_type || 'OTR'
    }));
  } catch (err) {
    console.error('getJobsByState error:', err);
    return [];
  }
}

/**
 * Get partner logos for "Trusted By" sections
 */
export async function getPartnerLogos(limit = 12) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { logo_url: { ne: '' }, nbr_power_unit: { gte: 100 } },
      sort: [{ field: 'nbr_power_unit', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(c => ({
      _id: c._id,
      name: c.legal_name,
      logoUrl: c.logo_url
    }));
  } catch (err) {
    console.error('getPartnerLogos error:', err);
    return [];
  }
}

/**
 * Get jobs by operation type
 */
export async function getJobsByOperationType(operationType, limit = 6) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { operation_type: operationType, is_hiring: true },
      sort: [{ field: 'pay_per_mile_max', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrier.legal_name,
      dotNumber: carrier.dot_number,
      payRange: formatPayRange(carrier.pay_per_mile_min, carrier.pay_per_mile_max),
      location: `${carrier.phy_city || ''}, ${carrier.phy_state || ''}`.replace(/^, |, $/g, ''),
      operationType: carrier.operation_type || operationType,
      homeTime: carrier.home_time || 'Varies',
      benefits: carrier.benefits_summary || 'Full benefits package',
      fleetSize: carrier.nbr_power_unit,
      truckAge: carrier.avg_truck_age
    }));
  } catch (err) {
    console.error('getJobsByOperationType error:', err);
    return [];
  }
}

/**
 * Get jobs requiring specific endorsements
 */
export async function getJobsByEndorsement(endorsement, limit = 6) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { required_endorsements: { contains: endorsement }, is_hiring: true },
      sort: [{ field: 'pay_per_mile_max', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrier.legal_name,
      dotNumber: carrier.dot_number,
      payRange: formatPayRange(carrier.pay_per_mile_min, carrier.pay_per_mile_max),
      location: `${carrier.phy_city || ''}, ${carrier.phy_state || ''}`.replace(/^, |, $/g, ''),
      operationType: carrier.operation_type || 'OTR',
      endorsements: carrier.required_endorsements || [endorsement],
      benefits: carrier.benefits_summary || 'Full benefits package',
      fleetSize: carrier.nbr_power_unit
    }));
  } catch (err) {
    console.error('getJobsByEndorsement error:', err);
    return [];
  }
}

/**
 * Get location page data
 */
export async function getLocationPageData(state, city = null) {
  try {
    const filters = { phy_state: state, is_hiring: true };
    if (city) filters.phy_city = city;

    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, { filters, limit: 100, suppressAuth: true });
    const carriers = result.items || [];

    if (carriers.length === 0) return { state, city, jobCount: 0, avgPay: null, topCarriers: [], operationTypes: {} };

    const payRates = carriers.map(c => c.pay_per_mile_max || c.pay_per_mile_min).filter(Boolean);
    const avgPay = payRates.length > 0 ? (payRates.reduce((a, b) => a + b, 0) / payRates.length).toFixed(2) : null;

    const operationTypes = carriers.reduce((acc, c) => {
      const type = c.operation_type || 'Other';
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});

    const topCarriers = carriers
      .sort((a, b) => (b.quality_score || 0) - (a.quality_score || 0))
      .slice(0, 5)
      .map(c => ({
        _id: c._id, name: c.legal_name, dotNumber: c.dot_number,
        payRange: formatPayRange(c.pay_per_mile_min, c.pay_per_mile_max),
        operationType: c.operation_type || 'OTR', fleetSize: c.nbr_power_unit
      }));

    return { state, city, jobCount: carriers.length, avgPay: avgPay ? `$${avgPay}/mi` : 'Competitive', topCarriers, operationTypes, totalFleetSize: carriers.reduce((sum, c) => sum + (c.nbr_power_unit || 0), 0) };
  } catch (err) {
    console.error('getLocationPageData error:', err);
    return { state, city, jobCount: 0, avgPay: null, topCarriers: [], operationTypes: {} };
  }
}

/**
 * Get premium/urgent job opportunities
 */
export async function getPremiumOpportunities(limit = 5) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      filters: { is_hiring: true, pay_per_mile_max: { gte: 0.65 } },
      sort: [{ field: 'pay_per_mile_max', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrier.legal_name,
      dotNumber: carrier.dot_number,
      payRange: formatPayRange(carrier.pay_per_mile_min, carrier.pay_per_mile_max),
      signOnBonus: carrier.sign_on_bonus || null,
      location: `${carrier.phy_city || ''}, ${carrier.phy_state || ''}`.replace(/^, |, $/g, ''),
      operationType: carrier.operation_type || 'OTR',
      benefits: carrier.benefits_summary || 'Full benefits package',
      urgencyLevel: carrier.urgency_level || 'normal',
      openPositions: carrier.open_positions || 1
    }));
  } catch (err) {
    console.error('getPremiumOpportunities error:', err);
    return [];
  }
}

// Helpers
function getDaysAgo(date) {
  if (!date) return 0;
  const diffTime = Math.abs(new Date() - new Date(date));
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

function formatPayRange(min, max) {
  if (max && min) return `$${min.toFixed(2)}-${max.toFixed(2)}/mi`;
  if (max) return `Up to $${max.toFixed(2)}/mi`;
  if (min) return `From $${min.toFixed(2)}/mi`;
  return 'Competitive pay';
}

// Helper functions

function getDaysAgo(date) {
  if (!date) return 0;
  const now = new Date();
  const then = new Date(date);
  const diffTime = Math.abs(now - then);
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

function formatPayRange(min, max) {
  if (max && min) {
    return `$${min.toFixed(2)}-${max.toFixed(2)}/mi`;
  } else if (max) {
    return `Up to $${max.toFixed(2)}/mi`;
  } else if (min) {
    return `From $${min.toFixed(2)}/mi`;
  }
  return 'Competitive pay';
}

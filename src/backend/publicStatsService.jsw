import * as dataAccess from 'backend/dataAccess';

// Collection keys for dataAccess
const COLLECTION_KEYS = {
  drivers: 'driverProfiles',
  carriers: 'carriers',
  interests: 'driverCarrierInterests'
};

function isUnknownFieldError(err) {
  const msg = String(err && err.message ? err.message : err);
  return msg.includes('Unknown field name') ||
    msg.includes('Unknown field names') ||
    msg.includes('formula for filtering records is invalid');
}

async function queryCarriersSafe(options = {}) {
  try {
    return await dataAccess.queryRecords(COLLECTION_KEYS.carriers, options);
  } catch (err) {
    if (!isUnknownFieldError(err)) throw err;
    console.warn('queryCarriersSafe fallback (schema mismatch):', err.message);
    // Fallback to minimal query so public pages can still render.
    return await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
      limit: options.limit || 50,
      suppressAuth: true
    });
  }
}

function carrierValue(carrier, keys, fallback = null) {
  for (const key of keys) {
    if (carrier && carrier[key] !== undefined && carrier[key] !== null && carrier[key] !== '') {
      return carrier[key];
    }
  }
  return fallback;
}

function carrierPayMin(carrier) {
  return toNumber(carrierValue(carrier, ['pay_per_mile_min', 'PAY_CPM_MIN', 'pay_cpm_min'], null));
}

function carrierPayMax(carrier) {
  return toNumber(carrierValue(carrier, ['pay_per_mile_max', 'PAY_CPM_MAX', 'pay_cpm_max', 'pay_cpm', 'PAY_CPM'], null));
}

function toNumber(value) {
  if (value === null || value === undefined || value === '') return null;
  const n = Number(value);
  return Number.isFinite(n) ? n : null;
}

/**
 * Get public platform stats for drivers and general audience
 */
export async function getPublicStats() {
  try {
    const [driversCount, carriersCount, hiresCount, interestsRes] = await Promise.all([
      dataAccess.countRecords(COLLECTION_KEYS.drivers, {}),
      dataAccess.countRecords(COLLECTION_KEYS.carriers, { is_active: true }),
      dataAccess.countRecords(COLLECTION_KEYS.interests, { status: 'hired' }),
      dataAccess.queryRecords(COLLECTION_KEYS.interests, { limit: 1000, suppressAuth: true })
    ]);

    const interestsItems = interestsRes.items || [];
    const scores = interestsItems.map(i => i.match_score).filter(Boolean);
    const avgScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 85;

    return {
      driversPlaced: hiresCount || 0,
      activeCarriers: carriersCount || 0,
      avgMatchScore: avgScore,
      openPositions: (carriersCount || 0) * 3,
      registeredDrivers: driversCount || 0
    };
  } catch (err) {
    console.error('getPublicStats error:', err);
    return { driversPlaced: 0, activeCarriers: 0, avgMatchScore: 85, openPositions: 0, registeredDrivers: 0 };
  }
}

/**
 * Get platform stats formatted for carriers (B2B audience)
 */
export async function getCarrierPlatformStats() {
  try {
    const [activeDriversCount, hiresRes] = await Promise.all([
      dataAccess.countRecords(COLLECTION_KEYS.drivers, { status: 'active', cdl_class: { ne: '' } }),
      dataAccess.queryRecords(COLLECTION_KEYS.interests, { filters: { status: 'hired' }, limit: 500, suppressAuth: true })
    ]);

    const hireTimes = (hiresRes.items || [])
      .map((h) => {
        const endDate = h.action_timestamp || h.hired_at || h.updated_at || h._updatedDate;
        if (!h.applied_date || !endDate) return null;
        return Math.ceil((new Date(endDate) - new Date(h.applied_date)) / (1000 * 60 * 60 * 24));
      })
      .filter((d) => Number.isFinite(d) && d >= 0);

    const avgDays = hireTimes.length > 0 ? Math.round(hireTimes.reduce((a, b) => a + b, 0) / hireTimes.length) : 14;

    return { qualifiedDrivers: activeDriversCount || 0, avgDaysToHire: avgDays, retentionRate: 87, avgCostPerHire: 299 };
  } catch (err) {
    console.error('getCarrierPlatformStats error:', err);
    return { qualifiedDrivers: 0, avgDaysToHire: 14, retentionRate: 87, avgCostPerHire: 299 };
  }
}

/**
 * Get featured carriers for homepage carousel
 */
export async function getFeaturedCarriers(limit = 8) {
  try {
    const result = await queryCarriersSafe({
      filters: { nbr_power_unit: { gte: 50 }, logo_url: { ne: '' } },
      sort: [{ field: 'quality_score', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      name: carrierValue(carrier, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      logo: carrierValue(carrier, ['logo_url', 'LOGO_URL'], ''),
      location: `${carrierValue(carrier, ['phy_city', 'PHY_CITY'], '') || ''}, ${carrierValue(carrier, ['phy_state', 'PHY_STATE'], '') || ''}`.replace(/^, |, $/g, ''),
      tagline: carrier.hiring_tagline || 'Now Hiring CDL Drivers',
      fleetSize: toNumber(carrierValue(carrier, ['nbr_power_unit', 'NBR_POWER_UNIT'], 0)) || 0,
      payRange: carrier.pay_range || ''
    }));
  } catch (err) {
    console.error('getFeaturedCarriers error:', err);
    return [];
  }
}

/**
 * Get recent hires for social proof
 */
export async function getRecentHires(limit = 10) {
  try {
    const result = await dataAccess.queryRecords(COLLECTION_KEYS.interests, {
      filters: { status: 'hired' },
      sort: [{ field: 'action_timestamp', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(h => ({
      location: h.driver_state || 'USA',
      daysAgo: getDaysAgo(h.action_timestamp || h.hired_at || h.updated_at || h._updatedDate),
      operationType: h.operation_type || 'OTR'
    }));
  } catch (err) {
    console.error('getRecentHires error:', err);
    return [];
  }
}

/**
 * Get top job opportunities for drivers
 */
export async function getTopJobOpportunities(limit = 6) {
  try {
    const result = await queryCarriersSafe({
      filters: { pay_cpm: { gte: 0.55 }, is_hiring: true },
      sort: [{ field: 'pay_cpm', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrierValue(carrier, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      payRange: formatPayRange(carrierPayMin(carrier), carrierPayMax(carrier)),
      location: `${carrierValue(carrier, ['phy_city', 'PHY_CITY'], '') || ''}, ${carrierValue(carrier, ['phy_state', 'PHY_STATE'], '') || ''}`.replace(/^, |, $/g, ''),
      operationType: carrierValue(carrier, ['operation_type', 'OPERATION_TYPE'], 'OTR'),
      benefits: carrier.benefits_summary || 'Full benefits package',
      fleetSize: toNumber(carrierValue(carrier, ['nbr_power_unit', 'NBR_POWER_UNIT'], 0)) || 0
    }));
  } catch (err) {
    console.error('getTopJobOpportunities error:', err);
    return [];
  }
}

/**
 * Get jobs filtered by state
 */
export async function getJobsByState(state, limit = 4) {
  try {
    const result = await queryCarriersSafe({
      filters: { phy_state: state, is_hiring: true },
      sort: [{ field: 'quality_score', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrierValue(carrier, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      payRange: formatPayRange(carrierPayMin(carrier), carrierPayMax(carrier)),
      location: `${carrierValue(carrier, ['phy_city', 'PHY_CITY'], '') || ''}, ${carrierValue(carrier, ['phy_state', 'PHY_STATE'], '') || ''}`.replace(/^, |, $/g, ''),
      operationType: carrierValue(carrier, ['operation_type', 'OPERATION_TYPE'], 'OTR')
    }));
  } catch (err) {
    console.error('getJobsByState error:', err);
    return [];
  }
}

/**
 * Get partner logos for "Trusted By" sections
 */
export async function getPartnerLogos(limit = 12) {
  try {
    const result = await queryCarriersSafe({
      filters: { logo_url: { ne: '' }, nbr_power_unit: { gte: 100 } },
      sort: [{ field: 'nbr_power_unit', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(c => ({
      _id: c._id,
      name: carrierValue(c, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      logoUrl: carrierValue(c, ['logo_url', 'LOGO_URL'], '')
    }));
  } catch (err) {
    console.error('getPartnerLogos error:', err);
    return [];
  }
}

/**
 * Get jobs by operation type
 */
export async function getJobsByOperationType(operationType, limit = 6) {
  try {
    const result = await queryCarriersSafe({
      filters: { operation_type: operationType, is_hiring: true },
      sort: [{ field: 'pay_cpm', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrierValue(carrier, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      dotNumber: carrierValue(carrier, ['dot_number', 'DOT_NUMBER'], ''),
      payRange: formatPayRange(carrierPayMin(carrier), carrierPayMax(carrier)),
      location: `${carrierValue(carrier, ['phy_city', 'PHY_CITY'], '') || ''}, ${carrierValue(carrier, ['phy_state', 'PHY_STATE'], '') || ''}`.replace(/^, |, $/g, ''),
      operationType: carrierValue(carrier, ['operation_type', 'OPERATION_TYPE'], operationType),
      homeTime: carrier.home_time || 'Varies',
      benefits: carrier.benefits_summary || 'Full benefits package',
      fleetSize: toNumber(carrierValue(carrier, ['nbr_power_unit', 'NBR_POWER_UNIT'], 0)) || 0,
      truckAge: toNumber(carrierValue(carrier, ['avg_truck_age', 'AVG_TRUCK_AGE'], null))
    }));
  } catch (err) {
    console.error('getJobsByOperationType error:', err);
    return [];
  }
}

/**
 * Get jobs requiring specific endorsements
 */
export async function getJobsByEndorsement(endorsement, limit = 6) {
  try {
    const result = await queryCarriersSafe({
      filters: { required_endorsements: { contains: endorsement }, is_hiring: true },
      sort: [{ field: 'pay_cpm', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrierValue(carrier, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      dotNumber: carrierValue(carrier, ['dot_number', 'DOT_NUMBER'], ''),
      payRange: formatPayRange(carrierPayMin(carrier), carrierPayMax(carrier)),
      location: `${carrierValue(carrier, ['phy_city', 'PHY_CITY'], '') || ''}, ${carrierValue(carrier, ['phy_state', 'PHY_STATE'], '') || ''}`.replace(/^, |, $/g, ''),
      operationType: carrierValue(carrier, ['operation_type', 'OPERATION_TYPE'], 'OTR'),
      endorsements: carrier.required_endorsements || [endorsement],
      benefits: carrier.benefits_summary || 'Full benefits package',
      fleetSize: toNumber(carrierValue(carrier, ['nbr_power_unit', 'NBR_POWER_UNIT'], 0)) || 0
    }));
  } catch (err) {
    console.error('getJobsByEndorsement error:', err);
    return [];
  }
}

/**
 * Get location page data
 */
export async function getLocationPageData(state, city = null) {
  try {
    const filters = { phy_state: state, is_hiring: true };
    if (city) filters.phy_city = city;

    const result = await queryCarriersSafe({ filters, limit: 100, suppressAuth: true });
    const carriers = result.items || [];

    if (carriers.length === 0) return { state, city, jobCount: 0, avgPay: null, topCarriers: [], operationTypes: {} };

    const payRates = carriers.map(c => carrierPayMax(c) || carrierPayMin(c)).filter(Boolean);
    const avgPay = payRates.length > 0 ? (payRates.reduce((a, b) => a + b, 0) / payRates.length).toFixed(2) : null;

    const operationTypes = carriers.reduce((acc, c) => {
      const type = carrierValue(c, ['operation_type', 'OPERATION_TYPE'], 'Other');
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});

    const topCarriers = carriers
      .sort((a, b) => (b.quality_score || 0) - (a.quality_score || 0))
      .slice(0, 5)
      .map(c => ({
        _id: c._id, name: carrierValue(c, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'), dotNumber: carrierValue(c, ['dot_number', 'DOT_NUMBER'], ''),
        payRange: formatPayRange(carrierPayMin(c), carrierPayMax(c)),
        operationType: carrierValue(c, ['operation_type', 'OPERATION_TYPE'], 'OTR'), fleetSize: toNumber(carrierValue(c, ['nbr_power_unit', 'NBR_POWER_UNIT'], 0)) || 0
      }));

    return {
      state,
      city,
      jobCount: carriers.length,
      avgPay: avgPay ? `$${avgPay}/mi` : 'Competitive',
      topCarriers,
      operationTypes,
      totalFleetSize: carriers.reduce((sum, c) => sum + (toNumber(carrierValue(c, ['nbr_power_unit', 'NBR_POWER_UNIT'], 0)) || 0), 0)
    };
  } catch (err) {
    console.error('getLocationPageData error:', err);
    return { state, city, jobCount: 0, avgPay: null, topCarriers: [], operationTypes: {} };
  }
}

/**
 * Get premium/urgent job opportunities
 */
export async function getPremiumOpportunities(limit = 5) {
  try {
    const result = await queryCarriersSafe({
      filters: { is_hiring: true, pay_cpm: { gte: 0.65 } },
      sort: [{ field: 'pay_cpm', direction: 'desc' }],
      limit, suppressAuth: true
    });

    return (result.items || []).map(carrier => ({
      _id: carrier._id,
      carrierName: carrierValue(carrier, ['legal_name', 'LEGAL_NAME', 'company_name'], 'Carrier'),
      dotNumber: carrierValue(carrier, ['dot_number', 'DOT_NUMBER'], ''),
      payRange: formatPayRange(carrierPayMin(carrier), carrierPayMax(carrier)),
      signOnBonus: carrier.sign_on_bonus || null,
      location: `${carrierValue(carrier, ['phy_city', 'PHY_CITY'], '') || ''}, ${carrierValue(carrier, ['phy_state', 'PHY_STATE'], '') || ''}`.replace(/^, |, $/g, ''),
      operationType: carrierValue(carrier, ['operation_type', 'OPERATION_TYPE'], 'OTR'),
      benefits: carrier.benefits_summary || 'Full benefits package',
      urgencyLevel: carrier.urgency_level || 'normal',
      openPositions: carrier.open_positions || 1
    }));
  } catch (err) {
    console.error('getPremiumOpportunities error:', err);
    return [];
  }
}

// Helpers
function getDaysAgo(date) {
  if (!date) return 0;
  const diffTime = Math.abs(new Date() - new Date(date));
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

function formatPayRange(min, max) {
  if (min !== null && min !== undefined) min = Number(min);
  if (max !== null && max !== undefined) max = Number(max);
  const minOk = Number.isFinite(min);
  const maxOk = Number.isFinite(max);
  if (maxOk && minOk) return `$${min.toFixed(2)}-${max.toFixed(2)}/mi`;
  if (maxOk) return `Up to $${max.toFixed(2)}/mi`;
  if (minOk) return `From $${min.toFixed(2)}/mi`;
  return 'Competitive pay';
}

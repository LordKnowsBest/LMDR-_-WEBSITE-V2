import { currentMember } from 'wix-members-backend';
import { triggeredEmails } from 'wix-crm-backend';
import * as dataAccess from 'backend/dataAccess';

// ============================================
// COLLECTION CONFIGURATION
// ============================================

const COLLECTION_KEYS = {
    drivers: 'driverProfiles',
    carriers: 'carriers',
    applications: 'driverCarrierInterests',
    matches: 'matchEvents',
    enrichments: 'carrierEnrichments',
    auditLog: 'auditLog'
};

// ============================================
// AUTHORIZATION
// ============================================

/**
 * Check if current user has admin role
 * @returns {Promise<boolean>}
 */
async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;

        // Check for admin role in member data
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';

        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) {
        console.error('Admin check failed:', error);
        return false;
    }
}

/**
 * Require admin access - throws if not authorized
 */
async function requireAdmin() {
    const authorized = await isAdmin();
    if (!authorized) {
        throw new Error('Unauthorized: Admin access required');
    }
}

// ============================================
// DRIVER MANAGEMENT
// ============================================

/**
 * Get paginated list of drivers with filters
 * @param {Object} options - Query options
 * @returns {Promise<Object>} - Drivers list with pagination info
 */
export async function getDriversList(options = {}) {
    await requireAdmin();

    const {
        filters = {},
        page = 1,
        pageSize = 25,
        sortField = 'lastActive',
        sortDirection = 'desc'
    } = options;

    try {
        const queryFilters = {};

        // Apply filters
        if (filters.status && filters.status !== 'all') {
            queryFilters.status = filters.status;
        }
        if (filters.verification && filters.verification !== 'all') {
            queryFilters.verificationStatus = filters.verification;
        }
        if (filters.tier && filters.tier !== 'all') {
            queryFilters.membershipTier = filters.tier;
        }

        // Handle search
        if (filters.search) {
            queryFilters.firstName = { contains: filters.search.toLowerCase() };
        }

        // Apply sorting
        const sortFieldMap = {
            name: 'lastName',
            profileCompletion: 'profileCompletion',
            lastActive: '_updatedDate'
        };
        const dbSortField = sortFieldMap[sortField] || '_updatedDate';

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.drivers, {
            filters: queryFilters,
            sort: [{ field: dbSortField, direction: sortDirection }],
            limit: pageSize,
            skip: (page - 1) * pageSize,
            suppressAuth: true
        });

        if (!result.success) throw new Error(result.error);

        // Transform drivers for frontend
        const drivers = result.items.map(driver => ({
            _id: driver._id,
            firstName: driver.firstName || '',
            lastName: driver.lastName || '',
            email: driver.email || '',
            phone: driver.phone || '',
            status: driver.status || 'incomplete',
            verificationStatus: driver.verificationStatus || 'unverified',
            profileCompletion: calculateProfileCompletion(driver),
            location: formatLocation(driver),
            lastActive: driver._updatedDate,
            _createdDate: driver._createdDate,
            profileImage: driver.profileImage || null,
            membershipTier: driver.membershipTier || 'free'
        }));

        const totalCount = result.totalCount || result.items.length;

        return {
            drivers,
            totalCount,
            currentPage: page,
            pageSize,
            totalPages: Math.ceil(totalCount / pageSize)
        };

    } catch (error) {
        console.error('Error fetching drivers list:', error);
        throw new Error('Failed to fetch drivers');
    }
}

/**
 * Get detailed driver information
 * @param {string} driverId - Driver ID
 * @returns {Promise<Object>} - Driver details
 */
export async function getDriverDetail(driverId) {
    await requireAdmin();

    try {
        const driver = await dataAccess.getRecord(COLLECTION_KEYS.drivers, driverId, { suppressAuth: true });
        if (!driver) throw new Error('Driver not found');

        // Get application history
        const applications = await dataAccess.queryRecords(COLLECTION_KEYS.applications, {
            filters: { driverId },
            sort: [{ field: '_createdDate', direction: 'desc' }],
            limit: 20,
            suppressAuth: true
        });

        // Get match history
        const matches = await dataAccess.queryRecords(COLLECTION_KEYS.matches, {
            filters: { driverId },
            sort: [{ field: '_createdDate', direction: 'desc' }],
            limit: 20,
            suppressAuth: true
        });

        return {
            ...driver,
            profileCompletion: calculateProfileCompletion(driver),
            location: formatLocation(driver),
            applications: applications.items || [],
            matchHistory: matches.items || [],
            stats: {
                totalApplications: applications.totalCount || 0,
                totalMatches: matches.totalCount || 0
            }
        };

    } catch (error) {
        console.error('Error fetching driver detail:', error);
        throw new Error('Failed to fetch driver details');
    }
}

/**
 * Update driver status
 */
export async function updateDriverStatus(driverId, status, reason = '') {
    await requireAdmin();

    const validStatuses = ['active', 'pending', 'suspended', 'incomplete'];
    if (!validStatuses.includes(status)) throw new Error('Invalid status');

    try {
        const driver = await dataAccess.getRecord(COLLECTION_KEYS.drivers, driverId, { suppressAuth: true });
        if (!driver) throw new Error('Driver not found');

        const previousStatus = driver.status;
        driver.status = status;
        driver.statusHistory = driver.statusHistory || [];
        driver.statusHistory.push({
            from: previousStatus,
            to: status,
            reason,
            changedAt: new Date(),
            changedBy: 'admin'
        });

        const result = await dataAccess.updateRecord(COLLECTION_KEYS.drivers, driver, { suppressAuth: true });
        if (!result.success) throw new Error(result.error);

        await logAdminAction('updateDriverStatus', driverId, { previousStatus, newStatus: status, reason });

        return result.record;
    } catch (error) {
        console.error('Error updating driver status:', error);
        throw new Error('Failed to update driver status');
    }
}

/**
 * Verify driver documents
 */
export async function verifyDriver(driverId) {
    await requireAdmin();

    try {
        const driver = await dataAccess.getRecord(COLLECTION_KEYS.drivers, driverId, { suppressAuth: true });
        if (!driver) throw new Error('Driver not found');

        driver.verificationStatus = 'verified';
        driver.verifiedAt = new Date();
        driver.status = 'active';

        const result = await dataAccess.updateRecord(COLLECTION_KEYS.drivers, driver, { suppressAuth: true });
        if (!result.success) throw new Error(result.error);

        await logAdminAction('verifyDriver', driverId, {});

        return result.record;
    } catch (error) {
        console.error('Error verifying driver:', error);
        throw new Error('Failed to verify driver');
    }
}

/**
 * Suspend driver account
 */
export async function suspendDriver(driverId, reason = '') {
    await requireAdmin();
    return await updateDriverStatus(driverId, 'suspended', reason);
}

/**
 * Bulk update driver statuses
 */
export async function bulkUpdateDrivers(driverIds, action) {
    await requireAdmin();

    const results = { success: 0, failed: 0, errors: [] };

    for (const driverId of driverIds) {
        try {
            switch (action) {
                case 'verify': await verifyDriver(driverId); break;
                case 'suspend': await suspendDriver(driverId, 'Bulk suspension'); break;
                case 'activate': await updateDriverStatus(driverId, 'active', 'Bulk activation'); break;
                default: throw new Error('Invalid action');
            }
            results.success++;
        } catch (error) {
            results.failed++;
            results.errors.push({ driverId, error: error.message });
        }
    }

    return results;
}

// ============================================
// ANALYTICS & STATS
// ============================================

/**
 * Get driver statistics for dashboard
 */
export async function getDriverStats() {
    await requireAdmin();

    try {
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);

        const [total, active, pending, expired, newThisWeek] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.drivers, {}),
            dataAccess.countRecords(COLLECTION_KEYS.drivers, { status: 'active' }),
            dataAccess.countRecords(COLLECTION_KEYS.drivers, { verificationStatus: 'in_review' }),
            dataAccess.countRecords(COLLECTION_KEYS.drivers, { verificationStatus: 'expired' }),
            dataAccess.countRecords(COLLECTION_KEYS.drivers, { _createdDate: { gte: weekAgo } })
        ]);

        return {
            total,
            active,
            activePercent: total > 0 ? Math.round((active / total) * 100) : 0,
            pending,
            expiredDocs: expired,
            newThisWeek
        };
    } catch (error) {
        console.error('Error fetching driver stats:', error);
        throw new Error('Failed to fetch stats');
    }
}

/**
 * Get driver analytics over time
 */
export async function getDriverAnalytics(period = 'month') {
    await requireAdmin();

    try {
        const now = new Date();
        let startDate = new Date();

        if (period === 'week') startDate.setDate(now.getDate() - 7);
        else if (period === 'quarter') startDate.setMonth(now.getMonth() - 3);
        else startDate.setMonth(now.getMonth() - 1);

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.drivers, {
            filters: { _createdDate: { gte: startDate } },
            limit: 1000,
            suppressAuth: true
        });

        const dailyRegistrations = {};
        (result.items || []).forEach(driver => {
            const date = new Date(driver._createdDate).toISOString().split('T')[0];
            dailyRegistrations[date] = (dailyRegistrations[date] || 0) + 1;
        });

        return {
            period,
            totalRegistrations: result.totalCount || result.items.length,
            dailyBreakdown: dailyRegistrations
        };
    } catch (error) {
        console.error('Error fetching analytics:', error);
        throw new Error('Failed to fetch analytics');
    }
}

// ============================================
// EXPORT & MESSAGING
// ============================================

/**
 * Export drivers to CSV format
 */
export async function exportDriversCSV(filters = {}) {
    await requireAdmin();

    try {
        const queryFilters = {};
        if (filters.status && filters.status !== 'all') queryFilters.status = filters.status;
        if (filters.verification && filters.verification !== 'all') queryFilters.verificationStatus = filters.verification;

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.drivers, {
            filters: queryFilters,
            limit: 1000,
            suppressAuth: true
        });

        const headers = ['ID', 'First Name', 'Last Name', 'Email', 'Status', 'Verification', 'Location', 'Joined Date'];
        const rows = result.items.map(d => [
            d._id, d.firstName || '', d.lastName || '', d.email || '', 
            d.status || '', d.verificationStatus || '', formatLocation(d),
            d._createdDate ? new Date(d._createdDate).toISOString() : ''
        ]);

        return [
            headers.join(','),
            ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
        ].join('\n');
    } catch (error) {
        console.error('Error exporting drivers:', error);
        throw new Error('Failed to export drivers');
    }
}

/**
 * Send email to driver
 */
export async function sendDriverEmail(driverId, templateId, variables = {}) {
    await requireAdmin();

    try {
        const driver = await dataAccess.getRecord(COLLECTION_KEYS.drivers, driverId, { suppressAuth: true });
        if (!driver || !driver.email) throw new Error('Driver not found or no email');

        await triggeredEmails.emailContact(templateId, driver._owner, {
            variables: { firstName: driver.firstName, ...variables }
        });

        await logAdminAction('sendEmail', driverId, { templateId });
    } catch (error) {
        console.error('Error sending email:', error);
        throw new Error('Failed to send email');
    }
}

// ============================================
// AUDIT LOGGING
// ============================================

async function logAdminAction(action, targetId, details = {}) {
    try {
        const member = await currentMember.getMember();
        await dataAccess.insertRecord(COLLECTION_KEYS.auditLog, {
            action,
            targetType: 'driver',
            targetId,
            details,
            adminId: member?._id || 'system',
            adminEmail: member?.loginEmail || 'system',
            timestamp: new Date()
        }, { suppressAuth: true });
    } catch (error) {
        console.error('Failed to log admin action:', error);
    }
}

// ============================================
// CARRIER MANAGEMENT
// ============================================

/**
 * Get paginated list of carriers with filters
 */
export async function getCarriersList(options = {}) {
    await requireAdmin();

    const {
        filters = {},
        page = 1,
        pageSize = 25,
        sortField = 'lastUpdated',
        sortDirection = 'desc'
    } = options;

    try {
        const queryFilters = {};
        if (filters.status && filters.status !== 'all') queryFilters.admin_status = filters.status;
        if (filters.safetyRating && filters.safetyRating !== 'all') queryFilters.safety_rating = filters.safetyRating;

        // Fleet size filter
        if (filters.fleetSize && filters.fleetSize !== 'all') {
            if (filters.fleetSize === 'small') queryFilters.nbr_power_unit = { lt: 50 };
            else if (filters.fleetSize === 'medium') queryFilters.nbr_power_unit = { gte: 50, lt: 200 };
            else if (filters.fleetSize === 'large') queryFilters.nbr_power_unit = { ge: 200 };
        }

        const sortFieldMap = {
            name: 'legal_name',
            fleetSize: 'nbr_power_unit',
            lastUpdated: '_updatedDate',
            safetyRating: 'safety_rating'
        };
        const dbSortField = sortFieldMap[sortField] || '_updatedDate';

        const result = await dataAccess.queryRecords(COLLECTION_KEYS.carriers, {
            filters: queryFilters,
            sort: [{ field: dbSortField, direction: sortDirection }],
            limit: pageSize,
            skip: (page - 1) * pageSize,
            suppressAuth: true
        });

        if (!result.success) throw new Error(result.error);

        // Fetch Enrichment Status
        const dotNumbers = result.items.map(c => String(c.dot_number));
        const enrichments = await getCarrierEnrichments(dotNumbers);

        const carriers = result.items.map(carrier => ({
            _id: carrier._id,
            legalName: carrier.legal_name || 'Unknown',
            dbaName: carrier.dba_name || '',
            dotNumber: carrier.dot_number,
            mcNumber: carrier.mc_number,
            city: carrier.phy_city || '',
            state: carrier.phy_state || '',
            fleetSize: carrier.nbr_power_unit || 0,
            driverCount: carrier.driver_total || 0,
            safetyRating: carrier.safety_rating || 'NOT RATED',
            status: carrier.admin_status || 'active',
            isFlagged: carrier.is_flagged || false,
            enrichmentStatus: enrichments[carrier.dot_number] ? 'Full' : 'None',
            lastUpdated: carrier._updatedDate
        }));

        return {
            carriers,
            totalCount: result.totalCount || result.items.length,
            currentPage: page,
            pageSize,
            totalPages: Math.ceil((result.totalCount || result.items.length) / pageSize)
        };
    } catch (error) {
        console.error('Error fetching carriers list:', error);
        throw new Error('Failed to fetch carriers');
    }
}

async function getCarrierEnrichments(dotNumbers) {
    if (!dotNumbers.length) return {};
    try {
        const result = await dataAccess.queryRecords(COLLECTION_KEYS.enrichments, {
            filters: { dot_number: { hasSome: dotNumbers } },
            suppressAuth: true
        });
        const map = {};
        (result.items || []).forEach(item => { map[item.dot_number] = item; });
        return map;
    } catch (e) {
        return {};
    }
}

/**
 * Get carrier dashboard stats
 */
export async function getCarrierStats() {
    await requireAdmin();
    try {
        const [total, flagged, enriched, active] = await Promise.all([
            dataAccess.countRecords(COLLECTION_KEYS.carriers, {}),
            dataAccess.countRecords(COLLECTION_KEYS.carriers, { is_flagged: true }),
            dataAccess.countRecords(COLLECTION_KEYS.enrichments, {}),
            dataAccess.countRecords(COLLECTION_KEYS.carriers, { admin_status: { ne: 'inactive' } })
        ]);

        return {
            total,
            active,
            activePercent: total > 0 ? Math.round((active / total) * 100) : 0,
            flagged,
            enriched,
            enrichedPercent: total > 0 ? Math.round((enriched / total) * 100) : 0,
            newThisWeek: 0
        };
    } catch (error) {
        console.error('Error fetching carrier stats:', error);
        throw new Error('Failed to fetch carrier stats');
    }
}

/**
 * Get detailed carrier info
 */
export async function getCarrierDetail(carrierId) {
    await requireAdmin();
    try {
        const carrier = await dataAccess.getRecord(COLLECTION_KEYS.carriers, carrierId, { suppressAuth: true });
        if (!carrier) throw new Error('Carrier not found');

        let enrichment = null;
        if (carrier.dot_number) {
            const enrichResult = await dataAccess.queryRecords(COLLECTION_KEYS.enrichments, {
                filters: { dot_number: String(carrier.dot_number) },
                limit: 1
            });
            enrichment = enrichResult.items?.[0] || null;
        }

        return {
            ...normalizeCarrier(carrier),
            enrichment,
            status: carrier.admin_status || 'active',
            isFlagged: carrier.is_flagged || false
        };
    } catch (error) {
        console.error('Error fetching carrier detail:', error);
        throw new Error('Failed to fetch carrier detail');
    }
}

/**
 * Update carrier status/flag
 */
export async function updateCarrierStatus(carrierId, updates) {
    await requireAdmin();
    try {
        const carrier = await dataAccess.getRecord(COLLECTION_KEYS.carriers, carrierId, { suppressAuth: true });
        if (!carrier) throw new Error('Carrier not found');

        let changed = false;
        if (updates.status && updates.status !== carrier.admin_status) {
            carrier.admin_status = updates.status;
            changed = true;
        }
        if (typeof updates.isFlagged === 'boolean' && updates.isFlagged !== carrier.is_flagged) {
            carrier.is_flagged = updates.isFlagged;
            changed = true;
        }

        if (changed) {
            await dataAccess.updateRecord(COLLECTION_KEYS.carriers, carrier, { suppressAuth: true });
            await logAdminAction('updateCarrier', carrierId, updates);
        }

        return carrier;
    } catch (error) {
        console.error('Error updating carrier:', error);
        throw new Error('Failed to update carrier');
    }
}

// ============================================
// HELPERS
// ============================================

function calculateProfileCompletion(driver) {
    const fields = ['firstName', 'lastName', 'email', 'phone', 'cdlClass', 'yearsExperience', 'homeZip'];
    let completed = 0;
    fields.forEach(field => { if (driver[field]) completed++; });
    return Math.round((completed / fields.length) * 100);
}

function formatLocation(driver) {
    const parts = [];
    if (driver.city) parts.push(driver.city);
    if (driver.state) parts.push(driver.state);
    return parts.join(', ') || driver.homeZip || 'Not specified';
}

function normalizeCarrier(carrier) {
    return {
        _id: carrier._id,
        legalName: carrier.legal_name,
        dbaName: carrier.dba_name,
        dotNumber: carrier.dot_number,
        mcNumber: carrier.mc_number,
        city: carrier.phy_city,
        state: carrier.phy_state,
        fleetSize: carrier.nbr_power_unit,
        safetyRating: carrier.safety_rating,
        ...carrier
    };
}
/**
 * Admin Service - Backend functions for Admin Portal
 * Handles driver management, analytics, and administrative operations
 *
 * DUAL-SOURCE SUPPORT: This service supports both Wix and Airtable data sources.
 * The data source is determined by the config.jsw configuration.
 *
 * Collections used:
 * - DriverProfiles (drivers)
 * - Carriers (carriers)
 * - DriverCarrierInterests (applications)
 * - MatchEvents (matches)
 * - CarrierEnrichments (enrichments)
 * - AdminAuditLog (auditLog)
 */

import wixData from 'wix-data';
import { currentMember } from 'wix-members-backend';
import { triggeredEmails } from 'wix-crm-backend';
import { getDataSource, getWixCollectionName, getAirtableTableName } from 'backend/config';
import * as airtable from 'backend/airtableClient';

// ============================================
// COLLECTION CONFIGURATION
// ============================================

const COLLECTIONS = {
    drivers: {
        wixName: 'DriverProfiles',
        configKey: 'driverProfiles'
    },
    carriers: {
        wixName: 'Carriers',
        configKey: 'carriers'
    },
    applications: {
        wixName: 'DriverCarrierInterests',
        configKey: 'driverCarrierInterests'
    },
    matches: {
        wixName: 'MatchEvents',
        configKey: 'matchEvents'
    },
    enrichments: {
        wixName: 'CarrierEnrichments',
        configKey: 'carrierEnrichments'
    },
    auditLog: {
        wixName: 'AdminAuditLog',
        configKey: 'auditLog'
    }
};

// ============================================
// DUAL-SOURCE DATA HELPERS
// ============================================

/**
 * Get the data source for a collection
 * @param {string} collectionKey - Key from COLLECTIONS
 * @returns {'wix' | 'airtable'}
 */
function getSource(collectionKey) {
    return getDataSource(COLLECTIONS[collectionKey].configKey);
}

/**
 * Get the collection name for the current data source
 * @param {string} collectionKey - Key from COLLECTIONS
 * @returns {string}
 */
function getCollectionName(collectionKey) {
    return COLLECTIONS[collectionKey].wixName;
}

/**
 * Query records from appropriate data source with full query support
 * @param {string} collectionKey - Key from COLLECTIONS
 * @param {Object} options - Query options
 * @returns {Promise<Object>} Query result with items
 */
async function queryFromSource(collectionKey, options = {}) {
    const collectionName = getCollectionName(collectionKey);

    if (getSource(collectionKey) === 'airtable') {
        const airtableOptions = {};
        const conditions = [];

        // Handle equality conditions
        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                const airtableField = mapFieldToAirtable(field);
                conditions.push(formatAirtableCondition(airtableField, '=', value));
            }
        }

        // Handle contains conditions
        if (options.contains) {
            for (const [field, value] of Object.entries(options.contains)) {
                const airtableField = mapFieldToAirtable(field);
                conditions.push(`FIND(LOWER('${value}'), LOWER({${airtableField}})) > 0`);
            }
        }

        // Handle greater than or equal conditions
        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                const airtableField = mapFieldToAirtable(field);
                if (value instanceof Date) {
                    conditions.push(`IS_AFTER({${airtableField}}, '${value.toISOString()}')`);
                } else {
                    conditions.push(`{${airtableField}} >= ${value}`);
                }
            }
        }

        // Handle less than conditions
        if (options.lt) {
            for (const [field, value] of Object.entries(options.lt)) {
                const airtableField = mapFieldToAirtable(field);
                if (value instanceof Date) {
                    conditions.push(`IS_BEFORE({${airtableField}}, '${value.toISOString()}')`);
                } else {
                    conditions.push(`{${airtableField}} < ${value}`);
                }
            }
        }

        // Handle not equal conditions
        if (options.ne) {
            for (const [field, value] of Object.entries(options.ne)) {
                const airtableField = mapFieldToAirtable(field);
                conditions.push(formatAirtableCondition(airtableField, '!=', value));
            }
        }

        // Handle hasSome conditions
        if (options.hasSome) {
            for (const [field, values] of Object.entries(options.hasSome)) {
                const airtableField = mapFieldToAirtable(field);
                const orConditions = values.map(v => formatAirtableCondition(airtableField, '=', v));
                if (orConditions.length === 1) {
                    conditions.push(orConditions[0]);
                } else if (orConditions.length > 1) {
                    conditions.push(`OR(${orConditions.join(', ')})`);
                }
            }
        }

        if (conditions.length > 0) {
            airtableOptions.filterByFormula = conditions.length === 1 ? conditions[0] : `AND(${conditions.join(', ')})`;
        }

        if (options.limit) {
            airtableOptions.maxRecords = options.limit;
        }

        if (options.skip) {
            // Airtable doesn't support skip directly, we need to fetch more and slice
            airtableOptions.maxRecords = (options.limit || 100) + (options.skip || 0);
        }

        if (options.sortField) {
            const airtableSortField = mapFieldToAirtable(options.sortField);
            airtableOptions.sort = [{
                field: airtableSortField,
                direction: options.sortDirection || 'desc'
            }];
        }

        const result = await airtable.queryRecords(collectionName, airtableOptions);
        let records = result.records || [];

        // Handle skip (since Airtable doesn't support offset natively)
        if (options.skip && options.skip > 0) {
            records = records.slice(options.skip);
        }

        if (options.limit) {
            records = records.slice(0, options.limit);
        }

        return {
            items: records,
            totalCount: result.records?.length || 0
        };
    } else {
        // Wix Data source
        let query = wixData.query(collectionName);

        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                query = query.eq(field, value);
            }
        }

        if (options.contains) {
            for (const [field, value] of Object.entries(options.contains)) {
                query = query.contains(field, value);
            }
        }

        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                query = query.ge(field, value);
            }
        }

        if (options.lt) {
            for (const [field, value] of Object.entries(options.lt)) {
                query = query.lt(field, value);
            }
        }

        if (options.ne) {
            for (const [field, value] of Object.entries(options.ne)) {
                query = query.ne(field, value);
            }
        }

        if (options.hasSome) {
            for (const [field, values] of Object.entries(options.hasSome)) {
                query = query.hasSome(field, values);
            }
        }

        if (options.sortField) {
            if (options.sortDirection === 'asc') {
                query = query.ascending(options.sortField);
            } else {
                query = query.descending(options.sortField);
            }
        }

        if (options.skip) {
            query = query.skip(options.skip);
        }

        if (options.limit) {
            query = query.limit(options.limit);
        }

        const findOptions = options.suppressAuth ? { suppressAuth: true } : {};
        return await query.find(findOptions);
    }
}

/**
 * Count records from appropriate data source
 * @param {string} collectionKey - Key from COLLECTIONS
 * @param {Object} options - Query options
 * @returns {Promise<number>}
 */
async function countFromSource(collectionKey, options = {}) {
    const collectionName = getCollectionName(collectionKey);

    if (getSource(collectionKey) === 'airtable') {
        // For Airtable, we need to query and count
        const result = await queryFromSource(collectionKey, { ...options, limit: 10000 });
        return result.items?.length || 0;
    } else {
        let query = wixData.query(collectionName);

        if (options.eq) {
            for (const [field, value] of Object.entries(options.eq)) {
                query = query.eq(field, value);
            }
        }

        if (options.ge) {
            for (const [field, value] of Object.entries(options.ge)) {
                query = query.ge(field, value);
            }
        }

        if (options.ne) {
            for (const [field, value] of Object.entries(options.ne)) {
                query = query.ne(field, value);
            }
        }

        return await query.count();
    }
}

/**
 * Get a single record by ID
 * @param {string} collectionKey - Key from COLLECTIONS
 * @param {string} recordId - Record ID
 * @returns {Promise<Object|null>}
 */
async function getFromSource(collectionKey, recordId) {
    const collectionName = getCollectionName(collectionKey);

    if (getSource(collectionKey) === 'airtable') {
        const result = await airtable.getRecord(collectionName, recordId);
        return result.error ? null : result;
    } else {
        return await wixData.get(collectionName, recordId);
    }
}

/**
 * Update a record
 * @param {string} collectionKey - Key from COLLECTIONS
 * @param {Object} record - Record to update
 * @param {Object} options - Update options
 * @returns {Promise<Object>}
 */
async function updateInSource(collectionKey, record, options = {}) {
    const collectionName = getCollectionName(collectionKey);

    if (getSource(collectionKey) === 'airtable') {
        const { _id, ...fields } = record;
        return await airtable.updateRecord(collectionName, _id, fields);
    } else {
        const updateOptions = options.suppressAuth ? { suppressAuth: true } : {};
        return await wixData.update(collectionName, record, updateOptions);
    }
}

/**
 * Insert a record
 * @param {string} collectionKey - Key from COLLECTIONS
 * @param {Object} record - Record to insert
 * @param {Object} options - Insert options
 * @returns {Promise<Object>}
 */
async function insertInSource(collectionKey, record, options = {}) {
    const collectionName = getCollectionName(collectionKey);

    if (getSource(collectionKey) === 'airtable') {
        return await airtable.createRecord(collectionName, record);
    } else {
        const insertOptions = options.suppressAuth ? { suppressAuth: true } : {};
        return await wixData.insert(collectionName, record, insertOptions);
    }
}

/**
 * Map Wix field name to Airtable field name
 * @param {string} field - Wix field name
 * @returns {string} Airtable field name
 */
function mapFieldToAirtable(field) {
    const fieldMap = {
        '_id': 'Record ID',
        '_createdDate': 'Created',
        '_updatedDate': 'Last Modified',
        '_owner': 'Owner',
        'firstName': 'First Name',
        'lastName': 'Last Name',
        'email': 'Email',
        'phone': 'Phone',
        'status': 'Status',
        'verificationStatus': 'Verification Status',
        'membershipTier': 'Membership Tier',
        'profileCompletion': 'Profile Completion',
        'dot_number': 'DOT Number',
        'legal_name': 'Legal Name',
        'dba_name': 'DBA Name',
        'phy_city': 'Physical City',
        'phy_state': 'Physical State',
        'nbr_power_unit': 'Total Power Units',
        'safety_rating': 'Safety Rating',
        'admin_status': 'Admin Status',
        'is_flagged': 'Is Flagged',
        'isFlagged': 'Is Flagged',
        'mc_number': 'MC Number',
        'driverId': 'Driver',
        'carrierId': 'Carrier',
        'action': 'Action',
        'targetType': 'Target Type',
        'targetId': 'Target ID',
        'timestamp': 'Timestamp'
    };

    return fieldMap[field] || field.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

/**
 * Format a value for Airtable filter formula
 * @param {string} field - Airtable field name
 * @param {string} operator - Comparison operator
 * @param {*} value - Value to compare
 * @returns {string} Airtable formula clause
 */
function formatAirtableCondition(field, operator, value) {
    if (typeof value === 'string') {
        return `{${field}} ${operator} '${value.replace(/'/g, "\\'")}'`;
    } else if (typeof value === 'boolean') {
        return `{${field}} ${operator} ${value ? 'TRUE()' : 'FALSE()'}`;
    } else if (value === null) {
        return operator === '=' ? `{${field}} = BLANK()` : `{${field}} != BLANK()`;
    } else {
        return `{${field}} ${operator} ${value}`;
    }
}

// ============================================
// AUTHORIZATION
// ============================================

/**
 * Check if current user has admin role
 * @returns {Promise<boolean>}
 */
async function isAdmin() {
    try {
        const member = await currentMember.getMember({ fieldsets: ['FULL'] });
        if (!member) return false;

        // Check for admin role in member data
        // Customize this based on your role implementation
        const adminRoles = ['admin', 'super_admin', 'ops_admin'];
        const memberRole = member.contactDetails?.customFields?.role || '';

        return adminRoles.includes(memberRole.toLowerCase());
    } catch (error) {
        console.error('Admin check failed:', error);
        return false;
    }
}

/**
 * Require admin access - throws if not authorized
 */
async function requireAdmin() {
    const authorized = await isAdmin();
    if (!authorized) {
        throw new Error('Unauthorized: Admin access required');
    }
}

// ============================================
// DRIVER MANAGEMENT
// ============================================

/**
 * Get paginated list of drivers with filters
 * @param {Object} options - Query options
 * @returns {Promise<Object>} - Drivers list with pagination info
 */
export async function getDriversList(options = {}) {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    const {
        filters = {},
        page = 1,
        pageSize = 25,
        sortField = 'lastActive',
        sortDirection = 'desc'
    } = options;

    try {
        // Build query options
        const queryOptions = {};

        // Apply status filter
        if (filters.status && filters.status !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, status: filters.status };
        }

        // Apply verification filter
        if (filters.verification && filters.verification !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, verificationStatus: filters.verification };
        }

        // Apply tier filter
        if (filters.tier && filters.tier !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, membershipTier: filters.tier };
        }

        // Apply sorting
        const sortFieldMap = {
            name: 'lastName',
            profileCompletion: 'profileCompletion',
            lastActive: '_updatedDate'
        };
        const dbSortField = sortFieldMap[sortField] || '_updatedDate';
        queryOptions.sortField = dbSortField;
        queryOptions.sortDirection = sortDirection;

        // Apply pagination
        const skip = (page - 1) * pageSize;
        queryOptions.skip = skip;
        queryOptions.limit = pageSize;

        // For search, we need special handling
        let result;
        if (filters.search && getSource('drivers') === 'wix') {
            // Wix-specific: use OR queries for search
            const searchTerm = filters.search.toLowerCase();
            let query = wixData.query('DriverProfiles');

            query = query.contains('firstName', searchTerm)
                .or(wixData.query('DriverProfiles').contains('lastName', searchTerm))
                .or(wixData.query('DriverProfiles').contains('email', searchTerm));

            if (filters.status && filters.status !== 'all') {
                query = query.eq('status', filters.status);
            }
            if (filters.verification && filters.verification !== 'all') {
                query = query.eq('verificationStatus', filters.verification);
            }
            if (filters.tier && filters.tier !== 'all') {
                query = query.eq('membershipTier', filters.tier);
            }

            if (sortDirection === 'asc') {
                query = query.ascending(dbSortField);
            } else {
                query = query.descending(dbSortField);
            }

            query = query.skip(skip).limit(pageSize);
            result = await query.find();
        } else if (filters.search && getSource('drivers') === 'airtable') {
            // Airtable: use FIND for text search
            const searchTerm = filters.search.toLowerCase();
            queryOptions.contains = {
                firstName: searchTerm
            };
            // Note: Airtable OR search would require a custom formula
            result = await queryFromSource('drivers', queryOptions);
        } else {
            result = await queryFromSource('drivers', queryOptions);
        }

        // Get total count
        const countOptions = {};
        if (filters.status && filters.status !== 'all') {
            countOptions.eq = { ...countOptions.eq, status: filters.status };
        }
        if (filters.verification && filters.verification !== 'all') {
            countOptions.eq = { ...countOptions.eq, verificationStatus: filters.verification };
        }
        const countResult = await countFromSource('drivers', countOptions);

        // Transform drivers for frontend
        const drivers = result.items.map(driver => ({
            _id: driver._id,
            firstName: driver.firstName || '',
            lastName: driver.lastName || '',
            email: driver.email || '',
            phone: driver.phone || '',
            status: driver.status || 'incomplete',
            verificationStatus: driver.verificationStatus || 'unverified',
            profileCompletion: calculateProfileCompletion(driver),
            location: formatLocation(driver),
            lastActive: driver._updatedDate,
            _createdDate: driver._createdDate,
            profileImage: driver.profileImage || null,
            membershipTier: driver.membershipTier || 'free'
        }));

        return {
            drivers,
            totalCount: countResult,
            currentPage: page,
            pageSize,
            totalPages: Math.ceil(countResult / pageSize)
        };

    } catch (error) {
        console.error('Error fetching drivers list:', error);
        throw new Error('Failed to fetch drivers');
    }
}

/**
 * Get detailed driver information
 * @param {string} driverId - Driver ID
 * @returns {Promise<Object>} - Driver details
 */
export async function getDriverDetail(driverId) {
    // Collections: DriverProfiles (drivers), DriverCarrierInterests (applications), MatchEvents (matches)
    await requireAdmin();

    try {
        const driver = await getFromSource('drivers', driverId);
        if (!driver) {
            throw new Error('Driver not found');
        }

        // Get application history
        const applications = await queryFromSource('applications', {
            eq: { driverId: driverId },
            sortField: '_createdDate',
            sortDirection: 'desc',
            limit: 20
        });

        // Get match history
        const matches = await queryFromSource('matches', {
            eq: { driverId: driverId },
            sortField: '_createdDate',
            sortDirection: 'desc',
            limit: 20
        });

        return {
            ...driver,
            profileCompletion: calculateProfileCompletion(driver),
            location: formatLocation(driver),
            applications: applications.items,
            matchHistory: matches.items,
            stats: {
                totalApplications: applications.totalCount,
                totalMatches: matches.totalCount
            }
        };

    } catch (error) {
        console.error('Error fetching driver detail:', error);
        throw new Error('Failed to fetch driver details');
    }
}

/**
 * Update driver status
 * @param {string} driverId - Driver ID
 * @param {string} status - New status
 * @param {string} reason - Reason for status change
 * @returns {Promise<Object>} - Updated driver
 */
export async function updateDriverStatus(driverId, status, reason = '') {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    const validStatuses = ['active', 'pending', 'suspended', 'incomplete'];
    if (!validStatuses.includes(status)) {
        throw new Error('Invalid status');
    }

    try {
        const driver = await getFromSource('drivers', driverId);
        if (!driver) {
            throw new Error('Driver not found');
        }

        const previousStatus = driver.status;
        driver.status = status;
        driver.statusHistory = driver.statusHistory || [];
        driver.statusHistory.push({
            from: previousStatus,
            to: status,
            reason,
            changedAt: new Date(),
            changedBy: 'admin' // Could enhance to include admin ID
        });

        const updated = await updateInSource('drivers', driver);

        // Log admin action
        await logAdminAction('updateDriverStatus', driverId, { previousStatus, newStatus: status, reason });

        return updated;

    } catch (error) {
        console.error('Error updating driver status:', error);
        throw new Error('Failed to update driver status');
    }
}

/**
 * Verify driver documents
 * @param {string} driverId - Driver ID
 * @returns {Promise<Object>} - Updated driver
 */
export async function verifyDriver(driverId) {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    try {
        const driver = await getFromSource('drivers', driverId);
        if (!driver) {
            throw new Error('Driver not found');
        }

        driver.verificationStatus = 'verified';
        driver.verifiedAt = new Date();
        driver.status = 'active';

        const updated = await updateInSource('drivers', driver);

        // Log admin action
        await logAdminAction('verifyDriver', driverId, {});

        return updated;

    } catch (error) {
        console.error('Error verifying driver:', error);
        throw new Error('Failed to verify driver');
    }
}

/**
 * Suspend driver account
 * @param {string} driverId - Driver ID
 * @param {string} reason - Suspension reason
 * @returns {Promise<Object>} - Updated driver
 */
export async function suspendDriver(driverId, reason = '') {
    await requireAdmin();

    try {
        return await updateDriverStatus(driverId, 'suspended', reason);
    } catch (error) {
        console.error('Error suspending driver:', error);
        throw new Error('Failed to suspend driver');
    }
}

/**
 * Bulk update driver statuses
 * @param {string[]} driverIds - Array of driver IDs
 * @param {string} action - Action to perform
 * @returns {Promise<Object>} - Result summary
 */
export async function bulkUpdateDrivers(driverIds, action) {
    await requireAdmin();

    const results = { success: 0, failed: 0, errors: [] };

    for (const driverId of driverIds) {
        try {
            switch (action) {
                case 'verify':
                    await verifyDriver(driverId);
                    break;
                case 'suspend':
                    await suspendDriver(driverId, 'Bulk suspension');
                    break;
                case 'activate':
                    await updateDriverStatus(driverId, 'active', 'Bulk activation');
                    break;
                default:
                    throw new Error('Invalid action');
            }
            results.success++;
        } catch (error) {
            results.failed++;
            results.errors.push({ driverId, error: error.message });
        }
    }

    return results;
}

// ============================================
// ANALYTICS & STATS
// ============================================

/**
 * Get driver statistics for dashboard
 * @returns {Promise<Object>} - Stats object
 */
export async function getDriverStats() {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    try {
        // Total drivers
        const totalResult = await countFromSource('drivers', {});

        // Active drivers
        const activeResult = await countFromSource('drivers', {
            eq: { status: 'active' }
        });

        // Pending verification
        const pendingResult = await countFromSource('drivers', {
            eq: { verificationStatus: 'in_review' }
        });

        // Expired documents (simplified - would need actual doc expiry tracking)
        const expiredResult = await countFromSource('drivers', {
            eq: { verificationStatus: 'expired' }
        });

        // New this week
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        const newThisWeek = await countFromSource('drivers', {
            ge: { _createdDate: weekAgo }
        });

        return {
            total: totalResult,
            active: activeResult,
            activePercent: totalResult > 0 ? Math.round((activeResult / totalResult) * 100) : 0,
            pending: pendingResult,
            expiredDocs: expiredResult,
            newThisWeek
        };

    } catch (error) {
        console.error('Error fetching driver stats:', error);
        throw new Error('Failed to fetch stats');
    }
}

/**
 * Get driver analytics over time
 * @param {string} period - Time period (week, month, quarter)
 * @returns {Promise<Object>} - Analytics data
 */
export async function getDriverAnalytics(period = 'month') {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    try {
        const now = new Date();
        let startDate;

        switch (period) {
            case 'week':
                startDate = new Date(now.setDate(now.getDate() - 7));
                break;
            case 'quarter':
                startDate = new Date(now.setMonth(now.getMonth() - 3));
                break;
            default: // month
                startDate = new Date(now.setMonth(now.getMonth() - 1));
        }

        // Get registrations in period
        const registrations = await queryFromSource('drivers', {
            ge: { _createdDate: startDate }
        });

        // Group by day
        const dailyRegistrations = {};
        registrations.items.forEach(driver => {
            const date = new Date(driver._createdDate).toISOString().split('T')[0];
            dailyRegistrations[date] = (dailyRegistrations[date] || 0) + 1;
        });

        return {
            period,
            totalRegistrations: registrations.totalCount,
            dailyBreakdown: dailyRegistrations
        };

    } catch (error) {
        console.error('Error fetching analytics:', error);
        throw new Error('Failed to fetch analytics');
    }
}

// ============================================
// EXPORT
// ============================================

/**
 * Export drivers to CSV format
 * @param {Object} filters - Filter options
 * @returns {Promise<string>} - CSV string
 */
export async function exportDriversCSV(filters = {}) {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    try {
        const queryOptions = { limit: 1000 };

        if (filters.status && filters.status !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, status: filters.status };
        }
        if (filters.verification && filters.verification !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, verificationStatus: filters.verification };
        }

        const result = await queryFromSource('drivers', queryOptions);

        // Generate CSV
        const headers = ['ID', 'First Name', 'Last Name', 'Email', 'Status', 'Verification', 'Location', 'Joined Date'];
        const rows = result.items.map(d => [
            d._id,
            d.firstName || '',
            d.lastName || '',
            d.email || '',
            d.status || '',
            d.verificationStatus || '',
            formatLocation(d),
            d._createdDate ? new Date(d._createdDate).toISOString() : ''
        ]);

        const csv = [
            headers.join(','),
            ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
        ].join('\n');

        return csv;

    } catch (error) {
        console.error('Error exporting drivers:', error);
        throw new Error('Failed to export drivers');
    }
}

// ============================================
// MESSAGING
// ============================================

/**
 * Send email to driver
 * @param {string} driverId - Driver ID
 * @param {string} templateId - Email template ID
 * @param {Object} variables - Template variables
 * @returns {Promise<void>}
 */
export async function sendDriverEmail(driverId, templateId, variables = {}) {
    // Collection: DriverProfiles (drivers)
    await requireAdmin();

    try {
        const driver = await getFromSource('drivers', driverId);
        if (!driver || !driver.email) {
            throw new Error('Driver not found or no email');
        }

        await triggeredEmails.emailContact(templateId, driver._owner, {
            variables: {
                firstName: driver.firstName,
                ...variables
            }
        });

        // Log action
        await logAdminAction('sendEmail', driverId, { templateId });

    } catch (error) {
        console.error('Error sending email:', error);
        throw new Error('Failed to send email');
    }
}

// ============================================
// AUDIT LOGGING
// ============================================

/**
 * Log admin action for audit trail
 * @param {string} action - Action type
 * @param {string} targetId - Target entity ID
 * @param {Object} details - Action details
 */
async function logAdminAction(action, targetId, details = {}) {
    // Collection: AdminAuditLog (auditLog)
    try {
        const member = await currentMember.getMember();

        await insertInSource('auditLog', {
            action,
            targetType: 'driver',
            targetId,
            details,
            adminId: member?._id || 'system',
            adminEmail: member?.loginEmail || 'system',
            timestamp: new Date()
        });
    } catch (error) {
        console.error('Failed to log admin action:', error);
        // Don't throw - audit logging failure shouldn't block the action
    }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

/**
 * Calculate profile completion percentage
 */
function calculateProfileCompletion(driver) {
    const fields = [
        'firstName', 'lastName', 'email', 'phone',
        'cdlClass', 'yearsExperience', 'preferredRegion',
        'equipmentExperience', 'homeZip'
    ];

    let completed = 0;
    fields.forEach(field => {
        if (driver[field] && String(driver[field]).trim() !== '') {
            completed++;
        }
    });

    return Math.round((completed / fields.length) * 100);
}

/**
 * Format location from driver data
 */
function formatLocation(driver) {
    const parts = [];
    if (driver.city) parts.push(driver.city);
    if (driver.state) parts.push(driver.state);
    if (parts.length === 0 && driver.homeZip) {
        return `ZIP: ${driver.homeZip}`;
    }
    return parts.join(', ') || 'Not specified';
}

// ============================================
// CARRIER MANAGEMENT
// ============================================

/**
 * Get paginated list of carriers with filters
 * @param {Object} options - Query options
 * @returns {Promise<Object>} - Carriers list with pagination info
 */
export async function getCarriersList(options = {}) {
    // Collections: Carriers (carriers), CarrierEnrichments (enrichments)
    await requireAdmin();

    const {
        filters = {},
        page = 1,
        pageSize = 25,
        sortField = 'lastUpdated',
        sortDirection = 'desc'
    } = options;

    try {
        // Build query options
        const queryOptions = {};

        // Apply status filter
        if (filters.status && filters.status !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, admin_status: filters.status };
        }

        // Apply safety rating filter
        if (filters.safetyRating && filters.safetyRating !== 'all') {
            queryOptions.eq = { ...queryOptions.eq, safety_rating: filters.safetyRating };
        }

        // Apply sorting
        const sortFieldMap = {
            name: 'legal_name',
            fleetSize: 'nbr_power_unit',
            lastUpdated: '_updatedDate',
            safetyRating: 'safety_rating'
        };
        const dbSortField = sortFieldMap[sortField] || '_updatedDate';
        queryOptions.sortField = dbSortField;
        queryOptions.sortDirection = sortDirection;

        // Apply pagination
        const skip = (page - 1) * pageSize;
        queryOptions.skip = skip;
        queryOptions.limit = pageSize;

        // Handle fleet size filter (requires range queries)
        if (filters.fleetSize && filters.fleetSize !== 'all') {
            switch (filters.fleetSize) {
                case 'small':
                    queryOptions.lt = { ...queryOptions.lt, nbr_power_unit: 50 };
                    break;
                case 'medium':
                    queryOptions.ge = { ...queryOptions.ge, nbr_power_unit: 50 };
                    queryOptions.lt = { ...queryOptions.lt, nbr_power_unit: 200 };
                    break;
                case 'large':
                    queryOptions.ge = { ...queryOptions.ge, nbr_power_unit: 200 };
                    break;
            }
        }

        // Handle search - needs special handling for OR queries
        let result;
        if (filters.search && getSource('carriers') === 'wix') {
            // Wix-specific: use OR queries for search
            const searchTerm = filters.search;
            const asNumber = parseInt(searchTerm, 10);

            let searchQuery = wixData.query('Carriers').contains('legal_name', searchTerm)
                .or(wixData.query('Carriers').contains('phy_city', searchTerm))
                .or(wixData.query('Carriers').contains('dba_name', searchTerm));

            if (!isNaN(asNumber)) {
                searchQuery = searchQuery.or(wixData.query('Carriers').eq('dot_number', asNumber));
                searchQuery = searchQuery.or(wixData.query('Carriers').eq('mc_number', asNumber));
            }

            if (filters.status && filters.status !== 'all') {
                searchQuery = searchQuery.eq('admin_status', filters.status);
            }
            if (filters.safetyRating && filters.safetyRating !== 'all') {
                searchQuery = searchQuery.eq('safety_rating', filters.safetyRating);
            }

            if (sortDirection === 'asc') {
                searchQuery = searchQuery.ascending(dbSortField);
            } else {
                searchQuery = searchQuery.descending(dbSortField);
            }

            searchQuery = searchQuery.skip(skip).limit(pageSize);
            result = await searchQuery.find();
        } else if (filters.search && getSource('carriers') === 'airtable') {
            // Airtable: use FIND for text search on legal_name
            queryOptions.contains = { legal_name: filters.search };
            result = await queryFromSource('carriers', queryOptions);
        } else {
            result = await queryFromSource('carriers', queryOptions);
        }

        // Get total count
        const countOptions = {};
        if (filters.status && filters.status !== 'all') {
            countOptions.eq = { ...countOptions.eq, admin_status: filters.status };
        }
        if (filters.safetyRating && filters.safetyRating !== 'all') {
            countOptions.eq = { ...countOptions.eq, safety_rating: filters.safetyRating };
        }
        const countResult = await countFromSource('carriers', countOptions);

        // Fetch Enrichment Status for these carriers
        const dotNumbers = result.items.map(c => String(c.dot_number));
        const enrichments = await getCarrierEnrichments(dotNumbers);

        // Transform carriers for frontend
        const carriers = result.items.map(carrier => ({
            _id: carrier._id,
            legalName: carrier.legal_name || 'Unknown',
            dbaName: carrier.dba_name || '',
            dotNumber: carrier.dot_number,
            mcNumber: carrier.mc_number,
            city: carrier.phy_city || '',
            state: carrier.phy_state || '',
            fleetSize: carrier.nbr_power_unit || 0,
            driverCount: carrier.driver_total || 0,
            safetyRating: carrier.safety_rating || 'NOT RATED',
            status: carrier.admin_status || 'active',
            isFlagged: carrier.is_flagged || false,
            enrichmentStatus: enrichments[carrier.dot_number] ? 'Full' : 'None',
            lastUpdated: carrier._updatedDate
        }));

        return {
            carriers,
            totalCount: countResult,
            currentPage: page,
            pageSize,
            totalPages: Math.ceil(countResult / pageSize)
        };

    } catch (error) {
        console.error('Error fetching carriers list:', error);
        throw new Error('Failed to fetch carriers');
    }
}

/**
 * Helper to get enrichment status
 */
async function getCarrierEnrichments(dotNumbers) {
    // Collection: CarrierEnrichments (enrichments)
    if (!dotNumbers.length) return {};
    try {
        const result = await queryFromSource('enrichments', {
            hasSome: { dot_number: dotNumbers }
        });

        const map = {};
        result.items.forEach(item => {
            map[item.dot_number] = item;
        });
        return map;
    } catch (e) {
        console.warn('Failed to fetch enrichments', e);
        return {};
    }
}

/**
 * Get carrier dashboard stats
 */
export async function getCarrierStats() {
    // Collections: Carriers (carriers), CarrierEnrichments (enrichments)
    await requireAdmin();
    try {
        const total = await countFromSource('carriers', {});
        const flagged = await countFromSource('carriers', { eq: { is_flagged: true } });
        const enriched = await countFromSource('enrichments', {});
        const active = await countFromSource('carriers', { ne: { admin_status: 'inactive' } });

        return {
            total,
            active,
            activePercent: total > 0 ? Math.round((active / total) * 100) : 0,
            flagged,
            enriched,
            enrichedPercent: total > 0 ? Math.round((enriched / total) * 100) : 0,
            newThisWeek: 0 // Placeholder or impl if needed
        };
    } catch (error) {
        console.error('Error fetching carrier stats:', error);
        throw new Error('Failed to fetch carrier stats');
    }
}

/**
 * Get detailed carrier info
 */
export async function getCarrierDetail(carrierId) {
    // Collections: Carriers (carriers), CarrierEnrichments (enrichments)
    await requireAdmin();
    try {
        const carrier = await getFromSource('carriers', carrierId);
        if (!carrier) throw new Error('Carrier not found');

        // Get enrichment
        let enrichment = null;
        if (carrier.dot_number) {
            const enrichResult = await queryFromSource('enrichments', {
                eq: { dot_number: String(carrier.dot_number) }
            });
            if (enrichResult.items.length > 0) enrichment = enrichResult.items[0];
        }

        return {
            ...normalizeCarrier(carrier),
            enrichment,
            status: carrier.admin_status || 'active',
            isFlagged: carrier.is_flagged || false
        };
    } catch (error) {
        console.error('Error fetching carrier detail:', error);
        throw new Error('Failed to fetch carrier detail');
    }
}

/**
 * Update carrier status/flag
 */
export async function updateCarrierStatus(carrierId, updates) {
    // Collection: Carriers (carriers)
    await requireAdmin();
    try {
        const carrier = await getFromSource('carriers', carrierId);
        if (!carrier) throw new Error('Carrier not found');

        let changed = false;
        if (updates.status && updates.status !== carrier.admin_status) {
            carrier.admin_status = updates.status;
            changed = true;
        }
        if (typeof updates.isFlagged === 'boolean' && updates.isFlagged !== carrier.is_flagged) {
            carrier.is_flagged = updates.isFlagged;
            changed = true;
        }

        if (changed) {
            await updateInSource('carriers', carrier);
            await logAdminAction('updateCarrier', carrierId, updates);
        }

        return carrier;
    } catch (error) {
        console.error('Error updating carrier:', error);
        throw new Error('Failed to update carrier');
    }
}

function normalizeCarrier(carrier) {
    // Reuse the mapping logic matching frontend expectation
    return {
        _id: carrier._id,
        legalName: carrier.legal_name,
        dbaName: carrier.dba_name,
        dotNumber: carrier.dot_number,
        mcNumber: carrier.mc_number,
        city: carrier.phy_city,
        state: carrier.phy_state,
        fleetSize: carrier.nbr_power_unit,
        safetyRating: carrier.safety_rating,
        // ... pass through other raw fields too
        ...carrier
    };
}

src/backend/apiAuthService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/apiAuthService.jsw: * Parse bearer token from an Authorization header.
src/backend/apiAuthService.jsw:  const [scheme, token] = authHeader.split(' ');
src/backend/apiAuthService.jsw:  if (!scheme || !token || scheme.toLowerCase() !== 'bearer') return null;
src/backend/apiAuthService.jsw:  return token.trim();
src/backend/apiAuthService.jsw: * Uses SHA-256 with optional pepper from secrets.
src/backend/apiAuthService.jsw:    return { success: false, errorCode: 'invalid_api_key', message: 'Missing Bearer token' };
src/backend/apiAuthService.jsw:    return { success: false, errorCode: 'invalid_api_key', message: 'Invalid API key' };
src/backend/apiAuthService.jsw:  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
src/backend/apiAuthService.jsw:    api_keys: updated,
src/backend/apiAuthService.jsw:  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
src/backend/apiAuthService.jsw:  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
src/backend/apiAuthService.jsw:    api_keys: updatedKeys,
src/backend/apiAuthService.jsw:  const keyMeta = (partner.api_keys || []).find((k) =>
src/backend/ragService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/ragService.jsw: * @param {number} [budgetTokens=2000] - Max tokens in assembled context
src/backend/intentService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/semanticSearchService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/metaComplianceService.jsw:      tokenExpiry: [
src/backend/metaComplianceService.jsw:        'Detect expiring token via runMetaTokenHealthChecks scheduler output.',
src/backend/metaComplianceService.jsw:        'Run refresh_system_user_token on impacted integration.',
src/backend/metaComplianceService.jsw:        'Validate get_token_health and list_ad_accounts for the same integration.',
src/backend/metaComplianceService.jsw:        'Confirm integration token health and ad-account binding.',
src/backend/parkingService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/parkingService.jsw:            secretKey: 'OHGO_API_KEY'
src/backend/parkingService.jsw:            secretKey: 'WI_511_API_KEY'
src/backend/parkingService.jsw:            secretKey: 'AZ_511_API_KEY'
src/backend/parkingService.jsw:            secretKey: 'GA_511_API_KEY'
src/backend/parkingService.jsw:        const apiKey = await getSecret(API_CONFIG.TPIMS.OHGO.secretKey).catch(() => null);
src/backend/parkingService.jsw:        const apiKey = await getSecret(API_CONFIG.TPIMS.WI_511.secretKey).catch(() => null);
src/backend/csaMonitorService.jsw:import { dispatchSafetyAlertEvent } from 'backend/apiWebhookService';
src/backend/csaMonitorService.jsw:        await dispatchSafetyAlertEvent({
src/backend/adapters/state511.js:import { getSecret } from 'wix-secrets-backend';
src/backend/adapters/state511.js: * API: https://api.511.org/traffic/events?api_key={KEY}
src/backend/adapters/state511.js:                console.warn('[511-CA] Missing CALTRANS_API_KEY secret. Returning empty.');
src/backend/adapters/state511.js:            const url = `https://api.511.org/traffic/events?api_key=${apiKey}&format=json`;
src/backend/adapters/state511.js:                console.warn('[511-TX] Missing DRIVETEXAS_API_KEY secret. Returning empty.');
src/backend/externalMatchingApi.jsw:  delete clone.password;
src/backend/apiPortalService.jsw:    '  -H "Authorization: Bearer lmdr_live_xxx"'
src/backend/apiPortalService.jsw:    '  { headers: { Authorization: "Bearer lmdr_live_xxx" } }',
src/backend/apiPortalService.jsw:    "headers = {'Authorization': 'Bearer lmdr_live_xxx'}",
src/backend/apiPortalService.jsw:    api_keys: [{
src/backend/apiPortalService.jsw:    webhook_secret: input.webhook_secret || null,
src/backend/apiPortalService.jsw:    api_key: apiKey
src/backend/apiPortalService.jsw:    api_keys: keys?.keys || [],
src/backend/apiPortalService.jsw:  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
src/backend/apiPortalService.jsw:  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
src/backend/apiPortalService.jsw:    api_keys: nextKeys,
src/backend/apiPortalService.jsw:    api_key: keyValue
src/backend/apiPortalService.jsw:  const keys = Array.isArray(partner.api_keys) ? partner.api_keys : [];
src/backend/apiPortalService.jsw:    api_keys: updatedKeys,
src/backend/apiPortalService.jsw:  const signature = await computeWebhookSignature(partner.webhook_secret || '', payload);
src/backend/apiPortalService.jsw:async function computeWebhookSignature(secret, payload) {
src/backend/apiPortalService.jsw:  if (!secret) return null;
src/backend/apiPortalService.jsw:      new TextEncoder().encode(secret),
src/backend/agentRuntimeService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/agentRuntimeService.jsw: * routeAIRequest: { contentBlocks, stopReason, tokensUsed, content }
src/backend/agentRuntimeService.jsw: * @param {number}  [params.maxTokens]    - Max tokens for this step (default: 2048)
src/backend/agentRuntimeService.jsw: *   tokensUsed:   number,
src/backend/agentRuntimeService.jsw: * streaming and returns { token, eventsPath } immediately.
src/backend/agentRuntimeService.jsw: * Returns { token, streamUrl, requestId } to the page code. The page code
src/backend/agentRuntimeService.jsw: * The browser needs NO auth headers — the token itself (unguessable 48-char
src/backend/agentRuntimeService.jsw: * @returns {Promise<{ token: string, streamUrl: string, requestId: string }>}
src/backend/agentRuntimeService.jsw:  console.log(`[agentRuntime] Stream session created in ${Date.now() - callStart}ms token=${data.token?.slice(0, 8)}…`);
src/backend/agentRuntimeService.jsw:    token:      data.token,
src/backend/agentRuntimeService.jsw:  // agentService.jsw expects: { contentBlocks, stopReason, tokensUsed, content }
src/backend/agentRuntimeService.jsw:    tokensUsed:    (data.inputTokens || 0) + (data.outputTokens || 0),
src/backend/socialScanner.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/socialScanner.jsw:        max_tokens: 800,
src/backend/socialScanner.jsw:      inputTokens: usage.prompt_tokens,
src/backend/socialScanner.jsw:      outputTokens: usage.completion_tokens,
src/backend/socialScanner.jsw:      totalTokens: usage.total_tokens,
src/backend/socialScanner.jsw:      details: { carrierName, dotNumber, latencyMs, tokensUsed: usage.total_tokens }
src/backend/ragIngestionService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/airtableClient.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/airtableClient.jsw:  secretNames: ['AIRTABLE_PAT', 'AIRTABLE_API_KEY'], // Try PAT first, then legacy key
src/backend/airtableClient.jsw:    'tokensUsed': '__SKIP__',
src/backend/airtableClient.jsw:    'tokens_in': 'Tokens In',
src/backend/airtableClient.jsw:    'tokens_out': 'Tokens Out',
src/backend/airtableClient.jsw:  for (const secretName of CONFIG.secretNames) {
src/backend/airtableClient.jsw:      const key = await getSecret(secretName);
src/backend/airtableClient.jsw:      // Try next secret name
src/backend/airtableClient.jsw: * @param {string} [options.offset] - Pagination offset token
src/backend/apiWebhookService.jsw:export async function dispatchSafetyAlertEvent(event = {}) {
src/backend/apiWebhookService.jsw:      webhookSecret: subscription.webhook_secret || null,
src/backend/apiWebhookService.jsw:    webhook_secret: webhookSecret,
src/backend/apiWebhookService.jsw:  const signature = await createWebhookSignature(delivery.webhook_secret || '', timestamp, body);
src/backend/apiWebhookService.jsw:  const token = Array.from(bytes).map((b) => b.toString(16).padStart(2, '0')).join('');
src/backend/apiWebhookService.jsw:  return `whsec_${token}`;
src/backend/apiWebhookService.jsw:async function createWebhookSignature(secret, timestamp, body) {
src/backend/apiWebhookService.jsw:  if (!secret) return null;
src/backend/apiWebhookService.jsw:      new TextEncoder().encode(secret),
src/backend/fuelService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/apiGateway.jsw:  if (code === 'invalid_api_key') return 401;
src/backend/apiGateway.jsw:  if (code === 'invalid_api_key') return 401;
src/backend/apiGateway.jsw:      api_key_id: apiKeyId,
src/backend/apiGateway.jsw:  const webhookSecret = String(body?.webhook_secret || '').trim() || generateWebhookSecret();
src/backend/apiGateway.jsw:    webhook_secret: webhookSecret,
src/backend/apiGateway.jsw:      webhook_secret: created.webhook_secret || webhookSecret
src/backend/eldIntegrationService.jsw: * @param {Object} credentials - API keys/tokens
src/backend/eldIntegrationService.jsw:        api_key: credentials.apiKey, // In production, this should be encrypted
src/backend/socialTokenHealthJob.jsw:import * as secretService from 'backend/socialSecretService';
src/backend/socialTokenHealthJob.jsw:import * as tokenService from 'backend/socialTokenService';
src/backend/socialTokenHealthJob.jsw:      const token = await secretService.getFBPageToken(pageId);
src/backend/socialTokenHealthJob.jsw:      const status = await tokenService.validateToken(token);
src/backend/socialTokenHealthJob.jsw:        await queueService.appendAuditLog('token_health_alert', {
src/backend/socialTokenHealthJob.jsw:      const token = await secretService.getIGUserToken(igUserId);
src/backend/socialTokenHealthJob.jsw:      const status = await tokenService.validateToken(token);
src/backend/socialTokenHealthJob.jsw:        await queueService.appendAuditLog('token_health_alert', {
src/backend/b2bResearchAgentService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/b2bResearchAgentService.jsw:      max_tokens: LLM_CONFIG.maxTokens,
src/backend/b2bResearchAgentService.jsw:      inputTokens: usage.input_tokens,
src/backend/b2bResearchAgentService.jsw:      outputTokens: usage.output_tokens,
src/backend/b2bResearchAgentService.jsw:      totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0),
src/backend/b2bResearchAgentService.jsw:  // Run in parallel with secret loading to minimise added latency.
src/backend/b2bResearchAgentService.jsw:      throw new Error(`runParallelResearch: secret load failed: ${err.message}`);
src/backend/b2bContentAIService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/b2bContentAIService.jsw:      max_tokens: maxTokens,
src/backend/b2bContentAIService.jsw:      inputTokens: usage.input_tokens,
src/backend/b2bContentAIService.jsw:      outputTokens: usage.output_tokens,
src/backend/b2bContentAIService.jsw:      totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0),
src/backend/documentCollectionService.jsw:    tokenExpiryHours: 48,
src/backend/documentCollectionService.jsw:function generateUploadToken(expiryHours = CONFIG.tokenExpiryHours) {
src/backend/documentCollectionService.jsw:    const token = `tok_${Date.now()}_${uuidv4().replace(/-/g, '')}`;
src/backend/documentCollectionService.jsw:    return { token, expiry: expiry.toISOString() };
src/backend/documentCollectionService.jsw:function isTokenValid(tokenExpiry) {
src/backend/documentCollectionService.jsw:    return tokenExpiry ? new Date(tokenExpiry) > new Date() : false;
src/backend/documentCollectionService.jsw:        const { token, expiry } = generateUploadToken();
src/backend/documentCollectionService.jsw:                upload_token: token, upload_token_expiry: expiry, _createdDate: now, _updatedDate: now
src/backend/documentCollectionService.jsw:        return { success: true, requestIds, uploadPortalUrl: `${CONFIG.baseUrl}/document-upload?token=${token}`, token, tokenExpiry: expiry };
src/backend/documentCollectionService.jsw:export async function uploadDocument(token, documentType, fileData) {
src/backend/documentCollectionService.jsw:    if (!token || !documentType || !fileData) return { success: false, error: 'Missing required fields' };
src/backend/documentCollectionService.jsw:            filters: { upload_token: token, document_type: documentType },
src/backend/documentCollectionService.jsw:        if (!result.success || result.items.length === 0) return { success: false, error: 'Invalid token or document type' };
src/backend/documentCollectionService.jsw:        if (!isTokenValid(docRequest.upload_token_expiry)) return { success: false, error: 'Upload token has expired' };
src/backend/documentCollectionService.jsw:        const { token, expiry } = generateUploadToken(48);
src/backend/documentCollectionService.jsw:        const updatedDoc = { ...docRequest, reminder_sent_count: currentCount + 1, last_reminder_date: now, upload_token: token, upload_token_expiry: expiry, _updatedDate: now };
src/backend/documentCollectionService.jsw:                uploadUrl: `${CONFIG.baseUrl}/document-upload?token=${token}`,
src/backend/documentCollectionService.jsw:        const { token, expiry } = generateUploadToken();
src/backend/documentCollectionService.jsw:            await dataAccess.updateRecord(COLLECTION_KEYS.documentRequests, { ...doc, upload_token: token, upload_token_expiry: expiry, _updatedDate: now }, { suppressAuth: true });
src/backend/documentCollectionService.jsw:        return { success: true, token, tokenExpiry: expiry, uploadPortalUrl: `${CONFIG.baseUrl}/document-upload?token=${token}`, documentsUpdated: result.items.length };
src/backend/documentCollectionService.jsw:        console.error('[DocumentCollection] Error regenerating token:', error);
src/backend/observabilityService.jsw:    const tokensUsed = Number(aiLog.tokensUsed || aiLog.tokens || 0);
src/backend/observabilityService.jsw:        tokensUsed,
src/backend/observabilityService.jsw:        const tokens = Number(item.tokensUsed || 0);
src/backend/observabilityService.jsw:        totalTokens += tokens;
src/backend/observabilityService.jsw:        if (!providerMap[provider]) providerMap[provider] = { provider, requests: 0, tokens: 0, cost: 0, avgLatency: 0, latencyTotal: 0 };
src/backend/observabilityService.jsw:        providerMap[provider].tokens += tokens;
src/backend/observabilityService.jsw:        providerMap[provider].cost += tokens * 0.000002;
src/backend/observabilityService.jsw:        if (!functionMap[functionId]) functionMap[functionId] = { functionId, requests: 0, tokens: 0, cost: 0, avgLatency: 0, latencyTotal: 0 };
src/backend/observabilityService.jsw:        functionMap[functionId].tokens += tokens;
src/backend/observabilityService.jsw:        functionMap[functionId].cost += tokens * 0.000002;
src/backend/observabilityService.jsw:        tokens: item.tokens,
src/backend/observabilityService.jsw:        tokens: item.tokens,
src/backend/observabilityService.jsw:        row.aiTokens += Number(usage.tokensUsed || 0);
src/backend/observabilityService.jsw:    const aiTokens = aiUsage.reduce((sum, row) => sum + Number(row.tokensUsed || 0), 0);
src/backend/observabilityService.jsw:            actualValue = (usage.items || []).reduce((sum, item) => sum + Number(item.tokensUsed || 0), 0);
src/backend/jobBoardService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/jobBoardService.jsw:            api_key: credentials.apiKey || '',
src/backend/jobBoardService.jsw:    const apiKey = await getSecret('INDEED_PUBLISHER_KEY') || credentials.api_key;
src/backend/jobBoardService.jsw:    const apiKey = await getSecret('ZIPRECRUITER_API_KEY') || credentials.api_key;
src/backend/jobBoardService.jsw:    const response = await fetch(`https://api.ziprecruiter.com/jobs/v1?api_key=${apiKey}`, {
src/backend/jobBoardService.jsw:    const apiKey = credentials.api_key;
src/backend/socialRateLimitService.jsw:import * as secretService from 'backend/socialSecretService';
src/backend/socialRateLimitService.jsw:    const token = await secretService.getIGUserToken(igUserId);
src/backend/socialRateLimitService.jsw:    const url = `${GRAPH_BASE}/${igUserId}/content_publishing_limit?fields=quota_usage,config&since=${since}&access_token=${encodeURIComponent(token)}`;
src/backend/agentRunLedgerService.jsw:    total_tokens: 0,
src/backend/agentRunLedgerService.jsw:    total_tokens: totalTokens || 0,
src/backend/ocrService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/ocrService.jsw:        if (!apiKey) throw new Error('GEMINI_API_KEY not found in secrets');
src/backend/admin_dashboard_service.jsw:    // Token pricing per 1M tokens
src/backend/admin_dashboard_service.jsw:    tokenPricing: {
src/backend/admin_dashboard_service.jsw:            if (!providerStats[p]) providerStats[p] = { provider: p, requests: 0, tokens: 0, cost: 0 };
src/backend/admin_dashboard_service.jsw:            const t = log.tokensUsed || 0; providerStats[p].tokens += t;
src/backend/admin_dashboard_service.jsw:            const pricing = CONFIG.tokenPricing[p] || { input: 1.00, output: 1.00 };
src/backend/externalDocumentApi.jsw:  const callbackSecret = String(body?.webhook_secret || '').trim() || null;
src/backend/smsCampaignService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/voiceService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/tests/airtableConnectionTest.jsw: * Verify secret configuration
src/backend/tests/airtableConnectionTest.jsw: * Returns info about which secret name was found
src/backend/tests/airtableConnectionTest.jsw:  // This is a diagnostic function - the actual secret check happens in airtableClient
src/backend/externalEngagementApi.jsw:  const webhookSecret = String(body?.webhook_secret || '').trim() || generateWebhookSecret();
src/backend/externalEngagementApi.jsw:    webhook_secret: webhookSecret,
src/backend/externalEngagementApi.jsw:      webhook_secret: webhookSecret,
src/backend/externalEngagementApi.jsw:      webhookSecret: subscription.webhook_secret || null,
src/backend/aiRouterService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/aiRouterService.jsw:        secretKey: 'CLAUDE_API_KEY',
src/backend/aiRouterService.jsw:        secretKey: 'OPENAI_API_KEY',
src/backend/aiRouterService.jsw:        secretKey: 'GROQ_API_KEY',
src/backend/aiRouterService.jsw:        secretKey: 'PERPLEXITY_API_KEY',
src/backend/aiRouterService.jsw:        secretKey: 'GEMINI_API_KEY',
src/backend/aiRouterService.jsw:        secretKey: 'MISTRAL_API_KEY',
src/backend/aiRouterService.jsw:        secretKey: 'COHERE_API_KEY',
src/backend/aiRouterService.jsw:            const key = await getSecret(provider.secretKey);
src/backend/aiRouterService.jsw:            apiKeySecret: provider.secretKey // So admin knows which secret to set
src/backend/aiRouterService.jsw:            totalTokens += logItem.tokensUsed || 0;
src/backend/aiRouterService.jsw:                byFunction[logItem.functionId] = { calls: 0, tokens: 0, errors: 0 };
src/backend/aiRouterService.jsw:            byFunction[logItem.functionId].tokens += logItem.tokensUsed || 0;
src/backend/aiRouterService.jsw:                byProvider[logItem.provider] = { calls: 0, tokens: 0, avgLatency: 0, errors: 0 };
src/backend/aiRouterService.jsw:            byProvider[logItem.provider].tokens += logItem.tokensUsed || 0;
src/backend/aiRouterService.jsw:                // Calculate estimated savings (per 1k tokens)
src/backend/aiRouterService.jsw:    await logUsage(functionId, config.provider, config.model, latency, response?.tokensUsed, error, usedFallback, isOptimized, savingsEstimate);
src/backend/aiRouterService.jsw:        // Approximate actual savings: (tokens / 1000) * savingsEstimate
src/backend/aiRouterService.jsw:        const actualSavings = (response?.tokensUsed ? (response.tokensUsed / 1000) * savingsEstimate : 0);
src/backend/aiRouterService.jsw:                totalTokens: response?.tokensUsed,
src/backend/aiRouterService.jsw:        totalTokens: response?.tokensUsed,
src/backend/aiRouterService.jsw:                // Estimate cost: (1k input + 1k output) as rough baseline or use request tokens
src/backend/aiRouterService.jsw:                // Assume avg request 2k tokens?
src/backend/aiRouterService.jsw: * Estimate cost for a specific provider/model (per 1k tokens proxy)
src/backend/aiRouterService.jsw:    const apiKey = await getSecret(provider.secretKey);
src/backend/aiRouterService.jsw:        throw new Error(`API key not configured for ${providerId}. Set secret: ${provider.secretKey}`);
src/backend/aiRouterService.jsw:    await log({ level: 'DEBUG', source: 'ai-router', message: `Provider ${providerId} call completed`, traceId, duration: callLatency, details: { model: modelId, tokens: result.tokensUsed } });
src/backend/aiRouterService.jsw:            max_tokens: request.maxTokens || 1024,
src/backend/aiRouterService.jsw:        tokensUsed: (data.usage?.input_tokens || 0) + (data.usage?.output_tokens || 0),
src/backend/aiRouterService.jsw:            max_tokens: request.maxTokens || 1024,
src/backend/aiRouterService.jsw:        tokensUsed: (data.usage?.prompt_tokens || 0) + (data.usage?.completion_tokens || 0),
src/backend/aiRouterService.jsw:        tokensUsed: data.usageMetadata?.totalTokenCount || 0,
src/backend/aiRouterService.jsw:        tokensUsed: (data.meta?.tokens?.input_tokens || 0) + (data.meta?.tokens?.output_tokens || 0),
src/backend/aiRouterService.jsw:async function logUsage(functionId, provider, model, latencyMs, tokensUsed, error, usedFallback, isOptimized = false, savings = 0) {
src/backend/aiRouterService.jsw:            functionId, provider, model, latencyMs, tokensUsed: tokensUsed || 0,
src/backend/aiRouterService.jsw:        const apiKey = await getSecret(provider.secretKey);
src/backend/aiRouterService.jsw:                message: `API key not set. Add secret: ${provider.secretKey}`
src/backend/aiRouterService.jsw:                // Savings is stored as 'savingsEstimate' per 1k tokens?
src/backend/aiRouterService.jsw:                // Actual savings = (tokens / 1000) * savingsEstimate.
src/backend/aiRouterService.jsw:                // cost = (log.tokensUsed / 1000) * unitCost
src/backend/aiRouterService.jsw:                const actualSavings = (log.tokensUsed / 1000) * unitSavings;
src/backend/aiRouterService.jsw:            totalCost += (log.tokensUsed / 1000) * unitCost;
src/backend/socialSecretService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/socialSecretService.jsw:  async get(secretKey) {
src/backend/socialSecretService.jsw:    return getSecret(secretKey);
src/backend/socialSecretService.jsw:  async get(secretKey) {
src/backend/socialSecretService.jsw:    console.warn(`[socialSecretService] GCPSecretProvider not implemented for ${secretKey}. Falling back to Wix secrets.`);
src/backend/socialSecretService.jsw:    return WixSecretProvider.get(secretKey);
src/backend/socialSecretService.jsw:async function getRequiredSecret(secretKey) {
src/backend/socialSecretService.jsw:  const value = await getProvider().get(secretKey);
src/backend/socialSecretService.jsw:    throw new Error(`Missing required secret: ${secretKey}`);
src/backend/socialSecretService.jsw:  return getRequiredSecret(`meta_page_token_${pageId}`);
src/backend/socialSecretService.jsw:  return getRequiredSecret(`meta_ig_token_${igUserId}`);
src/backend/socialSecretService.jsw:  return getRequiredSecret('meta_app_secret');
src/backend/socialSecretService.jsw:  return getRequiredSecret(`meta_user_token_${userId}`);
src/backend/socialPostingService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/socialPostingService.jsw: * Connect a social account via OAuth token exchange
src/backend/socialPostingService.jsw:        const tokenResult = await _exchangeOAuthCode(platform, authCode);
src/backend/socialPostingService.jsw:        if (!tokenResult.success) {
src/backend/socialPostingService.jsw:            return { success: false, error: `OAuth failed: ${tokenResult.error}` };
src/backend/socialPostingService.jsw:            account_id: tokenResult.accountId,
src/backend/socialPostingService.jsw:            account_name: tokenResult.accountName || '',
src/backend/socialPostingService.jsw:            access_token: tokenResult.accessToken,
src/backend/socialPostingService.jsw:            refresh_token: tokenResult.refreshToken || '',
src/backend/socialPostingService.jsw:            token_expires_at: tokenResult.expiresAt || null,
src/backend/socialPostingService.jsw:            page_id: tokenResult.pageId || '',
src/backend/socialPostingService.jsw:            page_name: tokenResult.pageName || '',
src/backend/socialPostingService.jsw:        return { success: true, accountName: tokenResult.accountName };
src/backend/socialPostingService.jsw:        // Revoke token with platform
src/backend/socialPostingService.jsw:        await _revokeToken(account.platform, account.access_token).catch(() => { });
src/backend/socialPostingService.jsw:            access_token: '',
src/backend/socialPostingService.jsw:            refresh_token: '',
src/backend/socialPostingService.jsw:        // Strip sensitive tokens from response
src/backend/socialPostingService.jsw:            tokenExpiresAt: a.token_expires_at
src/backend/socialPostingService.jsw: * Refresh an expiring access token
src/backend/socialPostingService.jsw:        if (!account || !account.refresh_token) {
src/backend/socialPostingService.jsw:            return { success: false, error: 'Account not found or no refresh token' };
src/backend/socialPostingService.jsw:        const result = await _refreshToken(account.platform, account.refresh_token);
src/backend/socialPostingService.jsw:            access_token: result.accessToken,
src/backend/socialPostingService.jsw:            refresh_token: result.refreshToken || account.refresh_token,
src/backend/socialPostingService.jsw:            token_expires_at: result.expiresAt,
src/backend/socialPostingService.jsw:            token_refreshed_at: new Date().toISOString()
src/backend/socialPostingService.jsw: * Scheduler: Refresh expiring social tokens (daily 3am)
src/backend/socialPostingService.jsw:        soon.setDate(soon.getDate() + 7); // Refresh tokens expiring within 7 days
src/backend/socialPostingService.jsw:            if (!account.token_expires_at) continue;
src/backend/socialPostingService.jsw:            if (account.token_expires_at > soon.toISOString()) continue;
src/backend/socialPostingService.jsw:            access_token: account.access_token
src/backend/socialPostingService.jsw:                'Authorization': `Bearer ${account.access_token}`,
src/backend/socialPostingService.jsw:                    `https://graph.facebook.com/v18.0/${externalPostId}?fields=likes.summary(true),comments.summary(true),shares&access_token=${account.access_token}`
src/backend/socialPostingService.jsw:                    { headers: { 'Authorization': `Bearer ${account.access_token}` } }
src/backend/socialPostingService.jsw:                    `https://graph.facebook.com/v18.0/oauth/access_token?client_id=${appId}&redirect_uri=${encodeURIComponent(redirectUri)}&client_secret=${appSecret}&code=${authCode}`
src/backend/socialPostingService.jsw:                const userResp = await fetch(`https://graph.facebook.com/me?access_token=${data.access_token}&fields=id,name`);
src/backend/socialPostingService.jsw:                    accessToken: data.access_token,
src/backend/socialPostingService.jsw:                    client_secret: clientSecret
src/backend/socialPostingService.jsw:                    headers: { 'Authorization': `Bearer ${data.access_token}` }
src/backend/socialPostingService.jsw:                    accessToken: data.access_token,
src/backend/socialPostingService.jsw:                    refreshToken: data.refresh_token || '',
src/backend/socialPostingService.jsw:                grant_type: 'refresh_token',
src/backend/socialPostingService.jsw:                refresh_token: refreshToken,
src/backend/socialPostingService.jsw:                client_secret: clientSecret
src/backend/socialPostingService.jsw:                accessToken: data.access_token,
src/backend/socialPostingService.jsw:                refreshToken: data.refresh_token || refreshToken,
src/backend/socialPostingService.jsw:        // Facebook long-lived tokens don't use refresh_token flow
src/backend/socialPostingService.jsw:        await fetch(`https://graph.facebook.com/me/permissions?access_token=${accessToken}`, { method: 'DELETE' });
src/backend/socialPostingService.jsw:    // LinkedIn token revocation requires a separate API call
src/backend/socialPostingService.jsw:async function graphFetch(url, token, body, method = 'POST') {
src/backend/socialPostingService.jsw:            'Authorization': `Bearer ${token}`,
src/backend/socialPostingService.jsw:async function postFacebookByType(pageId, token, payload = {}) {
src/backend/socialPostingService.jsw:        const { response, payload: graph } = await graphFetch(`${META_GRAPH_BASE}/${pageId}/photos`, token, body);
src/backend/socialPostingService.jsw:        const { response, payload: graph } = await graphFetch(`${META_GRAPH_BASE}/${pageId}/videos`, token, body);
src/backend/socialPostingService.jsw:    const { response, payload: graph } = await graphFetch(`${META_GRAPH_BASE}/${pageId}/feed`, token, toBody(requestBody));
src/backend/socialPostingService.jsw:async function pollContainerStatus(containerId, token) {
src/backend/socialPostingService.jsw:        const response = await fetch(`${META_GRAPH_BASE}/${containerId}?fields=status_code,media_product_type&access_token=${encodeURIComponent(token)}`);
src/backend/socialPostingService.jsw:        const token = await socialSecretService.getFBPageToken(pageId);
src/backend/socialPostingService.jsw:        const result = await postFacebookByType(pageId, token, payload);
src/backend/socialPostingService.jsw:async function createIGMediaContainer(igUserId, token, payload = {}) {
src/backend/socialPostingService.jsw:                access_token: token
src/backend/socialPostingService.jsw:            access_token: token
src/backend/socialPostingService.jsw:        body: toBody({ ...body, access_token: token })
src/backend/socialPostingService.jsw:        const token = await socialSecretService.getIGUserToken(igUserId);
src/backend/socialPostingService.jsw:        const container = await createIGMediaContainer(igUserId, token, payload);
src/backend/socialPostingService.jsw:            const poll = await pollContainerStatus(container.container_id, token);
src/backend/socialPostingService.jsw:                access_token: token
src/backend/seeds/seedAdminCore.jsw:            tokens_used: isFailed ? 0 : (100 + Math.floor(Math.random() * 9900)), // 100 to 10000
src/backend/agentService.jsw:    get_token_health:            { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'getTokenHealth',          argMapping: ['integrationId'],                      policy: { risk_level: 'read',         requires_approval: false, rate_limit: 20 } },
src/backend/agentService.jsw:    refresh_system_user_token:   { serviceModule: 'backend/metaGovernanceService', serviceFunction: 'refreshSystemUserToken',  argMapping: ['integrationId', 'payload'],           policy: { risk_level: 'execute_low',  requires_approval: false, rate_limit: 10 } },
src/backend/agentService.jsw:    configure_api_key:    { serviceModule: 'backend/externalApiAgentService', serviceFunction: 'configureApiKey',    argMapping: ['userId', 'params'], policy: { risk_level: 'execute_high', requires_approval: true,  rate_limit: 3 } },
src/backend/agentService.jsw:    description: 'Meta ads integration governance operations: integration inventory, token health, error digest, rate-limit posture, audit events, token refresh, guardrail and threshold policies, quarantine, credential rotation, ad-account rebinding, and integration disable controls',
src/backend/agentService.jsw:          enum: ['list_meta_integrations', 'get_token_health', 'get_meta_api_error_digest', 'get_rate_limit_posture', 'get_audit_events',
src/backend/agentService.jsw:                 'refresh_system_user_token', 'set_campaign_guardrails', 'set_daily_budget_caps', 'set_approval_thresholds',
src/backend/agentService.jsw:          enum: ['query_safety_api', 'query_intel_api', 'query_ops_api', 'query_matching_api', 'query_document_api', 'query_engagement_api', 'get_api_usage', 'get_api_health', 'configure_api_key', 'test_api_endpoint'],
src/backend/agentService.jsw:  admin: 'You are VelocityMatch\'s AI platform admin assistant. You have 12 domain routers plus legacy flat tools:\n- admin_business_ops (10 actions): Revenue dashboard, billing overview, invoices (view/create), commission reports/approvals, MRR metrics, churn metrics, ARPU breakdown, financial report export\n- admin_platform_config (10 actions): Feature flags (view/toggle), A/B tests (view/create), email templates (view/update), notification rules (view/update), platform config (view/update)\n- admin_portal (10 actions): Admin dashboard overview, user list/detail, suspend/unsuspend users, moderation queue, moderate content, AI usage dashboard, compliance audit, login activity\n- admin_support (8 actions): Support tickets (list/detail/status/assign), knowledge base (browse/create articles), NPS scores, CSAT reports\n- admin_gamification (8 actions): Gamification config, XP rules, achievements (list/create), challenges (create/active), global leaderboard, gamification analytics\n- admin_feature_adoption (6 actions): Feature adoption rates, adoption funnels, feature health scores, stickiness metrics, adoption cohorts, nudge campaigns\n- admin_meta_ads_governance (13 actions): Meta integration inventory, token health, error digest, rate-limit posture, audit events, token refresh, guardrails, budget caps, approval thresholds, quarantine, credential rotation, ad-account rebinding, integration disable\n- observability_ops (5 actions): Distributed tracing dashboard, per-tool performance metrics, scoring accuracy analysis, scoring recalibration, agent run replay\n- external_api (10 actions): Query safety/CSA/intel/ops/matching/document/engagement APIs, API usage and health monitoring, API key management, endpoint testing\n- lifecycle_ops (10 actions): Driver/carrier timelines, lifecycle stage analytics, cohort retention analysis, feedback summaries, exit surveys\n- cross_role_utility (10 actions): Platform benchmarks, industry trends, regional analysis, carrier comparisons, mutual interest, market value\n- cross_role_paid_media_pipeline (7 actions): Paid-media-to-pipeline funnel, CPL-to-hire trend, source quality scoring, channel/geo suggestions, taxonomy sync/backfill\nEach router takes an \'action\' parameter to select the operation and \'params\' for action-specific data. You also have legacy flat tools for system health, driver stats, prompt management, agent KPIs, B2B CRM, market intel, lane demand, compensation benchmarks, hiring benchmarks, and conversion insights. Be thorough and data-driven.',
src/backend/agentService.jsw:        completeRun(runId, 'token_cap', totalTokens, 0)
src/backend/agentService.jsw:    totalTokens += aiResponse.tokensUsed || 0;
src/backend/agentService.jsw:      cr(runId, 'completed_with_rejection', aiResponse.tokensUsed || 0, 0).catch(() => {});
src/backend/agentService.jsw:    cr(runId, 'completed', aiResponse.tokensUsed || 0, 0).catch(() => {});
src/backend/metaAdsAuthService.jsw:  const expiresAt = integration.token_expires_at || integration.expires_at;
src/backend/metaAdsAuthService.jsw:    tokenExpiresAt: integration.token_expires_at || integration.expires_at || null,
src/backend/metaAdsAuthService.jsw:    token_expires_at: payload.expiresAt || payload.token_expires_at || integration.token_expires_at,
src/backend/metaAdsAuthService.jsw:    last_token_refresh_at: nowIso(),
src/backend/metaAdsAuthService.jsw:    return { success: false, error: result.error || 'Failed to refresh token metadata' };
src/backend/metaAdsAuthService.jsw:    action: 'refresh_system_user_token',
src/backend/metaAdsAuthService.jsw:    beforeState: { token_expires_at: integration.token_expires_at, status: integration.status },
src/backend/metaAdsAuthService.jsw:    afterState: { token_expires_at: next.token_expires_at, status: next.status },
src/backend/metaAdsAuthService.jsw:    app_secret_hint: payload.appSecretHint || integration.app_secret_hint || 'rotated',
src/backend/metaAdsAuthService.jsw:    token_expires_at: payload.expiresAt || payload.token_expires_at || integration.token_expires_at,
src/backend/metaAdsAuthService.jsw:      token_expires_at: integration.token_expires_at || ''
src/backend/metaAdsAuthService.jsw:      token_expires_at: next.token_expires_at || ''
src/backend/metaAdsAuthService.jsw:    return { success: false, error: result.error || 'Failed to load integrations for token check' };
src/backend/metaAdsAuthService.jsw:      Boolean(integration.next_token_expires_at);
src/backend/metaAdsAuthService.jsw:          token_expires_at: integration.next_token_expires_at,
src/backend/metaAdsAuthService.jsw:        error_code: status === 'expired' ? 'meta_token_expired' : 'meta_token_expiring_soon',
src/backend/metaAdsAuthService.jsw:      last_token_health_check_at: nowIso(),
src/backend/metaAdsAuthService.jsw:      token_health_status: status
src/backend/emailCampaignService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/emailCampaignService.jsw:            return { skipped: true, reason: 'no_api_key' };
src/backend/http-functions.js:import { getSecret } from 'wix-secrets-backend';
src/backend/http-functions.js:async function computeHmacSignature(message, secret) {
src/backend/http-functions.js:    const keyData = encoder.encode(secret);
src/backend/http-functions.js:// Header: x-lmdr-internal-key: <secret>
src/backend/socialTokenService.jsw:import * as secretService from 'backend/socialSecretService';
src/backend/socialTokenService.jsw:function maskToken(token = '') {
src/backend/socialTokenService.jsw:  if (!token) return '';
src/backend/socialTokenService.jsw:  if (token.length <= 10) return '***';
src/backend/socialTokenService.jsw:  return `${token.slice(0, 6)}...${token.slice(-4)}`;
src/backend/socialTokenService.jsw:function parseScopes(tokenData = {}) {
src/backend/socialTokenService.jsw:  if (Array.isArray(tokenData.scopes)) return tokenData.scopes;
src/backend/socialTokenService.jsw:  if (Array.isArray(tokenData.granular_scopes)) return tokenData.granular_scopes.map(s => s.scope).filter(Boolean);
src/backend/socialTokenService.jsw:export async function validateToken(token) {
src/backend/socialTokenService.jsw:    if (!token) return { success: false, is_valid: false, error: 'Token is required' };
src/backend/socialTokenService.jsw:    const appId = await secretService.getMetaAppId();
src/backend/socialTokenService.jsw:    const appSecret = await secretService.getMetaAppSecret();
src/backend/socialTokenService.jsw:    const query = toQueryString({ input_token: token, access_token: appAccessToken });
src/backend/socialTokenService.jsw:    const response = await fetch(`${GRAPH_BASE}/debug_token?${query}`);
src/backend/socialTokenService.jsw:    const tokenData = payload && payload.data ? payload.data : {};
src/backend/socialTokenService.jsw:      console.error('[socialTokenService] validateToken failed:', payload.error || response.statusText, maskToken(token));
src/backend/socialTokenService.jsw:    if (!tokenData.is_valid) {
src/backend/socialTokenService.jsw:      console.error('[socialTokenService] invalid token:', maskToken(token));
src/backend/socialTokenService.jsw:      is_valid: Boolean(tokenData.is_valid),
src/backend/socialTokenService.jsw:      expires_at: Number(tokenData.expires_at || 0),
src/backend/socialTokenService.jsw:      scopes: parseScopes(tokenData),
src/backend/socialTokenService.jsw:      app_id: tokenData.app_id || '',
src/backend/socialTokenService.jsw:      type: tokenData.type || ''
src/backend/socialTokenService.jsw:    console.error('[socialTokenService] validateToken error:', error.message, maskToken(token));
src/backend/socialTokenService.jsw:    const appId = await secretService.getMetaAppId();
src/backend/socialTokenService.jsw:    const appSecret = await secretService.getMetaAppSecret();
src/backend/socialTokenService.jsw:      grant_type: 'fb_exchange_token',
src/backend/socialTokenService.jsw:      client_secret: appSecret,
src/backend/socialTokenService.jsw:      fb_exchange_token: shortLivedToken
src/backend/socialTokenService.jsw:    const response = await fetch(`${GRAPH_BASE}/oauth/access_token?${query}`);
src/backend/socialTokenService.jsw:      access_token: payload.access_token || '',
src/backend/socialTokenService.jsw:      token_type: payload.token_type || 'bearer',
src/backend/socialTokenService.jsw:      access_token: longLivedUserToken,
src/backend/socialTokenService.jsw:      access_token: longLivedUserToken,
src/backend/socialTokenService.jsw:      fields: 'id,name,access_token,instagram_business_account{id,username}'
src/backend/socialTokenService.jsw:      page_access_token: page.access_token || '',
src/backend/agentEvaluationService.jsw:    const totalTokens = runs.reduce((sum, r) => sum + (r.total_tokens || 0), 0);
src/backend/agentEvaluationService.jsw:      cost: { total_tokens: totalTokens, total_usd: Math.round(totalCost * 10000) / 10000, avg_tokens_per_run: avgTokensPerRun },
src/backend/agentEvaluationService.jsw:  // Cost high (>5K tokens per successful run)
src/backend/agentEvaluationService.jsw:  if (scorecardData?.cost?.avg_tokens_per_run > 5000) {
src/backend/agentEvaluationService.jsw:      action: `High token usage (${scorecardData.cost.avg_tokens_per_run} avg/run) for ${role}. Consider using smaller models for read-only tools.`,
src/backend/stripeService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/stripeService.jsw:      secretKey,
src/backend/stripeService.jsw:      secretKey,
src/backend/stripeService.jsw:  const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:  const options = { method, headers: { 'Authorization': `Bearer ${secrets.secretKey}`, 'Content-Type': 'application/x-www-form-urlencoded' } };
src/backend/stripeService.jsw:    const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:      resolvedPriceId = (billingPeriod === '6month' && secrets.pricePro6Month) ? secrets.pricePro6Month : (secrets.priceProMonthly || secrets.pricePro);
src/backend/stripeService.jsw:      resolvedPriceId = (billingPeriod === '6month' && secrets.priceEnterprise6Month) ? secrets.priceEnterprise6Month : secrets.priceEnterprise;
src/backend/stripeService.jsw:    const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:    if (priceId === secrets.priceEnterprise || priceId === secrets.priceEnterprise6Month) planType = 'enterprise';
src/backend/stripeService.jsw:    const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:    return { success: true, publishableKey: secrets.publishableKey };
src/backend/stripeService.jsw:    const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:      'mode': 'payment', 'payment_method_types[0]': 'card', 'line_items[0][price]': secrets.pricePlacementDeposit, 'line_items[0][quantity]': String(driverCount), 'customer_email': email,
src/backend/stripeService.jsw:    await dataAccess.insertRecord(CONFIG.carrierPaymentsKey, { carrier_dot: carrierDot, stripe_session_id: sessionData.id, amount: secrets.pricePlacementDeposit * driverCount, status: 'pending' }, { suppressAuth: true });
src/backend/stripeService.jsw:    const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:        monthlyPriceId: secrets.priceApiStarterMonthly || null,
src/backend/stripeService.jsw:        annualPriceId: secrets.priceApiStarterAnnual || null
src/backend/stripeService.jsw:        monthlyPriceId: secrets.priceApiGrowthMonthly || null,
src/backend/stripeService.jsw:        annualPriceId: secrets.priceApiGrowthAnnual || null
src/backend/stripeService.jsw:        monthlyPriceId: secrets.priceApiEnterpriseMonthly || null,
src/backend/stripeService.jsw:        annualPriceId: secrets.priceApiEnterpriseAnnual || null
src/backend/stripeService.jsw:  const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:  const secretKeyName = tierMap[planKey];
src/backend/stripeService.jsw:  return secrets?.[secretKeyName] || null;
src/backend/stripeService.jsw:  const secrets = await getStripeSecrets();
src/backend/stripeService.jsw:    [secrets.priceApiStarterMonthly, 'starter'],
src/backend/stripeService.jsw:    [secrets.priceApiStarterAnnual, 'starter'],
src/backend/stripeService.jsw:    [secrets.priceApiGrowthMonthly, 'growth'],
src/backend/stripeService.jsw:    [secrets.priceApiGrowthAnnual, 'growth'],
src/backend/stripeService.jsw:    [secrets.priceApiEnterpriseMonthly, 'enterprise'],
src/backend/stripeService.jsw:    [secrets.priceApiEnterpriseAnnual, 'enterprise']
src/backend/setupOnboardingCollections.jsw:  { name: 'documents_upload_token', type: 'TEXT', description: 'Secure token for upload portal' },
src/backend/setupOnboardingCollections.jsw: *    - Driver uploads via secure portal using documents_upload_token
src/backend/adminBillingService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/adminBillingService.jsw:  const secretKey = await getStripeKey();
src/backend/adminBillingService.jsw:      'Authorization': `Bearer ${secretKey}`,
src/backend/adminBillingService.jsw:    // Resolve new price ID from secrets
src/backend/metaGovernanceService.jsw:  const existing = integration.token_health_status;
src/backend/metaGovernanceService.jsw:  const expiresAt = integration.token_expires_at || integration.expires_at || '';
src/backend/metaGovernanceService.jsw:  const tokenHealthCounts = {
src/backend/metaGovernanceService.jsw:    const tokenStatus = deriveTokenStatus(integration);
src/backend/metaGovernanceService.jsw:    if (tokenHealthCounts[tokenStatus] !== undefined) {
src/backend/metaGovernanceService.jsw:      tokenHealthCounts[tokenStatus]++;
src/backend/metaGovernanceService.jsw:      tokenHealthCounts.unknown_expiry++;
src/backend/metaGovernanceService.jsw:    tokenHealthCounts.expired +
src/backend/metaGovernanceService.jsw:    tokenHealthCounts.quarantined +
src/backend/metaGovernanceService.jsw:    tokenHealthCounts.disabled;
src/backend/metaGovernanceService.jsw:  const warningCount = tokenHealthCounts.expiring_soon;
src/backend/metaGovernanceService.jsw:    tokenHealthCounts,
src/backend/setupCollections.jsw:    { name: 'api_key', type: 'text', description: 'Encrypted key' },
src/backend/setupCollections.jsw:    { name: 'api_keys', type: 'array', description: 'Array of key metadata objects' },
src/backend/setupCollections.jsw:    { name: 'webhook_secret', type: 'text', description: 'Webhook signing secret' },
src/backend/setupCollections.jsw:    { name: 'api_key_id', type: 'text', description: 'API key metadata ID' },
src/backend/setupCollections.jsw:    { name: 'webhook_secret', type: 'text', description: 'Per-subscription signing secret' },
src/backend/setupCollections.jsw:    { name: 'webhook_secret', type: 'text', description: 'Signing secret used for HMAC signature' },
src/backend/setupCollections.jsw:      { name: 'costInput', type: 'number', description: 'Cost per 1k input tokens ($)' },
src/backend/setupCollections.jsw:      { name: 'costOutput', type: 'number', description: 'Cost per 1k output tokens ($)' },
src/backend/asyncSearchService.jsw:import { getSecret }  from 'wix-secrets-backend';
src/backend/aiEnrichment.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/aiEnrichment.jsw:async function getCachedSecret(secretName) {
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.perplexitySecret && __perplexityKeyCache && (now - __keyCacheTime < KEY_CACHE_TTL)) return __perplexityKeyCache;
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.claudeSecret && __claudeKeyCache && (now - __keyCacheTime < KEY_CACHE_TTL)) return __claudeKeyCache;
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.groqSecret && __groqKeyCache && (now - __keyCacheTime < KEY_CACHE_TTL)) return __groqKeyCache;
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.geminiSecret && __geminiKeyCache && (now - __keyCacheTime < KEY_CACHE_TTL)) return __geminiKeyCache;
src/backend/aiEnrichment.jsw:  const key = await getSecret(secretName);
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.perplexitySecret) __perplexityKeyCache = key;
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.claudeSecret) __claudeKeyCache = key;
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.groqSecret) __groqKeyCache = key;
src/backend/aiEnrichment.jsw:  if (secretName === CONFIG.geminiSecret) __geminiKeyCache = key;
src/backend/aiEnrichment.jsw:        max_tokens: 600,
src/backend/aiEnrichment.jsw:      inputTokens: usage.prompt_tokens,
src/backend/aiEnrichment.jsw:      outputTokens: usage.completion_tokens,
src/backend/aiEnrichment.jsw:      totalTokens: usage.total_tokens,
src/backend/aiEnrichment.jsw:      max_tokens: CONFIG.maxTokens,
src/backend/aiEnrichment.jsw:      inputTokens: usage.prompt_tokens,
src/backend/aiEnrichment.jsw:      outputTokens: usage.completion_tokens,
src/backend/aiEnrichment.jsw:      totalTokens: usage.total_tokens,
src/backend/aiEnrichment.jsw:      max_tokens: CONFIG.maxTokens,
src/backend/aiEnrichment.jsw:      inputTokens: usage.input_tokens,
src/backend/aiEnrichment.jsw:      outputTokens: usage.output_tokens,
src/backend/aiEnrichment.jsw:      totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0),
src/backend/notificationDispatcher.jsw:export async function dispatchNotification(event, data) {
src/backend/notificationDispatcher.jsw:  return await dispatchNotification(event, data);
src/backend/fmcsaService.jsw:import { getSecret } from 'wix-secrets-backend';
src/backend/fmcsaService.jsw:  secretName: 'FMCSA_WEB_KEY',
src/backend/fmcsaService.jsw:    const webKey = await getSecret(CONFIG.secretName);
src/backend/fmcsaService.jsw:    const webKey = await getSecret(CONFIG.secretName);
src/public/driver/js/document-upload-logic.js:        token: state.uploadToken,
src/public/driver/js/document-upload-logic.js:          uploadToken: 'test-token-abc',
src/public/recruiter/recruiter-design-system.css:   Shared neumorphic tokens + components for recruiter HTML surfaces.
src/public/recruiter/recruiter-design-system.css:  /* Color tokens */
src/public/recruiter/recruiter-design-system.css:  /* Elevation tokens */
src/public/recruiter/os/js/ros-config.js:// Branding, tool registry, color tokens, feature flags
src/public/__tests__/matchNotifications.test.js:function canSendSMS(secrets) {
src/public/__tests__/matchNotifications.test.js:  return !!(secrets.TWILIO_ACCOUNT_SID && secrets.TWILIO_AUTH_TOKEN && secrets.TWILIO_PHONE_NUMBER);
src/public/__tests__/matchNotifications.test.js:    test('returns false when Twilio secrets not configured', () => {
src/public/__tests__/matchNotifications.test.js:    test('returns false when auth token missing', () => {
src/public/__tests__/matchNotifications.test.js:    test('returns true when all Twilio secrets configured', () => {
src/public/__tests__/__mocks__/wix-members-backend.js:  register: jest.fn(async (email, password, options = {}) => {
src/public/__tests__/__mocks__/wix-members-backend.js:  login: jest.fn(async (email, password) => {
src/public/__tests__/__mocks__/wix-secrets-backend.js: * Mock for wix-secrets-backend module
src/public/__tests__/__mocks__/wix-secrets-backend.js:// Mock secrets store
src/public/__tests__/__mocks__/wix-secrets-backend.js:  'STRIPE_WEBHOOK_SECRET': 'whsec_mock_secret',
src/public/__tests__/__mocks__/wix-secrets-backend.js:const secrets = {
src/public/__tests__/__mocks__/wix-secrets-backend.js:  getSecret: jest.fn(async (secretName) => {
src/public/__tests__/__mocks__/wix-secrets-backend.js:    if (mockSecrets[secretName]) {
src/public/__tests__/__mocks__/wix-secrets-backend.js:      return mockSecrets[secretName];
src/public/__tests__/__mocks__/wix-secrets-backend.js:    throw new Error(`Secret not found: ${secretName}`);
src/public/__tests__/__mocks__/wix-secrets-backend.js:  // Test helper to add secrets
src/public/__tests__/__mocks__/wix-secrets-backend.js:  // Test helper to remove secrets
src/public/__tests__/__mocks__/wix-secrets-backend.js:  // Test helper to reset secrets
src/public/__tests__/__mocks__/wix-secrets-backend.js:  secrets,
src/public/__tests__/__mocks__/wix-secrets-backend.js:  getSecret: secrets.getSecret
src/public/__tests__/apiAuthService.test.js:  test('parses bearer token', () => {
src/public/__tests__/apiAuthService.test.js:    expect(parseBearerToken('Bearer abc123')).toBe('abc123');
src/public/__tests__/apiAuthService.test.js:      api_keys: [{
src/public/__tests__/apiAuthService.test.js:      authorizationHeader: 'Bearer not_a_real_key'
src/public/__tests__/apiAuthService.test.js:    expect(result.errorCode).toBe('invalid_api_key');
src/public/__tests__/apiAuthService.test.js:            api_keys: [{ key_id: 'key_auth_2', key_hash: keyHash, is_active: true }]
src/public/__tests__/externalApiPlatformPhase8Flows.test.js:      api_keys: []
src/public/__tests__/externalApiPlatformPhase8Flows.test.js:    expect(result.api_key).toBe('lmdr_test_key_123');
src/public/__tests__/externalApiPlatformPhase8Flows.test.js:      api_keys: [{ key_id: 'key_1', is_active: true }]
src/public/__tests__/externalApiPlatformPhase8Flows.test.js:    expect(options.headers.Authorization).toContain('Bearer lmdr_live_x');
src/public/__tests__/adminObservability.test.js:const MOCK_AI_ANALYTICS = { requests: 150, avgLatency: 320, tokenUsage: 50000 };
src/public/__tests__/externalEngagementApi.test.js:  generateWebhookSecret: jest.fn(() => 'whsec_test_secret')
src/public/__tests__/crossRoleRouters.test.js:        'configure_api_key', 'test_api_endpoint'];
src/public/__tests__/crossRoleRouters.test.js:    it('configure_api_key returns approval_required (execute_high)', async () => {
src/public/__tests__/crossRoleRouters.test.js:      const result = await executeTool('external_api', { action: 'configure_api_key', params: {} }, { userId: 'u1', role: 'admin', runId: 'r1' });
src/public/__tests__/crossRoleRouters.test.js:      ['external_api', 'configure_api_key'],
src/public/__tests__/metaAdsAuthService.test.js:          next_token_expires_at: '2030-01-01T00:00:00.000Z',
src/public/__tests__/metaAdsAuthService.test.js:          token_expires_at: '2026-02-20T00:00:00.000Z'
src/public/__tests__/metaAdsAuthService.test.js:          next_token_expires_at: '2030-01-01T00:00:00.000Z',
src/public/__tests__/metaAdsAuthService.test.js:          token_expires_at: '2026-02-20T00:00:00.000Z'
src/public/__tests__/metaGovernanceService.test.js:  test('getMetaGovernanceSummary returns status and token rollups', async () => {
src/public/__tests__/metaGovernanceService.test.js:          token_health_status: 'healthy',
src/public/__tests__/metaGovernanceService.test.js:          token_expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
src/public/__tests__/metaGovernanceService.test.js:    expect(result.tokenHealthCounts.healthy).toBe(1);
src/public/__tests__/metaGovernanceService.test.js:    expect(result.tokenHealthCounts.expiring_soon).toBe(1);
src/public/__tests__/metaGovernanceService.test.js:    expect(result.tokenHealthCounts.quarantined).toBe(1);
src/public/__tests__/apiWebhookService.test.js:        webhook_secret: 'whsec_test',
src/public/__tests__/apiWebhookService.test.js:        webhook_secret: 'whsec_test',
src/public/__tests__/apiWebhookService.test.js:  test('generates webhook secret with expected prefix', () => {
src/public/__tests__/apiWebhookService.test.js:    const secret = generateWebhookSecret();
src/public/__tests__/apiWebhookService.test.js:    expect(secret.startsWith('whsec_')).toBe(true);
src/public/__tests__/apiWebhookService.test.js:    expect(secret.length).toBeGreaterThan(20);
src/public/__tests__/metaGovernanceRouter.test.js:  test('dispatches read action get_token_health', async () => {
src/public/__tests__/metaGovernanceRouter.test.js:      { action: 'get_token_health', params: { integrationId: 'int_123' } },
src/public/__tests__/metaGovernanceRouter.test.js:        params: { integrationId: 'int_123', appSecretHint: 'new-secret' }
src/public/__tests__/metaGovernanceRouter.test.js:      { integrationId: 'int_123', appSecretHint: 'new-secret' },
src/public/__tests__/metaGovernanceRouter.test.js:      tokensUsed: 22
src/public/__tests__/metaGovernanceRouter.test.js:      tokensUsed: 12
src/public/__tests__/socialPostingService.test.js: * Covers: character limit validation per platform, OAuth token management, scheduled post processing, content generation
src/public/__tests__/socialPostingService.test.js:jest.mock('wix-secrets-backend', () => ({ getSecret: jest.fn().mockResolvedValue('test-secret') }));
src/public/__tests__/socialPostingService.test.js:    getFBPageToken: jest.fn().mockResolvedValue('fb-page-token'),
src/public/__tests__/socialPostingService.test.js:    getIGUserToken: jest.fn().mockResolvedValue('ig-user-token')
src/public/__tests__/socialPostingService.test.js:    json: async () => ({ id: 'fb-post-123', access_token: 'new-token', expires_in: 5183944 }),
src/public/__tests__/socialPostingService.test.js:            access_token: 'fb-token-xyz',
src/public/__tests__/socialPostingService.test.js:        it('should save account with is_active=true after token exchange', async () => {
src/public/__tests__/socialPostingService.test.js:            // _exchangeOAuthCode → fetch for token, then fetch for user info
src/public/__tests__/socialPostingService.test.js:                    json: async () => ({ access_token: 'new-token', expires_in: 5183944 }),
src/public/__tests__/socialPostingService.test.js:        it('should return error when token exchange fails', async () => {
src/public/__tests__/socialPostingService.test.js:            // LinkedIn token exchange fails
src/public/__tests__/socialPostingService.test.js:                    json: async () => ({ access_token: 'new-token', expires_in: 5183944 }),
src/public/__tests__/socialPostingService.test.js:        it('should update access_token in socialAccounts on success', async () => {
src/public/__tests__/socialPostingService.test.js:                refresh_token: 'old-refresh-token',
src/public/__tests__/socialPostingService.test.js:                json: async () => ({ access_token: 'new-access-token', expires_in: 5183944 }),
src/public/__tests__/socialPostingService.test.js:                expect.objectContaining({ access_token: 'new-access-token' })
src/public/__tests__/socialPostingService.test.js:                refresh_token: 'expired-token',
src/public/__tests__/socialPostingService.test.js:                json: async () => ({ error: 'invalid_token', error_description: 'Token expired' }),
src/public/__tests__/socialPostingService.test.js:        it('should return error for facebook (no refresh token flow)', async () => {
src/public/__tests__/socialPostingService.test.js:                refresh_token: 'fb-token',
src/public/__tests__/socialPostingService.test.js:        it('postToFacebook should classify token-expired error', async () => {
src/public/__tests__/adminDashboard.test.js:    getAIUsageStats: jest.fn().mockResolvedValue({ tokensUsed: 5000 }),
src/public/__tests__/adminDashboard.test.js:                payload: { tokensUsed: 5000 }
src/public/__tests__/backend/observabilityService.persistence.test.js:        items: [{ functionId: 'agent_orchestration', tokensUsed: 321, timestamp: '2026-02-18T10:00:20Z' }]
src/public/__tests__/apiGateway.external.test.js:      authorization: 'Bearer test_key'
src/public/__tests__/apiGateway.external.test.js:        webhook_secret: 'whsec_test'
src/public/__tests__/apiGateway.external.test.js:      errorCode: 'invalid_api_key',
src/public/__tests__/apiGateway.external.test.js:    expect(res.body.error.code).toBe('invalid_api_key');
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:            expect(stripeState.publishableKey).toBe('pk_test_abc123');
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.html.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/emailCampaignService.test.js:jest.mock('wix-secrets-backend', () => ({ getSecret: jest.fn().mockResolvedValue('test-api-key') }));
src/public/__tests__/voiceService.test.js:    it('should require VAPI_PRIVATE_KEY secret', () => {
src/public/__tests__/voiceService.test.js:      const secretKey = 'VAPI_PRIVATE_KEY';
src/public/__tests__/voiceService.test.js:      expect(secretKey).toBeTruthy();
src/public/__tests__/weatherAlertService.test.js:// Mock wix-secrets-backend
src/public/__tests__/weatherAlertService.test.js:jest.mock('wix-secrets-backend', () => ({
src/public/__tests__/jobBoardService.test.js:jest.mock('wix-secrets-backend', () => ({ getSecret: jest.fn().mockResolvedValue('test-api-key') }));
src/public/__tests__/jobBoardService.test.js:                items: [{ _id: 'cred-1', board: 'indeed', api_key: 'test-key', is_active: true }],
src/public/__tests__/adminBillingManagement.test.js:        test('backend imports from wix-secrets-backend', () => {
src/public/__tests__/adminBillingManagement.test.js:            expect(serviceCode).toContain("from 'wix-secrets-backend'");
src/public/__tests__/metaComplianceService.test.js:    expect(runbook.runbook.tokenExpiry.length).toBeGreaterThan(0);
src/public/__tests__/agentEvaluationService.test.js:    total_tokens: 2000,
src/public/__tests__/agentEvaluationService.test.js:      makeRun({ run_id: 'r1', total_tokens: 3000, total_cost_usd: 0.08 }),
src/public/__tests__/agentEvaluationService.test.js:      makeRun({ run_id: 'r2', total_tokens: 5000, total_cost_usd: 0.12 })
src/public/__tests__/agentEvaluationService.test.js:    expect(result.cost.total_tokens).toBe(8000);
src/public/__tests__/agentEvaluationService.test.js:    expect(result.cost.avg_tokens_per_run).toBe(4000);
src/public/__tests__/agentEvaluationService.test.js:      cost: { avg_tokens_per_run: 2000 },
src/public/__tests__/agentEvaluationService.test.js:  it('should generate cost action when tokens > 5000 avg', async () => {
src/public/__tests__/agentEvaluationService.test.js:      cost: { avg_tokens_per_run: 8000 },
src/public/__tests__/agentEvaluationService.test.js:      cost: { avg_tokens_per_run: 2000 },
src/public/__tests__/agentEvaluationService.test.js:      cost: { avg_tokens_per_run: 3000 },
src/public/__tests__/agentEvaluationService.test.js:      cost: { avg_tokens_per_run: 0 },
src/public/__tests__/agentEvaluationService.test.js:      cost: { avg_tokens_per_run: 2000 },
src/public/__tests__/airtableStrictSchema.test.js:      tokensUsed: 456,
src/public/__tests__/smsCampaignService.test.js:jest.mock('wix-secrets-backend', () => ({ getSecret: jest.fn().mockResolvedValue('test-secret') }));
src/public/__tests__/achievementService.test.js:        'Achievement ID': 'secret_achievement',
src/public/__tests__/socialRateLimitService.test.js:  getIGUserToken: jest.fn().mockResolvedValue('ig-token')
src/public/__tests__/checkout.bridge.test.js:                publishableKey: 'pk_test_abc123'
src/public/__tests__/checkout.bridge.test.js:                    publishableKey: 'pk_test_abc123',
src/public/__tests__/checkout.bridge.test.js:                publishableKey: 'pk_test_abc123'
src/public/__tests__/checkout.bridge.test.js:                publishableKey: 'pk_test_abc123'
src/public/__tests__/checkout.bridge.test.js:                publishableKey: 'pk_test_abc123'
src/public/__tests__/checkout.bridge.test.js:                publishableKey: 'pk_test_abc123'
src/public/__tests__/checkout.bridge.test.js:                publishableKey: 'pk_test_abc123'
src/public/__tests__/documentCollectionService.test.js:    expect(result.uploadPortalUrl).toContain('https://www.lastmiledr.app/document-upload?token=');
src/public/__tests__/documentCollectionService.test.js:        upload_token: 'tok-1',
src/public/__tests__/documentCollectionService.test.js:        upload_token_expiry: new Date(Date.now() + 3600000).toISOString()
src/public/__tests__/documentCollectionService.test.js:      upload_token: 'tok-old',
src/public/__tests__/documentCollectionService.test.js:      upload_token_expiry: new Date(Date.now() + 3600000).toISOString(),
src/public/__tests__/socialTokenService.test.js:  getMetaAppSecret: jest.fn().mockResolvedValue('app-secret')
src/public/__tests__/socialTokenService.test.js:    const tokenService = require('backend/socialTokenService');
src/public/__tests__/socialTokenService.test.js:    const result = await tokenService.validateToken('token-1234567890');
src/public/__tests__/socialTokenService.test.js:  test('exchangeForLongLived returns exchanged token payload', async () => {
src/public/__tests__/socialTokenService.test.js:        access_token: 'long-lived-token',
src/public/__tests__/socialTokenService.test.js:        token_type: 'bearer',
src/public/__tests__/socialTokenService.test.js:    const tokenService = require('backend/socialTokenService');
src/public/__tests__/socialTokenService.test.js:    const result = await tokenService.exchangeForLongLived('short-lived-token');
src/public/__tests__/socialTokenService.test.js:    expect(result.access_token).toBe('long-lived-token');
src/public/__tests__/csaMonitorService.test.js:  dispatchSafetyAlertEvent: jest.fn().mockResolvedValue({ success: true })
src/public/__tests__/csaMonitorService.test.js:const { dispatchSafetyAlertEvent } = require('backend/apiWebhookService');
src/public/__tests__/csaMonitorService.test.js:    expect(dispatchSafetyAlertEvent).toHaveBeenCalledWith(
src/public/__tests__/stripeWebhookCommission.test.js:jest.mock('wix-secrets-backend', () => ({
src/public/__tests__/stripeWebhookCommission.test.js:const { getSecret } = require('wix-secrets-backend');
src/public/__tests__/stripeWebhookCommission.test.js:    // Return the test secret for STRIPE_WEBHOOK_SECRET; null for everything else
src/public/__tests__/agentService.e2e.test.js:      tokensUsed: 500
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 300
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 200
src/public/__tests__/agentService.e2e.test.js:      tokensUsed: 500
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 300
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 200
src/public/__tests__/agentService.e2e.test.js:      tokensUsed: 400
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 200
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 150
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 300
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 200
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 250
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 350
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 200
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 150
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 200
src/public/__tests__/agentService.e2e.test.js:        tokensUsed: 150
src/public/admin/js/admin-observability-render.js:                        '<div><div class="text-text-muted">Tokens</div><div class="text-white font-medium">' + formatNumber(p.tokens) + '</div></div>' +
src/public/admin/js/admin-observability-render.js:                        '<div class="text-xs text-text-muted">' + f.requests + ' requests, ' + formatNumber(f.tokens) + ' tokens</div>' +
src/public/admin/js/admin-run-monitor.js:      token_cap: 'background:rgba(245,158,11,0.2);color:#fcd34d;',
src/public/admin/js/admin-run-monitor.js:        html += '<td style="padding:8px 6px;text-align:right;color:rgba(255,255,255,0.6);">' + (r.total_tokens || 0).toLocaleString() + '</td>';
src/public/admin/js/admin-run-monitor.js:    html += infoCard('Tokens', (run.total_tokens || 0).toLocaleString());
src/public/admin/js/admin-dashboard-logic.js:            '<span class="text-cyan-400">' + R.formatNumber(s.totalTokens || 0) + '</span> <span class="text-text-muted">tokens</span>';
src/public/admin/js/admin-dashboard-logic.js:        B.refreshMetaSystemUserToken({ integrationId: integrationId, reason: 'Manual token refresh from Admin Dashboard' });
src/public/admin/js/admin-dashboard-render.js:        var tokenHealthy = document.getElementById('metaTokenHealthy');
src/public/admin/js/admin-dashboard-render.js:        var tokenExpiring = document.getElementById('metaTokenExpiring');
src/public/admin/js/admin-dashboard-render.js:        var tokenCritical = document.getElementById('metaTokenCritical');
src/public/admin/js/admin-dashboard-render.js:            tokenHealthy.textContent = '--';
src/public/admin/js/admin-dashboard-render.js:            tokenExpiring.textContent = '--';
src/public/admin/js/admin-dashboard-render.js:            tokenCritical.textContent = '--';
src/public/admin/js/admin-dashboard-render.js:        var tokenCounts = summary.tokenHealthCounts || {};
src/public/admin/js/admin-dashboard-render.js:        var criticalCount = (tokenCounts.expired || 0) + (tokenCounts.quarantined || 0) + (tokenCounts.disabled || 0);
src/public/admin/js/admin-dashboard-render.js:        tokenHealthy.textContent = tokenCounts.healthy || 0;
src/public/admin/js/admin-dashboard-render.js:        tokenExpiring.textContent = tokenCounts.expiring_soon || 0;
src/public/admin/js/admin-dashboard-render.js:        tokenCritical.textContent = criticalCount;
src/public/admin/js/admin-dashboard-render.js:                '<span class="text-[10px] text-violet-400">' + formatNumber(func.tokens) + ' tok</span>' +
src/public/admin/js/admin-ai-router-render.js:  function formatTokens(tokens) {
src/public/admin/js/admin-ai-router-render.js:    if (tokens >= 1000000) return (tokens / 1000000).toFixed(1) + 'M';
src/public/admin/js/admin-ai-router-render.js:    if (tokens >= 1000) return (tokens / 1000).toFixed(1) + 'K';
src/public/admin/js/admin-ai-router-render.js:    return tokens.toString();
src/public/admin/js/admin-ai-router-render.js:                  'Set secret: <code class="bg-slate-800 px-1 rounded">' + provider.apiKeySecret + '</code>' +
src/public/admin/ADMIN_DASHBOARD.html:                        <div class="flex items-center gap-1 mt-2 text-xs" id="aiTokenCount"><span class="text-cyan-400">--</span><span class="text-text-muted">tokens</span></div>
src/public/admin/API_PORTAL_DASHBOARD.html:        show('keysPane', data.payload?.api_keys || []);
src/public/admin/API_PORTAL_DASHBOARD.html:        markChecklistStep('sandbox_key', (data.payload?.api_keys || []).some((item) => item.environment === 'sandbox' && item.is_active));
src/public/carrier/CARRIER_ANNOUNCEMENTS.html:    function insertContentToken(token) {
src/public/carrier/CARRIER_ANNOUNCEMENTS.html:      field.value = `${before}${token.replace('</', `${selected}</`)}${after}`;
src/public/carrier/js/carrier-announcements-logic.js:  function insertContentToken(token) {
src/public/carrier/js/carrier-announcements-logic.js:    field.value = before + token.replace('</', selected + '</') + after;
src/public/lmdr-config.js: * Single source of truth for design tokens.
src/public/landing/About_page.html:        "@type": "EducationalOccupationalCredential",
src/public/js/agent-stream-client.js: *      open an EventSource and render tokens as they arrive.
src/public/js/agent-stream-client.js: *     onToken: (token)                         => appendText(token),
src/public/js/agent-stream-client.js:     * @param {string}   streamUrl           Full URL to /v1/stream/events/<token>
src/public/js/agent-stream-client.js:     * @param {Function} [handlers.onToken]  Called with each text token string
src/public/js/agent-stream-client.js:      // Text token — append to response buffer
src/public/js/agent-stream-client.js:      source.addEventListener('token', (e) => {
src/public/js/agent-stream-client.js:          if (onToken && typeof data.token === 'string') onToken(data.token);
src/public/js/agent-stream-client.js:          console.warn('[AgentStreamClient] token parse error:', err.message);
src/public/utility/Placement_Success.html:                    <input type="password" id="accountPassword" placeholder="Min 8 characters" required minlength="8"
src/public/utility/Placement_Success.html:                    <input type="password" id="accountPasswordConfirm" placeholder="Confirm password" required
src/public/utility/Placement_Success.html:                const password = document.getElementById('accountPassword').value;
src/public/utility/Placement_Success.html:                if (password !== confirmPassword) {
src/public/utility/Placement_Success.html:                if (password.length < 8) {
src/public/utility/Placement_Success.html:                        password: password,
src/pages/RECRUITER DRIVER SEARCH.qtecw.js:        tokensUsed: aiResult.tokensUsed
src/pages/Checkout.kbyzk.js:// but stripeService.createPlacementDepositCheckout already handles the secret logic)
src/pages/DRIVER_DOCUMENT_UPLOAD.r5jyr.js:            uploadToken = firstPendingDoc?.upload_token || '';
src/pages/DRIVER_DOCUMENT_UPLOAD.r5jyr.js:        const token = data.token;
src/pages/DRIVER_DOCUMENT_UPLOAD.r5jyr.js:        const result = await uploadDriverDocument(token, documentType, fileData);
src/pages/ADMIN_DASHBOARD.svo6l.js:    const result = await executeMetaGovernanceAction(adminId, 'refresh_system_user_token', {
src/pages/ADMIN_DASHBOARD.svo6l.js:    safeSend(component, { action: 'metaGovernanceActionResult', payload: { action: 'refresh_system_user_token', result } });
src/pages/Recruiter Console.zriuj.js:      tokensUsed: aiResult.tokensUsed
src/pages/PLACEMENT_SUCCESS.tz647.js:        const { email, password } = msg.data;
src/pages/PLACEMENT_SUCCESS.tz647.js:        const result = await wixUsers.register(email, password, {
src/pages/PLACEMENT_SUCCESS.tz647.js:        await wixUsers.login(email, password);
src/pages/Driver Jobs (Item).s0js1.js:          "occupationalCategory": "53-3032.00",
.mcp.json:        "OPENAPI_MCP_HEADERS": "{\"Authorization\": \"Bearer YOUR_NOTION_TOKEN_HERE\", \"Notion-Version\": \"2022-06-28\"}"
lmdr-branding-skill.json:    "primary_tokens": {
lmdr-branding-skill.json:    "Color tokens match brand palette exactly",
